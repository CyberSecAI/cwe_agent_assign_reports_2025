## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved block fix **integer overflow** in BLKSECDISCARD I independently rediscovered commit 22d24a544b0d49bbcbd61c8c0eaf77d3c9297155 block fix overflow in blk_ioctl_discard() but for secure erase. Same problem uint64_t r[2] = {512, 18446744073709551104ULL} ioctl(fd, BLKSECDISCARD, r) will enter near infinite loop inside blkdev_issue_secure_erase() a.out attempt to access beyond end of device loop0 rw=5, sector=3399043073, nr_sectors = 1024 limit=2048 bio_check_eod 3286214 callbacks suppressed

### Vulnerability Description Key Phrases
- **weakness:** **integer overflow**
- **impact:** near infinite loop
- **vector:** ioctl(fd and BLKSECDISCARD and r)
- **product:** Linux kernel
- **component:** blk_ioctl_discard()

## CVE Reference Links Content Summary
The provided content relates to CVE-2024-49994.

**Root cause of vulnerability:**
An integer overflow vulnerability exists in the `blk_ioctl_secure_erase` function within the Linux kernel's block device handling. This occurs when calculating the end address of the secure erase operation, where the sum of the start address and length could overflow.

**Weaknesses/vulnerabilities present:**
- Integer overflow: The code adds the start sector and length without checking for overflow, potentially resulting in a smaller end address than intended. This can lead to out-of-bounds access.
- Incorrect bounds checking: Instead of checking if `start + len` exceeds the device size, the code performs a direct comparison, which can be circumvented with an overflow resulting in a much smaller value.

**Impact of exploitation:**
- Infinite loop: A carefully crafted `BLKSECDISCARD` ioctl command, with a large length that leads to an integer overflow, could cause the `blkdev_issue_secure_erase` function to enter a near infinite loop, repeatedly trying to access memory beyond the device's bounds.
- Denial of Service (DoS): The infinite loop can lead to system unresponsiveness.
- Potentially arbitrary memory corruption: Although not explicitly stated, out-of-bounds access can potentially lead to memory corruption.

**Attack vectors:**
- Local attacker: An attacker with local access to a block device can send the `BLKSECDISCARD` ioctl command, which triggers the vulnerability.

**Required attacker capabilities/position:**
- Local access to a block device.
- Ability to execute ioctl commands on the block device.
- Knowledge of the overflow condition to be exploited.

**Additional details:**
- The fix involves using the `check_add_overflow` function to prevent integer overflows when calculating the end address of the secure erase operation.
- The vulnerability is present in the `block/ioctl.c` file.
- The provided content includes the patch that resolves the vulnerability
- The commit message clearly states the vulnerability and how to trigger it.
- The patch changes the calculation of the end of range using `start + len` to using `check_add_overflow` to check for overflow and store the end in the `end` variable, which is then used for further checks.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 190 | Integer Overflow or Wraparound | Base | Allowed | alternate_terms | 0.800 |
| 2 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | Allowed | sparse | 0.258 |
| 3 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.255 |
| 4 | 191 | Integer Underflow (Wrap or Wraparound) | Base | Allowed | sparse | 0.254 |
| 5 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | Allowed | sparse | 0.246 |
| 6 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.245 |
| 7 | 122 | Heap-based Buffer Overflow | Variant | Allowed | sparse | 0.238 |
| 8 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | sparse | 0.236 |
| 9 | 667 | Improper Locking | Class | Allowed-with-Review | dense | 0.541 |
| 10 | 1260 | Improper Handling of Overlap Between Protected Memory Ranges | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-190: Integer Overflow or Wraparound

CWE-835: Loop with Unreachable Exit Condition ('Infinite Loop')

CWE-1284: Improper Validation of Specified Quantity in Input

CWE-191: Integer Underflow (Wrap or Wraparound)

CWE-1285: Improper Validation of Specified Index, Position, or Offset in Input

CWE-125: Out-of-bounds Read

CWE-122: Heap-based Buffer Overflow

CWE-674: Uncontrolled Recursion

CWE-667: Improper Locking

CWE-1260: Improper Handling of Overlap Between Protected Memory Ranges