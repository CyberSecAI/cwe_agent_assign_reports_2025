{
  "method": "sparse_base",
  "query": "In the Linux kernel, the following vulnerability has been resolved net/tcp Disable TCP-AO static key after RCU grace period The lifetime of TCP-AO static_key is the same as the last tcp_ao_info. On the socket destruction tcp_ao_info ceases to be with RCU grace period, while tcp-ao static branch is currently deferred destructed. The static key definition is DEFINE_STATIC_KEY_DEFERRED_FALSE(tcp_ao_needed, HZ) which means that if RCU grace period is delayed by more than a second and tcp_ao_needed is in the process of disablement, other CPUs may yet see tcp_ao_info which atent dead, but soon-to-be. And that breaks the assumption of static_key_fast_inc_not_disabled(). See the comment near the definition > * The caller must make sure that the static key cant get disabled while > * in this function. It doesnt patch jump labels, only adds a user to > * an already enabled static key. Originally it was introduced in commit eb8c507296f6 (jump_label Prevent key->enabled int overflow), which is needed for the atomic contexts, one of which would be the creation of a full socket from a request socket. In that atomic context, its known by the presence of the key (md5/ao) that the static branch is already enabled. So, the ref counter for that static branch is just incremented instead of holding the proper mutex. static_key_fast_inc_not_disabled() is just a helper for such usage case. But it must not be used if the static branch could get disabled in parallel as its not prote",
  "keyphrases": {
    "base_query": "In the Linux kernel, the following vulnerability has been resolved net/tcp Disable TCP-AO static key after RCU grace period The lifetime of TCP-AO static_key is the same as the last tcp_ao_info. On the socket destruction tcp_ao_info ceases to be with RCU grace period, while tcp-ao static branch is currently deferred destructed. The static key definition is DEFINE_STATIC_KEY_DEFERRED_FALSE(tcp_ao_needed, HZ) which means that if RCU grace period is delayed by more than a second and tcp_ao_needed is in the process of disablement, other CPUs may yet see tcp_ao_info which atent dead, but soon-to-be. And that breaks the assumption of static_key_fast_inc_not_disabled(). See the comment near the definition > * The caller must make sure that the static key cant get disabled while > * in this function. It doesnt patch jump labels, only adds a user to > * an already enabled static key. Originally it was introduced in commit eb8c507296f6 (jump_label Prevent key->enabled int overflow), which is needed for the atomic contexts, one of which would be the creation of a full socket from a request socket. In that atomic context, its known by the presence of the key (md5/ao) that the static branch is already enabled. So, the ref counter for that static branch is just incremented instead of holding the proper mutex. static_key_fast_inc_not_disabled() is just a helper for such usage case. But it must not be used if the static branch could get disabled in parallel as its not prote"
  },
  "timestamp": "2025-07-12T04:08:00.517987",
  "results_count": 10,
  "results_summary": [
    {
      "doc_id": "321",
      "name": "Use of Hard-coded Cryptographic Key",
      "score": 380.3659980101746
    },
    {
      "doc_id": "1204",
      "name": "Generation of Weak Initialization Vector (IV)",
      "score": 379.7392823233824
    },
    {
      "doc_id": "1391",
      "name": "Use of Weak Credentials",
      "score": 375.95681166977346
    },
    {
      "doc_id": "639",
      "name": "Authorization Bypass Through User-Controlled Key",
      "score": 375.3268224153198
    },
    {
      "doc_id": "863",
      "name": "Incorrect Authorization",
      "score": 373.7888608513985
    }
  ]
}