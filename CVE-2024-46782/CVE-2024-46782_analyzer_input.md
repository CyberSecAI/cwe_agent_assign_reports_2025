# Vulnerability Information: CVE-2024-46782

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved ila call nf_unregister_net_hooks() sooner syzbot found an **use-after-free** Read in ila_nf_input [1] Issue here is that ila_xlat_exit_net() frees the rhashtable, then call nf_unregister_net_hooks(). It should be done in the reverse way, with a synchronize_rcu(). This is a good match for a pre_exit() method. [1] BUG KASAN **use-after-free** in rht_key_hashfn include/linux/rhashtable.h159 [inline] BUG KASAN **use-after-free** in __rhashtable_lookup include/linux/rhashtable.h604 [inline] BUG KASAN **use-after-free** in rhashtable_lookup include/linux/rhashtable.h646 [inline] BUG KASAN **use-after-free** in rhashtable_lookup_fast+0x77a/0x9b0 include/linux/rhashtable.h672 Read of size 4 at addr ffff888064620008 by task ksoftirqd/0/16 CPU 0 UID 0 PID 16 Comm ksoftirqd/0 Not tainted 6.11.0-rc4-syzkaller-00238-g2ad6d23f465a #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024 Call Trace __dump_stack lib/dump_stack.c93 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c119 print_address_description mm/kasan/report.c377 [inline] print_report+0x169/0x550 mm/kasan/report.c488 kasan_report+0x143/0x180 mm/kasan/report.c601 rht_key_hashfn include/linux/rhashtable.h159 [inline] __rhashtable_lookup include/linux/rhashtable.h604 [inline] rhashtable_lookup include/linux/rhashtable.h646 [inline] rhashtable_lookup_fast+0x77a/0x9b0 include/linux/r

### Vulnerability Description Key Phrases
- **rootcause:** **use-after-free**
- **impact:** use-after-free
- **product:** Linux kernel
- **component:** ila_nf_input and nf_unregister_net_hooks()

## CVE Reference Links Content Summary
```
{
  "cveId": "CVE-2024-46782",
  "related": true,
  "content": "The provided content describes a use-after-free vulnerability in the Linux kernel's ILA (Identifier Locator Addressing) subsystem, specifically within the `ila_nf_input` function. The root cause lies in the incorrect order of operations during network namespace exit. The `ila_xlat_exit_net()` function would free the rhashtable used by ILA and *then* unregister the netfilter hooks using `nf_unregister_net_hooks()`. Because netfilter hooks can still be called after the rhashtable is freed, this leads to a use-after-free condition when a network packet is processed by the hook. \n\n**Root cause:** Incorrect order of operations during network namespace exit. The rhashtable was freed before unregistering the netfilter hooks.\n\n**Weaknesses/vulnerabilities:**\n*   Use-after-free vulnerability in `ila_nf_input`.\n*   Incorrect resource management during network namespace teardown.\n\n**Impact of exploitation:**\n*   Kernel crash, which could lead to a denial of service.\n*   Potential for further exploitation due to memory corruption.\n\n**Attack vectors:**\n*   Network packets processed by the ILA netfilter hook after the rhashtable has been freed.\n*   Triggering network namespace exit through `unshare` syscall.\n\n**Required attacker capabilities/position:**\n*   Ability to create and manipulate network namespaces.\n*   Ability to send network traffic that is processed by the ILA netfilter hook. \n\nThe fix introduces a new `ila_xlat_pre_exit_net()` function that unregisters the netfilter hooks before the rhashtable is freed, preventing the use-after-free.",
  "additional_details": {
    "fix": "The fix involves adding a pre_exit handler that unregisters the netfilter hooks prior to the freeing of the rhashtable."
  }
}
```

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 416 | Use After Free | Variant | Allowed | alternate_terms | 1.000 |
| 2 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.714 |
| 3 | 415 | Double Free | Variant | Allowed | sparse | 0.674 |
| 4 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.640 |
| 5 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.634 |
| 6 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.611 |
| 7 | 911 | Improper Update of Reference Count | Base | Allowed | sparse | 0.608 |
| 8 | 252 | Unchecked Return Value | Base | Allowed | sparse | 0.598 |
| 9 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | dense | 0.551 |
| 10 | 123 | Write-what-where Condition | Base | Allowed | graph | 0.003 |

