## Vulnerability Description
An **out-of-memory error** in the parseABC_NS_SET_INFO function of libming v0.4.8 allows attackers to cause a Denial of Service (DoS) due to allocator exhaustion.

### Vulnerability Description Key Phrases
- **weakness:** **out-of-memory error**
- **impact:** Denial of Service (DoS)
- **vector:** allocator exhaustion
- **attacker:** attackers
- **product:** libming
- **version:** v0.4.8
- **component:** parseABC_NS_SET_INFO function

## CVE Reference Links Content Summary
CVE-2025-29484 - PLACEHOLDER - Implement CVE description retrieval

The provided content details multiple vulnerabilities discovered in libming version 0.4.8. Here's a breakdown of the identified issues:

**1. Out-of-Memory Error in `parseABC_NS_SET_INFO` (DoS)**

*   **Root Cause:**  Attempting to allocate a large block of memory during parsing of ABC (ActionScript Bytecode) data.
*   **Weakness:**  Insufficient memory allocation handling, potential for allocator exhaustion.
*   **Impact:** Denial of Service (DoS) due to system instability.
*   **Attack Vector:** Processing SWF files containing specific ABC bytecode.
*   **Attacker Capability:** Ability to craft a malicious SWF file.
*   **Mitigation:** Not specified in the content.
*   **PoC:** <https://github.com/goodmow/PoC/blob/main/libming/poc1>

**2. Memory Leak in `parseSWF_ENABLEDEBUGGER2`**

*   **Root Cause:** Memory allocated for reading strings is not deallocated after parsing.
*   **Weakness:** Memory management error, failure to free allocated memory.
*   **Impact:** Memory leak, potentially leading to resource exhaustion.
*   **Attack Vector:** Processing SWF files.
*   **Attacker Capability:** Ability to provide a malicious SWF file.
*   **Mitigation:** Not specified in the content.
*   **PoC:** <https://github.com/goodmow/PoC/blob/main/libming/poc2>

**3. Memory Leak in `parseSWF_PLACEOBJECT3`**

*   **Root Cause:** Improper handling of memory allocation when reading strings.
*   **Weakness:** Memory management error.
*   **Impact:** Memory leak.
*   **Attack Vector:** Processing SWF files.
*   **Attacker Capability:** Ability to provide a malicious SWF file.
*   **Mitigation:** Not specified in the content.
*   **PoC:** <https://github.com/goodmow/PoC/blob/main/libming/poc3>

**4. Segmentation Fault (SEGV) in `decompileRETURN`**

*   **Root Cause:** READ memory access to an invalid address (zero page) during decompilation.
*   **Weakness:** Memory access error, potential buffer overflow or use-after-free.
*   **Impact:** Application crash.
*   **Attack Vector:** Processing SWF files during decompilation.
*   **Attacker Capability:** Ability to craft a SWF file that triggers the vulnerability during decompilation.
*   **Mitigation:** Not specified in the content.
*   **PoC:** <https://github.com/goodmow/PoC/blob/main/libming/poc4>

**5. Memory Leak in `parseSWF_INITACTION`**

*   **Root Cause:** Improper handling of memory reallocation.
*   **Weakness:** Memory management error.
*   **Impact:** Memory leak.
*   **Attack Vector:** Processing SWF files.
*   **Attacker Capability:** Ability to provide a malicious SWF file.
*   **Mitigation:** Not specified in the content.
*   **PoC:** <https://github.com/goodmow/PoC/blob/main/libming/poc5>

**6. Out-of-Memory Error in `parseABC_STRING_INFO` (DoS)**

*   **Root Cause:** Attempting to allocate a large block of memory while parsing ABC data.
*   **Weakness:** Insufficient memory allocation handling.
*   **Impact:** Denial of Service (DoS).
*   **Attack Vector:** Processing SWF files with specific ABC bytecode.
*   **Attacker Capability:** Ability to craft a malicious SWF file.
*   **Mitigation:** Not specified in the content.
*   **PoC:** <https://github.com/goodmow/PoC/blob/main/libming/poc6>

**7. Memory Leak in `parseSWF_MORPHLINESTYLES`**

*   **Root Cause:** Improper handling of memory allocation.
*   **Weakness:** Memory management error.
*   **Impact:** Memory leak.
*   **Attack Vector:** Processing SWF files.
*   **Attacker Capability:** Ability to provide a malicious SWF file.
*   **Mitigation:** Not specified in the content.
*   **PoC:** <https://github.com/goodmow/PoC/blob/main/libming/poc7>

**8. Segmentation Fault (SEGV) in `decompileCALLMETHOD`**

*   **Root Cause:** READ memory access to an invalid address (zero page) during decompilation.
*   **Weakness:** Memory access error.
*   **Impact:** Application crash.
*   **Attack Vector:** Processing SWF files during decompilation.
*   **Attacker Capability:** Ability to craft a SWF file that triggers the vulnerability during decompilation.
*   **Mitigation:** Not specified in the content.
*   **PoC:** <https://github.com/goodmow/PoC/blob/main/libming/poc8>

**9. Segmentation Fault (SEGV) in `decompileSETVARIABLE`**

*   **Root Cause:** READ memory access to an invalid address (zero page) during decompilation.
*   **Weakness:** Memory access error.
*   **Impact:** Application crash.
*   **Attack Vector:** Processing SWF files during decompilation.
*   **Attacker Capability:** Ability to craft a SWF file that triggers the vulnerability during decompilation.
*   **Mitigation:** Not specified in the content.
*   **PoC:** <https://github.com/goodmow/PoC/blob/main/libming/poc9>

**10. Allocation-Size-Too-Big Error in `parseSWF_DEFINEBINARYDATA`**

*   **Root Cause:** Attempting to allocate an excessively large block of memory.
*   **Weakness:** Insufficient input validation, memory allocation error.
*   **Impact:** Application crash.
*   **Attack Vector:** Processing SWF files.
*   **Attacker Capability:** Ability to provide a malicious SWF file.
*   **Mitigation:** Not specified in the content.
*   **PoC:** <https://github.com/goodmow/PoC/blob/main/libming/poc10>

**11. Segmentation Fault (SEGV) in `decompileGETPROPERTY`**

*   **Root Cause:** READ memory access to an invalid address (zero page) during decompilation.
*   **Weakness:** Memory access error.
*   **Impact:** Application crash.
*   **Attack Vector:** Processing SWF files during decompilation.
*   **Attacker Capability:** Ability to craft a SWF file that triggers the vulnerability during decompilation.
*   **Mitigation:** Not specified in the content.
*   **PoC:** <https://github.com/goodmow/PoC/blob/main/libming/poc11>

**12. Segmentation Fault (SEGV) in `decompileGETMEMBER`**

*   **Root Cause:** READ memory access to an invalid address (zero page) during decompilation.
*   **Weakness:** Memory access error.
*   **Impact:** Application crash.
*   **Attack Vector:** Processing SWF files during decompilation.
*   **Attacker Capability:** Ability to craft a SWF file that triggers the vulnerability during decompilation.
*   **Mitigation:** Not specified in the content.
*   **PoC:** <https://github.com/goodmow/PoC/blob/main/libming/poc12>

**13. Segmentation Fault (SEGV) in `decompileIMPLEMENTS`**

*   **Root Cause:** READ memory access to an invalid address (zero page) during decompilation.
*   **Weakness:** Memory access error.
*   **Impact:** Application crash.
*   **Attack Vector:** Processing SWF files during decompilation.
*   **Attacker Capability:** Ability to craft a SWF file that triggers the vulnerability during decompilation.
*   **Mitigation:** Not specified in the content.
*   **PoC:** <https://github.com/goodmow/PoC/blob/main/libming/poc13>

**14. Segmentation Fault (SEGV) in `decompileDUPLICATECLIP`**

*   **Root Cause:** READ memory access to an invalid address (zero page) during decompilation.
*   **Weakness:** Memory access error.
*   **Impact:** Application crash.
*   **Attack Vector:** Processing SWF files during decompilation.
*   **Attacker Capability:** Ability to craft a SWF file that triggers the vulnerability during decompilation.
*   **Mitigation:** Not specified in the content.
*   **PoC:** <https://github.com/goodmow/PoC/blob/main/libming/poc14>

**15. Memory Leak in `parseSWF_MORPHFILLSTYLES`**

*   **Root Cause:** Improper handling of memory allocation.
*   **Weakness:** Memory management error.
*   **Impact:** Memory leak.
*   **Attack Vector:** Processing SWF files.
*   **Attacker Capability:** Ability to provide a malicious SWF file.
*   **Mitigation:** Not specified in the content.
*   **PoC:** <https://github.com/goodmow/PoC/blob/main/libming/poc15>

This content provides significantly more detail than a typical CVE description, including ASAN reports and Proof-of-Concept links. It identifies a multitude of vulnerabilities within libming v0.4.8, ranging from memory leaks and out-of-memory errors to segmentation faults.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | sparse | 0.211 |
| 2 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.200 |
| 3 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.199 |
| 4 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | sparse | 0.197 |
| 5 | 476 | NULL Pointer Dereference | Base | Allowed | sparse | 0.192 |
| 6 | 1325 | Improperly Controlled Sequential Memory Allocation | Base | Allowed | dense | 0.504 |
| 7 | 252 | Unchecked Return Value | Base | Allowed | graph | 0.002 |
| 8 | 400 | Uncontrolled Resource Consumption | Class | Discouraged | sparse | 0.190 |
| 9 | 122 | Heap-based Buffer Overflow | Variant | Allowed | sparse | 0.187 |
| 10 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.187 |



# Complete CWE Specifications


## CWE-789: Memory Allocation with Excessive Size Value
**Abstraction:** Variant
**Status:** Draft

### Description
The product allocates memory based on an untrusted, large size value, but it does not ensure that the size is within expected limits, allowing arbitrary amounts of memory to be allocated.

### Extended Description
Not provided

### Alternative Terms
Stack Exhaustion: When a weakness allocates excessive memory on the stack, it is often described as "stack exhaustion," which is a technical impact of the weakness. This technical impact is often encountered as a consequence of CWE-789 and/or CWE-1325.

### Relationships
ChildOf -> CWE-770
CanPrecede -> CWE-476

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Additional Notes
**[Relationship]** This weakness can be closely associated with integer overflows (CWE-190). Integer overflow attacks would concentrate on providing an extremely large number that triggers an overflow that causes less memory to be allocated than expected. By providing a large value that does not trigger an integer overflow, the attacker could still cause excessive amounts of memory to be allocated.

**[Applicable Platform]** 

Uncontrolled memory allocation is possible in many languages, such as dynamic array allocation in perl or initial size parameters in Collections in Java. However, languages like C and C++ where programmers have the power to more directly control memory management will be more susceptible.




### Observed Examples
- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).
- **CVE-2010-3701:** program uses ::alloca() for encoding messages, but large messages trigger segfault
- **CVE-2008-1708:** memory consumption and daemon exit by specifying a large value in a length field




## CWE-770: Allocation of Resources Without Limits or Throttling
**Abstraction:** Base
**Status:** Incomplete

### Description
The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.

### Extended Description


Code frequently has to work with limited resources, so programmers must be careful to ensure that resources are not consumed too quickly, or too easily. Without use of quotas, resource limits, or other protection mechanisms, it can be easy for an attacker to consume many resources by rapidly making many requests, or causing larger resources to be used than is needed. When too many resources are allocated, or if a single resource is too large, then it can prevent the code from working correctly, possibly leading to a denial of service.


### Alternative Terms
None

### Relationships
ChildOf -> CWE-400
ChildOf -> CWE-665
ChildOf -> CWE-400

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Additional Notes
**[Relationship]** This entry is different from uncontrolled resource consumption (CWE-400) in that there are other weaknesses that are related to inability to control resource consumption, such as holding on to a resource too long after use, or not correctly keeping track of active resources so that they can be managed and released when they are finished (CWE-771).

**[Theoretical]** Vulnerability theory is largely about how behaviors and resources interact. "Resource exhaustion" can be regarded as either a consequence or an attack, depending on the perspective. This entry is an attempt to reflect one of the underlying weaknesses that enable these attacks (or consequences) to take place.



### Observed Examples
- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).
- **CVE-2009-4017:** Language interpreter does not restrict the number of temporary files being created when handling a MIME request with a large number of parts..
- **CVE-2009-2726:** Driver does not use a maximum width when invoking sscanf style functions, causing stack consumption.




## CWE-125: Out-of-bounds Read
**Abstraction:** Base
**Status:** Draft

### Description
The product reads data past the end, or before the beginning, of the intended buffer.

### Extended Description
Not provided

### Alternative Terms
OOB read: Shorthand for "Out of bounds" read

### Relationships
ChildOf -> CWE-119
ChildOf -> CWE-119
ChildOf -> CWE-119
ChildOf -> CWE-119

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use



### Observed Examples
- **CVE-2023-1018:** The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to read 2 bytes past the end of a buffer.
- **CVE-2020-11899:** Out-of-bounds read in IP stack used in embedded systems, as exploited in the wild per CISA KEV.
- **CVE-2014-0160:** Chain: "Heartbleed" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.




## CWE-674: Uncontrolled Recursion
**Abstraction:** Class
**Status:** Draft

### Description
The product does not properly control the amount of recursion that takes place,  consuming excessive resources, such as allocated memory or the program stack.

### Extended Description
Not provided

### Alternative Terms
Stack Exhaustion

### Relationships
ChildOf -> CWE-834

### Mapping Guidance
**Usage:** Allowed-with-Review
**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate
**Comments:** Examine children of this entry to see if there is a better fit
**Reasons:**
- Abstraction



### Observed Examples
- **CVE-2007-1285:** Deeply nested arrays trigger stack exhaustion.
- **CVE-2007-3409:** Self-referencing pointers create infinite loop and resultant stack exhaustion.
- **CVE-2016-10707:** Javascript application accidentally changes input in a way that prevents a recursive call from detecting an exit condition.




## CWE-476: NULL Pointer Dereference
**Abstraction:** Base
**Status:** Stable

### Description
The product dereferences a pointer that it expects to be valid but is NULL.

### Extended Description
Not provided

### Alternative Terms
NPD: Common abbreviation for Null Pointer Dereference
null deref: Common abbreviation for Null Pointer Dereference
NPE: Common abbreviation for Null Pointer Exception
nil pointer dereference: used for access of nil in Go programs

### Relationships
ChildOf -> CWE-710
ChildOf -> CWE-754
ChildOf -> CWE-754

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use



### Observed Examples
- **CVE-2005-3274:** race condition causes a table to be corrupted if a timer activates while it is being modified, leading to resultant NULL dereference; also involves locking.
- **CVE-2002-1912:** large number of packets leads to NULL dereference
- **CVE-2005-0772:** packet with invalid error status value triggers NULL dereference




## CWE-1325: Improperly Controlled Sequential Memory Allocation
**Abstraction:** Base
**Status:** Incomplete

### Description
The product manages a group of objects or resources and performs a separate memory allocation for each object, but it does not properly limit the total amount of memory that is consumed by all of the combined objects.

### Extended Description


While the product might limit the amount of memory that is allocated in a single operation for a single object (such as a malloc of an array), if an attacker can cause multiple objects to be allocated in separate operations, then this might cause higher total memory consumption than the developer intended, leading to a denial of service.


### Alternative Terms
Stack Exhaustion: When a weakness allocates excessive memory on the stack, it is often described as "stack exhaustion," which is a technical impact of the weakness. This technical impact is often encountered as a consequence of CWE-789 and/or CWE-1325.

### Relationships
ChildOf -> CWE-770
PeerOf -> CWE-789
CanPrecede -> CWE-476

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use



### Observed Examples
- **CVE-2020-36049:** JavaScript-based packet decoder uses concatenation of many small strings, causing out-of-memory (OOM) condition
- **CVE-2019-20176:** Product allocates a new buffer on the stack for each file in a directory, allowing stack exhaustion
- **CVE-2013-1591:** Chain: an integer overflow (CWE-190) in the image size calculation causes an infinite loop (CWE-835) which sequentially allocates buffers without limits (CWE-1325) until the stack is full.




## CWE-252: Unchecked Return Value
**Abstraction:** Base
**Status:** Draft

### Description
The product does not check the return value from a method or function, which can prevent it from detecting unexpected states and conditions.

### Extended Description
Two common programmer assumptions are "this function call can never fail" and "it doesn't matter if this function call fails". If an attacker can force the function to fail or otherwise return a value that is not expected, then the subsequent program logic could lead to a vulnerability, because the product is not in a state that the programmer assumes. For example, if the program calls a function to drop privileges but does not check the return code to ensure that privileges were successfully dropped, then the program will continue to operate with the higher privileges.

### Alternative Terms
None

### Relationships
ChildOf -> CWE-754
ChildOf -> CWE-754
CanPrecede -> CWE-476

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use



### Observed Examples
- **CVE-2020-17533:** Chain: unchecked return value (CWE-252) of some functions for policy enforcement leads to authorization bypass (CWE-862)
- **CVE-2020-6078:** Chain: The return value of a function returning a pointer is not checked for success (CWE-252) resulting in the later use of an uninitialized variable (CWE-456) and a null pointer dereference (CWE-476)
- **CVE-2019-15900:** Chain: sscanf() call is used to check if a username and group exists, but the return value of sscanf() call is not checked (CWE-252), causing an uninitialized variable to be checked (CWE-457), returning success to allow authorization bypass for executing a privileged (CWE-863).




## CWE-400: Uncontrolled Resource Consumption
**Abstraction:** Class
**Status:** Draft

### Description
The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.

### Extended Description


Limited resources include memory, file system storage, database connection pool entries, and CPU. If an attacker can trigger the allocation of these limited resources, but the number or size of the resources is not controlled, then the attacker could cause a denial of service that consumes all available resources. This would prevent valid users from accessing the product, and it could potentially have an impact on the surrounding environment. For example, a memory exhaustion attack against an application could slow down the application as well as its host operating system.


There are at least three distinct scenarios which can commonly lead to resource exhaustion:


  - Lack of throttling for the number of allocated resources

  - Losing all references to a resource before reaching the shutdown stage

  - Not closing/returning a resource after processing

Resource exhaustion problems are often result due to an incorrect implementation of the following situations:

  - Error conditions and other exceptional circumstances.

  - Confusion over which part of the program is responsible for releasing the resource.



### Alternative Terms
Resource Exhaustion

### Relationships
ChildOf -> CWE-664

### Mapping Guidance
**Usage:** Discouraged
**Rationale:** CWE-400 is intended for incorrect behaviors in which the product is expected to track and restrict how many resources it consumes, but CWE-400 is often misused because it is conflated with the "technical impact" of vulnerabilities in which resource consumption occurs. It is sometimes used for low-information vulnerability reports. It is a level-1 Class (i.e., a child of a Pillar).
**Comments:** Closely analyze the specific mistake that is causing resource consumption, and perform a CWE mapping for that mistake. Consider children/descendants such as CWE-770: Allocation of Resources Without Limits or Throttling, CWE-771: Missing Reference to Active Allocated Resource, CWE-410: Insufficient Resource Pool, CWE-772: Missing Release of Resource after Effective Lifetime, CWE-834: Excessive Iteration, CWE-405: Asymmetric Resource Consumption (Amplification), and others.
**Reasons:**
- Frequent Misuse


### Additional Notes
**[Maintenance]** "Resource consumption" could be interpreted as a consequence instead of an insecure behavior, so this entry is being considered for modification. It appears to be referenced too frequently when more precise mappings are available. Some of its children, such as CWE-771, might be better considered as a chain.

**[Theoretical]** Vulnerability theory is largely about how behaviors and resources interact. "Resource exhaustion" can be regarded as either a consequence or an attack, depending on the perspective. This entry is an attempt to reflect the underlying weaknesses that enable these attacks (or consequences) to take place.

**[Other]** 

Database queries that take a long time to process are good DoS targets. An attacker would have to write a few lines of Perl code to generate enough traffic to exceed the site's ability to keep up. This would effectively prevent authorized users from using the site at all. Resources can be exploited simply by ensuring that the target machine must do much more work and consume more resources in order to service a request than the attacker must do to initiate a request.


A prime example of this can be found in old switches that were vulnerable to "macof" attacks (so named for a tool developed by Dugsong). These attacks flooded a switch with random IP and MAC address combinations, therefore exhausting the switch's cache, which held the information of which port corresponded to which MAC addresses. Once this cache was exhausted, the switch would fail in an insecure way and would begin to act simply as a hub, broadcasting all traffic on all ports and allowing for basic sniffing attacks.


**[Maintenance]** The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the "Mapping CWE to 62443" subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions.



### Observed Examples
- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).
- **CVE-2020-7218:** Go-based workload orchestrator does not limit resource usage with unauthenticated connections, allowing a DoS by flooding the service
- **CVE-2020-3566:** Resource exhaustion in distributed OS because of "insufficient" IGMP queue management, as exploited in the wild per CISA KEV.




## CWE-122: Heap-based Buffer Overflow
**Abstraction:** Variant
**Status:** Draft

### Description
A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().

### Extended Description
Not provided

### Alternative Terms
None

### Relationships
ChildOf -> CWE-788
ChildOf -> CWE-787

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Additional Notes
**[Relationship]** Heap-based buffer overflows are usually just as dangerous as stack-based buffer overflows.



### Observed Examples
- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)
- **CVE-2007-4268:** Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)
- **CVE-2009-2523:** Chain: product does not handle when an input string is not NULL terminated (CWE-170), leading to buffer over-read (CWE-125) or heap-based buffer overflow (CWE-122).




## CWE-1284: Improper Validation of Specified Quantity in Input
**Abstraction:** Base
**Status:** Incomplete

### Description
The product receives input that is expected to specify a quantity (such as size or length), but it does not validate or incorrectly validates that the quantity has the required properties.

### Extended Description


Specified quantities include size, length, frequency, price, rate, number of operations, time, and others. Code may rely on specified quantities to allocate resources, perform calculations, control iteration, etc. When the quantity is not properly validated, then attackers can specify malicious quantities to cause excessive resource allocation, trigger unexpected failures, enable buffer overflows, etc.


### Alternative Terms
None

### Relationships
ChildOf -> CWE-20
ChildOf -> CWE-20
CanPrecede -> CWE-789

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Additional Notes
**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.



### Observed Examples
- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).
- **CVE-2008-1440:** lack of validation of length field leads to infinite loop
- **CVE-2008-2374:** lack of validation of string length fields allows memory consumption or buffer over-read

