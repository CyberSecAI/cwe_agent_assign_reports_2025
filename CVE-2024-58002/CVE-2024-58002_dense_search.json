{
  "retriever": "dense",
  "query": "In the Linux kernel, the following vulnerability has been resolved media uvcvideo Remove dangling pointers When an async control is written, we copy a pointer to the file handle that started the operation. That pointer will be used when the device is done. Which could be anytime in the future. If the user closes that file descriptor, its structure will be freed, and there will be one dangling pointer per pending async control, that the driver will try to use. Clean all the dangling pointers during release(). To avoid adding a performance penalty in the most common case (no async operation), a counter has been introduced with some logic to make sure that it is properly handled.",
  "keyphrases": {
    "rootcause": [
      "Remove dangling pointers"
    ]
  },
  "timestamp": "2025-07-12 06:58:49",
  "cve_id": "CVE-2024-58002",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "822",
      "name": "Untrusted Pointer Dereference",
      "type": "Base",
      "score": 0.48775767437827683
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 0.48258586539046044
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "type": "Variant",
      "score": 0.4802660470973852
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "type": "Class",
      "score": 0.4790120823679534
    },
    {
      "cwe_id": "908",
      "name": "Use of Uninitialized Resource",
      "type": "Base",
      "score": 0.4736554748823674
    },
    {
      "cwe_id": "775",
      "name": "Missing Release of File Descriptor or Handle after Effective Lifetime",
      "type": "Variant",
      "score": 0.46662171168328176
    },
    {
      "cwe_id": "823",
      "name": "Use of Out-of-range Pointer Offset",
      "type": "Base",
      "score": 0.4616741880618428
    },
    {
      "cwe_id": "825",
      "name": "Expired Pointer Dereference",
      "type": "Base",
      "score": 0.4612318714267727
    },
    {
      "cwe_id": "415",
      "name": "Double Free",
      "type": "Variant",
      "score": 0.4597853957462503
    },
    {
      "cwe_id": "909",
      "name": "Missing Initialization of Resource",
      "type": "Class",
      "score": 0.4586935438285977
    },
    {
      "cwe_id": "773",
      "name": "Missing Reference to Active File Descriptor or Handle",
      "type": "Variant",
      "score": 0.45742169736631294
    },
    {
      "cwe_id": "366",
      "name": "Race Condition within a Thread",
      "type": "Base",
      "score": 0.446484394288099
    },
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "type": "Base",
      "score": 0.4426125224939125
    },
    {
      "cwe_id": "763",
      "name": "Release of Invalid Pointer or Reference",
      "type": "Base",
      "score": 0.4396191663464936
    },
    {
      "cwe_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "type": "Base",
      "score": 0.4391012355200521
    },
    {
      "cwe_id": "403",
      "name": "Exposure of File Descriptor to Unintended Control Sphere ('File Descriptor Leak')",
      "type": "Base",
      "score": 0.437499295144111
    },
    {
      "cwe_id": "367",
      "name": "Time-of-check Time-of-use (TOCTOU) Race Condition",
      "type": "Base",
      "score": 0.4342435599275573
    },
    {
      "cwe_id": "824",
      "name": "Access of Uninitialized Pointer",
      "type": "Base",
      "score": 0.4327119305900648
    },
    {
      "cwe_id": "1264",
      "name": "Hardware Logic with Insecure De-Synchronization between Control and Data Channels",
      "type": "Base",
      "score": 0.43251236006333693
    },
    {
      "cwe_id": "190",
      "name": "Integer Overflow or Wraparound",
      "type": "Base",
      "score": 0.43175713768519297
    }
  ]
}