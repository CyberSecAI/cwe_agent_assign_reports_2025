# Vulnerability Information: CVE-2024-38667

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved riscv prevent pt_regs corruption for secondary idle threads Top of the kernel thread stack should be reserved for pt_regs. However this is not the case for the idle threads of the secondary boot harts. Their stacks overlap with their pt_regs, so both may get corrupted. Similar issue has been fixed for the primary hart, see c7cdd96eca28 (riscv prevent **stack corruption** by reserving task_pt_regs(p) early). However that fix was not propagated to the secondary harts. The problem has been noticed in some CPU hotplug tests with V enabled. The function smp_callin stored several registers on stack, corrupting top of pt_regs structure including status field. As a result, kernel attempted to save or restore inexistent V context.

### Vulnerability Description Key Phrases
- **rootcause:** **stack corruption**
- **impact:** pt_regs corruption
- **product:** Linux kernel

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of the vulnerability:

**Root Cause:**

- The root cause is the incorrect stack pointer initialization for secondary idle threads on RISC-V architecture. Specifically, the stack pointer was being set to the top of the thread's stack page instead of being set to the reserved `pt_regs` area. This caused the stack to overlap with the `pt_regs` structure.

**Weaknesses/Vulnerabilities Present:**

- **Stack Corruption:** The primary vulnerability is stack corruption. Because the stack pointer was not correctly initialized, operations such as `smp_callin` could write directly to the area reserved for `pt_regs`.
- **`pt_regs` Corruption:**  The `pt_regs` structure, which stores register states for context switching, was being overwritten when the stack pointer was not correctly initialized. This is a critical data structure which when corrupted leads to undefined behavior.

**Impact of Exploitation:**

- **Undefined Behavior:** Corrupting the `pt_regs` structure resulted in the kernel attempting to save or restore the incorrect V (vector) context, leading to undefined behavior and potentially causing crashes.
- **CPU Hotplug Issues:** The vulnerability was noticed during CPU hotplug tests, particularly when V (vector) extensions were enabled, indicating that this issue has the potential to destabilize the system during dynamic CPU management.

**Attack Vectors:**

- **CPU Hotplug:** The vulnerability was exposed during CPU hotplug operations, where the system attempts to bring additional CPU cores online.
- **Secondary Hart Initialization:** The issue was specifically related to the initialization of secondary harts (hardware threads), as the primary hart's initialization had already been addressed.
- **`smp_callin` Function:** The `smp_callin` function, which is invoked during the process of bringing secondary harts online, was identified as one of the functions writing to the stack, causing corruption of the `pt_regs`.

**Required Attacker Capabilities/Position:**

- **System-Level Access:** An attacker would likely require system-level access to trigger CPU hotplug operations, where they might be able to exploit the vulnerability.
- **Knowledge of RISC-V Architecture:** The attacker would need some understanding of the RISC-V architecture and how the kernel manages threads and context switching.
- **Ability to Trigger CPU Hotplug:** Specifically, the attacker must be able to initiate CPU hotplug events, which typically are performed by the operating system itself or privileged applications.

**Additional Details:**

- The fix addresses the issue by setting the `stack_ptr` or `__cpu_spinwait_stack_pointer` to `task_pt_regs(tidle)` instead of `task_stack_page(tidle) + THREAD_SIZE`. This ensures that the stack pointer is correctly positioned just before the `pt_regs` area which reserves the top of the thread's stack.
- The issue was identified during testing of CPU hotplug with vector extensions enabled and was related to `smp_callin` function.

In summary, the vulnerability lies in the incorrect stack pointer initialization during the bring-up of secondary CPU cores in RISC-V systems. This resulted in stack corruption, overwriting the `pt_regs` structure and leading to undefined behavior. An attacker able to trigger CPU hotplug operations would be able to exploit this issue, potentially destabilizing the system.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | sparse | 0.586 |
| 2 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.581 |
| 3 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.556 |
| 4 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.552 |
| 5 | 457 | Use of Uninitialized Variable | Variant | Allowed | sparse | 0.549 |
| 6 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.540 |
| 7 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.538 |
| 8 | 190 | Integer Overflow or Wraparound | Base | Allowed | sparse | 0.534 |
| 9 | 1342 | Information Exposure through Microarchitectural State after Transient Execution | Base | Allowed | dense | 0.523 |
| 10 | 476 | NULL Pointer Dereference | Base | Allowed | graph | 0.002 |

