## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved blk-rq-qos fix crash on **rq_qos_wait vs. rq_qos_wake_function race** Were seeing crashes from rq_qos_wake_function that look like this BUG unable to handle page fault for address ffffafe180a40084 #PF supervisor write access in kernel mode #PF error_code(0x0002) - not-present page PGD 100000067 P4D 100000067 PUD 10027c067 PMD 10115d067 PTE 0 Oops Oops 0002

### Vulnerability Description Key Phrases
- **rootcause:** **rq_qos_wait vs. rq_qos_wake_function race**
- **impact:** Oops and crash
- **product:** Linux kernel

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of the vulnerability:

**Root Cause:**
A race condition exists between the `rq_qos_wait()` and `rq_qos_wake_function()` functions in the Linux kernel's block request quality of service (blk-rq-qos) subsystem. Specifically, `rq_qos_wake_function()` was accessing the waitqueue entry *after* it had been deleted, leading to a use-after-free condition.

**Weaknesses/Vulnerabilities:**
- **Use-After-Free:** The primary vulnerability is a use-after-free, where the `rq_qos_wake_function` attempts to access memory associated with a waitqueue entry that has already been freed.
- **Race Condition:** The race condition occurs because `rq_qos_wait()` can return after receiving a token and before `rq_qos_wake_function()` has completed its operation, leading to a situation where the waitqueue entry is accessed after the waiting task has already moved on and potentially overwritten the data it was using.
- **Incorrect List Manipulation:** The incorrect use of `list_del_init()` instead of `list_del_init_careful()` in `rq_qos_wake_function()` contributes to the race condition and use-after-free.

**Impact of Exploitation:**
- **Kernel Crash:** The primary impact is a kernel crash, as evidenced by the provided Oops message. The use-after-free leads to a page fault when the kernel tries to access the freed memory.
- **Denial of Service:** The crash results in a denial-of-service condition, as the system will become unresponsive.

**Attack Vectors:**
- **Triggering the Race Condition:** The vulnerability is triggered by a race between tasks waiting on a request token (`rq_qos_wait()`) and the task providing the token and waking up the waiters (`rq_qos_wake_function()`).
- **Specific Kernel Subsystem:** This vulnerability is located within the blk-rq-qos subsystem, which deals with block device I/O request QoS. Exploitation would likely involve manipulating block device I/O operations in a way that triggers the race condition.

**Required Attacker Capabilities/Position:**
- **Kernel Execution:** An attacker needs to have some ability to cause I/O operations and thus indirectly control the `rq_qos_wait` and `rq_qos_wake_function` behavior.
- **Precise Timing:** Exploiting the race condition might require a degree of timing precision to ensure that the `rq_qos_wait` and `rq_qos_wake_function` functions interact in a way that triggers the bug.

**Technical Details:**

The core issue arises in the `rq_qos_wake_function`:

1. The function sets `data->got_token = true`.
2.  It then executes `list_del_init(&curr->entry);`, removing the waitqueue entry from the list.
3.  Finally, it calls `wake_up_process(data->task);`.

The problem is that after the waitqueue entry has been removed, the data it points to can be clobbered by the task that was waiting if it gets scheduled again before `wake_up_process` is called.
The fix involves:

1.  Switching the order of the list manipulation and the wake-up call. The correct order is to first call `wake_up_process(data->task)` and then `list_del_init_careful(&curr->entry)`.
2. Changing `list_del_init()` to `list_del_init_careful()`, to align with the `list_empty_careful()` check in finish_wait().

This ensures that the waitqueue entry is not accessed after it has been removed, preventing the use-after-free.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.255 |
| 2 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.232 |
| 3 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.228 |
| 4 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | Allowed | sparse | 0.221 |
| 5 | 787 | Out-of-bounds Write | Base | Allowed | sparse | 0.218 |
| 6 | 364 | Signal Handler Race Condition | Base | Allowed | sparse | 0.214 |
| 7 | 476 | NULL Pointer Dereference | Base | Allowed | sparse | 0.207 |
| 8 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | sparse | 0.205 |
| 9 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | dense | 0.520 |
| 10 | 609 | Double-Checked Locking | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-667: Improper Locking

CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition

CWE-1285: Improper Validation of Specified Index, Position, or Offset in Input

CWE-787: Out-of-bounds Write

CWE-364: Signal Handler Race Condition

CWE-476: NULL Pointer Dereference

CWE-909: Missing Initialization of Resource

CWE-401: Missing Release of Memory after Effective Lifetime

CWE-609: Double-Checked Locking