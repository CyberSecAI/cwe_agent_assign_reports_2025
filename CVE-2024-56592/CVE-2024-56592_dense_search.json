{
  "retriever": "dense",
  "query": "In the Linux kernel, the following vulnerability has been resolved bpf Call free_htab_elem() after htab_unlock_bucket() For htab of maps, when the map is removed from the htab, it may hold the last reference of the map. bpf_map_fd_put_ptr() will invoke bpf_map_free_id() to free the id of the removed map element. However, bpf_map_fd_put_ptr() is invoked while holding a bucket lock (raw_spin_lock_t), and bpf_map_free_id() attempts to acquire map_idr_lock (spinlock_t), triggering the following lockdep warning ============================= [ BUG Invalid wait context ] 6.11.0-rc4+ #49 Not tainted ----------------------------- test_maps/4881 is trying to lock ffffffff84884578 (map_idr_lock){+...}-{33}, at bpf_map_free_id.part.0+0x21/0x70 other info that might help us debug this context-{55} 2 locks held by test_maps/4881 #0 ffffffff846caf60 (rcu_read_lock){....}-{13}, at bpf_fd_htab_map_update_elem+0xf9/0x270 #1 ffff888149ced148 (&htab->lockdep_key#2){....}-{22}, at htab_map_update_elem+0x178/0xa80 stack backtrace CPU 0 UID 0 PID 4881 Comm test_maps Not tainted 6.11.0-rc4+ #49 Hardware name QEMU Standard PC (i440FX + PIIX, 1996), ... Call Trace dump_stack_lvl+0x6e/0xb0 dump_stack+0x10/0x20 __lock_acquire+0x73e/0x36c0 lock_acquire+0x182/0x450 _raw_spin_lock_irqsave+0x43/0x70 bpf_map_free_id.part.0+0x21/0x70 bpf_map_put+0xcf/0x110 bpf_map_fd_put_ptr+0x9a/0xb0 free_htab_elem+0x69/0xe0 htab_map_update_elem+0x50f/0xa80 bpf_fd_htab_map_update_elem+0x131/0x270 htab_map_update_elem+0x50f/0xa80 bpf_fd_htab_map_update_elem+0x131/0x270 bpf_map_update_value+0x266/0x380 __sys_bpf+0x21bb/0x36b0 __x64_sys_bpf+0x45/0x60 x64_sys_call+0x1b2a/0x20d0 do_syscall_64+0x5d/0x100 entry_SYSCALL_64_after_hwframe+0x76/0x7e One way to fix the lockdep warning is using raw_spinlock_t for map_idr_lock as well. However, bpf_map_alloc_id() invokes idr_alloc_cyclic() after acquiring map_idr_lock, it will trigger a similar lockdep warning because the slabs lock (s->cpu_slab->lock) is still a spinlock. Instead of changing map_idr_locks type, fix the issue by invoking htab_put_fd_value() after htab_unlock_bucket(). However, only deferring the invocation of htab_put_fd_value() is not enough, because the old map pointers in htab of maps can not be saved during batched deletion. Therefore, also defer the invocation of free_htab_elem(), so these to-be-freed elements could be linked together similar to lru map. There are four callers for ->map_fd_put_ptr (1) alloc_htab_elem() (through htab_put_fd_value()) It invokes ->map_fd_put_ptr() under a raw_spinlock_t. The invocation of htab_put_fd_value() can not simply move after htab_unlock_bucket(), because the old element has already been stashed in htab->extra_elems. It may be reused immediately after htab_unlock_bucket() and the invocation of htab_put_fd_value() after htab_unlock_bucket() may release the newly-added element incorrectly. Therefore, saving the map pointer of the old element for htab of maps before unlocking the bucket and releasing the map_ptr after unlock. Beside the map pointer in the old element, should do the same thing for the special fields in the old element as well. (2) free_htab_elem() (through htab_put_fd_value()) Its caller includes __htab_map_lookup_and_delete_elem(), htab_map_delete_elem() and __htab_map_lookup_and_delete_batch(). For htab_map_delete_elem(), simply invoke free_htab_elem() after htab_unlock_bucket(). For __htab_map_lookup_and_delete_batch(), just like lru map, linking the to-be-freed element into node_to_free list and invoking free_htab_elem() for these element after unlock. It is safe to reuse batch_flink as the link for node_to_free, because these elements have been removed from the hash llist. Because htab of maps doesnt support lookup_and_delete operation, __htab_map_lookup_and_delete_elem() doesnt have the problem, so kept it as ---truncated---",
  "keyphrases": {
    "rootcause": [
      "Invalid wait context"
    ]
  },
  "timestamp": "2025-07-13 23:51:02",
  "cve_id": "CVE-2024-56592",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "type": "Class",
      "score": 0.5111993195183306
    },
    {
      "cwe_id": "911",
      "name": "Improper Update of Reference Count",
      "type": "Base",
      "score": 0.48466659314621596
    },
    {
      "cwe_id": "909",
      "name": "Missing Initialization of Resource",
      "type": "Class",
      "score": 0.4834392381928876
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 0.47502677869840926
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 0.46748259137984627
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "type": "Variant",
      "score": 0.4668792036771806
    },
    {
      "cwe_id": "366",
      "name": "Race Condition within a Thread",
      "type": "Base",
      "score": 0.46674708863947934
    },
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "type": "Base",
      "score": 0.4640319610331123
    },
    {
      "cwe_id": "126",
      "name": "Buffer Over-read",
      "type": "Variant",
      "score": 0.4640279279447188
    },
    {
      "cwe_id": "763",
      "name": "Release of Invalid Pointer or Reference",
      "type": "Base",
      "score": 0.4639064541675304
    },
    {
      "cwe_id": "401",
      "name": "Missing Release of Memory after Effective Lifetime",
      "type": "Variant",
      "score": 0.4518782881382143
    },
    {
      "cwe_id": "415",
      "name": "Double Free",
      "type": "Variant",
      "score": 0.447962422713855
    },
    {
      "cwe_id": "131",
      "name": "Incorrect Calculation of Buffer Size",
      "type": "Base",
      "score": 0.44286697787279633
    },
    {
      "cwe_id": "908",
      "name": "Use of Uninitialized Resource",
      "type": "Base",
      "score": 0.4397181550982778
    },
    {
      "cwe_id": "244",
      "name": "Improper Clearing of Heap Memory Before Release ('Heap Inspection')",
      "type": "Variant",
      "score": 0.43759126859225284
    },
    {
      "cwe_id": "122",
      "name": "Heap-based Buffer Overflow",
      "type": "Variant",
      "score": 0.43637975262424866
    },
    {
      "cwe_id": "404",
      "name": "Improper Resource Shutdown or Release",
      "type": "Class",
      "score": 0.43508556250196295
    },
    {
      "cwe_id": "761",
      "name": "Free of Pointer not at Start of Buffer",
      "type": "Variant",
      "score": 0.4344846592698152
    },
    {
      "cwe_id": "367",
      "name": "Time-of-check Time-of-use (TOCTOU) Race Condition",
      "type": "Base",
      "score": 0.4322758494846547
    },
    {
      "cwe_id": "403",
      "name": "Exposure of File Descriptor to Unintended Control Sphere ('File Descriptor Leak')",
      "type": "Base",
      "score": 0.42956456458551734
    }
  ]
}