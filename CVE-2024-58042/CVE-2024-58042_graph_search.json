{
  "retriever": "graph",
  "query": "In the Linux kernel, the following vulnerability has been resolved rhashtable Fix potential deadlock by moving schedule_work outside lock Move the hash table growth check and work scheduling outside the rht lock to prevent a possible circular locking dependency. The original implementation could trigger a lockdep warning due to a potential deadlock scenario involving nested locks between rhashtable bucket, rq lock, and dsq lock. By relocating the growth check and work scheduling after releasing the rth lock, we break this potential deadlock chain. This change expands the flexibility of rhashtable by removing restrictive locking that previously limited its use in scheduler and workqueue contexts. Import to say that this calls rht_grow_above_75(), which reads from struct rhashtable without holding the lock, if this is a problem, we can move the check to the lock, and schedule the workqueue after the lock. Modified so that atomic_inc is also moved outside of the bucket lock along with the growth above 75% check. Consider specifically these CWEs: CWE-667 CWE-833 CWE-191 CWE-413 CWE-764 CWE-362 CWE-412",
  "keyphrases": {
    "original_query": "In the Linux kernel, the following vulnerability has been resolved rhashtable Fix potential deadlock by moving schedule_work outside lock Move the hash table growth check and work scheduling outside the rht lock to prevent a possible circular locking dependency. The original implementation could trigger a lockdep warning due to a potential deadlock scenario involving nested locks between rhashtable bucket, rq lock, and dsq lock. By relocating the growth check and work scheduling after releasing the rth lock, we break this potential deadlock chain. This change expands the flexibility of rhashtable by removing restrictive locking that previously limited its use in scheduler and workqueue contexts. Import to say that this calls rht_grow_above_75(), which reads from struct rhashtable without holding the lock, if this is a problem, we can move the check to the lock, and schedule the workqueue after the lock. Modified so that atomic_inc is also moved outside of the bucket lock along with the growth above 75% check.",
    "enhanced_query": "In the Linux kernel, the following vulnerability has been resolved rhashtable Fix potential deadlock by moving schedule_work outside lock Move the hash table growth check and work scheduling outside the rht lock to prevent a possible circular locking dependency. The original implementation could trigger a lockdep warning due to a potential deadlock scenario involving nested locks between rhashtable bucket, rq lock, and dsq lock. By relocating the growth check and work scheduling after releasing the rth lock, we break this potential deadlock chain. This change expands the flexibility of rhashtable by removing restrictive locking that previously limited its use in scheduler and workqueue contexts. Import to say that this calls rht_grow_above_75(), which reads from struct rhashtable without holding the lock, if this is a problem, we can move the check to the lock, and schedule the workqueue after the lock. Modified so that atomic_inc is also moved outside of the bucket lock along with the growth above 75% check. Consider specifically these CWEs: CWE-667 CWE-833 CWE-191 CWE-413 CWE-764 CWE-362 CWE-412",
    "cwe_mentions": [
      "CWE-667",
      "CWE-833",
      "CWE-191",
      "CWE-413",
      "CWE-764",
      "CWE-362",
      "CWE-412"
    ],
    "search_time": 2.5617194175720215
  },
  "timestamp": "2025-07-14 00:43:28",
  "cve_id": "CVE-2024-58042",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "412",
      "name": "Unrestricted Externally Accessible Lock",
      "type": "base",
      "score": 2.4699999999999998,
      "relationship_count": 0
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "type": "variant",
      "score": 2.04,
      "relationship_count": 0
    },
    {
      "cwe_id": "120",
      "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "123",
      "name": "Write-what-where Condition",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 1.6878173084035564,
      "relationship_count": 0
    },
    {
      "cwe_id": "1265",
      "name": "Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "413",
      "name": "Improper Resource Locking",
      "type": "Base",
      "score": 1.6827397073524315,
      "relationship_count": 0
    },
    {
      "cwe_id": "386",
      "name": "Symbolic Name not Mapping to Correct Object",
      "type": "base",
      "score": 1.6744000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "764",
      "name": "Multiple Locks of a Critical Resource",
      "type": "Base",
      "score": 1.667325419437962,
      "relationship_count": 0
    },
    {
      "cwe_id": "61",
      "name": "UNIX Symbolic Link (Symlink) Following",
      "type": "compound",
      "score": 1.61,
      "relationship_count": 0
    },
    {
      "cwe_id": "170",
      "name": "Improper Null Termination",
      "type": "base",
      "score": 1.5350400000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "410",
      "name": "Insufficient Resource Pool",
      "type": "base",
      "score": 1.521,
      "relationship_count": 0
    },
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "type": "Base",
      "score": 1.5146412044209971,
      "relationship_count": 0
    },
    {
      "cwe_id": "415",
      "name": "Double Free",
      "type": "variant",
      "score": 1.4784000000000002,
      "relationship_count": 0
    },
    {
      "cwe_id": "191",
      "name": "Integer Underflow (Wrap or Wraparound)",
      "type": "Base",
      "score": 1.4697462388662899,
      "relationship_count": 0
    },
    {
      "cwe_id": "134",
      "name": "Use of Externally-Controlled Format String",
      "type": "base",
      "score": 1.3010400000000002,
      "relationship_count": 0
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 1.2601854077164474,
      "relationship_count": 0
    },
    {
      "cwe_id": "364",
      "name": "Signal Handler Race Condition",
      "type": "Base",
      "score": 1.234959306653095,
      "relationship_count": 0
    },
    {
      "cwe_id": "363",
      "name": "Race Condition Enabling Link Following",
      "type": "base",
      "score": 1.2261600000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "479",
      "name": "Signal Handler Use of a Non-reentrant Function",
      "type": "variant",
      "score": 1.20096,
      "relationship_count": 0
    }
  ]
}