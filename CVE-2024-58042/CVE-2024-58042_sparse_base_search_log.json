{
  "method": "sparse_base",
  "query": "In the Linux kernel, the following vulnerability has been resolved rhashtable Fix potential deadlock by moving schedule_work outside lock Move the hash table growth check and work scheduling outside the rht lock to prevent a possible circular locking dependency. The original implementation could trigger a lockdep warning due to a potential deadlock scenario involving nested locks between rhashtable bucket, rq lock, and dsq lock. By relocating the growth check and work scheduling after releasing the rth lock, we break this potential deadlock chain. This change expands the flexibility of rhashtable by removing restrictive locking that previously limited its use in scheduler and workqueue contexts. Import to say that this calls rht_grow_above_75(), which reads from struct rhashtable without holding the lock, if this is a problem, we can move the check to the lock, and schedule the workqueue after the lock. Modified so that atomic_inc is also moved outside of the bucket lock along with the growth above 75% check.",
  "keyphrases": {
    "base_query": "In the Linux kernel, the following vulnerability has been resolved rhashtable Fix potential deadlock by moving schedule_work outside lock Move the hash table growth check and work scheduling outside the rht lock to prevent a possible circular locking dependency. The original implementation could trigger a lockdep warning due to a potential deadlock scenario involving nested locks between rhashtable bucket, rq lock, and dsq lock. By relocating the growth check and work scheduling after releasing the rth lock, we break this potential deadlock chain. This change expands the flexibility of rhashtable by removing restrictive locking that previously limited its use in scheduler and workqueue contexts. Import to say that this calls rht_grow_above_75(), which reads from struct rhashtable without holding the lock, if this is a problem, we can move the check to the lock, and schedule the workqueue after the lock. Modified so that atomic_inc is also moved outside of the bucket lock along with the growth above 75% check."
  },
  "timestamp": "2025-07-12T06:59:13.853224",
  "results_count": 10,
  "results_summary": [
    {
      "doc_id": "667",
      "name": "Improper Locking",
      "score": 319.74254908930055
    },
    {
      "doc_id": "833",
      "name": "Deadlock",
      "score": 285.1162843182665
    },
    {
      "doc_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "score": 250.0541214341512
    },
    {
      "doc_id": "412",
      "name": "Unrestricted Externally Accessible Lock",
      "score": 246.56291551355997
    },
    {
      "doc_id": "764",
      "name": "Multiple Locks of a Critical Resource",
      "score": 237.93173841395515
    }
  ]
}