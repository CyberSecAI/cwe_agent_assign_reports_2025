# Vulnerability Information: CVE-2024-44948

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved x86/mtrr Check if fixed MTRRs exist before saving them MTRRs have an obsolete fixed variant for fine grained caching control of the 640K-1MB region that uses separate MSRs. This fixed variant has a separate capability bit in the MTRR capability MSR. So far all x86 CPUs which support MTRR have this separate bit set, so it went unnoticed that mtrr_save_state() does not check the capability bit before accessing the fixed MTRR MSRs. Though on a CPU that does not support the fixed MTRR capability this results in a #GP. The #GP itself is harmless because the RDMSR fault is handled gracefully, but results in a WARN_ON(). Add the **missing capability check** to prevent this.

### Vulnerability Description Key Phrases
- **rootcause:** **missing capability check**
- **impact:** Oops -f SIGFPE
- **product:** Linux kernel
- **component:** x86/mtrr

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of the vulnerability:

**Root Cause:**

The vulnerability arises from the `mtrr_save_state()` function in the Linux kernel's x86 Memory Type Range Register (MTRR) implementation. This function attempts to save the state of fixed MTRRs, which are used for fine-grained caching control of the 640K-1MB memory region. However, it fails to check if the CPU actually supports these fixed MTRRs before attempting to access their corresponding MSRs (Model Specific Registers).

**Weaknesses/Vulnerabilities:**

- **Missing Capability Check:** The primary weakness is the lack of a check for the fixed MTRR capability bit in the MTRR capability MSR. This bit indicates whether the CPU supports fixed MTRRs. Without this check, the code attempts to access MSRs that may not exist on the CPU.
- **Incorrect Assumption:** The code implicitly assumes that all x86 CPUs that support MTRRs also support the fixed MTRR variant, which is not always the case.

**Impact of Exploitation:**

- **General Protection Fault (#GP):** If the code attempts to access fixed MTRR MSRs on a CPU that doesn't support them, it results in a #GP (General Protection Fault). This fault is handled by the kernel, preventing a crash or privilege escalation.
- **WARN_ON() Trigger:** While the #GP is handled gracefully, it triggers a `WARN_ON()` call. This call generates a warning message in the kernel logs, indicating the issue.

**Attack Vectors:**

- **Processor Specific:** This is an issue only on CPUs that support MTRR, but not fixed MTRRs.
- **Software Triggered:** The vulnerability is triggered during the `mtrr_save_state` function call. This is done during CPU bringup.
- **No Remote Exploitation:** The vulnerability cannot be exploited remotely.

**Required Attacker Capabilities/Position:**

- **No specific position:** This is a bug in the kernel code, not related to specific user privileges. An attacker would need to run a kernel with this bug on hardware that does not support fixed MTRRs.

**Additional Details:**

- The provided commits are all patches that correct the vulnerability. They add a check for the `mtrr_state.have_fixed` flag before accessing the fixed MTRR MSRs.
- The fix addresses the issue where the function `mtrr_save_state()` does not check if the fixed MTRRs are supported before accessing their corresponding MSRs. This action could cause a #GP.
- The commit message includes a link to the discussion on the kernel mailing list, which provides further context and technical detail regarding the vulnerability.

**In summary,** the vulnerability is a missing capability check in the Linux kernel's MTRR handling. This can lead to a #GP and a WARN\_ON() message on CPUs that don't support fixed MTRRs. The fix adds a proper check to avoid this issue.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 863 | Incorrect Authorization | Class | Allowed-with-Review | sparse | 0.625 |
| 2 | 352 | Cross-Site Request Forgery (CSRF) | Compound | Allowed | sparse | 0.600 |
| 3 | 862 | Missing Authorization | Class | Allowed-with-Review | sparse | 0.597 |
| 4 | 201 | Insertion of Sensitive Information Into Sent Data | Base | Allowed | sparse | 0.568 |
| 5 | 99 | Improper Control of Resource Identifiers ('Resource Injection') | Class | Allowed-with-Review | sparse | 0.559 |
| 6 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.556 |
| 7 | 1342 | Information Exposure through Microarchitectural State after Transient Execution | Base | Allowed | sparse | 0.556 |
| 8 | 90 | Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection') | Base | Allowed | sparse | 0.553 |
| 9 | 1260 | Improper Handling of Overlap Between Protected Memory Ranges | Base | Allowed | dense | 0.561 |
| 10 | 226 | Sensitive Information in Resource Not Removed Before Reuse | Base | Allowed | graph | 0.003 |

