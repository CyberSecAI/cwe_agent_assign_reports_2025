{
  "retriever": "graph",
  "query": "In the Linux kernel, the following vulnerability has been resolved KVM SVM Forcibly leave SMM mode on SHUTDOWN interception Previously, commit ed129ec9057f (KVM x86 forcibly leave nested mode on vCPU reset) addressed an issue where a triple fault occurring in nested mode could lead to use-after-free scenarios. However, the commit did not handle the analogous situation for System Management Mode (SMM). This omission results in triggering a WARN when KVM forces a vCPU INIT after SHUTDOWN interception while the vCPU is in SMM. This situation was reprodused using Syzkaller by 1) Creating a KVM VM and vCPU 2) Sending a KVM_SMI ioctl to explicitly enter SMM 3) Executing invalid instructions causing consecutive exceptions and eventually a triple fault The issue manifests as follows WARNING CPU 0 PID 25506 at arch/x86/kvm/x86.c12112 kvm_vcpu_reset+0x1d2/0x1530 arch/x86/kvm/x86.c12112 Modules linked in CPU 0 PID 25506 Comm syz-executor.0 Not tainted 6.1.130-syzkaller-00157-g164fe5dde9b6 #0 Hardware name QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014 RIP 0010kvm_vcpu_reset+0x1d2/0x1530 arch/x86/kvm/x86.c12112 Call Trace shutdown_interception+0x66/0xb0 arch/x86/kvm/svm/svm.c2136 svm_invoke_exit_handler+0x110/0x530 arch/x86/kvm/svm/svm.c3395 svm_handle_exit+0x424/0x920 arch/x86/kvm/svm/svm.c3457 vcpu_enter_guest arch/x86/kvm/x86.c10959 [inline] vcpu_run+0x2c43/0x5a90 arch/x86/kvm/x86.c11062 kvm_arch_vcpu_ioctl_run+0x50f/0x1cf0 arch/x86/kvm/x86.c11283 kvm_vcpu_ioctl+0x570/0xf00 arch/x86/kvm/../../../virt/kvm/kvm_main.c4122 vfs_ioctl fs/ioctl.c51 [inline] __do_sys_ioctl fs/ioctl.c870 [inline] __se_sys_ioctl fs/ioctl.c856 [inline] __x64_sys_ioctl+0x19a/0x210 fs/ioctl.c856 do_syscall_x64 arch/x86/entry/common.c51 [inline] do_syscall_64+0x35/0x80 arch/x86/entry/common.c81 entry_SYSCALL_64_after_hwframe+0x6e/0xd8 Architecturally, INIT is blocked when the CPU is in SMM, hence KVMs WARN() in kvm_vcpu_reset() to guard against KVM bugs, e.g. to detect improper emulation of INIT. SHUTDOWN on SVM is a weird edge case where KVM needs to do _something_ sane with the VMCB, since its technically undefined, and INIT is the least awful choice given KVMs ABI. So, double down on stuffing INIT on SHUTDOWN, and force the vCPU out of SMM to avoid any weirdness (and the WARN). Found by Linux Verification Center (linuxtesting.org) with Syzkaller. [sean massage changelog, make it clear this isnt architectural behavior] Consider specifically these CWEs: CWE-367 CWE-1274 CWE-1342 CWE-909 CWE-1281 CWE-125 CWE-667 CWE-393 CWE-755",
  "keyphrases": {
    "original_query": "In the Linux kernel, the following vulnerability has been resolved KVM SVM Forcibly leave SMM mode on SHUTDOWN interception Previously, commit ed129ec9057f (KVM x86 forcibly leave nested mode on vCPU reset) addressed an issue where a triple fault occurring in nested mode could lead to use-after-free scenarios. However, the commit did not handle the analogous situation for System Management Mode (SMM). This omission results in triggering a WARN when KVM forces a vCPU INIT after SHUTDOWN interception while the vCPU is in SMM. This situation was reprodused using Syzkaller by 1) Creating a KVM VM and vCPU 2) Sending a KVM_SMI ioctl to explicitly enter SMM 3) Executing invalid instructions causing consecutive exceptions and eventually a triple fault The issue manifests as follows WARNING CPU 0 PID 25506 at arch/x86/kvm/x86.c12112 kvm_vcpu_reset+0x1d2/0x1530 arch/x86/kvm/x86.c12112 Modules linked in CPU 0 PID 25506 Comm syz-executor.0 Not tainted 6.1.130-syzkaller-00157-g164fe5dde9b6 #0 Hardware name QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014 RIP 0010kvm_vcpu_reset+0x1d2/0x1530 arch/x86/kvm/x86.c12112 Call Trace shutdown_interception+0x66/0xb0 arch/x86/kvm/svm/svm.c2136 svm_invoke_exit_handler+0x110/0x530 arch/x86/kvm/svm/svm.c3395 svm_handle_exit+0x424/0x920 arch/x86/kvm/svm/svm.c3457 vcpu_enter_guest arch/x86/kvm/x86.c10959 [inline] vcpu_run+0x2c43/0x5a90 arch/x86/kvm/x86.c11062 kvm_arch_vcpu_ioctl_run+0x50f/0x1cf0 arch/x86/kvm/x86.c11283 kvm_vcpu_ioctl+0x570/0xf00 arch/x86/kvm/../../../virt/kvm/kvm_main.c4122 vfs_ioctl fs/ioctl.c51 [inline] __do_sys_ioctl fs/ioctl.c870 [inline] __se_sys_ioctl fs/ioctl.c856 [inline] __x64_sys_ioctl+0x19a/0x210 fs/ioctl.c856 do_syscall_x64 arch/x86/entry/common.c51 [inline] do_syscall_64+0x35/0x80 arch/x86/entry/common.c81 entry_SYSCALL_64_after_hwframe+0x6e/0xd8 Architecturally, INIT is blocked when the CPU is in SMM, hence KVMs WARN() in kvm_vcpu_reset() to guard against KVM bugs, e.g. to detect improper emulation of INIT. SHUTDOWN on SVM is a weird edge case where KVM needs to do _something_ sane with the VMCB, since its technically undefined, and INIT is the least awful choice given KVMs ABI. So, double down on stuffing INIT on SHUTDOWN, and force the vCPU out of SMM to avoid any weirdness (and the WARN). Found by Linux Verification Center (linuxtesting.org) with Syzkaller. [sean massage changelog, make it clear this isnt architectural behavior]",
    "enhanced_query": "In the Linux kernel, the following vulnerability has been resolved KVM SVM Forcibly leave SMM mode on SHUTDOWN interception Previously, commit ed129ec9057f (KVM x86 forcibly leave nested mode on vCPU reset) addressed an issue where a triple fault occurring in nested mode could lead to use-after-free scenarios. However, the commit did not handle the analogous situation for System Management Mode (SMM). This omission results in triggering a WARN when KVM forces a vCPU INIT after SHUTDOWN interception while the vCPU is in SMM. This situation was reprodused using Syzkaller by 1) Creating a KVM VM and vCPU 2) Sending a KVM_SMI ioctl to explicitly enter SMM 3) Executing invalid instructions causing consecutive exceptions and eventually a triple fault The issue manifests as follows WARNING CPU 0 PID 25506 at arch/x86/kvm/x86.c12112 kvm_vcpu_reset+0x1d2/0x1530 arch/x86/kvm/x86.c12112 Modules linked in CPU 0 PID 25506 Comm syz-executor.0 Not tainted 6.1.130-syzkaller-00157-g164fe5dde9b6 #0 Hardware name QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014 RIP 0010kvm_vcpu_reset+0x1d2/0x1530 arch/x86/kvm/x86.c12112 Call Trace shutdown_interception+0x66/0xb0 arch/x86/kvm/svm/svm.c2136 svm_invoke_exit_handler+0x110/0x530 arch/x86/kvm/svm/svm.c3395 svm_handle_exit+0x424/0x920 arch/x86/kvm/svm/svm.c3457 vcpu_enter_guest arch/x86/kvm/x86.c10959 [inline] vcpu_run+0x2c43/0x5a90 arch/x86/kvm/x86.c11062 kvm_arch_vcpu_ioctl_run+0x50f/0x1cf0 arch/x86/kvm/x86.c11283 kvm_vcpu_ioctl+0x570/0xf00 arch/x86/kvm/../../../virt/kvm/kvm_main.c4122 vfs_ioctl fs/ioctl.c51 [inline] __do_sys_ioctl fs/ioctl.c870 [inline] __se_sys_ioctl fs/ioctl.c856 [inline] __x64_sys_ioctl+0x19a/0x210 fs/ioctl.c856 do_syscall_x64 arch/x86/entry/common.c51 [inline] do_syscall_64+0x35/0x80 arch/x86/entry/common.c81 entry_SYSCALL_64_after_hwframe+0x6e/0xd8 Architecturally, INIT is blocked when the CPU is in SMM, hence KVMs WARN() in kvm_vcpu_reset() to guard against KVM bugs, e.g. to detect improper emulation of INIT. SHUTDOWN on SVM is a weird edge case where KVM needs to do _something_ sane with the VMCB, since its technically undefined, and INIT is the least awful choice given KVMs ABI. So, double down on stuffing INIT on SHUTDOWN, and force the vCPU out of SMM to avoid any weirdness (and the WARN). Found by Linux Verification Center (linuxtesting.org) with Syzkaller. [sean massage changelog, make it clear this isnt architectural behavior] Consider specifically these CWEs: CWE-367 CWE-1274 CWE-1342 CWE-909 CWE-1281 CWE-125 CWE-667 CWE-393 CWE-755",
    "cwe_mentions": [
      "CWE-367",
      "CWE-1274",
      "CWE-1342",
      "CWE-909",
      "CWE-1281",
      "CWE-125",
      "CWE-667",
      "CWE-393",
      "CWE-755"
    ],
    "search_time": 3.4622995853424072
  },
  "timestamp": "2025-07-12 13:31:17",
  "cve_id": "CVE-2025-37957",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "609",
      "name": "Double-Checked Locking",
      "type": "base",
      "score": 2.8651999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "825",
      "name": "Expired Pointer Dereference",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "824",
      "name": "Access of Uninitialized Pointer",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "823",
      "name": "Use of Out-of-range Pointer Offset",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "367",
      "name": "Time-of-check Time-of-use (TOCTOU) Race Condition",
      "type": "base",
      "score": 2.1189999999999998,
      "relationship_count": 0
    },
    {
      "cwe_id": "125",
      "name": "Out-of-bounds Read",
      "type": "base",
      "score": 2.1189999999999998,
      "relationship_count": 0
    },
    {
      "cwe_id": "393",
      "name": "Return of Wrong Status Code",
      "type": "base",
      "score": 2.1189999999999998,
      "relationship_count": 0
    },
    {
      "cwe_id": "562",
      "name": "Return of Stack Variable Address",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "787",
      "name": "Out-of-bounds Write",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "129",
      "name": "Improper Validation of Array Index",
      "type": "variant",
      "score": 1.6320000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "781",
      "name": "Improper Address Validation in IOCTL with METHOD_NEITHER I/O Control Code",
      "type": "variant",
      "score": 1.6320000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "1281",
      "name": "Sequence of Processor Instructions Leads to Unexpected Behavior",
      "type": "Base",
      "score": 1.6157526822512709,
      "relationship_count": 0
    },
    {
      "cwe_id": "209",
      "name": "Generation of Error Message Containing Sensitive Information",
      "type": "base",
      "score": 1.5912000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "908",
      "name": "Use of Uninitialized Resource",
      "type": "Base",
      "score": 1.5315350891099802,
      "relationship_count": 0
    },
    {
      "cwe_id": "822",
      "name": "Untrusted Pointer Dereference",
      "type": "Base",
      "score": 1.52843216055459,
      "relationship_count": 0
    },
    {
      "cwe_id": "386",
      "name": "Symbolic Name not Mapping to Correct Object",
      "type": "base",
      "score": 1.521,
      "relationship_count": 0
    },
    {
      "cwe_id": "1342",
      "name": "Information Exposure through Microarchitectural State after Transient Execution",
      "type": "Base",
      "score": 1.510028132787963,
      "relationship_count": 0
    },
    {
      "cwe_id": "1274",
      "name": "Improper Access Control for Volatile Memory Containing Boot Code",
      "type": "Base",
      "score": 1.493193011206657,
      "relationship_count": 0
    },
    {
      "cwe_id": "789",
      "name": "Memory Allocation with Excessive Size Value",
      "type": "variant",
      "score": 1.2624,
      "relationship_count": 0
    },
    {
      "cwe_id": "782",
      "name": "Exposed IOCTL with Insufficient Access Control",
      "type": "variant",
      "score": 1.2624,
      "relationship_count": 0
    }
  ]
}