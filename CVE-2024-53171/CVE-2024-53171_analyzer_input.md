# Vulnerability Information: CVE-2024-53171

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved ubifs authentication Fix ****use-after-free**** in ubifs_tnc_end_commit After an insertion in TNC, the tree might split and cause a node to change its `znode->parent`. A further deletion of other nodes in the tree (which also could free the nodes), the aforementioned nodes `znode->cparent` could still point to a freed node. This `znode->cparent` may not be updated when getting nodes to commit in `ubifs_tnc_start_commit()`. This could then trigger a ****use-after-free**** when accessing the `znode->cparent` in `write_index()` in `ubifs_tnc_end_commit()`. This can be triggered by running rm -f /etc/test-file.bin dd if=/dev/urandom of=/etc/test-file.bin bs=1M count=60 conv=fsync in a loop, and with `CONFIG_UBIFS_FS_AUTHENTICATION`. KASAN then reports BUG KASAN ****use-after-free**** in ubifs_tnc_end_commit+0xa5c/0x1950 Write of size 32 at addr ffffff800a3af86c by task ubifs_bgt0_20/153 Call trace dump_backtrace+0x0/0x340 show_stack+0x18/0x24 dump_stack_lvl+0x9c/0xbc print_address_description.constprop.0+0x74/0x2b0 kasan_report+0x1d8/0x1f0 kasan_check_range+0xf8/0x1a0 memcpy+0x84/0xf4 ubifs_tnc_end_commit+0xa5c/0x1950 do_commit+0x4e0/0x1340 ubifs_bg_thread+0x234/0x2e0 kthread+0x36c/0x410 ret_from_fork+0x10/0x20 Allocated by task 401 kasan_save_stack+0x38/0x70 __kasan_kmalloc+0x8c/0xd0 __kmalloc+0x34c/0x5bc tnc_insert+0x140/0x16a4 ubifs_tnc_add+0x370/0x52c ubifs_jnl_write_data+0x5d8/0x870 do_writepage+0x36c/0x510 ubifs_writepage+0x190/0x4dc __writepage+0x58/0x154 write_cache_pages+0x394/0x830 do_writepages+0x1f0/0x5b0 filemap_fdatawrite_wbc+0x170/0x25c file_write_and_wait_range+0x140/0x190 ubifs_fsync+0xe8/0x290 vfs_fsync_range+0xc0/0x1e4 do_fsync+0x40/0x90 __arm64_sys_fsync+0x34/0x50 invoke_syscall.constprop.0+0xa8/0x260 do_el0_svc+0xc8/0x1f0 el0_svc+0x34/0x70 el0t_64_sync_handler+0x108/0x114 el0t_64_sync+0x1a4/0x1a8 Freed by task 403 kasan_save_stack+0x38/0x70 kasan_set_track+0x28/0x40 kasan_set_free_info+0x28/0x4c __kasan_slab_free+0xd4/0x13c kfree+0xc4/0x3a0 tnc_delete+0x3f4/0xe40 ubifs_tnc_remove_range+0x368/0x73c ubifs_tnc_remove_ino+0x29c/0x2e0 ubifs_jnl_delete_inode+0x150/0x260 ubifs_evict_inode+0x1d4/0x2e4 evict+0x1c8/0x450 iput+0x2a0/0x3c4 do_unlinkat+0x2cc/0x490 __arm64_sys_unlinkat+0x90/0x100 invoke_syscall.constprop.0+0xa8/0x260 do_el0_svc+0xc8/0x1f0 el0_svc+0x34/0x70 el0t_64_sync_handler+0x108/0x114 el0t_64_sync+0x1a4/0x1a8 The offending `memcpy()` in `ubifs_copy_hash()` has a ****use-after-free**** when a node becomes root in TNC but still has a `cparent` to an already freed node. More specifically, consider the following TNC zroot / / zp1 / / zn Inserting a new node `zn_new` with a key smaller then `zn` will trigger a split in `tnc_insert()` if `zp1` is full zroot / \\ / \\ zp1 zp2 / \\ / \\ zn_new zn `zn->parent` has now been moved to `zp2`, *but* `zn->cparent` still points to `zp1`. Now, consider a removal of all the nodes _except_ `zn`. Just when `tnc_delete()` is about to delete `zroot` and `zp2` zroot \\ \\ zp2 \\ \\ zn `zroot` and `zp2` get freed and the tree collapses zn `zn` now becomes the new `zroot`. `get_znodes_to_commit()` will now only find `zn`, the new `zroot`, and `write_index()` will check its `znode->cparent` that wrongly points to the already freed `zp1`. `ubifs_copy_hash()` thus gets wrongly called with `znode->cparent->zbranch[znode->iip].hash` that triggers the ****use-after-free****! Fix this by explicitly setting `znode->cparent` to `NULL` in `get_znodes_to_commit()` for the root node. The search for the dirty nodes ---truncated---

### Vulnerability Description Key Phrases
- **rootcause:** **use-after-free**
- **weakness:** **use-after-free**
- **product:** Linux kernel
- **component:** ubifs

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of the vulnerability:

**Root Cause:**
The root cause of this vulnerability is a use-after-free in the `ubifs_tnc_end_commit` function within the UBIFS file system when authentication is enabled (`CONFIG_UBIFS_FS_AUTHENTICATION`). This occurs due to a mismatch between the parent and child pointers in the TNC (Tree Node Cache) after tree splits and node deletions.

**Weaknesses/Vulnerabilities Present:**
- **Use-After-Free:** The primary vulnerability is a use-after-free. After a TNC insertion and subsequent splits, a node’s `znode->cparent` pointer may still point to a freed node due to the parent pointer not being updated. This leads to accessing freed memory when `ubifs_copy_hash` attempts to access hash data through this dangling pointer.
- **Incorrect Parent Pointer Handling:** The vulnerability stems from the incorrect handling of the `cparent` pointer during TNC node updates and deletions. This occurs during tree splits, where `znode->parent` gets updated, but `znode->cparent` is not.

**Impact of Exploitation:**
- **Kernel Crash:** The use-after-free causes a kernel crash, as KASAN reports a memory access violation. This can lead to a denial-of-service condition.
- **Potential Code Execution:** While not explicitly stated, use-after-free vulnerabilities can sometimes be leveraged for more severe attacks if the freed memory is subsequently reallocated with attacker-controlled data. This could potentially lead to code execution.

**Attack Vectors:**
- **File System Operations:** The vulnerability is triggered by performing file system operations on a UBIFS volume with authentication enabled, particularly through a specific sequence of file creations, writes, and deletions.
- **Specifically crafted loop:** The provided test case involves repeatedly removing a test file, writing random data to it, and syncing the file system. This triggers the TNC manipulations that expose the vulnerability.

**Required Attacker Capabilities/Position:**
- **Local User:** The attacker needs to be a local user with the ability to mount and perform file system operations on a UBIFS partition.
- **UBIFS with Authentication Enabled:** The vulnerability requires the UBIFS file system to be mounted with authentication enabled (`CONFIG_UBIFS_FS_AUTHENTICATION`).

**Technical Details and Explanation:**
1. **TNC Tree Structure:**
   The TNC is a tree-like structure used for indexing file system metadata in UBIFS. Each node (znode) has pointers to its parent (`znode->parent`) and a cached parent (`znode->cparent`).
2. **Tree Splits and Parent Changes:**
   - During insertion, if a znode's parent (zp1) is full, a tree split occurs.
   - This split results in a new sibling node (zp2), and some of the child nodes move to the new sibling.
   - The `znode->parent` pointer is updated to the new node. However, `znode->cparent` is left pointing to the old parent.
3. **Node Deletion and Tree Collapse:**
   - If all other nodes are deleted except the target node (zn), the TNC tree collapses, and zn becomes the new root.
   - The `znode->cparent` of the new root zn still points to a freed memory location (the old parent zp1).
4. **Vulnerability Trigger:**
   - In `get_znodes_to_commit()`, which is responsible for finding dirty nodes to commit, the code does not update `znode->cparent` for root nodes when it becomes root.
   - In `ubifs_tnc_end_commit()`, when `write_index()` calls `ubifs_copy_hash()` using the dangling `znode->cparent`, it results in a use-after-free as it tries to access `znode->cparent->zbranch[znode->iip].hash`, which is now freed memory.

**Patch/Fix:**
The fix addresses this issue by explicitly setting `znode->cparent` to `NULL` in `get_znodes_to_commit()` when the current node is identified as the root node of the TNC. This prevents the use of the dangling pointer and the associated use-after-free vulnerability.

**Additional Notes:**
- The content provides detailed crash traces from Kernel Address Sanitizer (KASAN) which confirms the vulnerability.
- This vulnerability was introduced by the commit `16a26b20d2af` which added hashes to the index nodes.
- The provided test case can easily be used to verify the bug.
- The fix includes an assertion to verify that the current node indeed has no parent when setting the `cparent` pointer to `NULL`.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 416 | Use After Free | Variant | Allowed | alternate_terms | 1.000 |
| 2 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 1.473 |
| 3 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 1.413 |
| 4 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 1.391 |
| 5 | 415 | Double Free | Variant | Allowed | sparse | 1.375 |
| 6 | 364 | Signal Handler Race Condition | Base | Allowed | sparse | 1.366 |
| 7 | 59 | Improper Link Resolution Before File Access ('Link Following') | Base | Allowed | sparse | 1.361 |
| 8 | 1390 | Weak Authentication | Class | Allowed-with-Review | sparse | 1.361 |
| 9 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | dense | 0.515 |
| 10 | 123 | Write-what-where Condition | Base | Allowed | graph | 0.003 |


---

## CWE Classification Guidance

The following guidance has been automatically included because relevant keywords were detected in the vulnerability description:

### Authentication vs Authorization vs Access Control Guidance

## ===Guidance===

### Level Set – Authentication vs Authorization vs Access Control

**Authentication**:
Determines *who* the actor is (identity validation). This is typically the *first step* in access control.

* Example phrases: "user must log in", "lack of login check", "bypasses login"
* CWE relevance: authentication is usually mapped to CWE-306 or its children.

  * **CWE-306**: *Missing Authentication for Critical Function* – used when no identity validation is enforced for sensitive functionality (e.g., password reset, user deletion).

**Authorization**:
Determines *what* an authenticated actor is allowed to do. It decides access *after* identity is verified.

* Example phrases: "unauthorized access", "regular user can access admin panel", "role checks are missing"
* CWE relevance: use CWEs like 862, 863, 285 for authorization errors:

  * **CWE-862**: *Missing Authorization* – the application doesn't check whether the user is authorized at all.
  * **CWE-863**: *Incorrect Authorization* – the application checks authorization, but does it incorrectly (e.g., flawed logic).
  * **CWE-285**: *Improper Authorization* – general category for any flawed authorization logic or design.

**Access Control**:
A broader term that includes both authentication and authorization. Governs how resources are protected and who can access them under what conditions.

* CWE relevance:

  * **CWE-284**: *Improper Access Control* – top-level category used when access control failure exists but root cause is unclear.
  * This should be avoided **if** a more specific child CWE like 285, 862, 863, or 306 is appropriate.

---

## Mapping Discussion – Common Misclassification Patterns

### 1. **CWE-306 vs CWE-862**:

* **306** is about lack of **authentication** (e.g., *no login required at all*).
* **862** is about lack of **authorization** *after* authentication (e.g., *admin check missing*).
* ✅ Example CWE-306: *“An unauthenticated attacker can invoke the password reset API.”*
* ✅ Example CWE-862: *“An authenticated user without admin privileges can delete any user account.”*

### 2. **CWE-285 vs CWE-284**:

* **285** is specific to authorization flaws – it's a better choice than 284 **if** the issue involves *improper or missing role checks*.
* **284** should be reserved for general access control issues when it’s unclear whether the issue lies in authn or authz.

---

## Technical Impact vs Root Cause Clarification

**Phrase like "unauthorized access" is not enough.**

* If you **cannot determine whether identity was checked**, assume it’s **authorization** and consider 862 or 863.
* If you **know no login happened**, lean toward **authentication** → CWE-306.
* If the **access control policy is unclear or inconsistently enforced**, but it's not due to missing checks, consider **CWE-284**.

---

## Good Mapping Examples

* ✅ **CWE-306**: “The endpoint `/admin/deleteUser` does not require any authentication.”
* ✅ **CWE-862**: “Any logged-in user can change any other user's email without being an admin.”
* ✅ **CWE-863**: “An admin check exists but incorrectly grants access to non-admin users.”
* ✅ **CWE-285**: “Application uses a static role check that fails when roles change dynamically.”
* ✅ **CWE-284**: “Inconsistent enforcement of access rules across services with unclear policy source.”

---

## Summary – Quick LLM Rules of Thumb

| **Indicator**                                              | **Likely CWE** |
| ---------------------------------------------------------- | -------------- |
| No identity check (no login)                               | CWE-306        |
| No role/privilege check after login                        | CWE-862        |
| Role check is present but flawed                           | CWE-863        |
| General or ambiguous authorization failure                 | CWE-285        |
| High-level access control problem with no clear root cause | CWE-284        |


