# Vulnerability Information: CVE-2024-40927

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved xhci Handle TD clearing for multiple streams case When multiple streams are in use, **multiple TDs might be in flight when an endpoint is stopped**. We need to issue a Set TR Dequeue Pointer for each, to ensure everything is reset properly and the caches cleared. Change the logic so that any N>1 TDs found active for different streams are deferred until after the first one is processed, calling xhci_invalidate_cancelled_tds() again from xhci_handle_cmd_set_deq() to queue another command until we are done with all of them. Also change the error/should never happen paths to ensure we at least clear any affected TDs, even if we cant issue a command to clear the hardware cache, and complain loudly with an xhci_warn() if this ever happens. This problem case dates back to commit e9df17eb1408 (USB xhci Correct assumptions about number of rings per endpoint.) early on in the XHCI drivers life, when stream support was first added. It was then identified but not fixed nor made into a warning in commit 674f8438c121 (xhci split handling halted endpoints into two steps), which added a FIXME comment for the problem case (without materially changing the behavior as far as I can tell, though the new logic made the problem more obvious). Then later, in commit 94f339147fc3 (xhci Fix failure to give back some cached cancelled URBs.), it was acknowledged again. [Mathias commit 94f339147fc3 (xhci Fix failure to

### Vulnerability Description Key Phrases
- **rootcause:** **multiple TDs might be in flight when an endpoint is stopped**
- **impact:** insufficient cache flushing
- **product:** Linux kernel
- **component:** xhci

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of the vulnerability:

**Root Cause:**
The root cause lies in the XHCI (eXtensible Host Controller Interface) driver's incorrect handling of Transfer Descriptors (TDs) when multiple streams are used for a USB endpoint. When an endpoint is stopped, multiple TDs associated with different streams could be in flight. The driver failed to properly clear these TDs, particularly their cached states, which resulted in a use-after-free condition.

**Weaknesses/Vulnerabilities:**
- **Improper TD Clearing:** The XHCI driver did not correctly handle the case where multiple TDs for different streams were active when an endpoint was stopped. It would only clear one TD, leaving others in a cached state, leading to a use-after-free.
- **Lack of Warning/Logging:** The driver logged the issue using `xhci_dbg()`, which is not enabled by default, masking a severe issue. This made the issue extremely hard to debug in real world scenarios.
- **Incorrect assumption about number of rings per endpoint:** The original code was assuming a single ring per endpoint, and did not account for multiple rings, leading to the bug.

**Impact of Exploitation:**
- **xHC Crashes and IOMMU Faults:**  The primary impact was observed as xHC (XHCI Host Controller) crashes and IOMMU faults, particularly with UAS (USB Attached SCSI) devices when handling errors. This is because a stale TD could reference DMA pages that have already been unmapped.
- **Memory Corruption:** On systems without an IOMMU, the vulnerability would silently corrupt freed memory, leading to unpredictable behavior and potential security issues.
- **Use-After-Free (UAF):** A malicious USB device, pretending to be a UAS device, could deliberately trigger the UAF by reporting errors with the right timing, allowing for writing to freed memory. This constitutes a security vulnerability which could potentially lead to privilege escalation.

**Attack Vectors:**
- **Malicious USB Device:** A malicious USB device could trigger the vulnerability by sending specific error responses that lead to cancellation of multiple TDs associated with different streams.
- **Error Handling:** The vulnerability could be triggered via a normal error scenario in UAS devices, such as a read error on a USB storage device.

**Required Attacker Capabilities/Position:**
- **Physical Access:** An attacker would likely need physical access to the target system to connect a malicious USB device.
- **Device Manipulation:** The attacker needs the ability to control a USB device to send specific responses that can trigger the described race condition.
- **UAS device knowledge:** An attacker would need a deeper understanding of the UAS protocol.

**Additional Notes:**
- The issue existed for approximately 14 years and was noted in previous code commits with comments, but was never fully fixed.
- The fix includes a deferred handling mechanism to ensure all TDs associated with different streams are cleared and the cache is updated
- The fix includes more robust error handling and logs a warning message to easily identify the issue in the future.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 1.057 |
| 2 | 863 | Incorrect Authorization | Class | Allowed-with-Review | sparse | 1.056 |
| 3 | 306 | Missing Authentication for Critical Function | Base | Allowed | sparse | 1.033 |
| 4 | 617 | Reachable Assertion | Base | Allowed | sparse | 1.033 |
| 5 | 1390 | Weak Authentication | Class | Allowed-with-Review | sparse | 1.031 |
| 6 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 1.018 |
| 7 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 1.018 |
| 8 | 407 | Inefficient Algorithmic Complexity | Class | Allowed-with-Review | sparse | 1.011 |
| 9 | 773 | Missing Reference to Active File Descriptor or Handle | Variant | Allowed | dense | 0.474 |
| 10 | 476 | NULL Pointer Dereference | Base | Allowed | graph | 0.002 |

