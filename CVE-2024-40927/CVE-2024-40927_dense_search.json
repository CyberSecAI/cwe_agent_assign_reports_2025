{
  "retriever": "dense",
  "query": "In the Linux kernel, the following vulnerability has been resolved xhci Handle TD clearing for multiple streams case When multiple streams are in use, multiple TDs might be in flight when an endpoint is stopped. We need to issue a Set TR Dequeue Pointer for each, to ensure everything is reset properly and the caches cleared. Change the logic so that any N>1 TDs found active for different streams are deferred until after the first one is processed, calling xhci_invalidate_cancelled_tds() again from xhci_handle_cmd_set_deq() to queue another command until we are done with all of them. Also change the error/should never happen paths to ensure we at least clear any affected TDs, even if we cant issue a command to clear the hardware cache, and complain loudly with an xhci_warn() if this ever happens. This problem case dates back to commit e9df17eb1408 (USB xhci Correct assumptions about number of rings per endpoint.) early on in the XHCI drivers life, when stream support was first added. It was then identified but not fixed nor made into a warning in commit 674f8438c121 (xhci split handling halted endpoints into two steps), which added a FIXME comment for the problem case (without materially changing the behavior as far as I can tell, though the new logic made the problem more obvious). Then later, in commit 94f339147fc3 (xhci Fix failure to give back some cached cancelled URBs.), it was acknowledged again. [Mathias commit 94f339147fc3 (xhci Fix failure to",
  "keyphrases": {
    "rootcause": [
      "multiple TDs might be in flight when an endpoint is stopped"
    ]
  },
  "timestamp": "2025-07-13 12:42:55",
  "cve_id": "CVE-2024-40927",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "773",
      "name": "Missing Reference to Active File Descriptor or Handle",
      "type": "Variant",
      "score": 0.474277815514216
    },
    {
      "cwe_id": "191",
      "name": "Integer Underflow (Wrap or Wraparound)",
      "type": "Base",
      "score": 0.4729540337852848
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 0.46264955899120014
    },
    {
      "cwe_id": "775",
      "name": "Missing Release of File Descriptor or Handle after Effective Lifetime",
      "type": "Variant",
      "score": 0.4598805450265096
    },
    {
      "cwe_id": "1264",
      "name": "Hardware Logic with Insecure De-Synchronization between Control and Data Channels",
      "type": "Base",
      "score": 0.4572306239026236
    },
    {
      "cwe_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "type": "Base",
      "score": 0.4540454044304293
    },
    {
      "cwe_id": "366",
      "name": "Race Condition within a Thread",
      "type": "Base",
      "score": 0.4501801981734489
    },
    {
      "cwe_id": "122",
      "name": "Heap-based Buffer Overflow",
      "type": "Variant",
      "score": 0.45004212401886734
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 0.4489603151986518
    },
    {
      "cwe_id": "805",
      "name": "Buffer Access with Incorrect Length Value",
      "type": "Base",
      "score": 0.4488272463449139
    },
    {
      "cwe_id": "1261",
      "name": "Improper Handling of Single Event Upsets",
      "type": "Base",
      "score": 0.4389950857073891
    },
    {
      "cwe_id": "606",
      "name": "Unchecked Input for Loop Condition",
      "type": "Base",
      "score": 0.43626194454662043
    },
    {
      "cwe_id": "774",
      "name": "Allocation of File Descriptors or Handles Without Limits or Throttling",
      "type": "Variant",
      "score": 0.4360803715150888
    },
    {
      "cwe_id": "121",
      "name": "Stack-based Buffer Overflow",
      "type": "Variant",
      "score": 0.43155366839234777
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "type": "Variant",
      "score": 0.4315198470193078
    },
    {
      "cwe_id": "401",
      "name": "Missing Release of Memory after Effective Lifetime",
      "type": "Variant",
      "score": 0.43129923435598305
    },
    {
      "cwe_id": "782",
      "name": "Exposed IOCTL with Insufficient Access Control",
      "type": "Variant",
      "score": 0.4299405963383435
    },
    {
      "cwe_id": "130",
      "name": "Improper Handling of Length Parameter Inconsistency",
      "type": "Base",
      "score": 0.4296534584645755
    },
    {
      "cwe_id": "1250",
      "name": "Improper Preservation of Consistency Between Independent Representations of Shared State",
      "type": "Base",
      "score": 0.42959907674102443
    },
    {
      "cwe_id": "119",
      "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
      "type": "Class",
      "score": 0.4295489714290662
    }
  ]
}