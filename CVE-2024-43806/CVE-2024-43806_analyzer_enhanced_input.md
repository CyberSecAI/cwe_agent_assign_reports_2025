## Vulnerability Description
Rustix is a set of safe Rust bindings to POSIX-ish APIs. When using `rustixfsDir` using the `linux_raw` backend, its possible for the iterator to get stuck when an IO error is encountered. Combined with a **memory over-allocation** issue in `rustixfsDirread_more`, this can cause quick and unbounded memory explosion (gigabytes in a few seconds if used on a hot path) and eventually lead to an OOM crash of the application. The symptoms were initially discovered in https//github.com/imsnif/bandwhich/issues/284. That post has lots of details of our investigation. Full details can be read on the GHSA-c827-hfw6-qwvm repo advisory. If a program tries to access a directory with its file descriptor after the file has been unlinked (or any other action that leaves the `Dir` iterator in the stuck state), and the implementation does not break after seeing an error, it can cause a memory explosion. As an example, Linuxs various virtual file systems (e.g. `/proc`, `/sys`) can contain directories that spontaneously pop in and out of existence. Attempting to iterate over them using `rustixfsDir` directly or indirectly (e.g. with the `procfs` crate) can trigger this fault condition if the implementation decides to continue on errors. An attacker knowledgeable about the implementation details of a vulnerable target can therefore try to trigger this fault condition via any one or a combination of several available APIs. If successful, the application host will quickly run out of m

### Vulnerability Description Key Phrases
- **rootcause:** **memory over-allocation**
- **impact:** memory explosion and OOM crash
- **product:** Rustix
- **component:** rustixfsDir

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of the vulnerability:

**Root Cause of Vulnerability:**
The vulnerability stems from two combined issues in the `rustix` crate, specifically when using the `linux_raw` backend for directory iteration:
1.  **Stuck Iterator:** The `rustix::fs::Dir` iterator can get stuck in an infinite loop when an I/O error is encountered, failing to halt after the error occurs.
2.  **Memory Over-allocation:** The `Dir::read_more` function incorrectly grows the read buffer (`self.buf`) each time it's called. It uses `self.buf.capacity()` instead of `self.buf.len()` when resizing, leading to unbounded memory growth.

**Weaknesses/Vulnerabilities Present:**
-   Incorrect buffer resizing logic in `Dir::read_more`.
-   The iterator's failure to halt upon encountering an I/O error.

**Impact of Exploitation:**
-   **Denial of Service (DoS):** An attacker can trigger a rapid and unbounded memory explosion by causing the `rustix::fs::Dir` iterator to get stuck. This leads to the application consuming excessive memory and eventually being terminated by the operating system's OOM killer.
-   **Application Crash:** The uncontrolled memory growth results in an out-of-memory (OOM) condition, causing the application to crash.

**Attack Vectors:**
-   Accessing a directory with its file descriptor after the directory has been unlinked.
-   Iterating over virtual file systems (e.g., `/proc`, `/sys`) where directories can appear and disappear.
-   Any scenario where the `rustix::fs::Dir` iterator encounters an I/O error and continues iterating.
-   Specifically, `bandwhich` uses `procfs` which internally uses `rustix` to iterate over file descriptors. This path was used to identify and reproduce the issue.

**Required Attacker Capabilities/Position:**
-   The attacker needs to be able to trigger the vulnerable code path. This could involve:
    -   Manipulating the file system to cause I/O errors during directory iteration.
    -   Interacting with virtual file systems that might cause the directory iterator to encounter transient errors.
-  Low privileges are enough to trigger the vulnerability, although the impact of the denial of service attack will likely affect the whole system.

**Additional Notes:**
-   The vulnerability was initially discovered in the `bandwhich` application and was tracked down to `rustix` crate.
-   The issue was diagnosed by analyzing memory usage and backtraces using tools like `heaptrack` and `flamegraph`.
-   The fix involves modifying `Dir::read_more` to use `self.buf.len()` instead of `self.buf.capacity()` when resizing the buffer, and ensuring that the iterator halts on I/O errors.
-   Patched versions are ~0.35.15, ~0.36.16, ~0.37.25, ~0.38.19
-   The issue was identified by `konnorandrews`.
-   The CVSS score was rated as moderate with a base score of 6.5
-   CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 1.238 |
| 2 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 1.184 |
| 3 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 1.181 |
| 4 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 1.174 |
| 5 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 1.174 |
| 6 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | sparse | 1.168 |
| 7 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 1.156 |
| 8 | 190 | Integer Overflow or Wraparound | Base | Allowed | sparse | 1.151 |
| 9 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | dense | 0.490 |
| 10 | 1325 | Improperly Controlled Sequential Memory Allocation | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-1284: Improper Validation of Specified Quantity in Input

CWE-770: Allocation of Resources Without Limits or Throttling

CWE-125: Out-of-bounds Read

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-401: Missing Release of Memory after Effective Lifetime

CWE-789: Memory Allocation with Excessive Size Value

CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition

CWE-190: Integer Overflow or Wraparound

CWE-674: Uncontrolled Recursion

CWE-1325: Improperly Controlled Sequential Memory Allocation