## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved KVM arm64 Get rid of userspace_irqchip_in_use Improper use of userspace_irqchip_in_use led to syzbot hitting the following WARN_ON() in kvm_timer_update_irq() WARNING CPU 0 PID 3281 at arch/arm64/kvm/arch_timer.c459 kvm_timer_update_irq+0x21c/0x394 Call trace kvm_timer_update_irq+0x21c/0x394 arch/arm64/kvm/arch_timer.c459 kvm_timer_vcpu_reset+0x158/0x684 arch/arm64/kvm/arch_timer.c968 kvm_reset_vcpu+0x3b4/0x560 arch/arm64/kvm/reset.c264 kvm_vcpu_set_target arch/arm64/kvm/arm.c1553 [inline] kvm_arch_vcpu_ioctl_vcpu_init arch/arm64/kvm/arm.c1573 [inline] kvm_arch_vcpu_ioctl+0x112c/0x1b3c arch/arm64/kvm/arm.c1695 kvm_vcpu_ioctl+0x4ec/0xf74 virt/kvm/kvm_main.c4658 vfs_ioctl fs/ioctl.c51 [inline] __do_sys_ioctl fs/ioctl.c907 [inline] __se_sys_ioctl fs/ioctl.c893 [inline] __arm64_sys_ioctl+0x108/0x184 fs/ioctl.c893 __invoke_syscall arch/arm64/kernel/syscall.c35 [inline] invoke_syscall+0x78/0x1b8 arch/arm64/kernel/syscall.c49 el0_svc_common+0xe8/0x1b0 arch/arm64/kernel/syscall.c132 do_el0_svc+0x40/0x50 arch/arm64/kernel/syscall.c151 el0_svc+0x54/0x14c arch/arm64/kernel/entry-common.c712 el0t_64_sync_handler+0x84/0xfc arch/arm64/kernel/entry-common.c730 el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S598 The following sequence led to the scenario - Userspace creates a VM and a vCPU. - The vCPU is initialized with KVM_ARM_VCPU_PMU_V3 during KVM_ARM_VCPU_INIT. - Without any other setup, such as vGIC or vPMU, userspace issues KVM_RUN on the vCPU. Since the vPMU is requested, but not setup, kvm_arm_pmu_v3_enable() fails in kvm_arch_vcpu_run_pid_change(). As a result, KVM_RUN returns after enabling the timer, but before incrementing userspace_irqchip_in_use kvm_arch_vcpu_run_pid_change() ret = kvm_arm_pmu_v3_enable() if (!vcpu->arch.pmu.created) return -EINVAL if (ret) return ret [...] if (!irqchip_in_kernel(kvm)) static_branch_inc(&userspace_irqchip_in_use) - Userspace ignores the error and issues KVM_ARM_VCPU_INIT again. Since the timer is already enabled, control moves through the following flow, ultimately hitting the WARN_ON() kvm_timer_vcpu_reset() if (timer->enabled) kvm_timer_update_irq() if (!userspace_irqchip()) ret = kvm_vgic_inject_irq() ret = vgic_lazy_init() if (unlikely(!vgic_initialized(kvm))) if (kvm->arch.vgic.vgic_model != KVM_DEV_TYPE_ARM_VGIC_V2) return -EBUSY WARN_ON(ret) Theoretically, since userspace_irqchip_in_uses functionality can be simply replaced by !irqchip_in_kernel(), get rid of the static key to avoid the mismanagement, which also helps with the syzbot issue.

### Vulnerability Description Key Phrases
- **component:** KVM
- **rootcause:** **Improper use of userspace_irqchip_in_use, userspace doesn't account for IRQ chip state**
- **vector:** KVM_ARM_VCPU_PMU_V3 activation and userspace KVM_RUN
- **product:** Linux kernel
- **impact:** WARN_ON

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of the vulnerability:

**Root Cause:**

The vulnerability stems from an improper use of the `userspace_irqchip_in_use` static key in the KVM (Kernel Virtual Machine) implementation for the ARM64 architecture. This key is intended to track whether a userspace interrupt controller is in use, but its usage is flawed, leading to a race condition and a subsequent WARN_ON failure.

**Vulnerabilities/Weaknesses:**

1.  **Incorrect `userspace_irqchip_in_use` Logic:** The static key `userspace_irqchip_in_use` is incremented in `kvm_arch_vcpu_run_pid_change()` when a vPMU (virtual Performance Monitoring Unit) is requested but not properly set up, and the function returns an error. Critically, the key is incremented *after* the timer is enabled, but *before* the function returns due to the vPMU setup failure. If userspace then attempts another initialization, this can lead to the static key being in an incorrect state, triggering a WARN\_ON in `kvm_timer_update_irq()`.
2.  **Race Condition:** The described sequence exposes a race between the vCPU initialization and KVM\_RUN. If a user issues KVM\_RUN before properly setting up a requested vPMU, the key might be incremented incorrectly, causing the system to enter a state where it assumes a userspace irqchip is in use when it is not.
3.  **Mismanagement of `userspace_irqchip_in_use`:** The usage of a static key to track a condition that can be reliably determined by checking `irqchip_in_kernel()` leads to unnecessary complexity and potential for errors. The static key is also decremented in `kvm_arch_vcpu_destroy()` but only if `vcpu_has_run_once(vcpu)` which leads to another potential mismatch in the static key state.

**Impact of Exploitation:**

*   **Kernel Panic:** The immediate impact is a kernel `WARN_ON` failure that is hit by the syzbot, leading to a kernel panic/crash, which can cause denial of service.

**Attack Vectors:**

*   **Userspace Interaction:** The attack is triggered by a specific sequence of ioctl calls from userspace to the KVM subsystem.
*   **KVM API:** The specific ioctls involved include:
    *   `KVM_ARM_VCPU_INIT` to initialize a vCPU with `KVM_ARM_VCPU_PMU_V3`.
    *   `KVM_RUN` to start the vCPU execution without proper vPMU setup.
    *   Potentially subsequent `KVM_ARM_VCPU_INIT` calls if the error is ignored by the user.

**Required Attacker Capabilities/Position:**

*   **Ability to use KVM API:** The attacker needs to be able to create VMs and vCPUs via the KVM API, using ioctl operations.
*   **No special privileges:** The attacker does not need root or other specific elevated privileges. This is because the vulnerability lies in the normal usage flow of the KVM API.

**More details than the CVE description:**

The provided content gives a detailed sequence of operations that lead to the WARN\_ON, which is more than a generic description. It also explains:

*   The exact code flow in the kernel that leads to the issue.
*   The flawed logic behind `userspace_irqchip_in_use`.
*   The specific functions where the static key is incremented/decremented.
*   How the static key is redundant.

The patch essentially removes the problematic `userspace_irqchip_in_use` static key and replaces its usage with direct checks against the function `irqchip_in_kernel()`. This eliminates the race condition and associated issues.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 393 | Return of Wrong Status Code | Base | Allowed | sparse | 1.087 |
| 2 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.987 |
| 3 | 733 | Compiler Optimization Removal or Modification of Security-critical Code | Base | Allowed | sparse | 0.906 |
| 4 | 226 | Sensitive Information in Resource Not Removed Before Reuse | Base | Allowed | sparse | 0.888 |
| 5 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | sparse | 0.875 |
| 6 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.837 |
| 7 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.820 |
| 8 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.779 |
| 9 | 1342 | Information Exposure through Microarchitectural State after Transient Execution | Base | Allowed | dense | 0.542 |
| 10 | 609 | Double-Checked Locking | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-393: Return of Wrong Status Code

CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition

CWE-733: Compiler Optimization Removal or Modification of Security-critical Code

CWE-226: Sensitive Information in Resource Not Removed Before Reuse

CWE-909: Missing Initialization of Resource

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-125: Out-of-bounds Read

CWE-667: Improper Locking

CWE-1342: Information Exposure through Microarchitectural State after Transient Execution

CWE-609: Double-Checked Locking