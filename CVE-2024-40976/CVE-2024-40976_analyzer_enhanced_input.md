## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved drm/lima mask irqs in timeout path before hard reset There is a **race condition** in which a rendering job might take just long enough to trigger the drm sched job timeout handler but also still complete before the hard reset is done by the timeout handler. This runs into **race condition**s not expected by the timeout handler. In some very specific cases it currently may result in a refcount imbalance on lima_pm_idle, with a stack dump such as [10136.669170] WARNING CPU 0 PID 0 at drivers/gpu/drm/lima/lima_devfreq.c205 lima_devfreq_record_idle+0xa0/0xb0 ... [10136.669459] pc lima_devfreq_record_idle+0xa0/0xb0 ... [10136.669628] Call trace [10136.669634] lima_devfreq_record_idle+0xa0/0xb0 [10136.669646] lima_sched_pipe_task_done+0x5c/0xb0 [10136.669656] lima_gp_irq_handler+0xa8/0x120 [10136.669666] __handle_irq_event_percpu+0x48/0x160 [10136.669679] handle_irq_event+0x4c/0xc0 We can prevent that **race condition** entirely by masking the irqs at the beginning of the timeout handler, at which point we give up on waiting for that job entirely. The irqs will be enabled again at the next hard reset which is already done as a recovery by the timeout handler.

### Vulnerability Description Key Phrases
- **rootcause:** **race condition**
- **impact:** refcount imbalance
- **product:** Linux kernel
- **component:** drm/lima mask irqs in timeout path before hard reset

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of the vulnerability addressed by the commits:

**Root Cause:**
A race condition exists in the Lima DRM driver's scheduler. A rendering job could take just enough time to trigger the timeout handler, but also complete before the hard reset initiated by the same handler. This leads to unexpected race conditions within the timeout handler.

**Weaknesses/Vulnerabilities:**
- **Race Condition:** The core issue is a race condition between the job completion and the timeout handler's actions. Specifically, the timeout handler doesn't properly account for the possibility of the job finishing concurrently with the handler's execution.
- **Refcount Imbalance:** In certain scenarios, this race condition results in a refcount imbalance on `lima_pm_idle`. This suggests a resource management issue where a resource is released or acquired at the wrong time.

**Impact of Exploitation:**
- **System Instability:** The immediate impact is a refcount imbalance and a stack dump, indicating the system enters an inconsistent state.
- **Potential for Further Issues:** While not explicitly stated, a refcount imbalance can lead to memory corruption or other unpredictable behavior if left unaddressed.
- **Denial of Service:** The stack dump could lead to a crash, thus denying service.

**Attack Vectors:**
- **Triggering Long-Running Jobs:** An attacker could trigger rendering jobs that are carefully timed to create the race condition.

**Required Attacker Capabilities/Position:**
- **Ability to submit rendering jobs:** The attacker must have the ability to submit rendering jobs to the GPU via the Lima DRM driver. This typically implies a user-space process capable of interacting with the graphics subsystem.

**Mitigation:**
The fix is to mask all IRQs at the beginning of the timeout handler. This prevents the job from completing while the handler is running. The IRQs are re-enabled later by the hard reset done by the timeout handler, thus not breaking normal operation.

**Additional Notes:**
- The patch adds a call to `pipe->task_mask_irq(pipe)` at the beginning of the `lima_sched_timedout_job` function, which masks the relevant interrupts to avoid the race condition.
- The provided stack trace highlights the specific call sequence that leads to the refcount issue.
- This issue was fixed in multiple stable kernel branches.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | alternate_terms | 1.000 |
| 2 | 364 | Signal Handler Race Condition | Base | Allowed | sparse | 0.773 |
| 3 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.768 |
| 4 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | sparse | 0.767 |
| 5 | 59 | Improper Link Resolution Before File Access ('Link Following') | Base | Allowed | sparse | 0.733 |
| 6 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.713 |
| 7 | 400 | Uncontrolled Resource Consumption | Class | Discouraged | sparse | 0.695 |
| 8 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | sparse | 0.692 |
| 9 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | Allowed | dense | 0.466 |
| 10 | 363 | Race Condition Enabling Link Following | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-364: Signal Handler Race Condition

CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition

CWE-789: Memory Allocation with Excessive Size Value

CWE-59: Improper Link Resolution Before File Access ('Link Following')

CWE-667: Improper Locking

CWE-400: Uncontrolled Resource Consumption

CWE-674: Uncontrolled Recursion

CWE-1285: Improper Validation of Specified Index, Position, or Offset in Input

CWE-363: Race Condition Enabling Link Following