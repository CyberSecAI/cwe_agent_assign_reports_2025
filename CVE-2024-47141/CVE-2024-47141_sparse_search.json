{
  "retriever": "sparse",
  "query": "In the Linux kernel, the following vulnerability has been resolved pinmux Use sequential access to access desc->pinmux data When two client of the same gpio call pinctrl_select_state() for the same functionality, we are seeing NULL pointer issue while accessing desc->mux_owner. Lets say two processes A, B executing in pin_request() for the same pin and process A updates the desc->mux_usecount but not yet updated the desc->mux_owner while process B see the desc->mux_usecount which got updated by A path and further executes strcmp and while accessing desc->mux_owner it crashes with NULL pointer. Serialize the access to mux related setting with a mutex lock. cpu0 (process A) cpu1(process B) pinctrl_select_state() { pinctrl_select_state() { pin_request() { pin_request() { ... .... } else { desc->mux_usecount++ desc->mux_usecount && strcmp(desc->mux_owner, owner)) { if (desc->mux_usecount > 1) return 0 desc->mux_owner = owner } }",
  "keyphrases": {
    "weakness": [
      "NULL pointer issue"
    ]
  },
  "timestamp": "2025-07-12 04:53:33",
  "cve_id": "CVE-2024-47141",
  "result_count": 12,
  "results": [
    {
      "cwe_id": "770",
      "name": "Allocation of Resources Without Limits or Throttling",
      "score": 551.8720918512677,
      "search_source": "weakness:NULL pointer issue"
    },
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "score": 531.1680649283732,
      "search_source": "weakness:NULL pointer issue"
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "score": 515.0909188722432,
      "search_source": "weakness:NULL pointer issue"
    },
    {
      "cwe_id": "121",
      "name": "Stack-based Buffer Overflow",
      "score": 514.6846078538532,
      "search_source": "weakness:NULL pointer issue"
    },
    {
      "cwe_id": "252",
      "name": "Unchecked Return Value",
      "score": 503.0307440778607,
      "search_source": "weakness:NULL pointer issue"
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "score": 493.0147146268125,
      "search_source": "weakness:NULL pointer issue"
    },
    {
      "cwe_id": "335",
      "name": "Incorrect Usage of Seeds in Pseudo-Random Number Generator (PRNG)",
      "score": 487.37720100868785,
      "search_source": "weakness:NULL pointer issue"
    },
    {
      "cwe_id": "364",
      "name": "Signal Handler Race Condition",
      "score": 473.62832474642005,
      "search_source": "weakness:NULL pointer issue"
    },
    {
      "cwe_id": "367",
      "name": "Time-of-check Time-of-use (TOCTOU) Race Condition",
      "score": 472.68423229673834,
      "search_source": "weakness:NULL pointer issue"
    },
    {
      "cwe_id": "617",
      "name": "Reachable Assertion",
      "score": 471.84043031229083,
      "search_source": "weakness:NULL pointer issue"
    },
    {
      "cwe_id": "863",
      "name": "Incorrect Authorization",
      "score": 166.16085485051372,
      "search_source": "base_query"
    },
    {
      "cwe_id": "1204",
      "name": "Generation of Weak Initialization Vector (IV)",
      "score": 165.0421525863187,
      "search_source": "base_query"
    }
  ]
}