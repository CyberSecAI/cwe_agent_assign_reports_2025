# Vulnerability Information: CVE-2024-43890

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved tracing **Fix overflow in get_free_elt() tracing_map->next_elt in get_free_elt() is at risk of overflowing**. Once it overflows, new elements can still be inserted into the tracing_map even though the maximum number of elements (`max_elts`) has been reached. Continuing to insert elements after the overflow could result in the tracing_map containing tracing_map->max_size elements, leaving no empty entries. If any attempt is made to insert an element into a full tracing_map using `__tracing_map_insert()`, it will cause an infinite loop with preemption disabled, leading to a CPU hang problem. Fix this by preventing any further increments to tracing_map->next_elt once it reaches tracing_map->max_elt.

### Vulnerability Description Key Phrases
- **weakness:** **Fix overflow in get_free_elt() tracing_map->next_elt in get_free_elt() is at risk of overflowing**
- **impact:** infinite loop with preemption disabled, leading to a CPU hang problem
- **vector:** inserting elements into a full tracing_map
- **product:** Linux kernel

## CVE Reference Links Content Summary
The provided content is related to CVE-2024-43890.

**Root cause of vulnerability:**
The `tracing_map->next_elt` variable in the `get_free_elt()` function of the Linux kernel tracing subsystem is at risk of overflowing.

**Weaknesses/vulnerabilities present:**
- Integer overflow: The atomic increment of `tracing_map->next_elt` was not properly checked against the maximum number of elements (`max_elts`). This allowed `next_elt` to wrap around to 0 after reaching the maximum value.
- Infinite Loop: If new elements were inserted into the tracing map after the overflow, the map would reach its maximum size (`tracing_map->max_size`), leaving no free entries. Subsequent attempts to insert elements into a full map using `__tracing_map_insert()` would result in an infinite loop with preemption disabled.

**Impact of exploitation:**
A successful exploitation of this vulnerability could lead to a denial of service condition, resulting in a CPU hang.

**Attack vectors:**
- The vulnerability can be triggered by continuously inserting elements into the tracing map until it overflows.

**Required attacker capabilities/position:**
- The attacker would need to be able to trigger the insertion of a sufficient number of elements into the tracing map to cause the overflow. This likely requires some form of privileged access to interact with the kernel tracing interface.

**Technical Details:**
The fix replaces `atomic_inc_return` with `atomic_fetch_add_unless`. This prevents any further increments to `tracing_map->next_elt` when it equals `tracing_map->max_elts`. Additionally, `atomic_set(&map->next_elt, -1);` was changed to `atomic_set(&map->next_elt, 0);` when the tracing map is cleared or created.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | Allowed | sparse | 0.522 |
| 2 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | sparse | 0.521 |
| 3 | 190 | Integer Overflow or Wraparound | Base | Allowed | sparse | 0.512 |
| 4 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.511 |
| 5 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.504 |
| 6 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.497 |
| 7 | 122 | Heap-based Buffer Overflow | Variant | Allowed | sparse | 0.486 |
| 8 | 193 | Off-by-one Error | Base | Allowed | sparse | 0.484 |
| 9 | 197 | Numeric Truncation Error | Base | Allowed | dense | 0.493 |
| 10 | 1339 | Insufficient Precision or Accuracy of a Real Number | Base | Allowed | graph | 0.002 |

