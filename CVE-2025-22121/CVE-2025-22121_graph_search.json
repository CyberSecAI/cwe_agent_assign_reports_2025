{
  "retriever": "graph",
  "query": "In the Linux kernel, the following vulnerability has been resolved ext4 fix out-of-bound read in ext4_xattr_inode_dec_ref_all() Theres issue as follows BUG KASAN use-after-free in ext4_xattr_inode_dec_ref_all+0x6ff/0x790 Read of size 4 at addr ffff88807b003000 by task syz-executor.0/15172 CPU 3 PID 15172 Comm syz-executor.0 Call Trace __dump_stack lib/dump_stack.c82 [inline] dump_stack+0xbe/0xfd lib/dump_stack.c123 print_address_description.constprop.0+0x1e/0x280 mm/kasan/report.c400 __kasan_report.cold+0x6c/0x84 mm/kasan/report.c560 kasan_report+0x3a/0x50 mm/kasan/report.c585 ext4_xattr_inode_dec_ref_all+0x6ff/0x790 fs/ext4/xattr.c1137 ext4_xattr_delete_inode+0x4c7/0xda0 fs/ext4/xattr.c2896 ext4_evict_inode+0xb3b/0x1670 fs/ext4/inode.c323 evict+0x39f/0x880 fs/inode.c622 iput_final fs/inode.c1746 [inline] iput fs/inode.c1772 [inline] iput+0x525/0x6c0 fs/inode.c1758 ext4_orphan_cleanup fs/ext4/super.c3298 [inline] ext4_fill_super+0x8c57/0xba40 fs/ext4/super.c5300 mount_bdev+0x355/0x410 fs/super.c1446 legacy_get_tree+0xfe/0x220 fs/fs_context.c611 vfs_get_tree+0x8d/0x2f0 fs/super.c1576 do_new_mount fs/namespace.c2983 [inline] path_mount+0x119a/0x1ad0 fs/namespace.c3316 do_mount+0xfc/0x110 fs/namespace.c3329 __do_sys_mount fs/namespace.c3540 [inline] __se_sys_mount+0x219/0x2e0 fs/namespace.c3514 do_syscall_64+0x33/0x40 arch/x86/entry/common.c46 entry_SYSCALL_64_after_hwframe+0x67/0xd1 Memory state around the buggy address ffff88807b002f00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ffff88807b002f80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 >ffff88807b003000 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ^ ffff88807b003080 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ffff88807b003100 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff Above issue happens as ext4_xattr_delete_inode() isnt check xattr is valid if xattr is in inode. To solve above issue call xattr_check_inode() check if xattr if valid in inode. In fact, we can directly verify in ext4_iget_extra_inode(), so that there is no divergent verification. Consider specifically these CWEs: CWE-288 CWE-912 CWE-190 CWE-416 CWE-362 CWE-909 CWE-294 CWE-763 CWE-667",
  "keyphrases": {
    "original_query": "In the Linux kernel, the following vulnerability has been resolved ext4 fix out-of-bound read in ext4_xattr_inode_dec_ref_all() Theres issue as follows BUG KASAN use-after-free in ext4_xattr_inode_dec_ref_all+0x6ff/0x790 Read of size 4 at addr ffff88807b003000 by task syz-executor.0/15172 CPU 3 PID 15172 Comm syz-executor.0 Call Trace __dump_stack lib/dump_stack.c82 [inline] dump_stack+0xbe/0xfd lib/dump_stack.c123 print_address_description.constprop.0+0x1e/0x280 mm/kasan/report.c400 __kasan_report.cold+0x6c/0x84 mm/kasan/report.c560 kasan_report+0x3a/0x50 mm/kasan/report.c585 ext4_xattr_inode_dec_ref_all+0x6ff/0x790 fs/ext4/xattr.c1137 ext4_xattr_delete_inode+0x4c7/0xda0 fs/ext4/xattr.c2896 ext4_evict_inode+0xb3b/0x1670 fs/ext4/inode.c323 evict+0x39f/0x880 fs/inode.c622 iput_final fs/inode.c1746 [inline] iput fs/inode.c1772 [inline] iput+0x525/0x6c0 fs/inode.c1758 ext4_orphan_cleanup fs/ext4/super.c3298 [inline] ext4_fill_super+0x8c57/0xba40 fs/ext4/super.c5300 mount_bdev+0x355/0x410 fs/super.c1446 legacy_get_tree+0xfe/0x220 fs/fs_context.c611 vfs_get_tree+0x8d/0x2f0 fs/super.c1576 do_new_mount fs/namespace.c2983 [inline] path_mount+0x119a/0x1ad0 fs/namespace.c3316 do_mount+0xfc/0x110 fs/namespace.c3329 __do_sys_mount fs/namespace.c3540 [inline] __se_sys_mount+0x219/0x2e0 fs/namespace.c3514 do_syscall_64+0x33/0x40 arch/x86/entry/common.c46 entry_SYSCALL_64_after_hwframe+0x67/0xd1 Memory state around the buggy address ffff88807b002f00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ffff88807b002f80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 >ffff88807b003000 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ^ ffff88807b003080 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ffff88807b003100 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff Above issue happens as ext4_xattr_delete_inode() isnt check xattr is valid if xattr is in inode. To solve above issue call xattr_check_inode() check if xattr if valid in inode. In fact, we can directly verify in ext4_iget_extra_inode(), so that there is no divergent verification.",
    "enhanced_query": "In the Linux kernel, the following vulnerability has been resolved ext4 fix out-of-bound read in ext4_xattr_inode_dec_ref_all() Theres issue as follows BUG KASAN use-after-free in ext4_xattr_inode_dec_ref_all+0x6ff/0x790 Read of size 4 at addr ffff88807b003000 by task syz-executor.0/15172 CPU 3 PID 15172 Comm syz-executor.0 Call Trace __dump_stack lib/dump_stack.c82 [inline] dump_stack+0xbe/0xfd lib/dump_stack.c123 print_address_description.constprop.0+0x1e/0x280 mm/kasan/report.c400 __kasan_report.cold+0x6c/0x84 mm/kasan/report.c560 kasan_report+0x3a/0x50 mm/kasan/report.c585 ext4_xattr_inode_dec_ref_all+0x6ff/0x790 fs/ext4/xattr.c1137 ext4_xattr_delete_inode+0x4c7/0xda0 fs/ext4/xattr.c2896 ext4_evict_inode+0xb3b/0x1670 fs/ext4/inode.c323 evict+0x39f/0x880 fs/inode.c622 iput_final fs/inode.c1746 [inline] iput fs/inode.c1772 [inline] iput+0x525/0x6c0 fs/inode.c1758 ext4_orphan_cleanup fs/ext4/super.c3298 [inline] ext4_fill_super+0x8c57/0xba40 fs/ext4/super.c5300 mount_bdev+0x355/0x410 fs/super.c1446 legacy_get_tree+0xfe/0x220 fs/fs_context.c611 vfs_get_tree+0x8d/0x2f0 fs/super.c1576 do_new_mount fs/namespace.c2983 [inline] path_mount+0x119a/0x1ad0 fs/namespace.c3316 do_mount+0xfc/0x110 fs/namespace.c3329 __do_sys_mount fs/namespace.c3540 [inline] __se_sys_mount+0x219/0x2e0 fs/namespace.c3514 do_syscall_64+0x33/0x40 arch/x86/entry/common.c46 entry_SYSCALL_64_after_hwframe+0x67/0xd1 Memory state around the buggy address ffff88807b002f00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ffff88807b002f80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 >ffff88807b003000 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ^ ffff88807b003080 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ffff88807b003100 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff Above issue happens as ext4_xattr_delete_inode() isnt check xattr is valid if xattr is in inode. To solve above issue call xattr_check_inode() check if xattr if valid in inode. In fact, we can directly verify in ext4_iget_extra_inode(), so that there is no divergent verification. Consider specifically these CWEs: CWE-288 CWE-912 CWE-190 CWE-416 CWE-362 CWE-909 CWE-294 CWE-763 CWE-667",
    "cwe_mentions": [
      "CWE-288",
      "CWE-912",
      "CWE-190",
      "CWE-416",
      "CWE-362",
      "CWE-909",
      "CWE-294",
      "CWE-763",
      "CWE-667"
    ],
    "search_time": 3.7746927738189697
  },
  "timestamp": "2025-07-12 10:03:26",
  "cve_id": "CVE-2025-22121",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "364",
      "name": "Signal Handler Race Condition",
      "type": "base",
      "score": 2.8651999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "123",
      "name": "Write-what-where Condition",
      "type": "base",
      "score": 2.7014000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "294",
      "name": "Authentication Bypass by Capture-replay",
      "type": "base",
      "score": 2.3295999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "128",
      "name": "Wrap-around Error",
      "type": "base",
      "score": 2.2698,
      "relationship_count": 0
    },
    {
      "cwe_id": "1339",
      "name": "Insufficient Precision or Accuracy of a Real Number",
      "type": "base",
      "score": 2.2698,
      "relationship_count": 0
    },
    {
      "cwe_id": "120",
      "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "1265",
      "name": "Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "456",
      "name": "Missing Initialization of a Variable",
      "type": "variant",
      "score": 2.1936,
      "relationship_count": 0
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "type": "Variant",
      "score": 2.160552477733332,
      "relationship_count": 0
    },
    {
      "cwe_id": "288",
      "name": "Authentication Bypass Using an Alternate Path or Channel",
      "type": "base",
      "score": 2.1189999999999998,
      "relationship_count": 0
    },
    {
      "cwe_id": "763",
      "name": "Release of Invalid Pointer or Reference",
      "type": "base",
      "score": 2.1189999999999998,
      "relationship_count": 0
    },
    {
      "cwe_id": "590",
      "name": "Free of Memory not on the Heap",
      "type": "variant",
      "score": 2.06592,
      "relationship_count": 0
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 1.7584334149240641,
      "relationship_count": 0
    },
    {
      "cwe_id": "1257",
      "name": "Improper Access Control Applied to Mirrored or Aliased Memory Regions",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "1260",
      "name": "Improper Handling of Overlap Between Protected Memory Ranges",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "839",
      "name": "Numeric Range Comparison Without Minimum Check",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "843",
      "name": "Access of Resource Using Incompatible Type ('Type Confusion')",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "170",
      "name": "Improper Null Termination",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "134",
      "name": "Use of Externally-Controlled Format String",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "1325",
      "name": "Improperly Controlled Sequential Memory Allocation",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    }
  ]
}