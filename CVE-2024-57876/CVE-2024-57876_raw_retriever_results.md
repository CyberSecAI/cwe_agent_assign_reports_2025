# Raw Retriever Results for CVE-2024-57876

# Raw Retriever Results for CVE-2024-57876
## Query
In the Linux kernel, the following vulnerability has been resolved drm/dp_mst Fix resetting msg rx state after topology removal If the MST topology is removed during the reception of an MST down reply or MST up request sideband message, the drm_dp_mst_topology_mgrup_req_recv/down_rep_recv states could be reset from one thread via drm_dp_mst_topology_mgr_set_mst(false), racing with the reading/parsing of the message from another thread via drm_dp_mst_handle_down_rep() or drm_dp_mst_handle_up_req(). The race is possible since the reader/parser doesnt hold any lock while accessing the reception state. This in turn can lead to a memory corruption in the reader/parser as described by commit bd2fccac61b4 (drm/dp_mst Fix MST sideband message body length check). Fix the above by resetting the message reception state if needed before reading/parsing a message. Another solution would be to hold the drm_dp_mst_topology_mgrlock for the whole duration of the message reception/parsing in drm_dp_mst_handle_down_rep() and drm_dp_mst_handle_up_req(), however this would require a bigger change. Since the fix is also needed for stable, opting for the simpler solution in this patch.

## Keyphrases
- **weakness**: 'memory corruption'

## Score Statistics
| Retriever | Min | Max | Mean | Median | Count |
|-----------|-----|-----|------|--------|-------|
| Dense | 0.4391 | 0.5033 | 0.4656 | 0.4677 | 20 |
| Sparse | 747.3920 | 1000.0000 | 792.7929 | 767.6343 | 10 |
| Graph | 2.0023 | 3.3020 | 2.4419 | 2.3816 | 20 |

## Graph Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Mapping Usage |
|---|--------|------|-------------|-------|---------------|
| 1 | 125 | Out-of-bounds Read | base | 3.3020 | Allowed |
| 2 | 823 | Use of Out-of-range Pointer Offset | base | 2.8652 | Allowed |
| 3 | 824 | Access of Uninitialized Pointer | base | 2.8652 | Allowed |
| 4 | 825 | Expired Pointer Dereference | base | 2.8652 | Allowed |
| 5 | 129 | Improper Validation of Array Index | variant | 2.6784 | Allowed |
| 6 | 416 | Use After Free | variant | 2.5507 | Allowed |
| 7 | 787 | Out-of-bounds Write | Base | 2.5285 | Allowed |
| 8 | 120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | base | 2.4232 | Allowed-with-Review |
| 9 | 123 | Write-what-where Condition | base | 2.4232 | Allowed |
| 10 | 124 | Buffer Underwrite ('Buffer Underflow') | base | 2.4232 | Allowed |
| 11 | 364 | Signal Handler Race Condition | base | 2.3400 | Allowed |
| 12 | 781 | Improper Address Validation in IOCTL with METHOD_NEITHER I/O Control Code | variant | 2.2704 | Allowed |
| 13 | 1339 | Insufficient Precision or Accuracy of a Real Number | base | 2.2100 | Allowed |
| 14 | 1257 | Improper Access Control Applied to Mirrored or Aliased Memory Regions | base | 2.2100 | Allowed |
| 15 | 128 | Wrap-around Error | base | 2.2100 | Allowed |

## Dense Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Original Score | Mapping Usage |
|---|--------|------|-------------|-------|----------------|---------------|
| 1 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | 0.5033 | 0.5033 | Allowed-with-Review |
| 2 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | 0.4961 | 0.4961 | Allowed |
| 3 | 401 | Missing Release of Memory after Effective Lifetime | Variant | 0.4831 | 0.4831 | Allowed |
| 4 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | 0.4830 | 0.4830 | Discouraged |
| 5 | 667 | Improper Locking | Class | 0.4815 | 0.4815 | Allowed-with-Review |
| 6 | 126 | Buffer Over-read | Variant | 0.4815 | 0.4815 | Allowed |
| 7 | 1284 | Improper Validation of Specified Quantity in Input | Base | 0.4809 | 0.4809 | Allowed |
| 8 | 1260 | Improper Handling of Overlap Between Protected Memory Ranges | Base | 0.4795 | 0.4795 | Allowed |
| 9 | 413 | Improper Resource Locking | Base | 0.4770 | 0.4770 | Allowed |
| 10 | 805 | Buffer Access with Incorrect Length Value | Base | 0.4768 | 0.4768 | Allowed |
| 11 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | 0.4586 | 0.4586 | Allowed |
| 12 | 1264 | Hardware Logic with Insecure De-Synchronization between Control and Data Channels | Base | 0.4543 | 0.4543 | Allowed |
| 13 | 191 | Integer Underflow (Wrap or Wraparound) | Base | 0.4487 | 0.4487 | Allowed |
| 14 | 787 | Out-of-bounds Write | Base | 0.4484 | 0.4484 | Allowed |
| 15 | 909 | Missing Initialization of Resource | Class | 0.4482 | 0.4482 | Allowed-with-Review |

## Sparse Retriever Results (10)
| # | CWE ID | Name | Score | Original Score | Mapping Usage |
|---|--------|------|-------|---------------|---------------|
| 1 | 787 | Out-of-bounds Write | 1000.0000 | 1000.0000 | Allowed |
| 2 | 1284 | Improper Validation of Specified Quantity in Input | 819.1527 | 819.1527 | Allowed |
| 3 | 667 | Improper Locking | 797.0444 | 797.0444 | Allowed-with-Review |
| 4 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | 776.6699 | 776.6699 | Allowed-with-Review |
| 5 | 125 | Out-of-bounds Read | 769.5732 | 769.5732 | Allowed |
| 6 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | 765.6953 | 765.6953 | Allowed |
| 7 | 190 | Integer Overflow or Wraparound | 752.3192 | 752.3192 | Allowed |
| 8 | 674 | Uncontrolled Recursion | 751.3237 | 751.3237 | Allowed-with-Review |
| 9 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | 748.7587 | 748.7587 | Allowed |
| 10 | 789 | Memory Allocation with Excessive Size Value | 747.3920 | 747.3920 | Allowed |
