# Vulnerability Information: CVE-2024-45311

## Vulnerability Description
Quinn is a pure-Rust, async-compatible implementation of the IETF QUIC transport protocol. As of quinn-proto 0.11, it is possible for a server to `accept()`, `retry()`, `refuse()`, or `ignore()` an `Incoming` connection. However, calling `retry()` on an unvalidated connection exposes the server to a likely panic in the following situations 1. Calling `refuse` or `ignore` on the resulting validated connection, if a duplicate initial packet is received. This issue can go undetected until a servers `refuse()`/`ignore()` code path is exercised, such as to stop a denial of service attack. 2. Accepting when the initial packet for the resulting validated connection fails to decrypt or exhausts connection IDs, if a similar initial packet that successfully decrypts and doesnt exhaust connection IDs is received. This issue can go undetected if clients are well-behaved. The former situation was observed in a real application, while the latter is only theoretical.

### Vulnerability Description Key Phrases
- **weakness:** **panic when calling retry() on unvalidated connection**
- **impact:** denial of service and panic
- **vector:** duplicate initial packet
- **product:** quinn-proto
- **version:** 0.11

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of CVE-2024-45311:

**1. Verification:**
   - The content directly references CVE-2024-45311 and provides detailed information about the vulnerability, including its root cause, affected versions, and impact, aligning with the expected behavior.

**2. Root cause of vulnerability:**
   - The vulnerability stems from how the `quinn-proto` library handles incoming connections when the `retry()` function is called on an unvalidated connection. Specifically, the issue arises due to incorrect management of `Incoming` connection state and buffers, particularly when the server uses `retry()`, and then subsequently either `refuse()`/`ignore()` or `accept()` under specific conditions involving duplicate initial packets, decryption failures, or connection ID exhaustion.

**3. Weaknesses/vulnerabilities present:**
   - **Incorrect state management after retry:** The `Endpoint` struct's handling of `Incoming` connections after a `retry` call is flawed. After calling `retry`, the code does not remove the initial connection state and associated buffer from the endpoint's data structures. This results in a double free or an out-of-bounds access when a duplicate initial packet for the same connection is subsequently received and either rejected or accepted.
    - The vulnerability lies in the `handle_first_packet` function which does not remove the incoming buffer after the first packet has been handled and before a retry is sent. It also occurs in the `accept()` function which may try to process the buffer a second time if another packet arrives before the client has retried.
   - **Lack of proper cleanup:** The code does not properly clean up the state after a retry if the connection is subsequently refused, ignored or there's a failure in the acceptance process.
   - **Potential for out-of-bounds access:** The core issue can manifest as a panic due to an out-of-bounds access when the code attempts to access the incoming buffer a second time after it has been removed.

**4. Impact of exploitation:**
   - **Denial of Service (DoS):** The primary impact is a denial of service. By sending carefully crafted packets, an attacker can trigger a panic in the server, causing it to crash and become unavailable. This can severely affect internet-facing servers relying on the vulnerable library.

**5. Attack vectors:**
   - **Network:** The attack vector is "network," meaning the attacker can be remote, sending packets over the network to exploit the vulnerability.
   - **Specifically crafted initial packets:** The attacker needs to send initial packets to establish a connection, then send another set of specific initial packets to trigger the vulnerability after a retry is issued by the server.

**6. Required attacker capabilities/position:**
   - **No privileges required:** The attacker doesn't require any special privileges on the target system.
   - **No user interaction needed:** The attack doesn't require any user interaction.
   - **Ability to send network packets:** The attacker needs the ability to send UDP packets to the target server.

**Additional details from content:**
   - The vulnerability can occur in two scenarios, one of which has been observed in a real application:
      - When the server calls `refuse` or `ignore` on a connection that has been retried if a duplicate initial packet is received.
      - When the server attempts to accept a connection, but the initial packet for the retried connection fails to decrypt or exhausts connection IDs, and another valid initial packet is received.
   - The vulnerability is present in `quinn-proto` versions 0.11.0 to 0.11.6 and is fixed in version 0.11.7.
   - The CVSS score is 7.5 High, with a vector of `CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H`.
   - The exact location of the panic is within the `endpoint.rs` file at line 213, which attempts to access a `incoming_buffer` that was already removed.

**In summary:**
CVE-2024-45311 is a denial-of-service vulnerability in the `quinn-proto` library related to the incorrect handling of `retry` calls followed by subsequent connection acceptance or rejection. By exploiting this, an attacker can cause a server to crash, affecting availability without needing special privileges or user interaction.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | sparse | 0.752 |
| 2 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.750 |
| 3 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.720 |
| 4 | 617 | Reachable Assertion | Base | Allowed | sparse | 0.714 |
| 5 | 295 | Improper Certificate Validation | Base | Allowed | sparse | 0.706 |
| 6 | 400 | Uncontrolled Resource Consumption | Class | Discouraged | sparse | 0.705 |
| 7 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.703 |
| 8 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | Allowed | sparse | 0.694 |
| 9 | 444 | Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling') | Base | Allowed | dense | 0.391 |
| 10 | 1325 | Improperly Controlled Sequential Memory Allocation | Base | Allowed | graph | 0.003 |

