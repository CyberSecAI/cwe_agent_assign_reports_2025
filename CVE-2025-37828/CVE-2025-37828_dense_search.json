{
  "retriever": "dense",
  "query": "In the Linux kernel, the following vulnerability has been resolved scsi ufs mcq Add NULL check in ufshcd_mcq_abort() A race can occur between the MCQ completion path and the abort handler once a request completes, __blk_mq_free_request() sets rq->mq_hctx to NULL, meaning the subsequent ufshcd_mcq_req_to_hwq() call in ufshcd_mcq_abort() can return a NULL pointer. If this NULL pointer is dereferenced, the kernel will crash. Add a NULL check for the returned hwq pointer. If hwq is NULL, log an error and return FAILED, preventing a potential NULL-pointer dereference. As suggested by Bart, the ufshcd_cmd_inflight() check is removed. This is similar to the fix in commit 74736103fb41 (scsi ufs core Fix ufshcd_abort_one racing issue). This is found by our static analysis tool KNighter.",
  "keyphrases": {
    "rootcause": [
      "NULL pointer dereference"
    ],
    "weakness": [
      "race condition"
    ]
  },
  "timestamp": "2025-07-12 13:23:48",
  "cve_id": "CVE-2025-37828",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "606",
      "name": "Unchecked Input for Loop Condition",
      "type": "Base",
      "score": 0.46929056323909346
    },
    {
      "cwe_id": "1264",
      "name": "Hardware Logic with Insecure De-Synchronization between Control and Data Channels",
      "type": "Base",
      "score": 0.4631724383547764
    },
    {
      "cwe_id": "170",
      "name": "Improper Null Termination",
      "type": "Base",
      "score": 0.46052608396282085
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 0.45968213171221184
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 0.45651536719989516
    },
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "type": "Base",
      "score": 0.452354758686221
    },
    {
      "cwe_id": "909",
      "name": "Missing Initialization of Resource",
      "type": "Class",
      "score": 0.4521204201486189
    },
    {
      "cwe_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "type": "Base",
      "score": 0.45031406399720886
    },
    {
      "cwe_id": "413",
      "name": "Improper Resource Locking",
      "type": "Base",
      "score": 0.4487612779743638
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "type": "Class",
      "score": 0.44526766861326283
    },
    {
      "cwe_id": "908",
      "name": "Use of Uninitialized Resource",
      "type": "Base",
      "score": 0.43536199780413265
    },
    {
      "cwe_id": "394",
      "name": "Unexpected Status Code or Return Value",
      "type": "Base",
      "score": 0.42858117135215856
    },
    {
      "cwe_id": "1332",
      "name": "Improper Handling of Faults that Lead to Instruction Skips",
      "type": "Base",
      "score": 0.4273626718285267
    },
    {
      "cwe_id": "911",
      "name": "Improper Update of Reference Count",
      "type": "Base",
      "score": 0.4271765179465256
    },
    {
      "cwe_id": "1261",
      "name": "Improper Handling of Single Event Upsets",
      "type": "Base",
      "score": 0.4251290942857589
    },
    {
      "cwe_id": "354",
      "name": "Improper Validation of Integrity Check Value",
      "type": "Base",
      "score": 0.4223026385200799
    },
    {
      "cwe_id": "822",
      "name": "Untrusted Pointer Dereference",
      "type": "Base",
      "score": 0.41592256702717456
    },
    {
      "cwe_id": "366",
      "name": "Race Condition within a Thread",
      "type": "Base",
      "score": 0.4144216285999138
    },
    {
      "cwe_id": "1260",
      "name": "Improper Handling of Overlap Between Protected Memory Ranges",
      "type": "Base",
      "score": 0.41403616452499925
    },
    {
      "cwe_id": "191",
      "name": "Integer Underflow (Wrap or Wraparound)",
      "type": "Base",
      "score": 0.4137498595700979
    }
  ]
}