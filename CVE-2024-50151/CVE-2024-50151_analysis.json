{
  "cve_id": "CVE-2024-50151",
  "description": "In the Linux kernel, the following vulnerability has been resolved smb client fix OOBs when building SMB2_IOCTL request When using encryption, either enforced by the server or when using seal mount option, the client will squash all compound request buffers down for encryption into a single iov in smb2_set_next_command(). SMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the SMB2_IOCTL request in the first iov, **and if the user passes an input buffer that is greater than 328 bytes**, **smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base** as shown below mount.cifs //srv/share /mnt -o ...,seal ln -s $(perl -e print(a)for 1..1024) /mnt/link BUG KASAN **slab-out-of-bounds** in smb2_set_next_command.cold+0x1d6/0x24c [cifs] Write of size 4116 at addr ffff8881148fcab8 by task ln/859 CPU 1 UID 0 PID 859 Comm ln Not tainted 6.12.0-rc3 #1 Hardware name QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-2.fc40 04/01/2014 Call Trace dump_stack_lvl+0x5d/0x80 ? smb2_set_next_command.cold+0x1d6/0x24c [cifs] print_report+0x156/0x4d9 ? smb2_set_next_command.cold+0x1d6/0x24c [cifs] ? __virt_addr_valid+0x145/0x310 ? __phys_addr+0x46/0x90 ? smb2_set_next_command.cold+0x1d6/0x24c [cifs] kasan_report+0xda/0x110 ? smb2_set_next_command.cold+0x1d6/0x24c [cifs] kasan_check_range+0x10f/0x1f0 __asan_memcpy+0x3c/0x60 smb2_set_next_command.cold+0x1d6/0x24c [cifs] smb2_compound_op+0x238c/0x3840 [cifs] ? kasan_save_track+0x14/0x30 ? kasan_save_free_info+0x3b/0x70 ? vfs_symlink+0x1a1/0x2c0 ? do_symlinkat+0x108/0x1c0 ? __pfx_smb2_compound_op+0x10/0x10 [cifs] ? kmem_cache_free+0x118/0x3e0 ? cifs_get_writable_path+0xeb/0x1a0 [cifs] smb2_get_reparse_inode+0x423/0x540 [cifs] ? __pfx_smb2_get_reparse_inode+0x10/0x10 [cifs] ? rcu_is_watching+0x20/0x50 ? __kmalloc_noprof+0x37c/0x480 ? smb2_create_reparse_symlink+0x257/0x490 [cifs] ? smb2_create_reparse_symlink+0x38f/0x490 [cifs] smb2_create_reparse_symlink+0x38f/0x490 [cifs] ? __pfx_smb2_create_reparse_symlink+0x10/0x10 [cifs] ? find_held_lock+0x8a/0xa0 ? hlock_class+0x32/0xb0 ? __build_path_from_dentry_optional_prefix+0x19d/0x2e0 [cifs] cifs_symlink+0x24f/0x960 [cifs] ? __pfx_make_vfsuid+0x10/0x10 ? __pfx_cifs_symlink+0x10/0x10 [cifs] ? make_vfsgid+0x6b/0xc0 ? generic_permission+0x96/0x2d0 vfs_symlink+0x1a1/0x2c0 do_symlinkat+0x108/0x1c0 ? __pfx_do_symlinkat+0x10/0x10 ? strncpy_from_user+0xaa/0x160 __x64_sys_symlinkat+0xb9/0xf0 do_syscall_64+0xbb/0x1d0 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP 00330x7f08d75c13bb",
  "key_phrases": {
    "rootcause": [
      "The client will squash all compound request buffers down for encryption into a single iov in smb2_set_next_command(). SMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the SMB2_IOCTL request in the first iov",
      "and if the user passes an input buffer that is greater than 328 bytes",
      "smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base"
    ],
    "weakness": [
      "Out-of-bounds write vulnerability in smb2_set_next_command function",
      "slab-out-of-bounds"
    ],
    "impact": [
      "Kernel memory corruption",
      "potentially leading to system crash or arbitrary code execution"
    ],
    "vector": "Mounting a CIFS share with seal option and creating a symbolic link with a large target",
    "attacker": "Local user",
    "product": "Linux Kernel",
    "version": "6.12.0-rc3",
    "component": "cifs"
  },
  "reference_content": "Based on the provided content, here's a breakdown of the vulnerability:\n\n**Root Cause:**\n- The vulnerability lies in the `smb2_set_next_command()` function within the CIFS (Common Internet File System) client implementation in the Linux kernel. Specifically, it's triggered when encryption is enabled (either by server enforcement or the 'seal' mount option).\n- When encryption is enabled, the client combines all compound request buffers into a single iov (I/O vector) for encryption. `SMB2_ioctl_init()` allocates a small buffer (448 bytes) in the first iov to hold the SMB2_IOCTL request. If a user provides an input buffer larger than 328 bytes, `smb2_set_next_command()` will write past the end of the allocated buffer in `rqst->iov[0].iov_base`, leading to a heap buffer overflow.\n\n**Weaknesses/Vulnerabilities:**\n- **Heap buffer overflow:**  A fixed-size buffer is allocated, but a larger input can cause data to be written beyond its bounds. This occurs because the size calculation does not properly account for the size of the input data when encryption is enabled.\n\n**Impact of Exploitation:**\n- **Kernel crash:** The out-of-bounds write corrupts kernel memory, leading to a kernel panic, as demonstrated by the KASAN report. This can cause a denial-of-service.\n- **Potential for arbitrary code execution:** Although not explicitly stated, heap buffer overflows can sometimes be leveraged for arbitrary code execution, depending on the surrounding memory layout. This would lead to a full compromise of the system.\n\n**Attack Vectors:**\n- **Malicious SMB server:** A malicious server could enforce encryption, and then provide a response that includes a large enough data input to overflow the buffer on the client.\n- **Mount Option:** User can force the 'seal' mount option, and then trigger the overflow using a crafted input buffer.\n\n**Required Attacker Capabilities/Position:**\n- **Ability to mount a CIFS share:** The attacker must be able to mount a CIFS share on a vulnerable system.\n- **Control over input data:** The attacker needs to control the size of the input buffer passed to the SMB2 IOCTL command. This can be achieved by, for example, creating a symbolic link with a long name.\n- For a malicious server, it needs to force encryption.",
  "similar_info": {
    "cwe_distribution": {},
    "cwe_consensus": "",
    "similarity_stats": {
      "thresholds": [],
      "total_samples_by_threshold": {},
      "top_cwes_by_threshold": {}
    }
  },
  "similarity_summary": {
    "consensus_cwe": "",
    "top_cwes": [],
    "confidence_levels": {},
    "total_samples": 0
  },
  "analysis": "# Summary\n| CWE ID    | CWE Name                                                                      | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |\n| :---------- | :---------------------------------------------------------------------------- | :--------- | :---------------------- | :------------------------------ | :------------------------------ |\n| CWE-787   | Out-of-bounds Write                                                           | 0.9        | Base                    | Primary                         | Allowed                       |\n| CWE-119   | Improper Restriction of Operations within the Bounds of a Memory Buffer | 0.7        | Class                   | Secondary                       | Discouraged                   |\n| CWE-770   | Allocation of Resources Without Limits or Throttling                      | 0.6        | Base                    | Secondary                       | Allowed                       |\n| CWE-1284  | Improper Validation of Specified Quantity in Input                        | 0.5        | Base                    | Secondary                       | Allowed                       |\n\n## Evidence and Confidence\n\n*   **Confidence Score:** 0.8\n*   **Evidence Strength:** HIGH\n\n## Relationship Analysis\nThe primary weakness is CWE-787 (Out-of-bounds Write), a base-level CWE that directly describes the **writing off the end of a buffer**. This is a child of CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer), a more general class-level CWE. CWE-1284 (Improper Validation of Specified Quantity in Input) can precede CWE-787, as **missing input validation** could lead to an out-of-bounds write. CWE-770 (Allocation of Resources Without Limits or Throttling) is relevant because the initial buffer allocation is too small, and there are no checks to prevent writing beyond its boundaries when handling large user inputs.\n\n```mermaid\ngraph TD\n    cwe787[\"CWE-787: Out-of-bounds Write\"]\n    cwe119[\"CWE-119: Improper Restriction of Operations\"]\n    cwe120[\"CWE-120: Buffer Copy without Checking Size\"]\n    cwe1284[\"CWE-1284: Improper Validation of Specified Quantity in Input\"]\n    cwe770[\"CWE-770: Allocation of Resources Without Limits or Throttling\"]\n    \n    cwe787 -->|CHILDOF| cwe119\n    cwe1284 -->|CANPRECEDE| cwe787\n    cwe770 -->|CANPRECEDE| cwe787\n    \n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    classDef tertiary fill:#9e9,stroke:#333\n    class cwe787 primary\n    class cwe119,cwe1284,cwe770 secondary\n```\n\n## Vulnerability Chain\n1.  The CIFS client allocates a fixed-size buffer (448 bytes) for SMB2 IOCTL requests (**ROOT CAUSE**).\n2.  The user provides an input buffer larger than 328 bytes (**ROOT CAUSE**).\n3.  The `smb2_set_next_command()` function **writes data beyond the allocated buffer**, resulting in an **out-of-bounds write** (CWE-787).\n4.  This leads to **memory corruption** and potentially a **system crash or arbitrary code execution**.\n\n## Summary of Analysis\nThe analysis identifies CWE-787 (Out-of-bounds Write) as the primary weakness because the core issue is the **writing of data beyond the allocated buffer**. The evidence clearly states that \"smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base.\" This aligns directly with the definition of an out-of-bounds write. While CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer) is related, it's a broader category. CWE-787 is more specific and therefore a better fit.\n\nCWE-1284 (Improper Validation of Specified Quantity in Input) is considered since the **user-provided input size isn't validated** against the buffer's capacity. This missing validation directly contributes to the out-of-bounds write. CWE-770 (Allocation of Resources Without Limits or Throttling) is also relevant because the code **allocates a small buffer without proper size checks**, leading to the overflow.\n\nThe retriever results, particularly the keyphrase analysis, supports the selection of CWE-787, CWE-119, CWE-1284 and CWE-770. The graph relationships further clarify how these CWEs are interconnected, with CWE-787 being a specific case of CWE-119, and CWE-1284/CWE-770 potentially preceding it.\n\nCWE-125 (Out-of-bounds Read) was considered, but the vulnerability description explicitly mentions a **write**, not a read. Other CWEs like CWE-266, CWE-532, and CWE-88 are not directly related to the **memory corruption** aspect of this vulnerability.\n\nThe chosen CWEs are at the optimal level of specificity because they accurately reflect the root cause (**out-of-bounds write**), the contributing factor (**lack of input validation**), and the memory allocation issue, providing a comprehensive understanding of the vulnerability.",
  "analysis_with_relationships": "# Summary\n| CWE ID    | CWE Name                                                                      | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |\n| :---------- | :---------------------------------------------------------------------------- | :--------- | :---------------------- | :------------------------------ | :------------------------------ |\n| CWE-787   | Out-of-bounds Write                                                           | 0.9        | Base                    | Primary                         | Allowed                       |\n| CWE-119   | Improper Restriction of Operations within the Bounds of a Memory Buffer | 0.7        | Class                   | Secondary                       | Discouraged                   |\n| CWE-770   | Allocation of Resources Without Limits or Throttling                      | 0.6        | Base                    | Secondary                       | Allowed                       |\n| CWE-1284  | Improper Validation of Specified Quantity in Input                        | 0.5        | Base                    | Secondary                       | Allowed                       |\n\n## Evidence and Confidence\n\n*   **Confidence Score:** 0.8\n*   **Evidence Strength:** HIGH\n\n## Relationship Analysis\nThe primary weakness is CWE-787 (Out-of-bounds Write), a base-level CWE that directly describes the **writing off the end of a buffer**. This is a child of CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer), a more general class-level CWE. CWE-1284 (Improper Validation of Specified Quantity in Input) can precede CWE-787, as **missing input validation** could lead to an out-of-bounds write. CWE-770 (Allocation of Resources Without Limits or Throttling) is relevant because the initial buffer allocation is too small, and there are no checks to prevent writing beyond its boundaries when handling large user inputs.\n\n```mermaid\ngraph TD\n    cwe787[\"CWE-787: Out-of-bounds Write\"]\n    cwe119[\"CWE-119: Improper Restriction of Operations\"]\n    cwe120[\"CWE-120: Buffer Copy without Checking Size\"]\n    cwe1284[\"CWE-1284: Improper Validation of Specified Quantity in Input\"]\n    cwe770[\"CWE-770: Allocation of Resources Without Limits or Throttling\"]\n    \n    cwe787 -->|CHILDOF| cwe119\n    cwe1284 -->|CANPRECEDE| cwe787\n    cwe770 -->|CANPRECEDE| cwe787\n    \n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    classDef tertiary fill:#9e9,stroke:#333\n    class cwe787 primary\n    class cwe119,cwe1284,cwe770 secondary\n```\n\n## Vulnerability Chain\n1.  The CIFS client allocates a fixed-size buffer (448 bytes) for SMB2 IOCTL requests (**ROOT CAUSE**).\n2.  The user provides an input buffer larger than 328 bytes (**ROOT CAUSE**).\n3.  The `smb2_set_next_command()` function **writes data beyond the allocated buffer**, resulting in an **out-of-bounds write** (CWE-787).\n4.  This leads to **memory corruption** and potentially a **system crash or arbitrary code execution**.\n\n## Summary of Analysis\nThe analysis identifies CWE-787 (Out-of-bounds Write) as the primary weakness because the core issue is the **writing of data beyond the allocated buffer**. The evidence clearly states that \"smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base.\" This aligns directly with the definition of an out-of-bounds write. While CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer) is related, it's a broader category. CWE-787 is more specific and therefore a better fit.\n\nCWE-1284 (Improper Validation of Specified Quantity in Input) is considered since the **user-provided input size isn't validated** against the buffer's capacity. This missing validation directly contributes to the out-of-bounds write. CWE-770 (Allocation of Resources Without Limits or Throttling) is also relevant because the code **allocates a small buffer without proper size checks**, leading to the overflow.\n\nThe retriever results, particularly the keyphrase analysis, supports the selection of CWE-787, CWE-119, CWE-1284 and CWE-770. The graph relationships further clarify how these CWEs are interconnected, with CWE-787 being a specific case of CWE-119, and CWE-1284/CWE-770 potentially preceding it.\n\nCWE-125 (Out-of-bounds Read) was considered, but the vulnerability description explicitly mentions a **write**, not a read. Other CWEs like CWE-266, CWE-532, and CWE-88 are not directly related to the **memory corruption** aspect of this vulnerability.\n\nThe chosen CWEs are at the optimal level of specificity because they accurately reflect the root cause (**out-of-bounds write**), the contributing factor (**lack of input validation**), and the memory allocation issue, providing a comprehensive understanding of the vulnerability.\n\n\n## CWE Relationship Analysis\n\nCurrent CWEs represent these abstraction levels: .\n\n\n### Vulnerability Chain Analysis\n\n**Chain starting from CWE-1284:**\n- 1284 (Improper Validation of Specified Quantity in Input) - ROOT\n\n\n**Chain starting from CWE-770:**\n- 770 (Allocation of Resources Without Limits or Throttling) - ROOT\n\n\n\n### CWE Relationship Diagram\n\n```mermaid\ngraph TD\n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    classDef tertiary fill:#9e9,stroke:#333\n```",
  "criticism": "",
  "resolution": "",
  "relevant_cwes": [
    {
      "metadata": {
        "doc_id": "266",
        "name": "Incorrect Privilege Assignment",
        "source": "sparse",
        "original_content": "A product incorrectly assigns a privilege to a particular actor, creating an unintended sphere of control for that actor.",
        "keyphrase_sources": [
          {
            "id": "rootcause:The client will squash all compound request buffers down for encryption into a single iov in smb2_set_next_command(). SMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the SMB2_IOCTL request in the first iov",
            "keyphrase": "The client will squash all compound request buffers down for encryption into a single iov in smb2_set_next_command(). SMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the SMB2_IOCTL request in the first iov",
            "type": "rootcause"
          },
          {
            "id": "rootcause:and if the user passes an input buffer that is greater than 328 bytes",
            "keyphrase": "and if the user passes an input buffer that is greater than 328 bytes",
            "type": "rootcause"
          },
          {
            "id": "rootcause:smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base",
            "keyphrase": "smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base",
            "type": "rootcause"
          },
          {
            "id": "weakness:Out-of-bounds write vulnerability in smb2_set_next_command function",
            "keyphrase": "Out-of-bounds write vulnerability in smb2_set_next_command function",
            "type": "weakness"
          },
          {
            "id": "weakness:slab-out-of-bounds",
            "keyphrase": "slab-out-of-bounds",
            "type": "weakness"
          },
          {
            "id": "impact:Kernel memory corruption",
            "keyphrase": "Kernel memory corruption",
            "type": "impact"
          },
          {
            "id": "impact:potentially leading to system crash or arbitrary code execution",
            "keyphrase": "potentially leading to system crash or arbitrary code execution",
            "type": "impact"
          },
          {
            "id": "vector:Mounting a CIFS share with seal option and creating a symbolic link with a large target",
            "keyphrase": "Mounting a CIFS share with seal option and creating a symbolic link with a large target",
            "type": "vector"
          },
          {
            "id": "attacker:Local user",
            "keyphrase": "Local user",
            "type": "attacker"
          },
          {
            "id": "product:Linux Kernel",
            "keyphrase": "Linux Kernel",
            "type": "product"
          },
          {
            "id": "version:6.12.0-rc3",
            "keyphrase": "6.12.0-rc3",
            "type": "version"
          },
          {
            "id": "component:cifs",
            "keyphrase": "cifs",
            "type": "component"
          }
        ]
      },
      "similarity": 1036.0832267718356
    },
    {
      "metadata": {
        "doc_id": "532",
        "name": "Insertion of Sensitive Information into Log File",
        "source": "sparse",
        "original_content": "The product writes sensitive information to a log file.",
        "keyphrase_sources": [
          {
            "id": "rootcause:The client will squash all compound request buffers down for encryption into a single iov in smb2_set_next_command(). SMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the SMB2_IOCTL request in the first iov",
            "keyphrase": "The client will squash all compound request buffers down for encryption into a single iov in smb2_set_next_command(). SMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the SMB2_IOCTL request in the first iov",
            "type": "rootcause"
          },
          {
            "id": "rootcause:and if the user passes an input buffer that is greater than 328 bytes",
            "keyphrase": "and if the user passes an input buffer that is greater than 328 bytes",
            "type": "rootcause"
          },
          {
            "id": "rootcause:smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base",
            "keyphrase": "smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base",
            "type": "rootcause"
          },
          {
            "id": "weakness:Out-of-bounds write vulnerability in smb2_set_next_command function",
            "keyphrase": "Out-of-bounds write vulnerability in smb2_set_next_command function",
            "type": "weakness"
          },
          {
            "id": "weakness:slab-out-of-bounds",
            "keyphrase": "slab-out-of-bounds",
            "type": "weakness"
          },
          {
            "id": "impact:Kernel memory corruption",
            "keyphrase": "Kernel memory corruption",
            "type": "impact"
          },
          {
            "id": "impact:potentially leading to system crash or arbitrary code execution",
            "keyphrase": "potentially leading to system crash or arbitrary code execution",
            "type": "impact"
          },
          {
            "id": "vector:Mounting a CIFS share with seal option and creating a symbolic link with a large target",
            "keyphrase": "Mounting a CIFS share with seal option and creating a symbolic link with a large target",
            "type": "vector"
          },
          {
            "id": "attacker:Local user",
            "keyphrase": "Local user",
            "type": "attacker"
          },
          {
            "id": "product:Linux Kernel",
            "keyphrase": "Linux Kernel",
            "type": "product"
          },
          {
            "id": "version:6.12.0-rc3",
            "keyphrase": "6.12.0-rc3",
            "type": "version"
          },
          {
            "id": "component:cifs",
            "keyphrase": "cifs",
            "type": "component"
          }
        ]
      },
      "similarity": 929.4848397794841
    },
    {
      "metadata": {
        "doc_id": "789",
        "name": "Memory Allocation with Excessive Size Value",
        "source": "sparse",
        "original_content": "The product allocates memory based on an untrusted, large size value, but it does not ensure that the size is within expected limits, allowing arbitrary amounts of memory to be allocated.",
        "keyphrase_sources": [
          {
            "id": "rootcause:The client will squash all compound request buffers down for encryption into a single iov in smb2_set_next_command(). SMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the SMB2_IOCTL request in the first iov",
            "keyphrase": "The client will squash all compound request buffers down for encryption into a single iov in smb2_set_next_command(). SMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the SMB2_IOCTL request in the first iov",
            "type": "rootcause"
          }
        ]
      },
      "similarity": 927.7495695125804
    },
    {
      "metadata": {
        "doc_id": "770",
        "name": "Allocation of Resources Without Limits or Throttling",
        "source": "sparse",
        "original_content": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
        "keyphrase_sources": [
          {
            "id": "rootcause:The client will squash all compound request buffers down for encryption into a single iov in smb2_set_next_command(). SMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the SMB2_IOCTL request in the first iov",
            "keyphrase": "The client will squash all compound request buffers down for encryption into a single iov in smb2_set_next_command(). SMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the SMB2_IOCTL request in the first iov",
            "type": "rootcause"
          },
          {
            "id": "vector:Mounting a CIFS share with seal option and creating a symbolic link with a large target",
            "keyphrase": "Mounting a CIFS share with seal option and creating a symbolic link with a large target",
            "type": "vector"
          },
          {
            "id": "version:6.12.0-rc3",
            "keyphrase": "6.12.0-rc3",
            "type": "version"
          }
        ]
      },
      "similarity": 926.5135996865358
    },
    {
      "metadata": {
        "doc_id": "226",
        "name": "Sensitive Information in Resource Not Removed Before Reuse",
        "source": "sparse",
        "original_content": "The product releases a resource such as memory or a file so that it can be made available for reuse, but it does not clear or \"zeroize\" the information contained in the resource before the product performs a critical state transition or makes the resource available for reuse by other entities.",
        "keyphrase_sources": [
          {
            "id": "rootcause:The client will squash all compound request buffers down for encryption into a single iov in smb2_set_next_command(). SMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the SMB2_IOCTL request in the first iov",
            "keyphrase": "The client will squash all compound request buffers down for encryption into a single iov in smb2_set_next_command(). SMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the SMB2_IOCTL request in the first iov",
            "type": "rootcause"
          }
        ]
      },
      "similarity": 922.5852467914336
    },
    {
      "metadata": {
        "doc_id": "88",
        "name": "Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')",
        "source": "sparse",
        "original_content": "The product constructs a string for a command to be executed by a separate component\nin another control sphere, but it does not properly delimit the\nintended arguments, options, or switches within that command string.",
        "keyphrase_sources": [
          {
            "id": "rootcause:and if the user passes an input buffer that is greater than 328 bytes",
            "keyphrase": "and if the user passes an input buffer that is greater than 328 bytes",
            "type": "rootcause"
          },
          {
            "id": "rootcause:smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base",
            "keyphrase": "smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base",
            "type": "rootcause"
          },
          {
            "id": "weakness:Out-of-bounds write vulnerability in smb2_set_next_command function",
            "keyphrase": "Out-of-bounds write vulnerability in smb2_set_next_command function",
            "type": "weakness"
          },
          {
            "id": "weakness:slab-out-of-bounds",
            "keyphrase": "slab-out-of-bounds",
            "type": "weakness"
          },
          {
            "id": "impact:Kernel memory corruption",
            "keyphrase": "Kernel memory corruption",
            "type": "impact"
          },
          {
            "id": "impact:potentially leading to system crash or arbitrary code execution",
            "keyphrase": "potentially leading to system crash or arbitrary code execution",
            "type": "impact"
          },
          {
            "id": "vector:Mounting a CIFS share with seal option and creating a symbolic link with a large target",
            "keyphrase": "Mounting a CIFS share with seal option and creating a symbolic link with a large target",
            "type": "vector"
          },
          {
            "id": "attacker:Local user",
            "keyphrase": "Local user",
            "type": "attacker"
          },
          {
            "id": "product:Linux Kernel",
            "keyphrase": "Linux Kernel",
            "type": "product"
          },
          {
            "id": "version:6.12.0-rc3",
            "keyphrase": "6.12.0-rc3",
            "type": "version"
          },
          {
            "id": "component:cifs",
            "keyphrase": "cifs",
            "type": "component"
          }
        ]
      },
      "similarity": 820.9672820951052
    },
    {
      "metadata": {
        "doc_id": "125",
        "name": "Out-of-bounds Read",
        "source": "sparse",
        "original_content": "The product reads data past the end, or before the beginning, of the intended buffer.",
        "keyphrase_sources": [
          {
            "id": "rootcause:and if the user passes an input buffer that is greater than 328 bytes",
            "keyphrase": "and if the user passes an input buffer that is greater than 328 bytes",
            "type": "rootcause"
          },
          {
            "id": "rootcause:smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base",
            "keyphrase": "smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base",
            "type": "rootcause"
          },
          {
            "id": "weakness:Out-of-bounds write vulnerability in smb2_set_next_command function",
            "keyphrase": "Out-of-bounds write vulnerability in smb2_set_next_command function",
            "type": "weakness"
          },
          {
            "id": "weakness:slab-out-of-bounds",
            "keyphrase": "slab-out-of-bounds",
            "type": "weakness"
          },
          {
            "id": "impact:Kernel memory corruption",
            "keyphrase": "Kernel memory corruption",
            "type": "impact"
          },
          {
            "id": "impact:potentially leading to system crash or arbitrary code execution",
            "keyphrase": "potentially leading to system crash or arbitrary code execution",
            "type": "impact"
          },
          {
            "id": "attacker:Local user",
            "keyphrase": "Local user",
            "type": "attacker"
          },
          {
            "id": "product:Linux Kernel",
            "keyphrase": "Linux Kernel",
            "type": "product"
          },
          {
            "id": "component:cifs",
            "keyphrase": "cifs",
            "type": "component"
          }
        ]
      },
      "similarity": 796.7460021688004
    },
    {
      "metadata": {
        "doc_id": "1284",
        "name": "Improper Validation of Specified Quantity in Input",
        "source": "sparse",
        "original_content": "The product receives input that is expected to specify a quantity (such as size or length), but it does not validate or incorrectly validates that the quantity has the required properties.",
        "keyphrase_sources": [
          {
            "id": "rootcause:and if the user passes an input buffer that is greater than 328 bytes",
            "keyphrase": "and if the user passes an input buffer that is greater than 328 bytes",
            "type": "rootcause"
          }
        ]
      },
      "similarity": 766.2392324162527
    },
    {
      "metadata": {
        "doc_id": "400",
        "name": "Uncontrolled Resource Consumption",
        "source": "sparse",
        "original_content": "The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",
        "keyphrase_sources": [
          {
            "id": "rootcause:smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base",
            "keyphrase": "smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base",
            "type": "rootcause"
          },
          {
            "id": "attacker:Local user",
            "keyphrase": "Local user",
            "type": "attacker"
          },
          {
            "id": "version:6.12.0-rc3",
            "keyphrase": "6.12.0-rc3",
            "type": "version"
          },
          {
            "id": "component:cifs",
            "keyphrase": "cifs",
            "type": "component"
          }
        ]
      },
      "similarity": 716.4904558741335
    },
    {
      "metadata": {
        "doc_id": "119",
        "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
        "source": "sparse",
        "original_content": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
        "keyphrase_sources": [
          {
            "id": "weakness:Out-of-bounds write vulnerability in smb2_set_next_command function",
            "keyphrase": "Out-of-bounds write vulnerability in smb2_set_next_command function",
            "type": "weakness"
          },
          {
            "id": "weakness:slab-out-of-bounds",
            "keyphrase": "slab-out-of-bounds",
            "type": "weakness"
          },
          {
            "id": "impact:Kernel memory corruption",
            "keyphrase": "Kernel memory corruption",
            "type": "impact"
          },
          {
            "id": "impact:potentially leading to system crash or arbitrary code execution",
            "keyphrase": "potentially leading to system crash or arbitrary code execution",
            "type": "impact"
          },
          {
            "id": "product:Linux Kernel",
            "keyphrase": "Linux Kernel",
            "type": "product"
          }
        ]
      },
      "similarity": 665.8781470952766
    },
    {
      "metadata": {
        "doc_id": "61",
        "name": "UNIX Symbolic Link (Symlink) Following",
        "source": "sparse",
        "original_content": "The product, when opening a file or directory, does not sufficiently account for when the file is a symbolic link that resolves to a target outside of the intended control sphere. This could allow an attacker to cause the product to operate on unauthorized files.",
        "keyphrase_sources": [
          {
            "id": "vector:Mounting a CIFS share with seal option and creating a symbolic link with a large target",
            "keyphrase": "Mounting a CIFS share with seal option and creating a symbolic link with a large target",
            "type": "vector"
          }
        ]
      },
      "similarity": 284.2570627028595
    }
  ],
  "identified_cwes": {
    "analyzer": [
      "CWE-1284",
      "CWE-770",
      "CWE-125",
      "CWE-88",
      "CWE-787",
      "CWE-119",
      "CWE-120",
      "CWE-532",
      "CWE-266"
    ],
    "critic_additional": []
  },
  "keyphrase_cwe_mapping": {
    "266": [
      {
        "id": "rootcause:The client will squash all compound request buffers down for encryption into a single iov in smb2_set_next_command(). SMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the SMB2_IOCTL request in the first iov",
        "keyphrase": "The client will squash all compound request buffers down for encryption into a single iov in smb2_set_next_command(). SMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the SMB2_IOCTL request in the first iov",
        "type": "rootcause"
      },
      {
        "id": "rootcause:and if the user passes an input buffer that is greater than 328 bytes",
        "keyphrase": "and if the user passes an input buffer that is greater than 328 bytes",
        "type": "rootcause"
      },
      {
        "id": "rootcause:smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base",
        "keyphrase": "smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base",
        "type": "rootcause"
      },
      {
        "id": "weakness:Out-of-bounds write vulnerability in smb2_set_next_command function",
        "keyphrase": "Out-of-bounds write vulnerability in smb2_set_next_command function",
        "type": "weakness"
      },
      {
        "id": "weakness:slab-out-of-bounds",
        "keyphrase": "slab-out-of-bounds",
        "type": "weakness"
      },
      {
        "id": "impact:Kernel memory corruption",
        "keyphrase": "Kernel memory corruption",
        "type": "impact"
      },
      {
        "id": "impact:potentially leading to system crash or arbitrary code execution",
        "keyphrase": "potentially leading to system crash or arbitrary code execution",
        "type": "impact"
      },
      {
        "id": "vector:Mounting a CIFS share with seal option and creating a symbolic link with a large target",
        "keyphrase": "Mounting a CIFS share with seal option and creating a symbolic link with a large target",
        "type": "vector"
      },
      {
        "id": "attacker:Local user",
        "keyphrase": "Local user",
        "type": "attacker"
      },
      {
        "id": "product:Linux Kernel",
        "keyphrase": "Linux Kernel",
        "type": "product"
      },
      {
        "id": "version:6.12.0-rc3",
        "keyphrase": "6.12.0-rc3",
        "type": "version"
      },
      {
        "id": "component:cifs",
        "keyphrase": "cifs",
        "type": "component"
      }
    ],
    "532": [
      {
        "id": "rootcause:The client will squash all compound request buffers down for encryption into a single iov in smb2_set_next_command(). SMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the SMB2_IOCTL request in the first iov",
        "keyphrase": "The client will squash all compound request buffers down for encryption into a single iov in smb2_set_next_command(). SMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the SMB2_IOCTL request in the first iov",
        "type": "rootcause"
      },
      {
        "id": "rootcause:and if the user passes an input buffer that is greater than 328 bytes",
        "keyphrase": "and if the user passes an input buffer that is greater than 328 bytes",
        "type": "rootcause"
      },
      {
        "id": "rootcause:smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base",
        "keyphrase": "smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base",
        "type": "rootcause"
      },
      {
        "id": "weakness:Out-of-bounds write vulnerability in smb2_set_next_command function",
        "keyphrase": "Out-of-bounds write vulnerability in smb2_set_next_command function",
        "type": "weakness"
      },
      {
        "id": "weakness:slab-out-of-bounds",
        "keyphrase": "slab-out-of-bounds",
        "type": "weakness"
      },
      {
        "id": "impact:Kernel memory corruption",
        "keyphrase": "Kernel memory corruption",
        "type": "impact"
      },
      {
        "id": "impact:potentially leading to system crash or arbitrary code execution",
        "keyphrase": "potentially leading to system crash or arbitrary code execution",
        "type": "impact"
      },
      {
        "id": "vector:Mounting a CIFS share with seal option and creating a symbolic link with a large target",
        "keyphrase": "Mounting a CIFS share with seal option and creating a symbolic link with a large target",
        "type": "vector"
      },
      {
        "id": "attacker:Local user",
        "keyphrase": "Local user",
        "type": "attacker"
      },
      {
        "id": "product:Linux Kernel",
        "keyphrase": "Linux Kernel",
        "type": "product"
      },
      {
        "id": "version:6.12.0-rc3",
        "keyphrase": "6.12.0-rc3",
        "type": "version"
      },
      {
        "id": "component:cifs",
        "keyphrase": "cifs",
        "type": "component"
      }
    ],
    "789": [
      {
        "id": "rootcause:The client will squash all compound request buffers down for encryption into a single iov in smb2_set_next_command(). SMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the SMB2_IOCTL request in the first iov",
        "keyphrase": "The client will squash all compound request buffers down for encryption into a single iov in smb2_set_next_command(). SMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the SMB2_IOCTL request in the first iov",
        "type": "rootcause"
      }
    ],
    "770": [
      {
        "id": "rootcause:The client will squash all compound request buffers down for encryption into a single iov in smb2_set_next_command(). SMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the SMB2_IOCTL request in the first iov",
        "keyphrase": "The client will squash all compound request buffers down for encryption into a single iov in smb2_set_next_command(). SMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the SMB2_IOCTL request in the first iov",
        "type": "rootcause"
      },
      {
        "id": "vector:Mounting a CIFS share with seal option and creating a symbolic link with a large target",
        "keyphrase": "Mounting a CIFS share with seal option and creating a symbolic link with a large target",
        "type": "vector"
      },
      {
        "id": "version:6.12.0-rc3",
        "keyphrase": "6.12.0-rc3",
        "type": "version"
      }
    ],
    "226": [
      {
        "id": "rootcause:The client will squash all compound request buffers down for encryption into a single iov in smb2_set_next_command(). SMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the SMB2_IOCTL request in the first iov",
        "keyphrase": "The client will squash all compound request buffers down for encryption into a single iov in smb2_set_next_command(). SMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the SMB2_IOCTL request in the first iov",
        "type": "rootcause"
      }
    ],
    "88": [
      {
        "id": "rootcause:and if the user passes an input buffer that is greater than 328 bytes",
        "keyphrase": "and if the user passes an input buffer that is greater than 328 bytes",
        "type": "rootcause"
      },
      {
        "id": "rootcause:smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base",
        "keyphrase": "smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base",
        "type": "rootcause"
      },
      {
        "id": "weakness:Out-of-bounds write vulnerability in smb2_set_next_command function",
        "keyphrase": "Out-of-bounds write vulnerability in smb2_set_next_command function",
        "type": "weakness"
      },
      {
        "id": "weakness:slab-out-of-bounds",
        "keyphrase": "slab-out-of-bounds",
        "type": "weakness"
      },
      {
        "id": "impact:Kernel memory corruption",
        "keyphrase": "Kernel memory corruption",
        "type": "impact"
      },
      {
        "id": "impact:potentially leading to system crash or arbitrary code execution",
        "keyphrase": "potentially leading to system crash or arbitrary code execution",
        "type": "impact"
      },
      {
        "id": "vector:Mounting a CIFS share with seal option and creating a symbolic link with a large target",
        "keyphrase": "Mounting a CIFS share with seal option and creating a symbolic link with a large target",
        "type": "vector"
      },
      {
        "id": "attacker:Local user",
        "keyphrase": "Local user",
        "type": "attacker"
      },
      {
        "id": "product:Linux Kernel",
        "keyphrase": "Linux Kernel",
        "type": "product"
      },
      {
        "id": "version:6.12.0-rc3",
        "keyphrase": "6.12.0-rc3",
        "type": "version"
      },
      {
        "id": "component:cifs",
        "keyphrase": "cifs",
        "type": "component"
      }
    ],
    "125": [
      {
        "id": "rootcause:and if the user passes an input buffer that is greater than 328 bytes",
        "keyphrase": "and if the user passes an input buffer that is greater than 328 bytes",
        "type": "rootcause"
      },
      {
        "id": "rootcause:smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base",
        "keyphrase": "smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base",
        "type": "rootcause"
      },
      {
        "id": "weakness:Out-of-bounds write vulnerability in smb2_set_next_command function",
        "keyphrase": "Out-of-bounds write vulnerability in smb2_set_next_command function",
        "type": "weakness"
      },
      {
        "id": "weakness:slab-out-of-bounds",
        "keyphrase": "slab-out-of-bounds",
        "type": "weakness"
      },
      {
        "id": "impact:Kernel memory corruption",
        "keyphrase": "Kernel memory corruption",
        "type": "impact"
      },
      {
        "id": "impact:potentially leading to system crash or arbitrary code execution",
        "keyphrase": "potentially leading to system crash or arbitrary code execution",
        "type": "impact"
      },
      {
        "id": "attacker:Local user",
        "keyphrase": "Local user",
        "type": "attacker"
      },
      {
        "id": "product:Linux Kernel",
        "keyphrase": "Linux Kernel",
        "type": "product"
      },
      {
        "id": "component:cifs",
        "keyphrase": "cifs",
        "type": "component"
      }
    ],
    "1284": [
      {
        "id": "rootcause:and if the user passes an input buffer that is greater than 328 bytes",
        "keyphrase": "and if the user passes an input buffer that is greater than 328 bytes",
        "type": "rootcause"
      }
    ],
    "400": [
      {
        "id": "rootcause:smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base",
        "keyphrase": "smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base",
        "type": "rootcause"
      },
      {
        "id": "attacker:Local user",
        "keyphrase": "Local user",
        "type": "attacker"
      },
      {
        "id": "version:6.12.0-rc3",
        "keyphrase": "6.12.0-rc3",
        "type": "version"
      },
      {
        "id": "component:cifs",
        "keyphrase": "cifs",
        "type": "component"
      }
    ],
    "119": [
      {
        "id": "weakness:Out-of-bounds write vulnerability in smb2_set_next_command function",
        "keyphrase": "Out-of-bounds write vulnerability in smb2_set_next_command function",
        "type": "weakness"
      },
      {
        "id": "weakness:slab-out-of-bounds",
        "keyphrase": "slab-out-of-bounds",
        "type": "weakness"
      },
      {
        "id": "impact:Kernel memory corruption",
        "keyphrase": "Kernel memory corruption",
        "type": "impact"
      },
      {
        "id": "impact:potentially leading to system crash or arbitrary code execution",
        "keyphrase": "potentially leading to system crash or arbitrary code execution",
        "type": "impact"
      },
      {
        "id": "product:Linux Kernel",
        "keyphrase": "Linux Kernel",
        "type": "product"
      }
    ],
    "61": [
      {
        "id": "vector:Mounting a CIFS share with seal option and creating a symbolic link with a large target",
        "keyphrase": "Mounting a CIFS share with seal option and creating a symbolic link with a large target",
        "type": "vector"
      }
    ]
  }
}