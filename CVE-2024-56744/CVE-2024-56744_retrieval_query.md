# Retrieval Query for CVE-2024-56744

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved f2fs fix to avoid potential **deadlock** in f2fs_record_stop_reason() syzbot reports **deadlock** issue of f2fs as below ====================================================== WARNING possible circular locking dependency detected 6.12.0-rc3-syzkaller-00087-gc964ced77262 #0 Not tainted ------------------------------------------------------ kswapd0/79 is trying to acquire lock ffff888011824088 (&sbi->sb_lock){++++}-{33}, at f2fs_down_write fs/f2fs/f2fs.h2199 [inline] ffff888011824088 (&sbi->sb_lock){++++}-{33}, at f2fs_record_stop_reason+0x52/0x1d0 fs/f2fs/super.c4068 but task is already holding lock ffff88804bd92610 (sb_internal#2){.+.+}-{00}, at f2fs_evict_inode+0x662/0x15c0 fs/f2fs/inode.c842 which lock already depends on the new lock. the existing dependency chain (in reverse order) is -> #2 (sb_internal#2){.+.+}-{00} lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c5825 percpu_down_read include/linux/percpu-rwsem.h51 [inline] __sb_start_write include/linux/fs.h1716 [inline] sb_start_intwrite+0x4d/0x1c0 include/linux/fs.h1899 f2fs_evict_inode+0x662/0x15c0 fs/f2fs/inode.c842 evict+0x4e8/0x9b0 fs/inode.c725 f2fs_evict_inode+0x1a4/0x15c0 fs/f2fs/inode.c807 evict+0x4e8/0x9b0 fs/inode.c725 dispose_list fs/inode.c774 [inline] prune_icache_sb+0x239/0x2f0 fs/inode.c963 super_cache_scan+0x38c/0x4b0 fs/super.c223 do_shrink_slab+0x701/0x1160 mm/shrinker.c435 shrink_slab+0x1093/0x14d0 mm/shrinker.c662 shrink_one+0x43b/0x850 mm/vmscan.c4818 shrink_many mm/vmscan.c4879 [inline] lru_gen_shrink_node mm/vmscan.c4957 [inline] shrink_node+0x3799/0x3de0 mm/vmscan.c5937 kswapd_shrink_node mm/vmscan.c6765 [inline] balance_pgdat mm/vmscan.c6957 [inline] kswapd+0x1ca3/0x3700 mm/vmscan.c7226 kthread+0x2f0/0x390 kernel/kthread.c389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S244 -> #1 (fs_reclaim){+.+.}-{00} lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c5825 __fs_reclaim_acquire mm/page_alloc.c3834 [inline] fs_reclaim_acquire+0x88/0x130 mm/page_alloc.c3848 might_alloc include/linux/sched/mm.h318 [inline] prepare_alloc_pages+0x147/0x5b0 mm/page_alloc.c4493 __alloc_pages_noprof+0x16f/0x710 mm/page_alloc.c4722 alloc_pages_mpol_noprof+0x3e8/0x680 mm/mempolicy.c2265 alloc_pages_noprof mm/mempolicy.c2345 [inline] folio_alloc_noprof+0x128/0x180 mm/mempolicy.c2352 filemap_alloc_folio_noprof+0xdf/0x500 mm/filemap.c1010 do_read_cache_folio+0x2eb/0x850 mm/filemap.c3787 read_mapping_folio include/linux/pagemap.h1011 [inline] f2fs_commit_super+0x3c0/0x7d0 fs/f2fs/super.c4032 f2fs_record_stop_reason+0x13b/0x1d0 fs/f2fs/super.c4079 f2fs_handle_critical_error+0x2ac/0x5c0 fs/f2fs/super.c4174 f2fs_write_inode+0x35f/0x4d0 fs/f2fs/inode.c785 write_inode fs/fs-writeback.c1503 [inline] __writeback_single_inode+0x711/0x10d0 fs/fs-writeback.c1723 writeback_single_inode+0x1f3/0x660 fs/fs-writeback.c1779 sync_inode_metadata+0xc4/0x120 fs/fs-writeback.c2849 f2fs_release_file+0xa8/0x100 fs/f2fs/file.c1941 __fput+0x23f/0x880 fs/file_table.c431 task_work_run+0x24f/0x310 kernel/task_work.c228 resume_user_mode_work include/linux/resume_user_mode.h50 [inline] exit_to_user_mode_loop kernel/entry/common.c114 [inline] exit_to_user_mode_prepare include/linux/entry-common.h328 [inline] __syscall_exit_to_user_mode_work kernel/entry/common.c207 [inline] syscall_exit_to_user_mode+0x168/0x370 kernel/entry/common.c218 do_syscall_64+0x100/0x230 arch/x86/entry/common.c89 entry_SYSCALL_64_after_hwframe+0x77/0x7f ---truncated---

### Vulnerability Description Key Phrases
- **weakness:** **deadlock**
- **product:** Linux kernel
- **component:** f2fs

## CVE Reference Links Content Summary
Based on the provided content, here's a breakdown of the vulnerability:

**Root Cause:**

- A potential deadlock can occur in the f2fs filesystem when `f2fs_record_stop_reason()` is called synchronously from `f2fs_handle_critical_error()`. This is due to a circular locking dependency involving `&sbi->sb_lock`, `fs_reclaim`, and `sb_internal#2`.
- The deadlock arises when two threads (specifically `kswapd` and a thread performing file operations) try to acquire read locks and then write locks on the same resource in a conflicting order.

**Weaknesses/Vulnerabilities:**

- **Circular Locking Dependency:**  The core issue is a circular dependency between locks.  A thread can hold `sb_internal#2` while trying to acquire `&sbi->sb_lock`, while another thread is holding `&sbi->sb_lock` and trying to acquire `sb_internal#2` via `fs_reclaim`.
- **Synchronous Call:** The synchronous call to `f2fs_record_stop_reason()` within `f2fs_handle_critical_error()` is the trigger for this deadlock.

**Impact of Exploitation:**

- **Deadlock:** The primary impact is a system deadlock, which leads to the system becoming unresponsive.
- **System Unavailability:**  The deadlock will block the threads and the system is not able to operate.

**Attack Vectors:**

- The vulnerability is triggered during normal file system operations that involve error handling within the F2FS filesystem.
- The `kswapd` thread and file operation threads needs to call into the `f2fs_handle_critical_error` and `f2fs_record_stop_reason`

**Required Attacker Capabilities/Position:**

- An attacker would need to be able to cause specific error conditions within the F2FS filesystem that lead to the execution of `f2fs_handle_critical_error()` and the synchronous call to `f2fs_record_stop_reason()`. 
- This can be achieved by writing data to the filesystem which causes specific errors that will cause the function call.
- No specific privilege is needed for the exploit.

**More Details than CVE Description:**

- The provided content gives a detailed explanation of the locking dependency chain and the call stack leading to the deadlock. It also includes a potential scenario demonstrating how the deadlock is triggered between two threads which are `kswapd` and file operation thread.
- The patch changes the call of `f2fs_record_stop_reason()` from synchronous to asynchronous to avoid the deadlock.
- The content gives the specific function names and line number where the deadlock occurs.

In summary, the vulnerability is a deadlock caused by a circular locking dependency in the F2FS filesystem, triggered when certain error conditions occur. The fix is to always use an asynchronous task to call `f2fs_record_stop_reason()`.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.863 |
| 2 | 833 | Deadlock | Base | Allowed | sparse | 0.838 |
| 3 | 912 | Hidden Functionality | Class | Allowed-with-Review | sparse | 0.781 |
| 4 | 763 | Release of Invalid Pointer or Reference | Base | Allowed | sparse | 0.775 |
| 5 | 392 | Missing Report of Error Condition | Base | Allowed | sparse | 0.772 |
| 6 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | dense | 0.579 |
| 7 | 456 | Missing Initialization of a Variable | Variant | Allowed | graph | 0.002 |
| 8 | 288 | Authentication Bypass Using an Alternate Path or Channel | Base | Allowed | sparse | 0.757 |
| 9 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.635 |
| 10 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | Allowed | sparse | 0.587 |



# Complete CWE Specifications


## CWE-667: Improper Locking
**Abstraction:** Class
**Status:** Draft

### Description
The product does not properly acquire or release a lock on a resource, leading to unexpected resource state changes and behaviors.

### Extended Description


Locking is a type of synchronization behavior that ensures that multiple independently-operating processes or threads do not interfere with each other when accessing the same resource. All processes/threads are expected to follow the same steps for locking. If these steps are not followed precisely - or if no locking is done at all - then another process/thread could modify the shared resource in a way that is not visible or predictable to the original process. This can lead to data or memory corruption, denial of service, etc.


### Alternative Terms
None

### Relationships
ChildOf -> CWE-662
ChildOf -> CWE-662
ChildOf -> CWE-662
ChildOf -> CWE-662

### Mapping Guidance
**Usage:** Allowed-with-Review
**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate
**Comments:** Examine children of this entry to see if there is a better fit
**Reasons:**
- Abstraction


### Additional Notes
**[Maintenance]** Deeper research is necessary for synchronization and related mechanisms, including locks, mutexes, semaphores, and other mechanisms. Multiple entries are dependent on this research, which includes relationships to concurrency, race conditions, reentrant functions, etc. CWE-662 and its children - including CWE-667, CWE-820, CWE-821, and others - may need to be modified significantly, along with their relationships.



### Observed Examples
- **CVE-2021-1782:** Chain: improper locking (CWE-667) leads to race condition (CWE-362), as exploited in the wild per CISA KEV.
- **CVE-2009-0935:** Attacker provides invalid address to a memory-reading function, causing a mutex to be unlocked twice
- **CVE-2010-4210:** function in OS kernel unlocks a mutex that was not previously locked, causing a panic or overwrite of arbitrary memory.




## CWE-833: Deadlock
**Abstraction:** Base
**Status:** Incomplete

### Description
The product contains multiple threads or executable segments that are waiting for each other to release a necessary lock, resulting in deadlock.

### Extended Description
Not provided

### Alternative Terms
None

### Relationships
ChildOf -> CWE-667
ChildOf -> CWE-662

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use



### Observed Examples
- **CVE-1999-1476:** A bug in some Intel Pentium processors allow DoS (hang) via an invalid "CMPXCHG8B" instruction, causing a deadlock
- **CVE-2009-2857:** OS deadlock
- **CVE-2009-1961:** OS deadlock involving 3 separate functions




## CWE-912: Hidden Functionality
**Abstraction:** Class
**Status:** Incomplete

### Description
The product contains functionality that is not documented, not part of the specification, and not accessible through an interface or command sequence that is obvious to the product's users or administrators.

### Extended Description
Hidden functionality can take many forms, such as intentionally malicious code, "Easter Eggs" that contain extraneous functionality such as games, developer-friendly shortcuts that reduce maintenance or support costs such as hard-coded accounts, etc. From a security perspective, even when the functionality is not intentionally malicious or damaging, it can increase the product's attack surface and expose additional weaknesses beyond what is already exposed by the intended functionality. Even if it is not easily accessible, the hidden functionality could be useful for attacks that modify the control flow of the application.

### Alternative Terms
None

### Relationships
ChildOf -> CWE-684

### Mapping Guidance
**Usage:** Allowed-with-Review
**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate
**Comments:** Examine children of this entry to see if there is a better fit
**Reasons:**
- Abstraction



### Observed Examples
- **CVE-2022-31260:** Chain: a digital asset management program has an undisclosed backdoor in the legacy version of a PHP script (CWE-912) that could allow an unauthenticated user to export metadata (CWE-306)
- **CVE-2022-3203:** A wireless access point manual specifies that the only method of configuration is via web interface (CWE-1059), but there is an undisclosed telnet server that was activated by default (CWE-912).




## CWE-763: Release of Invalid Pointer or Reference
**Abstraction:** Base
**Status:** Incomplete

### Description
The product attempts to return a memory resource to the system, but it calls the wrong release function or calls the appropriate release function incorrectly.

### Extended Description


This weakness can take several forms, such as:


  - The memory was allocated, explicitly or implicitly, via one memory management method and deallocated using a different, non-compatible function (CWE-762).

  - The function calls or memory management routines chosen are appropriate, however they are used incorrectly, such as in CWE-761.



### Alternative Terms
None

### Relationships
ChildOf -> CWE-404
ChildOf -> CWE-404
ChildOf -> CWE-404

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Additional Notes
**[Maintenance]** The view-1000 subtree that is associated with this weakness needs additional work. Several entries will likely be created in this branch. Currently the focus is on free() of memory, but delete and other related release routines may require the creation of intermediate entries that are not specific to a particular function. In addition, the role of other types of invalid pointers, such as an expired pointer, i.e. CWE-415 Double Free and release of uninitialized pointers, related to CWE-457.



### Observed Examples
- **CVE-2019-11930:** function "internally calls 'calloc' and returns a pointer at an index... inside the allocated buffer. This led to freeing invalid memory."




## CWE-392: Missing Report of Error Condition
**Abstraction:** Base
**Status:** Draft

### Description
The product encounters an error but does not provide a status code or return value to indicate that an error has occurred.

### Extended Description
Not provided

### Alternative Terms
None

### Relationships
ChildOf -> CWE-755
ChildOf -> CWE-684
ChildOf -> CWE-703
ChildOf -> CWE-703

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use



### Observed Examples
- **[REF-1374]:** Chain: JavaScript-based cryptocurrency library can fall back to the insecure Math.random() function instead of reporting a failure (CWE-392), thus reducing the entropy (CWE-332) and leading to generation of non-unique cryptographic keys for Bitcoin wallets (CWE-1391)
- **CVE-2004-0063:** Function returns "OK" even if another function returns a different status code than expected, leading to accepting an invalid PIN number.
- **CVE-2002-1446:** Error checking routine in PKCS#11 library returns "OK" status even when invalid signature is detected, allowing spoofed messages.




## CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')
**Abstraction:** Class
**Status:** Draft

### Description
The product contains a concurrent code sequence that requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence operating concurrently.

### Extended Description


A race condition occurs within concurrent environments, and it is effectively a property of a code sequence. Depending on the context, a code sequence may be in the form of a function call, a small number of instructions, a series of program invocations, etc.


A race condition violates these properties, which are closely related:


  - Exclusivity - the code sequence is given exclusive access to the shared resource, i.e., no other code sequence can modify properties of the shared resource before the original sequence has completed execution.

  - Atomicity - the code sequence is behaviorally atomic, i.e., no other thread or process can concurrently execute the same sequence of instructions (or a subset) against the same resource.

A race condition exists when an "interfering code sequence" can still access the shared resource, violating exclusivity.

The interfering code sequence could be "trusted" or "untrusted." A trusted interfering code sequence occurs within the product; it cannot be modified by the attacker, and it can only be invoked indirectly. An untrusted interfering code sequence can be authored directly by the attacker, and typically it is external to the vulnerable product.


### Alternative Terms
Race Condition

### Relationships
ChildOf -> CWE-691
CanPrecede -> CWE-416
CanPrecede -> CWE-476

### Mapping Guidance
**Usage:** Allowed-with-Review
**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate
**Comments:** Examine children of this entry to see if there is a better fit
**Reasons:**
- Abstraction


### Additional Notes
**[Maintenance]** The relationship between race conditions and synchronization problems (CWE-662) needs to be further developed. They are not necessarily two perspectives of the same core concept, since synchronization is only one technique for avoiding race conditions, and synchronization can be used for other purposes besides race condition prevention.

**[Research Gap]** Race conditions in web applications are under-studied and probably under-reported. However, in 2008 there has been growing interest in this area.

**[Research Gap]** Much of the focus of race condition research has been in Time-of-check Time-of-use (TOCTOU) variants (CWE-367), but many race conditions are related to synchronization problems that do not necessarily require a time-of-check.

**[Research Gap]** From a classification/taxonomy perspective, the relationships between concurrency and program state need closer investigation and may be useful in organizing related issues.



### Observed Examples
- **CVE-2022-29527:** Go application for cloud management creates a world-writable sudoers file that allows local attackers to inject sudo rules and escalate privileges to root by winning a race condition.
- **CVE-2021-1782:** Chain: improper locking (CWE-667) leads to race condition (CWE-362), as exploited in the wild per CISA KEV.
- **CVE-2021-0920:** Chain: mobile platform race condition (CWE-362) leading to use-after-free (CWE-416), as exploited in the wild per CISA KEV.




## CWE-456: Missing Initialization of a Variable
**Abstraction:** Variant
**Status:** Draft

### Description
The product does not initialize critical variables, which causes the execution environment to use unexpected values.

### Extended Description
Not provided

### Alternative Terms
None

### Relationships
ChildOf -> CWE-909
ChildOf -> CWE-665
ChildOf -> CWE-665
CanPrecede -> CWE-89
CanPrecede -> CWE-120
CanPrecede -> CWE-98
CanPrecede -> CWE-457

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Additional Notes
**[Relationship]** This weakness is a major factor in a number of resultant weaknesses, especially in web applications that allow global variable initialization (such as PHP) with libraries that can be directly requested.

**[Research Gap]** It is highly likely that a large number of resultant weaknesses have missing initialization as a primary factor, but researcher reports generally do not provide this level of detail.



### Observed Examples
- **CVE-2020-6078:** Chain: The return value of a function returning a pointer is not checked for success (CWE-252) resulting in the later use of an uninitialized variable (CWE-456) and a null pointer dereference (CWE-476)
- **CVE-2009-2692:** Chain: Use of an unimplemented network socket operation pointing to an uninitialized handler function (CWE-456) causes a crash because of a null pointer dereference (CWE-476).
- **CVE-2020-20739:** A variable that has its value set in a conditional statement is sometimes used when the conditional fails, sometimes causing data leakage




## CWE-288: Authentication Bypass Using an Alternate Path or Channel
**Abstraction:** Base
**Status:** Incomplete

### Description
The product requires authentication, but the product has an alternate path or channel that does not require authentication.

### Extended Description
Not provided

### Alternative Terms
None

### Relationships
ChildOf -> CWE-306
ChildOf -> CWE-284
PeerOf -> CWE-420

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Additional Notes
**[Relationship]** overlaps Unprotected Alternate Channel



### Observed Examples
- **CVE-2000-1179:** Router allows remote attackers to read system logs without authentication by directly connecting to the login screen and typing certain control characters.
- **CVE-1999-1454:** Attackers with physical access to the machine may bypass the password prompt by pressing the ESC (Escape) key.
- **CVE-1999-1077:** OS allows local attackers to bypass the password protection of idled sessions via the programmer's switch or CMD-PWR keyboard sequence, which brings up a debugger that the attacker can use to disable the lock.




## CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition
**Abstraction:** Base
**Status:** Incomplete

### Description
The product checks the state of a resource before using that resource, but the resource's state can change between the check and the use in a way that invalidates the results of the check. This can cause the product to perform invalid actions when the resource is in an unexpected state.

### Extended Description
This weakness can be security-relevant when an attacker can influence the state of the resource between check and use. This can happen with shared resources such as files, memory, or even variables in multithreaded programs.

### Alternative Terms
TOCTTOU: The TOCTTOU acronym expands to "Time Of Check To Time Of Use".
TOCCTOU: The TOCCTOU acronym is most likely a typo of TOCTTOU, but it has been used in some influential documents, so the typo is repeated fairly frequently.

### Relationships
ChildOf -> CWE-362
ChildOf -> CWE-362

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Additional Notes
**[Relationship]** TOCTOU issues do not always involve symlinks, and not every symlink issue is a TOCTOU problem.

**[Research Gap]** Non-symlink TOCTOU issues are not reported frequently, but they are likely to occur in code that attempts to be secure.



### Observed Examples
- **CVE-2015-1743:** TOCTOU in sandbox process allows installation of untrusted browser add-ons by replacing a file after it has been verified, but before it is executed
- **CVE-2003-0813:** A multi-threaded race condition allows remote attackers to cause a denial of service (crash or reboot) by causing two threads to process the same RPC request, which causes one thread to use memory after it has been freed.
- **CVE-2004-0594:** PHP flaw allows remote attackers to execute arbitrary code by aborting execution before the initialization of key data structures is complete.




## CWE-835: Loop with Unreachable Exit Condition ('Infinite Loop')
**Abstraction:** Base
**Status:** Incomplete

### Description
The product contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop.

### Extended Description
Not provided

### Alternative Terms
None

### Relationships
ChildOf -> CWE-834
ChildOf -> CWE-834

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use



### Observed Examples
- **CVE-2022-22224:** Chain: an operating system does not properly process malformed Open Shortest Path First (OSPF) Type/Length/Value Identifiers (TLV) (CWE-703), which can cause the process to enter an infinite loop (CWE-835)
- **CVE-2022-25304:** A Python machine communication platform did not account for receiving a malformed packet with a null size, causing the receiving function to never update the message buffer and be caught in an infinite loop.
- **CVE-2011-1027:** Chain: off-by-one error (CWE-193) leads to infinite loop (CWE-835) using invalid hex-encoded characters.

