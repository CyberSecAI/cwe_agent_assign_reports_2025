## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved f2fs fix to avoid potential **deadlock** in f2fs_record_stop_reason() syzbot reports **deadlock** issue of f2fs as below ====================================================== WARNING possible circular locking dependency detected 6.12.0-rc3-syzkaller-00087-gc964ced77262 #0 Not tainted ------------------------------------------------------ kswapd0/79 is trying to acquire lock ffff888011824088 (&sbi->sb_lock){++++}-{33}, at f2fs_down_write fs/f2fs/f2fs.h2199 [inline] ffff888011824088 (&sbi->sb_lock){++++}-{33}, at f2fs_record_stop_reason+0x52/0x1d0 fs/f2fs/super.c4068 but task is already holding lock ffff88804bd92610 (sb_internal#2){.+.+}-{00}, at f2fs_evict_inode+0x662/0x15c0 fs/f2fs/inode.c842 which lock already depends on the new lock. the existing dependency chain (in reverse order) is -> #2 (sb_internal#2){.+.+}-{00} lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c5825 percpu_down_read include/linux/percpu-rwsem.h51 [inline] __sb_start_write include/linux/fs.h1716 [inline] sb_start_intwrite+0x4d/0x1c0 include/linux/fs.h1899 f2fs_evict_inode+0x662/0x15c0 fs/f2fs/inode.c842 evict+0x4e8/0x9b0 fs/inode.c725 f2fs_evict_inode+0x1a4/0x15c0 fs/f2fs/inode.c807 evict+0x4e8/0x9b0 fs/inode.c725 dispose_list fs/inode.c774 [inline] prune_icache_sb+0x239/0x2f0 fs/inode.c963 super_cache_scan+0x38c/0x4b0 fs/super.c223 do_shrink_slab+0x701/0x1160 mm/shrinker.c435 shrink_slab+0x1093/0x14d0 mm/shrinker.c662 shrink_one+0x43b/0x850 mm/vmscan.c4818 shrink_many mm/vmscan.c4879 [inline] lru_gen_shrink_node mm/vmscan.c4957 [inline] shrink_node+0x3799/0x3de0 mm/vmscan.c5937 kswapd_shrink_node mm/vmscan.c6765 [inline] balance_pgdat mm/vmscan.c6957 [inline] kswapd+0x1ca3/0x3700 mm/vmscan.c7226 kthread+0x2f0/0x390 kernel/kthread.c389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S244 -> #1 (fs_reclaim){+.+.}-{00} lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c5825 __fs_reclaim_acquire mm/page_alloc.c3834 [inline] fs_reclaim_acquire+0x88/0x130 mm/page_alloc.c3848 might_alloc include/linux/sched/mm.h318 [inline] prepare_alloc_pages+0x147/0x5b0 mm/page_alloc.c4493 __alloc_pages_noprof+0x16f/0x710 mm/page_alloc.c4722 alloc_pages_mpol_noprof+0x3e8/0x680 mm/mempolicy.c2265 alloc_pages_noprof mm/mempolicy.c2345 [inline] folio_alloc_noprof+0x128/0x180 mm/mempolicy.c2352 filemap_alloc_folio_noprof+0xdf/0x500 mm/filemap.c1010 do_read_cache_folio+0x2eb/0x850 mm/filemap.c3787 read_mapping_folio include/linux/pagemap.h1011 [inline] f2fs_commit_super+0x3c0/0x7d0 fs/f2fs/super.c4032 f2fs_record_stop_reason+0x13b/0x1d0 fs/f2fs/super.c4079 f2fs_handle_critical_error+0x2ac/0x5c0 fs/f2fs/super.c4174 f2fs_write_inode+0x35f/0x4d0 fs/f2fs/inode.c785 write_inode fs/fs-writeback.c1503 [inline] __writeback_single_inode+0x711/0x10d0 fs/fs-writeback.c1723 writeback_single_inode+0x1f3/0x660 fs/fs-writeback.c1779 sync_inode_metadata+0xc4/0x120 fs/fs-writeback.c2849 f2fs_release_file+0xa8/0x100 fs/f2fs/file.c1941 __fput+0x23f/0x880 fs/file_table.c431 task_work_run+0x24f/0x310 kernel/task_work.c228 resume_user_mode_work include/linux/resume_user_mode.h50 [inline] exit_to_user_mode_loop kernel/entry/common.c114 [inline] exit_to_user_mode_prepare include/linux/entry-common.h328 [inline] __syscall_exit_to_user_mode_work kernel/entry/common.c207 [inline] syscall_exit_to_user_mode+0x168/0x370 kernel/entry/common.c218 do_syscall_64+0x100/0x230 arch/x86/entry/common.c89 entry_SYSCALL_64_after_hwframe+0x77/0x7f ---truncated---

### Vulnerability Description Key Phrases
- **weakness:** **deadlock**
- **product:** Linux kernel
- **component:** f2fs

## CVE Reference Links Content Summary
Based on the provided content, here's a breakdown of the vulnerability:

**Root Cause:**

- A potential deadlock can occur in the f2fs filesystem when `f2fs_record_stop_reason()` is called synchronously from `f2fs_handle_critical_error()`. This is due to a circular locking dependency involving `&sbi->sb_lock`, `fs_reclaim`, and `sb_internal#2`.
- The deadlock arises when two threads (specifically `kswapd` and a thread performing file operations) try to acquire read locks and then write locks on the same resource in a conflicting order.

**Weaknesses/Vulnerabilities:**

- **Circular Locking Dependency:**  The core issue is a circular dependency between locks.  A thread can hold `sb_internal#2` while trying to acquire `&sbi->sb_lock`, while another thread is holding `&sbi->sb_lock` and trying to acquire `sb_internal#2` via `fs_reclaim`.
- **Synchronous Call:** The synchronous call to `f2fs_record_stop_reason()` within `f2fs_handle_critical_error()` is the trigger for this deadlock.

**Impact of Exploitation:**

- **Deadlock:** The primary impact is a system deadlock, which leads to the system becoming unresponsive.
- **System Unavailability:**  The deadlock will block the threads and the system is not able to operate.

**Attack Vectors:**

- The vulnerability is triggered during normal file system operations that involve error handling within the F2FS filesystem.
- The `kswapd` thread and file operation threads needs to call into the `f2fs_handle_critical_error` and `f2fs_record_stop_reason`

**Required Attacker Capabilities/Position:**

- An attacker would need to be able to cause specific error conditions within the F2FS filesystem that lead to the execution of `f2fs_handle_critical_error()` and the synchronous call to `f2fs_record_stop_reason()`. 
- This can be achieved by writing data to the filesystem which causes specific errors that will cause the function call.
- No specific privilege is needed for the exploit.

**More Details than CVE Description:**

- The provided content gives a detailed explanation of the locking dependency chain and the call stack leading to the deadlock. It also includes a potential scenario demonstrating how the deadlock is triggered between two threads which are `kswapd` and file operation thread.
- The patch changes the call of `f2fs_record_stop_reason()` from synchronous to asynchronous to avoid the deadlock.
- The content gives the specific function names and line number where the deadlock occurs.

In summary, the vulnerability is a deadlock caused by a circular locking dependency in the F2FS filesystem, triggered when certain error conditions occur. The fix is to always use an asynchronous task to call `f2fs_record_stop_reason()`.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.863 |
| 2 | 833 | Deadlock | Base | Allowed | sparse | 0.838 |
| 3 | 912 | Hidden Functionality | Class | Allowed-with-Review | sparse | 0.781 |
| 4 | 763 | Release of Invalid Pointer or Reference | Base | Allowed | sparse | 0.775 |
| 5 | 392 | Missing Report of Error Condition | Base | Allowed | sparse | 0.772 |
| 6 | 288 | Authentication Bypass Using an Alternate Path or Channel | Base | Allowed | sparse | 0.757 |
| 7 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.635 |
| 8 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | Allowed | sparse | 0.587 |
| 9 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | dense | 0.579 |
| 10 | 123 | Write-what-where Condition | Base | Allowed | graph | 0.002 |



# Complete CWE Specifications

CWE-667: Improper Locking

CWE-833: Deadlock

CWE-912: Hidden Functionality

CWE-763: Release of Invalid Pointer or Reference

CWE-392: Missing Report of Error Condition

CWE-288: Authentication Bypass Using an Alternate Path or Channel

CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition

CWE-835: Loop with Unreachable Exit Condition ('Infinite Loop')

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-123: Write-what-where Condition