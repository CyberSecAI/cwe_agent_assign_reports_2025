## Vulnerability Description
cpp-httplib is a C++ header-only HTTP/HTTPS server and client library. Prior to version 0.20.1, the library fails to enforce configured size limits on incoming request bodies when `Transfer-Encoding chunked` is used or when no `Content-Length` header is provided. A remote attacker can send a chunked request without the terminating zero-length chunk, causing **uncontrolled memory allocation** on the server. This leads to potential exhaustion of system memory and results in a server crash or unresponsiveness. Version 0.20.1 fixes the issue by enforcing limits during parsing. If the limit is exceeded at any point during reading, the connection is terminated immediately. A short-term workaround through a Reverse Proxy is available. If updating the library immediately is not feasible, deploy a reverse proxy (e.g., Nginx, HAProxy) in front of the `cpp-httplib` application. Configure the proxy to enforce maximum request body size limits, thereby stopping excessively large requests before they reach the vulnerable library code.

### Vulnerability Description Key Phrases
- **vector:** chunked request without terminating zero-length chunk
- **weakness:** **uncontrolled memory allocation**
- **product:** cpp-httplib
- **impact:** ['server crash', 'unresponsiveness']
- **attacker:** remote attacker
- **version:** Prior to version 0.20.1

## CVE Reference Links Content Summary
```text
The following content relates to CVE-2025-46728:

Root cause of vulnerability:
The server's `read_content_chunked` function (and associated stream reading logic) continuously reads incoming chunks, accumulating the data without limiting the total accumulated size *during* this reading process for chunked transfers.

Weaknesses/vulnerabilities present:
The library fails to enforce configured size limits on incoming request bodies when `Transfer-Encoding: chunked` is used or when no `Content-Length` header is provided. A remote attacker can send a chunked request without the terminating zero-length chunk, causing uncontrolled memory allocation on the server.

Impact of exploitation:
*   Denial of Service: The server process will consume excessive memory until it crashes or becomes unresponsive.
*   Resource Exhaustion: On multi-tenant systems, this can impact other applications by consuming system resources.

Attack vectors:
A remote attacker can send a chunked request without the terminating zero-length chunk.

Required attacker capabilities/position:
Remote attacker

Mitigation or fix:
1.  Short-term workaround through a Reverse Proxy: Deploy a reverse proxy (e.g., Nginx, HAProxy) in front of the `cpp-httplib` application. Configure the proxy to enforce maximum request body size limits, thereby stopping excessively large requests before they reach the vulnerable library code.
2.  Code fix: Enforce limits during parsing. If the limit is exceeded at any point during reading, the connection should be terminated immediately (e.g., by returning an error or closing the stream).
```

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | sparse | 0.917 |
| 2 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.865 |
| 3 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.796 |
| 4 | 190 | Integer Overflow or Wraparound | Base | Allowed | sparse | 0.787 |
| 5 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | sparse | 0.772 |
| 6 | 444 | Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling') | Base | Allowed | sparse | 0.770 |
| 7 | 400 | Uncontrolled Resource Consumption | Class | Discouraged | sparse | 0.766 |
| 8 | 476 | NULL Pointer Dereference | Base | Allowed | sparse | 0.733 |
| 9 | 130 | Improper Handling of Length Parameter Inconsistency | Base | Allowed | dense | 0.435 |
| 10 | 1325 | Improperly Controlled Sequential Memory Allocation | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-789: Memory Allocation with Excessive Size Value

CWE-770: Allocation of Resources Without Limits or Throttling

CWE-1284: Improper Validation of Specified Quantity in Input

CWE-190: Integer Overflow or Wraparound

CWE-674: Uncontrolled Recursion

CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')

CWE-400: Uncontrolled Resource Consumption

CWE-476: NULL Pointer Dereference

CWE-130: Improper Handling of Length Parameter Inconsistency

CWE-1325: Improperly Controlled Sequential Memory Allocation