# Raw Retriever Results for CVE-2024-41051

# Raw Retriever Results for CVE-2024-41051
## Query
In the Linux kernel, the following vulnerability has been resolved cachefiles wait for ondemand_object_worker to finish when dropping object When queuing ondemand_object_worker() to re-open the object, cachefiles_object is not pinned. The cachefiles_object may be freed when the pending read request is completed intentionally and the related erofs is umounted. If ondemand_object_worker() runs after the object is freed, it will incur use-after-free problem as shown below. process A processs B process C process D cachefiles_ondemand_send_req() // send a read req X // wait for its completion // close ondemand fd cachefiles_ondemand_fd_release() // set object as CLOSE cachefiles_ondemand_daemon_read() // set object as REOPENING queue_work(fscache_wq, &info->ondemand_work) // close /dev/cachefiles cachefiles_daemon_release cachefiles_flush_reqs complete(&req->done) // read req X is completed // umount the erofs fs cachefiles_put_object() // object will be freed cachefiles_ondemand_deinit_obj_info() kmem_cache_free(object) // both info and object are freed ondemand_object_worker() When dropping an object, it is no longer necessary to reopen the object, so use cancel_work_sync() to cancel or wait fo

## Keyphrases
- **rootcause**: 'race condition'
- **weakness**: 'use-after-free'

## Score Statistics
| Retriever | Min | Max | Mean | Median | Count |
|-----------|-----|-----|------|--------|-------|
| Dense | 0.4020 | 0.4805 | 0.4354 | 0.4376 | 20 |
| Sparse | 199.4577 | 1000.0000 | 664.0437 | 634.1649 | 12 |
| Graph | 1.6100 | 2.9120 | 2.0469 | 1.9127 | 20 |

## Graph Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Mapping Usage |
|---|--------|------|-------------|-------|---------------|
| 1 | 123 | Write-what-where Condition | base | 2.9120 | Allowed |
| 2 | 364 | Signal Handler Race Condition | base | 2.8652 | Allowed |
| 3 | 415 | Double Free | Variant | 2.5941 | Allowed |
| 4 | 416 | Use After Free | Variant | 2.5097 | Allowed |
| 5 | 1325 | Improperly Controlled Sequential Memory Allocation | Base | 2.3360 | Allowed |
| 6 | 476 | NULL Pointer Dereference | base | 2.2100 | Allowed |
| 7 | 1265 | Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls | base | 2.2100 | Allowed |
| 8 | 120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | base | 2.2100 | Allowed-with-Review |
| 9 | 390 | Detection of Error Condition Without Action | base | 2.2100 | Allowed |
| 10 | 639 | Authorization Bypass Through User-Controlled Key | base | 2.1190 | Allowed |
| 11 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | 1.7064 | Allowed-with-Review |
| 12 | 252 | Unchecked Return Value | base | 1.6848 | Allowed |
| 13 | 134 | Use of Externally-Controlled Format String | base | 1.6848 | Allowed |
| 14 | 826 | Premature Release of Resource During Expected Lifetime | base | 1.6848 | Allowed |
| 15 | 562 | Return of Stack Variable Address | base | 1.6848 | Allowed |

## Dense Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Original Score | Mapping Usage |
|---|--------|------|-------------|-------|----------------|---------------|
| 1 | 403 | Exposure of File Descriptor to Unintended Control Sphere ('File Descriptor Leak') | Base | 0.4805 | 0.4805 | Allowed |
| 2 | 775 | Missing Release of File Descriptor or Handle after Effective Lifetime | Variant | 0.4781 | 0.4781 | Allowed |
| 3 | 1341 | Multiple Releases of Same Resource or Handle | Base | 0.4589 | 0.4589 | Allowed |
| 4 | 1325 | Improperly Controlled Sequential Memory Allocation | Base | 0.4545 | 0.4545 | Allowed |
| 5 | 366 | Race Condition within a Thread | Base | 0.4517 | 0.4517 | Allowed |
| 6 | 774 | Allocation of File Descriptors or Handles Without Limits or Throttling | Variant | 0.4514 | 0.4514 | Allowed |
| 7 | 226 | Sensitive Information in Resource Not Removed Before Reuse | Base | 0.4507 | 0.4507 | Allowed |
| 8 | 415 | Double Free | Variant | 0.4457 | 0.4457 | Allowed |
| 9 | 911 | Improper Update of Reference Count | Base | 0.4454 | 0.4454 | Allowed |
| 10 | 404 | Improper Resource Shutdown or Release | Class | 0.4449 | 0.4449 | Allowed-with-Review |
| 11 | 763 | Release of Invalid Pointer or Reference | Base | 0.4304 | 0.4304 | Allowed |
| 12 | 910 | Use of Expired File Descriptor | Base | 0.4259 | 0.4259 | Allowed |
| 13 | 594 | J2EE Framework: Saving Unserializable Objects to Disk | Variant | 0.4194 | 0.4194 | Allowed |
| 14 | 833 | Deadlock | Base | 0.4177 | 0.4177 | Allowed |
| 15 | 667 | Improper Locking | Class | 0.4172 | 0.4172 | Allowed-with-Review |

## Sparse Retriever Results (12)
| # | CWE ID | Name | Score | Original Score | Mapping Usage |
|---|--------|------|-------|---------------|---------------|
| 1 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | 1000.0000 | 1000.0000 | Allowed-with-Review |
| 2 | 416 | Use After Free | 1000.0000 | 1000.0000 | Allowed |
| 3 | 401 | Missing Release of Memory after Effective Lifetime | 686.7732 | 686.7732 | Allowed |
| 4 | 415 | Double Free | 678.1380 | 678.1380 | Allowed |
| 5 | 639 | Authorization Bypass Through User-Controlled Key | 671.3007 | 671.3007 | Allowed |
| 6 | 667 | Improper Locking | 634.2458 | 634.2458 | Allowed-with-Review |
| 7 | 911 | Improper Update of Reference Count | 634.0840 | 634.0840 | Allowed |
| 8 | 1321 | Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution') | 622.4641 | 622.4641 | Allowed |
| 9 | 347 | Improper Verification of Cryptographic Signature | 620.3413 | 620.3413 | Allowed |
| 10 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | 611.8258 | 611.8258 | Allowed |
| 11 | 863 | Incorrect Authorization | 609.8935 | 609.8935 | Allowed-with-Review |
| 12 | 1287 | Improper Validation of Specified Type of Input | 199.4577 | 199.4577 | Allowed |
