## Vulnerability Description
Botan is a C++ cryptography library. X.509 certificates can identify elliptic curves using either an object identifier or using explicit encoding of the parameters. Prior to versions 3.3.0 and 2.19.4, an attacker could present an ECDSA X.509 certificate using explicit encoding where the parameters are very large. The proof of concept used a 16Kbit prime for this purpose. When parsing, the parameter is checked to be prime, causing excessive computation. This was patched in 2.19.4 and 3.3.0 to allow the prime parameter of the elliptic curve to be at most 521 bits. No known workarounds are available. Note that support for explicit encoding of elliptic curve parameters is deprecated in Botan.

### Vulnerability Description Key Phrases
- **rootcause:** **excessive computation when parsing X.509 certificates with very large ECDSA parameters**
- **product:** Botan
- **version:** prior to 3.3.0 and 2.19.4

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of CVE-2024-34703:

**Root Cause of Vulnerability:**

The vulnerability stems from the lack of proper input validation when decoding elliptic curve parameters in X.509 certificates. Specifically, when an X.509 certificate uses explicit encoding for elliptic curve parameters, the prime parameter 'p' was not sufficiently limited in size. This allowed an attacker to provide a very large prime number which requires excessive computation to check for primality.

**Weaknesses/Vulnerabilities Present:**

- **Lack of Input Validation:** The code did not impose a maximum limit on the size of the prime 'p' during the decoding of elliptic curve parameters.
- **Resource Exhaustion:** The excessive computation required to check the primality of very large numbers leads to a denial-of-service condition.

**Impact of Exploitation:**

- **Denial of Service (DoS):** By providing a crafted X.509 certificate with an overly large prime parameter, an attacker could cause the system to exhaust computational resources while performing the primality check. This could lead to service unavailability.

**Attack Vectors:**

- **Malicious X.509 Certificates:** An attacker could craft a malicious X.509 certificate that includes explicit encoding of elliptic curve parameters with a large prime 'p'. This could be sent during TLS handshakes or other processes involving X.509 certificates.

**Required Attacker Capabilities/Position:**

- The attacker needs to be able to supply a crafted X.509 certificate to the vulnerable system, which typically involves being in a position to initiate a connection or otherwise provide the certificate. No special privileges are needed.

**Additional Details:**
- The vulnerability was addressed by adding a size limit of 1024 bits on the prime parameter `p`, and later refined to 521 bits in the patches.
- The code change shown in the provided diffs is related to adding the size check of the prime 'p'. Specifically, it adds the following validation: `if(p.bits() < 112 || p.bits() > 1024)`. This limits the size of the prime to between 112 and 1024 bits, preventing excessively large numbers from being processed.
- The GitHub Security Advisory (GHSA-w4g2-7m2h-7xj7) explicitly mentions a 16Kbit prime being used in a Proof of Concept (POC).
- Support for explicit encoding of elliptic curve parameters is deprecated in the library.

The provided information is more detailed than the typical CVE description, giving a precise root cause, attack vector, and fix.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 295 | Improper Certificate Validation | Base | Allowed | sparse | 0.682 |
| 2 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | sparse | 0.674 |
| 3 | 1176 | Inefficient CPU Computation | Class | Allowed-with-Review | sparse | 0.647 |
| 4 | 208 | Observable Timing Discrepancy | Base | Allowed | sparse | 0.646 |
| 5 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.644 |
| 6 | 116 | Improper Encoding or Escaping of Output | Class | Allowed-with-Review | sparse | 0.641 |
| 7 | 1333 | Inefficient Regular Expression Complexity | Base | Allowed | sparse | 0.637 |
| 8 | 639 | Authorization Bypass Through User-Controlled Key | Base | Allowed | sparse | 0.635 |
| 9 | 780 | Use of RSA Algorithm without OAEP | Variant | Allowed | dense | 0.442 |
| 10 | 1325 | Improperly Controlled Sequential Memory Allocation | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-295: Improper Certificate Validation

CWE-789: Memory Allocation with Excessive Size Value

CWE-1176: Inefficient CPU Computation

CWE-208: Observable Timing Discrepancy

CWE-770: Allocation of Resources Without Limits or Throttling

CWE-116: Improper Encoding or Escaping of Output

CWE-1333: Inefficient Regular Expression Complexity

CWE-639: Authorization Bypass Through User-Controlled Key

CWE-780: Use of RSA Algorithm without OAEP

CWE-1325: Improperly Controlled Sequential Memory Allocation