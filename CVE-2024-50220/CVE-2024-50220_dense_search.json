{
  "retriever": "dense",
  "query": "In the Linux kernel, the following vulnerability has been resolved fork do not invoke uffd on fork if error occurs Patch series fork do not expose incomplete mm on fork. During fork we may place the virtual memory address space into an inconsistent state before the fork operation is complete. In addition, we may encounter an error during the fork operation that indicates that the virtual memory address space is invalidated. As a result, we should not be exposing it in any way to external machinery that might interact with the mm or VMAs, machinery that is not designed to deal with incomplete state. We specifically update the fork logic to defer khugepaged and ksm to the end of the operation and only to be invoked if no error arose, and disallow uffd from observing fork events should an error have occurred. This patch (of 2) Currently on fork we expose the virtual address space of a process to userland unconditionally if uffd is registered in VMAs, regardless of whether an error arose in the fork. This is performed in dup_userfaultfd_complete() which is invoked unconditionally, and performs two duties - invoking registered handlers for the UFFD_EVENT_FORK event via dup_fctx(), and clearing down userfaultfd_fork_ctx objects established in dup_userfaultfd(). This is problematic, because the virtual address space may not yet be correctly initialised if an error arose. The change in commit d24062914837 (fork use __mt_dup() to duplicate maple tree in dup_mmap()) makes this more pertinent as we may be in a state where entries in the maple tree are not yet consistent. We address this by, on fork error, ensuring that we roll back state that we would otherwise expect to clean up through the event being handled by userland and perform the memory freeing duty otherwise performed by dup_userfaultfd_complete(). We do this by implementing a new function, dup_userfaultfd_fail(), which performs the same loop, only decrementing reference counts. Note that we perform mmgrab() on the parent and child mms, however userfaultfd_ctx_put() will mmdrop() this once the reference count drops to zero, so we will avoid memory leaks correctly here.",
  "keyphrases": {
    "weakness": [
      "expose the virtual address space of a process to userland unconditionally if uffd is registered in VMAs"
    ]
  },
  "timestamp": "2025-07-12 05:29:22",
  "cve_id": "CVE-2024-50220",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "909",
      "name": "Missing Initialization of Resource",
      "type": "Class",
      "score": 0.4710894741388385
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "type": "Class",
      "score": 0.4700894123771652
    },
    {
      "cwe_id": "1260",
      "name": "Improper Handling of Overlap Between Protected Memory Ranges",
      "type": "Base",
      "score": 0.46694254686207526
    },
    {
      "cwe_id": "403",
      "name": "Exposure of File Descriptor to Unintended Control Sphere ('File Descriptor Leak')",
      "type": "Base",
      "score": 0.45479878729418677
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 0.45306042780839983
    },
    {
      "cwe_id": "1342",
      "name": "Information Exposure through Microarchitectural State after Transient Execution",
      "type": "Base",
      "score": 0.4528646434437072
    },
    {
      "cwe_id": "911",
      "name": "Improper Update of Reference Count",
      "type": "Base",
      "score": 0.45255873823571835
    },
    {
      "cwe_id": "1316",
      "name": "Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges",
      "type": "Base",
      "score": 0.4517422104606261
    },
    {
      "cwe_id": "763",
      "name": "Release of Invalid Pointer or Reference",
      "type": "Base",
      "score": 0.4472104003959526
    },
    {
      "cwe_id": "908",
      "name": "Use of Uninitialized Resource",
      "type": "Base",
      "score": 0.4468437393367861
    },
    {
      "cwe_id": "822",
      "name": "Untrusted Pointer Dereference",
      "type": "Base",
      "score": 0.43221279587876493
    },
    {
      "cwe_id": "823",
      "name": "Use of Out-of-range Pointer Offset",
      "type": "Base",
      "score": 0.43168886131818207
    },
    {
      "cwe_id": "72",
      "name": "Improper Handling of Apple HFS+ Alternate Data Stream Path",
      "type": "Variant",
      "score": 0.430036083975357
    },
    {
      "cwe_id": "762",
      "name": "Mismatched Memory Management Routines",
      "type": "Variant",
      "score": 0.429944743350383
    },
    {
      "cwe_id": "366",
      "name": "Race Condition within a Thread",
      "type": "Base",
      "score": 0.4281636542935433
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "type": "Variant",
      "score": 0.42737901569900105
    },
    {
      "cwe_id": "1422",
      "name": "Exposure of Sensitive Information caused by Incorrect Data Forwarding during Transient Execution",
      "type": "Base",
      "score": 0.4273297700216785
    },
    {
      "cwe_id": "1421",
      "name": "Exposure of Sensitive Information in Shared Microarchitectural Structures during Transient Execution",
      "type": "Base",
      "score": 0.4266660002671978
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 0.4266535230731022
    },
    {
      "cwe_id": "1332",
      "name": "Improper Handling of Faults that Lead to Instruction Skips",
      "type": "Base",
      "score": 0.4254904578516122
    }
  ]
}