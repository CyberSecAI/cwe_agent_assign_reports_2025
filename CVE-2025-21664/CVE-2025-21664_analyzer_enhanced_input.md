## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved dm thin make get_first_thin use rcu-safe list first function The documentation in rculist.h explains the absence of list_empty_rcu() and cautions programmers against relying on a list_empty() -> list_first() sequence in RCU safe code. This is because each of these functions performs its own READ_ONCE() of the list head. This can lead to a situation where the list_empty() sees a valid list entry, but the subsequent list_first() sees a different view of list head state after a modification. In the case of dm-thin, this author had a production box crash from a GP fault in the process_deferred_bios path. This function saw a valid list head in get_first_thin() but when it subsequently dereferenced that and turned it into a thin_c, it got the inside of the struct pool, since the list was now empty and referring to itself. The kernel on which this occurred printed both a warning about a refcount_t being saturated, and a UBSAN error for an out-of-bounds cpuid access in the queued spinlock, prior to the fault itself. When the resulting kdump was examined, it was possible to see another thread patiently waiting in thin_dtrs synchronize_rcu. The thin_dtr call managed to pull the thin_c out of the active thins list (and have it be the last entry in the active_thins list) at just the wrong moment which lead to this crash. Fortunately, the fix here is straight forward. Switch get_first_thin() function to use list_first_or_null_rcu() which performs just a single READ_ONCE() and returns NULL if the list is already empty. This was run against the devicemapper test suites thin-provisioning suites for delete and suspend and no regressions were observed.

### Vulnerability Description Key Phrases
- **impact:** production box crash from a GP fault
- **product:** Linux kernel
- **component:** dm thin make get_first_thin use rcu-safe list first function

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 183 | Permissive List of Allowed Inputs | Base | Allowed | alternate_terms | 0.800 |
| 2 | 476 | NULL Pointer Dereference | Base | Allowed | sparse | 0.466 |
| 3 | 201 | Insertion of Sensitive Information Into Sent Data | Base | Allowed | sparse | 0.453 |
| 4 | 863 | Incorrect Authorization | Class | Allowed-with-Review | sparse | 0.449 |
| 5 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.444 |
| 6 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | sparse | 0.440 |
| 7 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.437 |
| 8 | 327 | Use of a Broken or Risky Cryptographic Algorithm | Class | Allowed-with-Review | sparse | 0.434 |
| 9 | 667 | Improper Locking | Class | Allowed-with-Review | dense | 0.454 |
| 10 | 772 | Missing Release of Resource after Effective Lifetime | Base | Allowed | graph | 0.002 |



# Complete CWE Specifications

CWE-183: Permissive List of Allowed Inputs

CWE-476: NULL Pointer Dereference

CWE-201: Insertion of Sensitive Information Into Sent Data

CWE-863: Incorrect Authorization

CWE-125: Out-of-bounds Read

CWE-909: Missing Initialization of Resource

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-327: Use of a Broken or Risky Cryptographic Algorithm

CWE-667: Improper Locking

CWE-772: Missing Release of Resource after Effective Lifetime