{
  "retriever": "sparse",
  "query": "In the Linux kernel, the following vulnerability has been resolved device-dax correct pgoff align in dax_set_mapping() pgoff should be aligned using ALIGN_DOWN() instead of ALIGN(). Otherwise, vmf->address not aligned to fault_size will be aligned to the next alignment, that can result in memory failure getting the wrong address. Its a subtle situation that only can be observed in page_mapped_in_vma() after the page is page fault handled by dev_dax_huge_fault. Generally, there is little chance to perform page_mapped_in_vma in dev-daxs page unless in specific error injection to the dax device to trigger an MCE - memory-failure. In that case, page_mapped_in_vma() will be triggered to determine which task is accessing the failure address and kill that task in the end. We used self-developed dax device (which is 2M aligned mapping) , to perform error injection to random address. It turned out that error injected to non-2M-aligned address was causing endless MCE until panic. Because page_mapped_in_vma() kept resulting wrong address and the task accessing the failure address was never killed properly [ 3783.719419] Memory failure 0x200c9742 recovery action for dax page Recovered [ 3784.049006] mce Uncorrected hardware memory error in user-access at 200c9742380 [ 3784.049190] Memory failure 0x200c9742 recovery action for dax page Recovered [ 3784.448042] mce Uncorrected hardware memory error in user-access at 200c9742380 [ 3784.448186] Memory failure 0x2",
  "keyphrases": {
    "weakness": [
      "wrong alignment in dax_set_mapping()"
    ]
  },
  "timestamp": "2025-07-13 19:45:52",
  "cve_id": "CVE-2024-50022",
  "result_count": 11,
  "results": [
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "score": 869.052345192915,
      "search_source": "weakness:wrong alignment in dax_set_mapping()"
    },
    {
      "cwe_id": "770",
      "name": "Allocation of Resources Without Limits or Throttling",
      "score": 856.9376274811863,
      "search_source": "weakness:wrong alignment in dax_set_mapping()"
    },
    {
      "cwe_id": "119",
      "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
      "score": 848.8426690021168,
      "search_source": "weakness:wrong alignment in dax_set_mapping()"
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "score": 840.4885915606678,
      "search_source": "weakness:wrong alignment in dax_set_mapping()"
    },
    {
      "cwe_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "score": 839.7563377979674,
      "search_source": "weakness:wrong alignment in dax_set_mapping()"
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "score": 831.3833729566243,
      "search_source": "weakness:wrong alignment in dax_set_mapping()"
    },
    {
      "cwe_id": "125",
      "name": "Out-of-bounds Read",
      "score": 830.5278035168589,
      "search_source": "weakness:wrong alignment in dax_set_mapping()"
    },
    {
      "cwe_id": "789",
      "name": "Memory Allocation with Excessive Size Value",
      "score": 820.3204462612491,
      "search_source": "weakness:wrong alignment in dax_set_mapping()"
    },
    {
      "cwe_id": "401",
      "name": "Missing Release of Memory after Effective Lifetime",
      "score": 816.5998427718018,
      "search_source": "weakness:wrong alignment in dax_set_mapping()"
    },
    {
      "cwe_id": "755",
      "name": "Improper Handling of Exceptional Conditions",
      "score": 815.9067617687258,
      "search_source": "weakness:wrong alignment in dax_set_mapping()"
    },
    {
      "cwe_id": "617",
      "name": "Reachable Assertion",
      "score": 287.3927748469102,
      "search_source": "base_query"
    }
  ]
}