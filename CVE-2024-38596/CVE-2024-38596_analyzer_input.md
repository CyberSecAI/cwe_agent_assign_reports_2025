# Vulnerability Information: CVE-2024-38596

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolvedaf_unix Fix data races in unix_release_sock/unix_stream_sendmsgA **data-race condition** has been identified in af_unix. In one data path,the write function unix_release_sock() atomically writes tosk->sk_shutdown using WRITE_ONCE. However, on the reader side,unix_stream_sendmsg() does not read it atomically. Consequently, thisissue is causing the following KCSAN splat to occur BUG KCSAN data-race in unix_release_sock / unix_stream_sendmsg write (marked) to 0xffff88867256ddbb of 1 bytes by task 7270 on cpu 28 unix_release_sock (net/unix/af_unix.c640) unix_release (net/unix/af_unix.c1050) sock_close (net/socket.c659 net/socket.c1421) __fput (fs/file_table.c422) __fput_sync (fs/file_table.c508) __se_sys_close (fs/open.c1559 fs/open.c1541) __x64_sys_close (fs/open.c1541) x64_sys_call (arch/x86/entry/syscall_64.c33) do_syscall_64 (arch/x86/entry/common.c?) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S130) read to 0xffff88867256ddbb of 1 bytes by task 989 on cpu 14 unix_stream_sendmsg (net/unix/af_unix.c2273) __sock_sendmsg (net/socket.c730 net/socket.c745) ____sys_sendmsg (net/socket.c2584) __sys_sendmmsg (net/socket.c2638 net/socket.c2724) __x64_sys_sendmmsg (net/socket.c2753 net/socket.c2750 net/socket.c2750) x64_sys_call (arch/x86/entry/syscall_64.c33) do_syscall_64 (arch/x86/entry/common.c?) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S130) value changed 0x01 -> 0x03The line numbers are related to commit dd5a440a31fa (Linux 6.9-rc7).Commit e1d09c2c2f57 (af_unix Fix data races around sk->sk_shutdown.)addressed a comparable issue in the past regarding sk->sk_shutdown.However, it overlooked resolving this particular data path.This patch only offending unix_stream_sendmsg() function, since theother reads seem to be protected by unix_state_lock() as discussed in

### Vulnerability Description Key Phrases
- **rootcause:** **data-race condition**
- **impact:** KCSAN splat
- **product:** Linux kernel
- **component:** af_unix

## CVE Reference Links Content Summary
### CVE-2024-38596

Based on the provided content, the vulnerability described is a **data race** in the Linux kernel's AF_UNIX socket implementation.

**Root Cause:**
- The `unix_release_sock()` function uses `WRITE_ONCE` to atomically set the `sk->sk_shutdown` flag.
- The `unix_stream_sendmsg()` function reads the `sk->sk_shutdown` flag without atomic access.

**Weaknesses/Vulnerabilities:**
- **Data Race:** Concurrent access to the `sk->sk_shutdown` flag by `unix_release_sock()` (write) and `unix_stream_sendmsg()` (read) without proper synchronization.

**Impact of Exploitation:**
- **Kernel Crash:** The data race leads to a KCSAN splat, which indicates a potential kernel crash. This can result in a denial-of-service condition.
- **Unpredictable Behavior:** Data races can lead to unpredictable behavior and potential memory corruption.

**Attack Vectors:**
- The vulnerability is triggered by concurrent operations on AF_UNIX sockets.
- A process closing a socket while another process is sending a message on the same socket.

**Required Attacker Capabilities/Position:**
- The attacker needs to have the ability to create and close AF_UNIX sockets, as well as send messages on them, which is generally available to local users.

**Technical Details:**
- The `sk->sk_shutdown` flag indicates whether a socket has been shut down.
- The `WRITE_ONCE` macro ensures that the write operation is atomic.
- The fix involves using `READ_ONCE` in `unix_stream_sendmsg()` to ensure atomic read of the `sk->sk_shutdown` flag.

**Additional Notes:**
- This issue was previously addressed in commit e1d09c2c2f57 ("af_unix: Fix data races around sk->sk_shutdown."), but that fix overlooked this specific path.
- The vulnerability affects multiple kernel versions.
- The provided patches use `READ_ONCE` to fix the data race.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | alternate_terms | 0.800 |
| 2 | 911 | Improper Update of Reference Count | Base | Allowed | sparse | 0.765 |
| 3 | 476 | NULL Pointer Dereference | Base | Allowed | sparse | 0.764 |
| 4 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | sparse | 0.750 |
| 5 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.741 |
| 6 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.730 |
| 7 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.712 |
| 8 | 774 | Allocation of File Descriptors or Handles Without Limits or Throttling | Variant | Allowed | sparse | 0.712 |
| 9 | 366 | Race Condition within a Thread | Base | Allowed | dense | 0.597 |
| 10 | 908 | Use of Uninitialized Resource | Base | Allowed | graph | 0.003 |

