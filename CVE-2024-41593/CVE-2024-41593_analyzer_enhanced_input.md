## Vulnerability Description
DrayTek Vigor310 devices through 4.3.2.6 allow a remote attacker to execute arbitrary code via the function ft_payload_dns(), because a byte sign-extension operation occurs for the length argument of a _memcpy call, leading to a heap-based Buffer Overflow.

### Vulnerability Description Key Phrases
- **rootcause:** **byte sign-extension operation for length argument of _memcpy call**
- **weakness:** **heap-based buffer overflow**
- **impact:** execute arbitrary code
- **attacker:** remote attacker
- **product:** DrayTek Vigor310 devices
- **version:** through 4.3.2.6
- **component:** ft_payload_dns() function

## CVE Reference Links Content Summary
Based on the provided document, here's a breakdown of the vulnerability information related to CVE-2024-41593:

**Root Cause of Vulnerability:**

*   The vulnerability lies within the `ft_payloads_dns()` function in the Web UI. This function processes the value of the `dnsserver` POST variable.
*   A signed `char` variable, `var_len`, is used to store the length of a domain name fragment. When a domain name fragment's length exceeds 127 (0x7f), it's interpreted as a negative value due to sign extension.
*   This negative value is then passed to a `_memcpy()` call, leading to a very large out-of-bounds write that corrupts memory.

**Weaknesses/Vulnerabilities Present:**

*   **Heap-based buffer overflow:** The `_memcpy()` operation writes beyond the allocated buffer on the heap due to the sign extension issue.
*   **Lack of bounds checking:** The code fails to properly validate the length of domain name fragments before using them in the `_memcpy()` function.
*   **Signed integer overflow:** The use of a signed `char` to hold length values that can exceed its maximum positive value.

**Impact of Exploitation:**

*   **Denial of Service (DoS):** The large out-of-bounds write corrupts a significant portion of the `.text` section of the `sohod64.bin` kernel image, which contains the code for memory integrity checks.
*   This corruption prevents the device from performing automatic reboots upon memory error detection.
*   The device requires a physical restart to recover.

**Attack Vectors:**

*   **Web UI:** The vulnerability is triggered through the web interface by sending a POST request with a crafted `dnsserver` variable that contains domain name fragments with lengths greater than 127 bytes.

**Required Attacker Capabilities/Position:**

*   The attacker needs to be able to send HTTP POST requests to the DrayTek router's web interface. This could be either from the LAN or, in cases where the web interface is exposed to the internet, from the WAN.

**Additional Details (not present in the original CVE description):**
* The vulnerability is a result of improper handling of signed `char` variables which are used to store length parameters. Due to how signed numbers are handled in C/C++, large positive values get interpreted as negative, resulting in a massive out of bounds write during a `_memcpy()` call.
* The vulnerability is located deep within the `ft_payload_dns()` function which is called during POST processing of the `dnsserver` parameter on certain CGI pages.
*  The memory corruption caused by this vulnerability prevents the device from performing automatic reboots, and requires a manual restart.

This document provides much more detail than a standard CVE description, outlining the vulnerable function, the specific coding error (sign extension), the memory corruption, and the impact of exploitation.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | alternate_terms | 0.800 |
| 2 | 190 | Integer Overflow or Wraparound | Base | Allowed | alternate_terms | 0.800 |
| 3 | 193 | Off-by-one Error | Base | Allowed | sparse | 0.325 |
| 4 | 681 | Incorrect Conversion between Numeric Types | Base | Allowed | sparse | 0.311 |
| 5 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.292 |
| 6 | 122 | Heap-based Buffer Overflow | Variant | Allowed | sparse | 0.292 |
| 7 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.289 |
| 8 | 126 | Buffer Over-read | Variant | Allowed | sparse | 0.284 |
| 9 | 121 | Stack-based Buffer Overflow | Variant | Allowed | dense | 0.612 |
| 10 | 128 | Wrap-around Error | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer

CWE-190: Integer Overflow or Wraparound

CWE-193: Off-by-one Error

CWE-681: Incorrect Conversion between Numeric Types

CWE-125: Out-of-bounds Read

CWE-122: Heap-based Buffer Overflow

CWE-1284: Improper Validation of Specified Quantity in Input

CWE-126: Buffer Over-read

CWE-121: Stack-based Buffer Overflow

CWE-128: Wrap-around Error