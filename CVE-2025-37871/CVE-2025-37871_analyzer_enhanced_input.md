## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved nfsd decrease sc_count directly if fail to queue dl_recall A deadlock warning occurred when invoking nfs4_put_stid following a failed dl_recall queue operation T1 T2 nfs4_laundromat nfs4_get_client_reaplist nfs4_anylock_blockers __break_lease spin_lock // ctx->flc_lock spin_lock // clp->cl_lock nfs4_lockowner_has_blockers locks_owner_has_blockers spin_lock // flctx->flc_lock nfsd_break_deleg_cb nfsd_break_one_deleg nfs4_put_stid refcount_dec_and_lock spin_lock // clp->cl_lock When a file is opened, an nfs4_delegation is allocated with sc_count initialized to 1, and the file_lease holds a reference to the delegation. The file_lease is then associated with the file through kernel_setlease. The disassociation is performed in nfsd4_delegreturn via the following call chain nfsd4_delegreturn --> destroy_delegation --> destroy_unhashed_deleg --> nfs4_unlock_deleg_lease --> kernel_setlease --> generic_delete_lease The corresponding sc_count reference will be released after this disassociation. Since nfsd_break_one_deleg executes while holding the flc_lock, the disassociation process becomes blocked when attempting to acquire flc_lock in generic_delete_lease. This means 1) sc_count in nfsd_break_one_deleg will not be decremented to 0 2) The nfs4_put_stid called by nfsd_break_one_deleg will not attempt to acquire cl_lock 3) Consequently, no deadlock condition is created. Given that sc_count in nfsd_break_one_deleg remains non-zero, we can safely perform refcount_dec on sc_count directly. This approach effectively avoids triggering deadlock warnings.

### Vulnerability Description Key Phrases
- **product:** Linux kernel
- **component:** nfsd

## CVE Reference Links Content Summary
UNRELATED

All provided content describes Anubis, a system designed to mitigate website scraping by AI companies. It does not relate to any vulnerability described by a CVE. The content details a defense mechanism, not a weakness.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.244 |
| 2 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.242 |
| 3 | 833 | Deadlock | Base | Allowed | sparse | 0.231 |
| 4 | 911 | Improper Update of Reference Count | Base | Allowed | sparse | 0.230 |
| 5 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.229 |
| 6 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.226 |
| 7 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.225 |
| 8 | 476 | NULL Pointer Dereference | Base | Allowed | sparse | 0.225 |
| 9 | 775 | Missing Release of File Descriptor or Handle after Effective Lifetime | Variant | Allowed | dense | 0.441 |
| 10 | 364 | Signal Handler Race Condition | Base | Allowed | graph | 0.002 |



# Complete CWE Specifications

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-667: Improper Locking

CWE-833: Deadlock

CWE-911: Improper Update of Reference Count

CWE-401: Missing Release of Memory after Effective Lifetime

CWE-770: Allocation of Resources Without Limits or Throttling

CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition

CWE-476: NULL Pointer Dereference

CWE-775: Missing Release of File Descriptor or Handle after Effective Lifetime

CWE-364: Signal Handler Race Condition