## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved eth bnxt always recalculate features after XDP clearing, fix null-deref Recalculate features when XDP is detached. Before # ip li set dev eth0 xdp obj xdp_dummy.bpf.o sec xdp # ip li set dev eth0 xdp off # ethtool -k eth0 | grep gro rx-gro-hw off [requested on] After # ip li set dev eth0 xdp obj xdp_dummy.bpf.o sec xdp # ip li set dev eth0 xdp off # ethtool -k eth0 | grep gro rx-gro-hw on The fact that HW-GRO doesnt get re-enabled automatically is just a minor annoyance. The real issue is that the features will randomly come back during another reconfiguration which just happens to invoke netdev_update_features(). The driver doesnt handle reconfiguring two things at a time very robustly. Starting with commit 98ba1d931f61 (bnxt_en Fix RSS logic in __bnxt_reserve_rings()) we only reconfigure the RSS hash table if the effective number of Rx rings has changed. If HW-GRO is enabled effective number of rings is 2x what user sees. So if we are in the bad state, with HW-GRO re-enablement pending after XDP off, and we lower the rings by / 2 - the HW-GRO rings doing 2x and the ethtool -L doing / 2 may cancel each other out, and the if (old_rx_rings != bp->hw_resc.resv_rx_rings && condition in __bnxt_reserve_rings() will be false. The RSS map wont get updated, and well crash with

### Vulnerability Description Key Phrases
- **weakness:** **null dereference**
- **impact:** crash
- **product:** Linux kernel
- **component:** eth bnxt

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 476 | NULL Pointer Dereference | Base | Allowed | alternate_terms | 0.800 |
| 2 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | sparse | 0.794 |
| 3 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.782 |
| 4 | 193 | Off-by-one Error | Base | Allowed | sparse | 0.698 |
| 5 | 400 | Uncontrolled Resource Consumption | Class | Discouraged | sparse | 0.692 |
| 6 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.691 |
| 7 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | sparse | 0.690 |
| 8 | 617 | Reachable Assertion | Base | Allowed | sparse | 0.680 |
| 9 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | Allowed | dense | 0.481 |
| 10 | 1325 | Improperly Controlled Sequential Memory Allocation | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-476: NULL Pointer Dereference

CWE-789: Memory Allocation with Excessive Size Value

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-193: Off-by-one Error

CWE-400: Uncontrolled Resource Consumption

CWE-1284: Improper Validation of Specified Quantity in Input

CWE-909: Missing Initialization of Resource

CWE-617: Reachable Assertion

CWE-1285: Improper Validation of Specified Index, Position, or Offset in Input

CWE-1325: Improperly Controlled Sequential Memory Allocation