{
  "method": "sparse_base",
  "query": "In the Linux kernel, the following vulnerability has been resolved dma-debug fix a possible deadlock on radix_lock radix_lock() shouldnt be held while holding dma_hash_entry[idx].lock otherwise, theres a possible deadlock scenario when dma debug API is called holding rq_lock() CPU0 CPU1 CPU2 dma_free_attrs() check_unmap() add_dma_entry() __schedule() //out (A) rq_lock() get_hash_bucket() (A) dma_entry_hash check_sync() (A) radix_lock() (W) dma_entry_hash dma_entry_free() (W) radix_lock() // CPU2s one (W) rq_lock() CPU1 situation can happen when it extending radix tree and it tries to wake up kswapd via wake_all_kswapd(). CPU2 situation can happen while perf_event_task_sched_out() (i.e. dma sync operation is called while deleting perf_event using etm and etr tmc which are Arm Coresight hwtracing driver backends). To remove this possible situation, call dma_entry_free() after put_hash_bucket() in check_unmap().",
  "keyphrases": {
    "base_query": "In the Linux kernel, the following vulnerability has been resolved dma-debug fix a possible deadlock on radix_lock radix_lock() shouldnt be held while holding dma_hash_entry[idx].lock otherwise, theres a possible deadlock scenario when dma debug API is called holding rq_lock() CPU0 CPU1 CPU2 dma_free_attrs() check_unmap() add_dma_entry() __schedule() //out (A) rq_lock() get_hash_bucket() (A) dma_entry_hash check_sync() (A) radix_lock() (W) dma_entry_hash dma_entry_free() (W) radix_lock() // CPU2s one (W) rq_lock() CPU1 situation can happen when it extending radix tree and it tries to wake up kswapd via wake_all_kswapd(). CPU2 situation can happen while perf_event_task_sched_out() (i.e. dma sync operation is called while deleting perf_event using etm and etr tmc which are Arm Coresight hwtracing driver backends). To remove this possible situation, call dma_entry_free() after put_hash_bucket() in check_unmap()."
  },
  "timestamp": "2025-07-12T04:53:40.440453",
  "results_count": 10,
  "results_summary": [
    {
      "doc_id": "833",
      "name": "Deadlock",
      "score": 154.30623491556153
    },
    {
      "doc_id": "667",
      "name": "Improper Locking",
      "score": 151.68437404831923
    },
    {
      "doc_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "score": 150.4426294683553
    },
    {
      "doc_id": "770",
      "name": "Allocation of Resources Without Limits or Throttling",
      "score": 143.90375657864976
    },
    {
      "doc_id": "367",
      "name": "Time-of-check Time-of-use (TOCTOU) Race Condition",
      "score": 139.31821258250298
    }
  ]
}