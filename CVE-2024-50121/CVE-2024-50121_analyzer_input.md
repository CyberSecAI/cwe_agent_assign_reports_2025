# Vulnerability Information: CVE-2024-50121

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved nfsd cancel nfsd_shrinker_work using sync mode in nfs4_state_shutdown_net In the normal case, when we excute `echo 0 > /proc/fs/nfsd/threads`, the function `nfs4_state_destroy_net` in `nfs4_state_shutdown_net` will release all resources related to the hashed `nfs4_client`. If the `nfsd_client_shrinker` is running concurrently, the `expire_client` function will first unhash this client and then destroy it. This can lead to the following warning. Additionally, numerous use-after-free errors may occur as well. nfsd_client_shrinker echo 0 > /proc/fs/nfsd/threads expire_client nfsd_shutdown_net unhash_client ... nfs4_state_shutdown_net /* wont wait shrinker exit */ /* cancel_work(&nn->nfsd_shrinker_work) * nfsd_file for this /* wont destroy unhashed client1 */ * client1 still alive nfs4_state_destroy_net */ nfsd_file_cache_shutdown /* trigger warning */ kmem_cache_destroy(nfsd_file_slab) kmem_cache_destroy(nfsd_file_mark_slab) /* release nfsd_file and mark */ __destroy_client ==================================================================== BUG nfsd_file (Not tainted) Objects remaining in nfsd_file on __kmem_cache_shutdown() -------------------------------------------------------------------- CPU 4 UID 0 PID 764 Comm sh Not tainted 6.12.0-rc3+ #1 dump_stack_lvl+0x53/0x70 slab_err+0xb0/0xf0 __kmem_cache_shutdown+0x15c/0x310 kmem_cache_destroy+0x66/0x160 nfsd_file_cache_shutdown+0xac/0x210 [nfsd] nfsd_destroy_serv+0x251/0x2a0 [nfsd] nfsd_svc+0x125/0x1e0 [nfsd] write_threads+0x16a/0x2a0 [nfsd] nfsctl_transaction_write+0x74/0xa0 [nfsd] vfs_write+0x1a5/0x6d0 ksys_write+0xc1/0x160 do_syscall_64+0x5f/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e ==================================================================== BUG nfsd_file_mark (Tainted G B W ) Objects remaining nfsd_file_mark on __kmem_cache_shutdown() -------------------------------------------------------------------- dump_stack_lvl+0x53/0x70 slab_err+0xb0/0xf0 __kmem_cache_shutdown+0x15c/0x310 kmem_cache_destroy+0x66/0x160 nfsd_file_cache_shutdown+0xc8/0x210 [nfsd] nfsd_destroy_serv+0x251/0x2a0 [nfsd] nfsd_svc+0x125/0x1e0 [nfsd] write_threads+0x16a/0x2a0 [nfsd] nfsctl_transaction_write+0x74/0xa0 [nfsd] vfs_write+0x1a5/0x6d0 ksys_write+0xc1/0x160 do_syscall_64+0x5f/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e To resolve this issue, cancel `nfsd_shrinker_work` using synchronous mode in nfs4_state_shutdown_net.

### Vulnerability Description Key Phrases
- **rootcause:** **The `nfsd_client_shrinker` can concurrently unhash and destroy an `nfs4_client` while `nfs4_state_shutdown_net` is releasing resources related to the hashed `nfs4_client`. This race condition leads to a use-after-free vulnerability and warnings due to objects remaining in `nfsd_file` and `nfsd_file_mark` on shutdown.**
- **weakness:** **Race condition between `nfsd_client_shrinker` and `nfs4_state_shutdown_net` during resource cleanup.**
- **impact:** Use-after-free errors and warnings due to inconsistent state of the `nfs4_client` and related resources during shutdown. The system can become unstable and crash.
- **vector:** The vulnerability can be triggered by writing to `/proc/fs/nfsd/threads` to initiate the shutdown process, while the `nfsd_client_shrinker` is also active.
- **attacker:** Local user with write access to `/proc/fs/nfsd/threads`
- **product:** Linux Kernel
- **version:** 6.12.0-rc3+
- **component:** nfsd

## CVE Reference Links Content Summary
Based on the provided content, here's the analysis of the vulnerability:

**Root cause of vulnerability:**

The vulnerability arises from a race condition between the `nfsd_client_shrinker` and the `nfs4_state_shutdown_net` functions during the shutdown of the NFS server. Specifically, when the command `echo 0 > /proc/fs/nfsd/threads` is executed, it triggers the `nfs4_state_destroy_net` function within `nfs4_state_shutdown_net` to release resources associated with hashed `nfs4_client` structures. Simultaneously, the `nfsd_client_shrinker` might be running, and its `expire_client` function could unhash and attempt to destroy the same client.

**Weaknesses/vulnerabilities present:**

*   **Race condition:**  A race exists between the `nfsd_client_shrinker` and `nfs4_state_shutdown_net` during resource cleanup.
*   **Use-after-free:** If the shrinker unhashes a client and the shutdown process doesn't wait for the shrinker to complete, a use-after-free can occur when the shutdown process attempts to destroy resources associated with the client that the shrinker has already started to free.
*   **Improper synchronization:** The original code used `cancel_work` which does not guarantee that the work item is completed before proceeding. This led to the shutdown process continuing before the shrinker had finished, causing the race condition and use-after-free scenarios.

**Impact of exploitation:**

*   **Kernel Warning/Bug:** The primary impact is a kernel warning or BUG, which can indicate unstable system behavior.
*   **Use-after-free errors:** The race condition can result in use-after-free errors, potentially leading to system crashes or other unpredictable behavior.

**Attack vectors:**

*   **Triggering NFS server shutdown:** The vulnerability is triggered by the shutdown of the NFS server, which can be done using the command `echo 0 > /proc/fs/nfsd/threads`.

**Required attacker capabilities/position:**

*   **Root or administrative privileges:** The attacker needs the ability to write to `/proc/fs/nfsd/threads` which requires root or administrative privileges on the system.
*   **Access to the NFS server:** The attacker must have access to a machine that's running an NFS server.

**Technical details:**

The core of the issue lies in the non-synchronous nature of `cancel_work()`. When `cancel_work` is used, it only attempts to remove the work item from the queue. It does not wait for the work item (in this case, `nfsd_shrinker_work`) to finish processing before continuing. This allows `nfs4_state_shutdown_net` to proceed with the shutdown process and the destruction of resources related to the nfs4 client, potentially before the shrinker has finished with the same resource leading to a race condition and a use-after-free. The fix introduces `cancel_work_sync()`, which waits for the work item to complete before continuing, resolving the race condition and use-after-free issue.

The provided content also includes detailed stack traces from the kernel bugs, illustrating the specific functions that are being called when the issue occurs.

The fix, as shown in the diff, replaces `cancel_work` with `cancel_work_sync` in `nfs4_state_shutdown_net`. This ensures that the `nfsd_shrinker_work` is fully completed before the shutdown process continues, thus resolving the identified race condition and preventing use-after-free errors.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | alternate_terms | 0.800 |
| 2 | 416 | Use After Free | Variant | Allowed | alternate_terms | 0.800 |
| 3 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.716 |
| 4 | 833 | Deadlock | Base | Allowed | sparse | 0.684 |
| 5 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.674 |
| 6 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.668 |
| 7 | 366 | Race Condition within a Thread | Base | Allowed | sparse | 0.654 |
| 8 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | Allowed | sparse | 0.646 |
| 9 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | dense | 0.552 |
| 10 | 364 | Signal Handler Race Condition | Base | Allowed | graph | 0.003 |

