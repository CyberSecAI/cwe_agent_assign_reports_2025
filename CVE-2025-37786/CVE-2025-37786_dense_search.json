{
  "retriever": "dense",
  "query": "In the Linux kernel, the following vulnerability has been resolved net dsa free routing table on probe failure If complete = true in dsa_tree_setup(), it means that we are the last switch of the tree which is successfully probing, and we should be setting up all switches from our probe path. After complete becomes true, dsa_tree_setup_cpu_ports() or any subsequent function may fail. If that happens, the entire tree setup is in limbo the first N-1 switches have successfully finished probing (doing nothing but having allocated persistent memory in the trees dst->ports, and maybe dst->rtable), and switch N failed to probe, ending the tree setup process before anything is tangible from the users PoV. If switch N fails to probe, its memory (ports) will be freed and removed from dst->ports. However, the dst->rtable elements pointing to its ports, as created by dsa_link_touch(), will remain there, and will lead to use-after-free if dereferenced. If dsa_tree_setup_switches() returns -EPROBE_DEFER, which is entirely possible because that is where ds->ops->setup() is, we get a kasan report like this ================================================================== BUG KASAN slab-use-after-free in mv88e6xxx_setup_upstream_port+0x240/0x568 Read of size 8 at addr ffff000004f56020 by task kworker/u83/42 Call trace __asan_report_load8_noabort+0x20/0x30 mv88e6xxx_setup_upstream_port+0x240/0x568 mv88e6xxx_setup+0xebc/0x1eb0 dsa_register_switch+0x1af4/0x2ae0 mv88e6xxx_register_switch+0x1b8/0x2a8 mv88e6xxx_probe+0xc4c/0xf60 mdio_probe+0x78/0xb8 really_probe+0x2b8/0x5a8 __driver_probe_device+0x164/0x298 driver_probe_device+0x78/0x258 __device_attach_driver+0x274/0x350 Allocated by task 42 __kasan_kmalloc+0x84/0xa0 __kmalloc_cache_noprof+0x298/0x490 dsa_switch_touch_ports+0x174/0x3d8 dsa_register_switch+0x800/0x2ae0 mv88e6xxx_register_switch+0x1b8/0x2a8 mv88e6xxx_probe+0xc4c/0xf60 mdio_probe+0x78/0xb8 really_probe+0x2b8/0x5a8 __driver_probe_device+0x164/0x298 driver_probe_device+0x78/0x258 __device_attach_driver+0x274/0x350 Freed by task 42 __kasan_slab_free+0x48/0x68 kfree+0x138/0x418 dsa_register_switch+0x2694/0x2ae0 mv88e6xxx_register_switch+0x1b8/0x2a8 mv88e6xxx_probe+0xc4c/0xf60 mdio_probe+0x78/0xb8 really_probe+0x2b8/0x5a8 __driver_probe_device+0x164/0x298 driver_probe_device+0x78/0x258 __device_attach_driver+0x274/0x350 The simplest way to fix the bug is to delete the routing table in its entirety. dsa_tree_setup_routing_table() has no problem in regenerating it even if we deleted links between ports other than those of switch N, because dsa_link_touch() first checks whether the port pair already exists in dst->rtable, allocating if not. The deletion of the routing table in its entirety already exists in dsa_tree_teardown(), so refactor that into a function that can also be called from the tree setup error path. In my analysis of the commit to blame, it is the one which added dsa_link elements to dst->rtable. Prior to that, each switch had its own ds->rtable which is freed when the switch fails to probe. But the tree is potentially persistent memory.",
  "keyphrases": {
    "rootcause": [
      "improper memory management"
    ],
    "weakness": [
      "use-after-free"
    ]
  },
  "timestamp": "2025-07-12 13:22:06",
  "cve_id": "CVE-2025-37786",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "401",
      "name": "Missing Release of Memory after Effective Lifetime",
      "type": "Variant",
      "score": 0.45035122480836465
    },
    {
      "cwe_id": "909",
      "name": "Missing Initialization of Resource",
      "type": "Class",
      "score": 0.4370998640824385
    },
    {
      "cwe_id": "606",
      "name": "Unchecked Input for Loop Condition",
      "type": "Base",
      "score": 0.4236137230662721
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 0.4226501744007183
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 0.4197634911723114
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "type": "Class",
      "score": 0.4193456322353594
    },
    {
      "cwe_id": "911",
      "name": "Improper Update of Reference Count",
      "type": "Base",
      "score": 0.4166444480572796
    },
    {
      "cwe_id": "835",
      "name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
      "type": "Base",
      "score": 0.4146342571382503
    },
    {
      "cwe_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "type": "Base",
      "score": 0.41317702326045125
    },
    {
      "cwe_id": "121",
      "name": "Stack-based Buffer Overflow",
      "type": "Variant",
      "score": 0.4111803730400562
    },
    {
      "cwe_id": "119",
      "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
      "type": "Class",
      "score": 0.40756687207051867
    },
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "type": "Base",
      "score": 0.3913480916876627
    },
    {
      "cwe_id": "771",
      "name": "Missing Reference to Active Allocated Resource",
      "type": "Base",
      "score": 0.3909464378106102
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "type": "Variant",
      "score": 0.3882240035370221
    },
    {
      "cwe_id": "1245",
      "name": "Improper Finite State Machines (FSMs) in Hardware Logic",
      "type": "Base",
      "score": 0.3875436740436191
    },
    {
      "cwe_id": "1296",
      "name": "Incorrect Chaining or Granularity of Debug Components",
      "type": "Base",
      "score": 0.38702434911618905
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "type": "Base",
      "score": 0.3869588716319612
    },
    {
      "cwe_id": "775",
      "name": "Missing Release of File Descriptor or Handle after Effective Lifetime",
      "type": "Variant",
      "score": 0.3853451314637005
    },
    {
      "cwe_id": "191",
      "name": "Integer Underflow (Wrap or Wraparound)",
      "type": "Base",
      "score": 0.38505586310189494
    },
    {
      "cwe_id": "364",
      "name": "Signal Handler Race Condition",
      "type": "Base",
      "score": 0.38455936079992253
    }
  ]
}