## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolvedwifi mac80211 Fix deadlock in ieee80211_sta_ps_deliver_wakeup()The ieee80211_sta_ps_deliver_wakeup() function takes sta->ps_lock tosynchronizes with ieee80211_tx_h_unicast_ps_buf() which is called fromsoftirq context. However using only spin_lock() to get sta->ps_lock inieee80211_sta_ps_deliver_wakeup() does not prevent softirq to executeon this same CPU, to run ieee80211_tx_h_unicast_ps_buf() and try totake this same lock ending in deadlock. Below is an example of rcu stallthat arises in such situation. rcu INFO rcu_sched self-detected stall on CPU rcu 2-.... (42413413 ticks this GP) idle=b154/1/0x4000000000000000 softirq=1763/1765 fqs=21206996 rcu (t=42586894 jiffies g=2057 q=362405 ncpus=4) CPU 2 PID 719 Comm wpa_supplicant Tainted G W 6.4.0-02158-g1b062f552873 #742 Hardware name RPT (r1) (DT) pstate 00000005 (nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc queued_spin_lock_slowpath+0x58/0x2d0 lr invoke_tx_handlers_early+0x5b4/0x5c0 sp ffff00001ef64660 x29 ffff00001ef64660 x28 ffff000009bc1070 x27 ffff000009bc0ad8 x26 ffff000009bc0900 x25 ffff00001ef647a8 x24 0000000000000000 x23 ffff000009bc0900 x22 ffff000009bc0900 x21 ffff00000ac0e000 x20 ffff00000a279e00 x19 ffff00001ef646e8 x18 0000000000000000 x17 ffff800016468000 x16 ffff00001ef608c0 x15 0010533c93f64f80 x14 0010395c9faa3946 x13 0000000000000000 x12 00000000fa83b2da x11 000000012edeceea x10 ffff0000010fbe00 x9 0000000000895440 x8 000000000010533c x7 ffff00000ad8b740 x6 ffff00000c350880 x5 0000000000000007 x4 0000000000000001 x3 0000000000000000 x2 0000000000000000 x1 0000000000000001 x0 ffff00000ac0e0e8 Call trace queued_spin_lock_slowpath+0x58/0x2d0 ieee80211_tx+0x80/0x12c ieee80211_tx_pending+0x110/0x278 tasklet_action_common.constprop.0+0x10c/0x144 tasklet_action+0x20/0x28 _stext+0x11c/0x284 ____do_softirq+0xc/0x14 call_on_irq_stack+0x24/0x34 do_softirq_own_stack+0x18/0x20 do_softirq+0x74/0x7c __local_bh_enable_ip+0xa0/0xa4 _ieee80211_wake_txqs+0x3b0/0x4b8 __ieee80211_wake_queue+0x12c/0x168 ieee80211_add_pending_skbs+0xec/0x138 ieee80211_sta_ps_deliver_wakeup+0x2a4/0x480 ieee80211_mps_sta_status_update.part.0+0xd8/0x11c ieee80211_mps_sta_status_update+0x18/0x24 sta_apply_parameters+0x3bc/0x4c0 ieee80211_change_station+0x1b8/0x2dc nl80211_set_station+0x444/0x49c genl_family_rcv_msg_doit.isra.0+0xa4/0xfc genl_rcv_msg+0x1b0/0x244 netlink_rcv_skb+0x38/0x10c genl_rcv+0x34/0x48 netlink_unicast+0x254/0x2bc netlink_sendmsg+0x190/0x3b4 ____sys_sendmsg+0x1e8/0x218 ___sys_sendmsg+0x68/0x8c __sys_sendmsg+0x44/0x84 __arm64_sys_sendmsg+0x20/0x28 do_el0_svc+0x6c/0xe8 el0_svc+0x14/0x48 el0t_64_sync_handler+0xb0/0xb4 el0t_64_sync+0x14c/0x150Using spin_lock_bh()/spin_unlock_bh() instead prevents softirq to raiseon the same CPU that is holding the lock.

### Vulnerability Description Key Phrases
- **rootcause:** **The function ieee80211_sta_ps_deliver_wakeup() uses spin_lock() to synchronize with ieee80211_tx_h_unicast_ps_buf(), but does not prevent softirq from executing on the same CPU, leading to a deadlock.**
- **weakness:** **The usage of spin_lock() in ieee80211_sta_ps_deliver_wakeup() does not prevent softirqs from interrupting the critical section on the same CPU, which leads to a deadlock when the softirq context attempts to acquire the same lock.**
- **impact:** Deadlock, causing the system to become unresponsive.
- **vector:** Local
- **attacker:** Local attacker, through a crafted netlink message.
- **product:** Linux Kernel
- **version:** 6.4.0-02158-g1b062f552873
- **component:** mac80211

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of the vulnerability:

**Root cause of vulnerability:**
- The `ieee80211_sta_ps_deliver_wakeup()` function, responsible for delivering frames to a station in power-save mode, uses `spin_lock(&sta->ps_lock)` to synchronize with `ieee80211_tx_h_unicast_ps_buf()`. The latter is called from a softirq context.
- Using a plain `spin_lock()` does not prevent a softirq from executing on the same CPU that holds the lock, leading to a deadlock when `ieee80211_tx_h_unicast_ps_buf()` tries to acquire the same lock.

**Weaknesses/vulnerabilities present:**
- **Deadlock:** A classic deadlock scenario occurs when two execution contexts (in this case, the main function and a softirq) try to acquire the same spinlock, leading to a complete system freeze.
- **Incorrect Locking:** The initial use of `spin_lock()` instead of `spin_lock_bh()` in `ieee80211_sta_ps_deliver_wakeup()` creates the potential for a deadlock, because it doesn't disable bottom halves (softirqs) from running on the same CPU.

**Impact of exploitation:**
- **System Hang/Stall:** The deadlock prevents the system from making progress, causing an RCU stall and effectively freezing the system, making it unresponsive. The provided call trace shows a stall detected by the RCU mechanism.

**Attack vectors:**
- This is not directly an "attack" in the sense of external exploitation. It is a concurrency issue that is triggered by normal WiFi operations involving power-saving features.
- Specifically, the scenario requires an interaction where `ieee80211_sta_ps_deliver_wakeup()` is called while a softirq attempts to transmit data to the same station using `ieee80211_tx_h_unicast_ps_buf()`.

**Required attacker capabilities/position:**
- No specific attacker capability is required. This deadlock can occur in normal use when a station is using power saving and the access point needs to deliver buffered frames.
- An attacker could potentially trigger the deadlock more easily by manipulating the station's power-saving behavior via crafted wireless packets, although this is not explicitly discussed in the provided text.

**Fix:**
- The fix is to replace `spin_lock(&sta->ps_lock)` and `spin_unlock(&sta->ps_lock)` with `spin_lock_bh(&sta->ps_lock)` and `spin_unlock_bh(&sta->ps_lock)` respectively. This ensures that softirqs are disabled while the lock is held, preventing the deadlock.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 833 | Deadlock | Base | Allowed | sparse | 0.577 |
| 2 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.576 |
| 3 | 400 | Uncontrolled Resource Consumption | Class | Discouraged | sparse | 0.524 |
| 4 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | sparse | 0.522 |
| 5 | 328 | Use of Weak Hash | Base | Allowed | sparse | 0.519 |
| 6 | 212 | Improper Removal of Sensitive Information Before Storage or Transfer | Base | Allowed | sparse | 0.506 |
| 7 | 863 | Incorrect Authorization | Class | Allowed-with-Review | sparse | 0.503 |
| 8 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | sparse | 0.502 |
| 9 | 413 | Improper Resource Locking | Base | Allowed | dense | 0.525 |
| 10 | 129 | Improper Validation of Array Index | Variant | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-833: Deadlock

CWE-667: Improper Locking

CWE-400: Uncontrolled Resource Consumption

CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer

CWE-328: Use of Weak Hash

CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer

CWE-863: Incorrect Authorization

CWE-674: Uncontrolled Recursion

CWE-413: Improper Resource Locking

CWE-129: Improper Validation of Array Index