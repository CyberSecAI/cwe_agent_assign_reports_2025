# Vulnerability Information: CVE-2024-45003

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved vfs Dont evict inode under the inode lru traversing context The inode reclaiming process(See function prune_icache_sb) collects all reclaimable inodes and mark them with I_FREEING flag at first, at that time, other processes will be stuck if they try getting these inodes (See function find_inode_fast), then the reclaiming process destroy the inodes by function dispose_list(). Some filesystems(eg. ext4 with ea_inode feature, ubifs with xattr) may do **inode lookup in the inode evicting callback function**, if the inode lookup is operated under the inode lru traversing context, deadlock problems may happen. Case 1 In function ext4_evict_inode(), the ea inode lookup could happen if ea_inode feature is enabled, the lookup process will be stuck under the evicting context like this 1. File A has inode i_reg and an ea inode i_ea 2. getfattr(A, xattr_buf) // i_ea is added into lru // lru->i_ea 3. Then, following three processes running like this PA PB echo 2 > /proc/sys/vm/drop_caches shrink_slab prune_dcache_sb // i_reg is added into lru, lru->i_ea->i_reg prune_icache_sb list_lru_walk_one inode_lru_isolate i_ea->i_state |= I_FREEING // set inode state inode_lru_isolate __iget(i_reg) spin_unlock(&i_reg->i_lock) spin_unlock(lru_lock) rm file A i_

### Vulnerability Description Key Phrases
- **rootcause:** **inode lookup in the inode evicting callback function**
- **impact:** deadlock
- **product:** Linux kernel
- **component:** vfs

## CVE Reference Links Content Summary
The provided content contains details about a fix for a deadlock vulnerability in the Linux kernel, specifically addressing issues related to inode eviction during LRU traversal. This information is relevant to the CVE, as it describes the root cause, impact, and fix for the vulnerability.

**Root Cause of Vulnerability:**

The root cause lies in the interaction between the inode reclaiming process and certain filesystems (ext4 with ea_inode, ubifs with xattr) that perform inode lookups within their inode eviction callbacks. The inode reclaiming process marks reclaimable inodes with the `I_FREEING` flag. When a filesystem attempts an inode lookup under the inode lru traversing context, and the target inode is marked with `I_FREEING`, it leads to a deadlock.

Two deadlock scenarios were identified:

*   **Case 1 (Ext4):**  A process (PA) attempts to drop caches which triggers inode reclaiming, while another process (PB) tries to remove a file. The sequence of operations can lead to a situation where the inode reclaim process is waiting for an inode to become free, while the inode evict process is trying to lookup another inode which is marked I\_FREEING, causing a deadlock.
*   **Case 2 (UBIFS):** A similar issue arises in UBIFS where a file deletion process holds a mutex (wbuf->io\_mutex) and then performs an inode lookup, and it races with the inode reclaiming process, resulting in an ABBA deadlock.

**Weaknesses/Vulnerabilities Present:**

*   **Deadlock:** The core vulnerability is the potential for a deadlock during inode eviction, specifically when filesystems perform inode lookups within eviction callbacks while the inode is in the process of being reclaimed.
*   **Race Condition:** The described scenarios involve race conditions between the inode reclaiming process and other processes performing file operations.
*   **Improper Synchronization:** The original design failed to properly synchronize access to inodes during both eviction and reclaiming process, leading to the deadlock.

**Impact of Exploitation:**

*   **System Hang/Denial of Service:** The deadlock leads to a system hang, preventing further operations and resulting in a denial of service. The system will become unresponsive, requiring a reboot.

**Attack Vectors:**

*   **Triggering Inode Reclaiming:** Attackers can trigger the vulnerability by initiating operations that lead to inode reclaiming, for example, by dropping caches (`echo 2 > /proc/sys/vm/drop_caches`).
*   **File Operations:** Simultaneously performing file operations that trigger inode evictions (like `rm file A` and `rm file B`), while the inode reclaim process is active, can trigger the deadlock.
*   **Specific Filesystem Usage**: The vulnerability is triggered when filesystems like `ext4` (with ea\_inode feature enabled) or `ubifs` (with xattr) are used

**Required Attacker Capabilities/Position:**

*   **Local User:** The attacker needs to be a local user on the system with the ability to perform file operations and drop caches.
*   **Ability to Trigger Specific File Operations:** The attacker needs to be able to trigger specific sequences of file operations that lead to inode eviction and lookups under memory pressure.
*  **Targeted Filesystem:** The target file system must be one of the affected types, such as ext4 with the ea\_inode feature or ubifs with xattr.

**Fix:**

The fix introduces a new inode state flag, `I_LRU_ISOLATING`, to handle inode reclamation safely. Instead of using a regular inode reference, inodes are "pinned" using the new flag during the `inode_lru_isolate()` function. This prevents inode deletion from being triggered during page reclamation, thus avoiding the deadlock. The `evict()` function is also modified to wait for the `I_LRU_ISOLATING` flag to be cleared before proceeding with cleanup. The fix involves modifications to `fs/inode.c` and `include/linux/fs.h`.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 775 | Missing Release of File Descriptor or Handle after Effective Lifetime | Variant | Allowed | sparse | 0.941 |
| 2 | 917 | Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection') | Base | Allowed | sparse | 0.677 |
| 3 | 201 | Insertion of Sensitive Information Into Sent Data | Base | Allowed | sparse | 0.636 |
| 4 | 79 | Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') | Base | Allowed | sparse | 0.622 |
| 5 | 379 | Creation of Temporary File in Directory with Insecure Permissions | Base | Allowed | sparse | 0.619 |
| 6 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.610 |
| 7 | 61 | UNIX Symbolic Link (Symlink) Following | Compound | Allowed | sparse | 0.608 |
| 8 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.608 |
| 9 | 911 | Improper Update of Reference Count | Base | Allowed | dense | 0.432 |
| 10 | 772 | Missing Release of Resource after Effective Lifetime | Base | Allowed | graph | 0.002 |

