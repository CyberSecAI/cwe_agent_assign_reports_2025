{
  "retriever": "graph",
  "query": "In the Linux kernel, the following vulnerability has been resolved btrfs fix assertion failure when splitting ordered extent after transaction abort If while we are doing a direct IO write a transaction abort happens, we mark all existing ordered extents with the BTRFS_ORDERED_IOERR flag (done at btrfs_destroy_ordered_extents()), and then after that if we enter btrfs_split_ordered_extent() and the ordered extent has bytes left (meaning we have a bio that doesnt cover the whole ordered extent, see details at btrfs_extract_ordered_extent()), we will fail on the following assertion at btrfs_split_ordered_extent() ASSERT(!(flags & ~BTRFS_ORDERED_TYPE_FLAGS)) because the BTRFS_ORDERED_IOERR flag is set and the definition of BTRFS_ORDERED_TYPE_FLAGS is just the union of all flags that identify the type of write (regular, nocow, prealloc, compressed, direct IO, encoded). Fix this by returning an error from btrfs_extract_ordered_extent() if we find the BTRFS_ORDERED_IOERR flag in the ordered extent. The error will be the error that resulted in the transaction abort or -EIO if no transaction abort happened. This was recently reported by syzbot with the following trace FAULT_INJECTION forcing a failure. name failslab, interval 1, probability 0, space 0, times 1 CPU 0 UID 0 PID 5321 Comm syz.0.0 Not tainted 6.13.0-rc5-syzkaller #0 Hardware name QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014 Call Trace __dump_stack lib/dump_stack.c94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c120 fail_dump lib/fault-inject.c53 [inline] should_fail_ex+0x3b0/0x4e0 lib/fault-inject.c154 should_failslab+0xac/0x100 mm/failslab.c46 slab_pre_alloc_hook mm/slub.c4072 [inline] slab_alloc_node mm/slub.c4148 [inline] __do_kmalloc_node mm/slub.c4297 [inline] __kmalloc_noprof+0xdd/0x4c0 mm/slub.c4310 kmalloc_noprof include/linux/slab.h905 [inline] kzalloc_noprof include/linux/slab.h1037 [inline] btrfs_chunk_alloc_add_chunk_item+0x244/0x1100 fs/btrfs/volumes.c5742 reserve_chunk_space+0x1ca/0x2c0 fs/btrfs/block-group.c4292 check_system_chunk fs/btrfs/block-group.c4319 [inline] do_chunk_alloc fs/btrfs/block-group.c3891 [inline] btrfs_chunk_alloc+0x77b/0xf80 fs/btrfs/block-group.c4187 find_free_extent_update_loop fs/btrfs/extent-tree.c4166 [inline] find_free_extent+0x42d1/0x5810 fs/btrfs/extent-tree.c4579 btrfs_reserve_extent+0x422/0x810 fs/btrfs/extent-tree.c4672 btrfs_new_extent_direct fs/btrfs/direct-io.c186 [inline] btrfs_get_blocks_direct_write+0x706/0xfa0 fs/btrfs/direct-io.c321 btrfs_dio_iomap_begin+0xbb7/0x1180 fs/btrfs/direct-io.c525 iomap_iter+0x697/0xf60 fs/iomap/iter.c90 __iomap_dio_rw+0xeb9/0x25b0 fs/iomap/direct-io.c702 btrfs_dio_write fs/btrfs/direct-io.c775 [inline] btrfs_direct_write+0x610/0xa30 fs/btrfs/direct-io.c880 btrfs_do_write_iter+0x2a0/0x760 fs/btrfs/file.c1397 do_iter_readv_writev+0x600/0x880 vfs_writev+0x376/0xba0 fs/read_write.c1050 do_pwritev fs/read_write.c1146 [inline] __do_sys_pwritev2 fs/read_write.c1204 [inline] __se_sys_pwritev2+0x196/0x2b0 fs/read_write.c1195 do_syscall_x64 arch/x86/entry/common.c52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c83 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP 00330x7f1281f85d29 RSP 002b00007f12819fe038 EFLAGS 00000246 ORIG_RAX 0000000000000148 RAX ffffffffffffffda RBX 00007f1282176080 RCX 00007f1281f85d29 RDX 0000000000000001 RSI 0000000020000240 RDI 0000000000000005 RBP 00007f12819fe090 R08 0000000000000000 R09 0000000000000003 R10 0000000000007000 R11 0000000000000246 R12 0000000000000002 R13 0000000000000000 R14 00007f1282176080 R15 00007ffcb9e23328 BTRFS error (device loop0 state A) Transaction aborted (error -12) BTRFS error (device loop0 state A ---truncated--- Consider specifically these CWEs: CWE-1284 CWE-288 CWE-392 CWE-362 CWE-1285 CWE-909 CWE-667 CWE-833 CWE-617",
  "keyphrases": {
    "original_query": "In the Linux kernel, the following vulnerability has been resolved btrfs fix assertion failure when splitting ordered extent after transaction abort If while we are doing a direct IO write a transaction abort happens, we mark all existing ordered extents with the BTRFS_ORDERED_IOERR flag (done at btrfs_destroy_ordered_extents()), and then after that if we enter btrfs_split_ordered_extent() and the ordered extent has bytes left (meaning we have a bio that doesnt cover the whole ordered extent, see details at btrfs_extract_ordered_extent()), we will fail on the following assertion at btrfs_split_ordered_extent() ASSERT(!(flags & ~BTRFS_ORDERED_TYPE_FLAGS)) because the BTRFS_ORDERED_IOERR flag is set and the definition of BTRFS_ORDERED_TYPE_FLAGS is just the union of all flags that identify the type of write (regular, nocow, prealloc, compressed, direct IO, encoded). Fix this by returning an error from btrfs_extract_ordered_extent() if we find the BTRFS_ORDERED_IOERR flag in the ordered extent. The error will be the error that resulted in the transaction abort or -EIO if no transaction abort happened. This was recently reported by syzbot with the following trace FAULT_INJECTION forcing a failure. name failslab, interval 1, probability 0, space 0, times 1 CPU 0 UID 0 PID 5321 Comm syz.0.0 Not tainted 6.13.0-rc5-syzkaller #0 Hardware name QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014 Call Trace __dump_stack lib/dump_stack.c94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c120 fail_dump lib/fault-inject.c53 [inline] should_fail_ex+0x3b0/0x4e0 lib/fault-inject.c154 should_failslab+0xac/0x100 mm/failslab.c46 slab_pre_alloc_hook mm/slub.c4072 [inline] slab_alloc_node mm/slub.c4148 [inline] __do_kmalloc_node mm/slub.c4297 [inline] __kmalloc_noprof+0xdd/0x4c0 mm/slub.c4310 kmalloc_noprof include/linux/slab.h905 [inline] kzalloc_noprof include/linux/slab.h1037 [inline] btrfs_chunk_alloc_add_chunk_item+0x244/0x1100 fs/btrfs/volumes.c5742 reserve_chunk_space+0x1ca/0x2c0 fs/btrfs/block-group.c4292 check_system_chunk fs/btrfs/block-group.c4319 [inline] do_chunk_alloc fs/btrfs/block-group.c3891 [inline] btrfs_chunk_alloc+0x77b/0xf80 fs/btrfs/block-group.c4187 find_free_extent_update_loop fs/btrfs/extent-tree.c4166 [inline] find_free_extent+0x42d1/0x5810 fs/btrfs/extent-tree.c4579 btrfs_reserve_extent+0x422/0x810 fs/btrfs/extent-tree.c4672 btrfs_new_extent_direct fs/btrfs/direct-io.c186 [inline] btrfs_get_blocks_direct_write+0x706/0xfa0 fs/btrfs/direct-io.c321 btrfs_dio_iomap_begin+0xbb7/0x1180 fs/btrfs/direct-io.c525 iomap_iter+0x697/0xf60 fs/iomap/iter.c90 __iomap_dio_rw+0xeb9/0x25b0 fs/iomap/direct-io.c702 btrfs_dio_write fs/btrfs/direct-io.c775 [inline] btrfs_direct_write+0x610/0xa30 fs/btrfs/direct-io.c880 btrfs_do_write_iter+0x2a0/0x760 fs/btrfs/file.c1397 do_iter_readv_writev+0x600/0x880 vfs_writev+0x376/0xba0 fs/read_write.c1050 do_pwritev fs/read_write.c1146 [inline] __do_sys_pwritev2 fs/read_write.c1204 [inline] __se_sys_pwritev2+0x196/0x2b0 fs/read_write.c1195 do_syscall_x64 arch/x86/entry/common.c52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c83 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP 00330x7f1281f85d29 RSP 002b00007f12819fe038 EFLAGS 00000246 ORIG_RAX 0000000000000148 RAX ffffffffffffffda RBX 00007f1282176080 RCX 00007f1281f85d29 RDX 0000000000000001 RSI 0000000020000240 RDI 0000000000000005 RBP 00007f12819fe090 R08 0000000000000000 R09 0000000000000003 R10 0000000000007000 R11 0000000000000246 R12 0000000000000002 R13 0000000000000000 R14 00007f1282176080 R15 00007ffcb9e23328 BTRFS error (device loop0 state A) Transaction aborted (error -12) BTRFS error (device loop0 state A ---truncated---",
    "enhanced_query": "In the Linux kernel, the following vulnerability has been resolved btrfs fix assertion failure when splitting ordered extent after transaction abort If while we are doing a direct IO write a transaction abort happens, we mark all existing ordered extents with the BTRFS_ORDERED_IOERR flag (done at btrfs_destroy_ordered_extents()), and then after that if we enter btrfs_split_ordered_extent() and the ordered extent has bytes left (meaning we have a bio that doesnt cover the whole ordered extent, see details at btrfs_extract_ordered_extent()), we will fail on the following assertion at btrfs_split_ordered_extent() ASSERT(!(flags & ~BTRFS_ORDERED_TYPE_FLAGS)) because the BTRFS_ORDERED_IOERR flag is set and the definition of BTRFS_ORDERED_TYPE_FLAGS is just the union of all flags that identify the type of write (regular, nocow, prealloc, compressed, direct IO, encoded). Fix this by returning an error from btrfs_extract_ordered_extent() if we find the BTRFS_ORDERED_IOERR flag in the ordered extent. The error will be the error that resulted in the transaction abort or -EIO if no transaction abort happened. This was recently reported by syzbot with the following trace FAULT_INJECTION forcing a failure. name failslab, interval 1, probability 0, space 0, times 1 CPU 0 UID 0 PID 5321 Comm syz.0.0 Not tainted 6.13.0-rc5-syzkaller #0 Hardware name QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014 Call Trace __dump_stack lib/dump_stack.c94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c120 fail_dump lib/fault-inject.c53 [inline] should_fail_ex+0x3b0/0x4e0 lib/fault-inject.c154 should_failslab+0xac/0x100 mm/failslab.c46 slab_pre_alloc_hook mm/slub.c4072 [inline] slab_alloc_node mm/slub.c4148 [inline] __do_kmalloc_node mm/slub.c4297 [inline] __kmalloc_noprof+0xdd/0x4c0 mm/slub.c4310 kmalloc_noprof include/linux/slab.h905 [inline] kzalloc_noprof include/linux/slab.h1037 [inline] btrfs_chunk_alloc_add_chunk_item+0x244/0x1100 fs/btrfs/volumes.c5742 reserve_chunk_space+0x1ca/0x2c0 fs/btrfs/block-group.c4292 check_system_chunk fs/btrfs/block-group.c4319 [inline] do_chunk_alloc fs/btrfs/block-group.c3891 [inline] btrfs_chunk_alloc+0x77b/0xf80 fs/btrfs/block-group.c4187 find_free_extent_update_loop fs/btrfs/extent-tree.c4166 [inline] find_free_extent+0x42d1/0x5810 fs/btrfs/extent-tree.c4579 btrfs_reserve_extent+0x422/0x810 fs/btrfs/extent-tree.c4672 btrfs_new_extent_direct fs/btrfs/direct-io.c186 [inline] btrfs_get_blocks_direct_write+0x706/0xfa0 fs/btrfs/direct-io.c321 btrfs_dio_iomap_begin+0xbb7/0x1180 fs/btrfs/direct-io.c525 iomap_iter+0x697/0xf60 fs/iomap/iter.c90 __iomap_dio_rw+0xeb9/0x25b0 fs/iomap/direct-io.c702 btrfs_dio_write fs/btrfs/direct-io.c775 [inline] btrfs_direct_write+0x610/0xa30 fs/btrfs/direct-io.c880 btrfs_do_write_iter+0x2a0/0x760 fs/btrfs/file.c1397 do_iter_readv_writev+0x600/0x880 vfs_writev+0x376/0xba0 fs/read_write.c1050 do_pwritev fs/read_write.c1146 [inline] __do_sys_pwritev2 fs/read_write.c1204 [inline] __se_sys_pwritev2+0x196/0x2b0 fs/read_write.c1195 do_syscall_x64 arch/x86/entry/common.c52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c83 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP 00330x7f1281f85d29 RSP 002b00007f12819fe038 EFLAGS 00000246 ORIG_RAX 0000000000000148 RAX ffffffffffffffda RBX 00007f1282176080 RCX 00007f1281f85d29 RDX 0000000000000001 RSI 0000000020000240 RDI 0000000000000005 RBP 00007f12819fe090 R08 0000000000000000 R09 0000000000000003 R10 0000000000007000 R11 0000000000000246 R12 0000000000000002 R13 0000000000000000 R14 00007f1282176080 R15 00007ffcb9e23328 BTRFS error (device loop0 state A) Transaction aborted (error -12) BTRFS error (device loop0 state A ---truncated--- Consider specifically these CWEs: CWE-1284 CWE-288 CWE-392 CWE-362 CWE-1285 CWE-909 CWE-667 CWE-833 CWE-617",
    "cwe_mentions": [
      "CWE-1284",
      "CWE-288",
      "CWE-392",
      "CWE-362",
      "CWE-1285",
      "CWE-909",
      "CWE-667",
      "CWE-833",
      "CWE-617"
    ],
    "search_time": 3.562333583831787
  },
  "timestamp": "2025-07-12 09:54:42",
  "cve_id": "CVE-2025-21754",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "288",
      "name": "Authentication Bypass Using an Alternate Path or Channel",
      "type": "base",
      "score": 2.1189999999999998,
      "relationship_count": 0
    },
    {
      "cwe_id": "392",
      "name": "Missing Report of Error Condition",
      "type": "base",
      "score": 2.1189999999999998,
      "relationship_count": 0
    },
    {
      "cwe_id": "456",
      "name": "Missing Initialization of a Variable",
      "type": "variant",
      "score": 1.83936,
      "relationship_count": 0
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "type": "Base",
      "score": 1.8368867515107203,
      "relationship_count": 0
    },
    {
      "cwe_id": "170",
      "name": "Improper Null Termination",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "120",
      "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "123",
      "name": "Write-what-where Condition",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "364",
      "name": "Signal Handler Race Condition",
      "type": "base",
      "score": 1.7550000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "1325",
      "name": "Improperly Controlled Sequential Memory Allocation",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "1265",
      "name": "Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "386",
      "name": "Symbolic Name not Mapping to Correct Object",
      "type": "base",
      "score": 1.6744000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "662",
      "name": "Improper Synchronization",
      "type": "class",
      "score": 1.6736000000000002,
      "relationship_count": 0
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 1.6707943891903825,
      "relationship_count": 0
    },
    {
      "cwe_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "type": "Base",
      "score": 1.6432221848657627,
      "relationship_count": 0
    },
    {
      "cwe_id": "609",
      "name": "Double-Checked Locking",
      "type": "base",
      "score": 1.5912000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "617",
      "name": "Reachable Assertion",
      "type": "Base",
      "score": 1.5911925083409377,
      "relationship_count": 0
    },
    {
      "cwe_id": "420",
      "name": "Unprotected Alternate Channel",
      "type": "base",
      "score": 1.521,
      "relationship_count": 0
    },
    {
      "cwe_id": "908",
      "name": "Use of Uninitialized Resource",
      "type": "Base",
      "score": 1.5196462967189566,
      "relationship_count": 0
    },
    {
      "cwe_id": "193",
      "name": "Off-by-one Error",
      "type": "Base",
      "score": 1.51442890288917,
      "relationship_count": 0
    },
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "type": "Base",
      "score": 1.5130116103116693,
      "relationship_count": 0
    }
  ]
}