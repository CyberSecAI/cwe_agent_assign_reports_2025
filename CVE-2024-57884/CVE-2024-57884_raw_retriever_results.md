# Raw Retriever Results for CVE-2024-57884

# Raw Retriever Results for CVE-2024-57884
## Query
In the Linux kernel, the following vulnerability has been resolved mm vmscan account for free pages to prevent infinite Loop in throttle_direct_reclaim() The task sometimes continues looping in throttle_direct_reclaim() because allow_direct_reclaim(pgdat) keeps returning false. #0 [ffff80002cb6f8d0] __switch_to at ffff8000080095ac #1 [ffff80002cb6f900] __schedule at ffff800008abbd1c #2 [ffff80002cb6f990] schedule at ffff800008abc50c #3 [ffff80002cb6f9b0] throttle_direct_reclaim at ffff800008273550 #4 [ffff80002cb6fa20] try_to_free_pages at ffff800008277b68 #5 [ffff80002cb6fae0] __alloc_pages_nodemask at ffff8000082c4660 #6 [ffff80002cb6fc50] alloc_pages_vma at ffff8000082e4a98 #7 [ffff80002cb6fca0] do_anonymous_page at ffff80000829f5a8 #8 [ffff80002cb6fce0] __handle_mm_fault at ffff8000082a5974 #9 [ffff80002cb6fd90] handle_mm_fault at ffff8000082a5bd4 At this point, the pgdat contains the following two zones NODE 4 ZONE 0 ADDR ffff00817fffe540 NAME DMA32 SIZE 20480 MIN/LOW/HIGH 11/28/45 VM_STAT NR_FREE_PAGES 359 NR_ZONE_INACTIVE_ANON 18813 NR_ZONE_ACTIVE_ANON 0 NR_ZONE_INACTIVE_FILE 50 NR_ZONE_ACTIVE_FILE 0 NR_ZONE_UNEVICTABLE 0 NR_ZONE_WRITE_PENDING 0 NR_MLOCK 0 NR_BOUNCE 0 NR_ZSPAGES 0 NR_FREE_CMA_PAGES 0 NODE 4 ZONE 1 ADDR ffff00817fffec00 NAME Normal SIZE 8454144 PRESENT 98304 MIN/LOW/HIGH 68/166/264 VM_STAT NR_FREE_PAGES 146 NR_ZONE_INACTIVE_ANON 94668 NR_ZONE_ACTIVE_ANON 3 NR_ZONE_INACTIVE_FILE 735 NR_ZONE_ACTIVE_FILE 78 NR_ZONE_UNEVICTABLE 0 NR_ZONE_WRITE_PENDING 0 NR_MLOCK 0 NR_BOUNCE 0 NR_ZSPAGES 0 NR_FREE_CMA_PAGES 0 In allow_direct_reclaim(), while processing ZONE_DMA32, the sum of inactive/active file-backed pages calculated in zone_reclaimable_pages() based on the result of zone_page_state_snapshot() is zero. Additionally, since this system lacks swap, the calculation of inactive/ active anonymous pages is skipped. crash> p nr_swap_pages nr_swap_pages = $1937 = { counter = 0 } As a result, ZONE_DMA32 is deemed unreclaimable and skipped, moving on to the processing of the next zone, ZONE_NORMAL, despite ZONE_DMA32 having free pages significantly exceeding the high watermark. The problem is that the pgdat->kswapd_failures hasnt been incremented. crash> px ((struct pglist_data *) 0xffff00817fffe540)->kswapd_failures $1935 = 0x0 This is because the node deemed balanced. The node balancing logic in balance_pgdat() evaluates all zones collectively. If one or more zones (e.g., ZONE_DMA32) have enough free pages to meet their watermarks, the entire node is deemed balanced. This causes balance_pgdat() to exit early before incrementing the kswapd_failures, as it considers the overall memory state acceptable, even though some zones (like ZONE_NORMAL) remain under significant pressure. The patch ensures that zone_reclaimable_pages() includes free pages (NR_FREE_PAGES) in its calculation when no other reclaimable pages are available (e.g., file-backed or anonymous pages). This change prevents zones like ZONE_DMA32, which have sufficient free pages, from being mistakenly deemed unreclaimable. By doing so, the patch ensures proper node balancing, avoids masking pressure on other zones like ZONE_NORMAL, and prevents infinite loops in throttle_direct_reclaim() caused by allow_direct_reclaim(pgdat) repeatedly returning false. The kernel hangs due to a task stuck in throttle_direct_reclaim(), caused by a node being incorrectly deemed balanced despite pressure in certain zones, such as ZONE_NORMAL. This issue arises from zone_reclaimable_pages ---truncated---

## Keyphrases
No keyphrases provided.

## Score Statistics
| Retriever | Min | Max | Mean | Median | Count |
|-----------|-----|-----|------|--------|-------|
| Dense | 0.4431 | 0.4970 | 0.4652 | 0.4614 | 20 |
| Sparse | 418.4655 | 450.2298 | 430.6323 | 427.2419 | 10 |
| Graph | 1.5165 | 2.2100 | 1.7243 | 1.6848 | 20 |

## Graph Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Mapping Usage |
|---|--------|------|-------------|-------|---------------|
| 1 | 1322 | Use of Blocking Code in Single-threaded, Non-blocking Context | base | 2.2100 | Allowed |
| 2 | 1284 | Improper Validation of Specified Quantity in Input | Base | 1.9976 | Allowed |
| 3 | 456 | Missing Initialization of a Variable | variant | 1.8394 | Allowed |
| 4 | 789 | Memory Allocation with Excessive Size Value | Variant | 1.8107 | Allowed |
| 5 | 22 | Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') | base | 1.7680 | Allowed |
| 6 | 41 | Improper Resolution of Path Equivalence | base | 1.7680 | Allowed |
| 7 | 120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | base | 1.7680 | Allowed-with-Review |
| 8 | 123 | Write-what-where Condition | base | 1.7680 | Allowed |
| 9 | 364 | Signal Handler Race Condition | base | 1.7550 | Allowed |
| 10 | 252 | Unchecked Return Value | base | 1.6848 | Allowed |
| 11 | 1265 | Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls | base | 1.6848 | Allowed |
| 12 | 386 | Symbolic Name not Mapping to Correct Object | base | 1.6744 | Allowed |
| 13 | 20 | Improper Input Validation | class | 1.6736 | Discouraged |
| 14 | 770 | Allocation of Resources Without Limits or Throttling | Base | 1.6433 | Allowed |
| 15 | 61 | UNIX Symbolic Link (Symlink) Following | compound | 1.6100 | Allowed |

## Dense Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Original Score | Mapping Usage |
|---|--------|------|-------------|-------|----------------|---------------|
| 1 | 909 | Missing Initialization of Resource | Class | 0.4970 | 0.4970 | Allowed-with-Review |
| 2 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | 0.4887 | 0.4887 | Allowed-with-Review |
| 3 | 770 | Allocation of Resources Without Limits or Throttling | Base | 0.4810 | 0.4810 | Allowed |
| 4 | 667 | Improper Locking | Class | 0.4802 | 0.4802 | Allowed-with-Review |
| 5 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | 0.4784 | 0.4784 | Allowed |
| 6 | 401 | Missing Release of Memory after Effective Lifetime | Variant | 0.4724 | 0.4724 | Allowed |
| 7 | 833 | Deadlock | Base | 0.4721 | 0.4721 | Allowed |
| 8 | 789 | Memory Allocation with Excessive Size Value | Variant | 0.4707 | 0.4707 | Allowed |
| 9 | 1284 | Improper Validation of Specified Quantity in Input | Base | 0.4669 | 0.4669 | Allowed |
| 10 | 126 | Buffer Over-read | Variant | 0.4621 | 0.4621 | Allowed |
| 11 | 1260 | Improper Handling of Overlap Between Protected Memory Ranges | Base | 0.4607 | 0.4607 | Allowed |
| 12 | 122 | Heap-based Buffer Overflow | Variant | 0.4579 | 0.4579 | Allowed |
| 13 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | 0.4575 | 0.4575 | Allowed |
| 14 | 416 | Use After Free | Variant | 0.4564 | 0.4564 | Allowed |
| 15 | 190 | Integer Overflow or Wraparound | Base | 0.4550 | 0.4550 | Allowed |

## Sparse Retriever Results (10)
| # | CWE ID | Name | Score | Original Score | Mapping Usage |
|---|--------|------|-------|---------------|---------------|
| 1 | 1390 | Weak Authentication | 450.2298 | 450.2298 | Allowed-with-Review |
| 2 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | 444.4875 | 444.4875 | Allowed-with-Review |
| 3 | 909 | Missing Initialization of Resource | 436.3931 | 436.3931 | Allowed-with-Review |
| 4 | 1284 | Improper Validation of Specified Quantity in Input | 435.5157 | 435.5157 | Allowed |
| 5 | 863 | Incorrect Authorization | 429.4426 | 429.4426 | Allowed-with-Review |
| 6 | 59 | Improper Link Resolution Before File Access ('Link Following') | 425.0413 | 425.0413 | Allowed |
| 7 | 639 | Authorization Bypass Through User-Controlled Key | 422.9654 | 422.9654 | Allowed |
| 8 | 401 | Missing Release of Memory after Effective Lifetime | 422.9326 | 422.9326 | Allowed |
| 9 | 770 | Allocation of Resources Without Limits or Throttling | 420.8495 | 420.8495 | Allowed |
| 10 | 190 | Integer Overflow or Wraparound | 418.4655 | 418.4655 | Allowed |
