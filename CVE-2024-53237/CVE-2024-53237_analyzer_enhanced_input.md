## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved Bluetooth fix **use-after-free** in device_for_each_child() Syzbot has reported the following KASAN splat BUG KASAN slab-**use-after-free** in device_for_each_child+0x18f/0x1a0 Read of size 8 at addr ffff88801f605308 by task kbnepd bnep0/4980 CPU 0 UID 0 PID 4980 Comm kbnepd bnep0 Not tainted 6.12.0-rc4-00161-gae90f6a6170d #1 Hardware name QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-2.fc40 04/01/2014 Call Trace dump_stack_lvl+0x100/0x190 ? device_for_each_child+0x18f/0x1a0 print_report+0x13a/0x4cb ? __virt_addr_valid+0x5e/0x590 ? __phys_addr+0xc6/0x150 ? device_for_each_child+0x18f/0x1a0 kasan_report+0xda/0x110 ? device_for_each_child+0x18f/0x1a0 ? __pfx_dev_memalloc_noio+0x10/0x10 device_for_each_child+0x18f/0x1a0 ? __pfx_device_for_each_child+0x10/0x10 pm_runtime_set_memalloc_noio+0xf2/0x180 netdev_unregister_kobject+0x1ed/0x270 unregister_netdevice_many_notify+0x123c/0x1d80 ? __mutex_trylock_common+0xde/0x250 ? __pfx_unregister_netdevice_many_notify+0x10/0x10 ? trace_contention_end+0xe6/0x140 ? __mutex_lock+0x4e7/0x8f0 ? __pfx_lock_acquire.part.0+0x10/0x10 ? rcu_is_watching+0x12/0xc0 ? unregister_netdev+0x12/0x30 unregister_netdevice_queue+0x30d/0x3f0 ? __pfx_unregister_netdevice_queue+0x10/0x10 ? __pfx_down_write+0x10/0x10 unregister_netdev+0x1c/0x30 bnep_session+0x1fb3/0x2ab0 ? __pfx_bnep_session+0x10/0x10 ? __pfx_lock_release+0x10/0x10 ? __pfx_woken_wake_function+0x10/0x10 ? __kthread_parkme+0x132/0x200 ? __pfx_bnep_session+0x10/0x10 ? kthread+0x13a/0x370 ? __pfx_bnep_session+0x10/0x10 kthread+0x2b7/0x370 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x48/0x80 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 Allocated by task 4974 kasan_save_stack+0x30/0x50 kasan_save_track+0x14/0x30 __kasan_kmalloc+0xaa/0xb0 __kmalloc_noprof+0x1d1/0x440 hci_alloc_dev_priv+0x1d/0x2820 __vhci_create_device+0xef/0x7d0 vhci_write+0x2c7/0x480 vfs_write+0x6a0/0xfc0 ksys_write+0x12f/0x260 do_syscall_64+0xc7/0x250 entry_SYSCALL_64_after_hwframe+0x77/0x7f Freed by task 4979 kasan_save_stack+0x30/0x50 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3b/0x60 __kasan_slab_free+0x4f/0x70 kfree+0x141/0x490 hci_release_dev+0x4d9/0x600 bt_host_release+0x6a/0xb0 device_release+0xa4/0x240 kobject_put+0x1ec/0x5a0 put_device+0x1f/0x30 vhci_release+0x81/0xf0 __fput+0x3f6/0xb30 task_work_run+0x151/0x250 do_exit+0xa79/0x2c30 do_group_exit+0xd5/0x2a0 get_signal+0x1fcd/0x2210 arch_do_signal_or_restart+0x93/0x780 syscall_exit_to_user_mode+0x140/0x290 do_syscall_64+0xd4/0x250 entry_SYSCALL_64_after_hwframe+0x77/0x7f In hci_conn_del_sysfs(), device_unregister() may be called when an underlying (kobject) reference counter is greater than 1. This means that reparenting (happened when the device is actually freed) is delayed and, during that delay, parent controller device (hciX) may be deleted. Since the latter may create a dangling pointer to freed parent, avoid that scenario by reparenting to NULL explicitly.

### Vulnerability Description Key Phrases
- **weakness:** **use-after-free**
- **product:** Linux kernel
- **component:** Bluetooth fix

## CVE Reference Links Content Summary
```
{
  "vulnerability": {
    "root_cause": "The vulnerability occurs in the `hci_conn_del_sysfs()` function within the Linux kernel's Bluetooth subsystem. When a Bluetooth connection is being removed, `device_unregister()` can be called while an underlying kobject reference counter is greater than 1. This leads to a delay in reparenting child devices. If the parent controller device (hciX) is deleted during this delay, it creates a dangling pointer to freed parent memory, leading to a use-after-free condition when the system tries to access the freed memory.",
    "weaknesses": [
      "Use-after-free"
    ],
    "impact": "A use-after-free vulnerability can lead to system crashes, denial of service, or potentially arbitrary code execution if an attacker can control the freed memory region.",
    "attack_vectors": "The vulnerability is triggered during the unregistration of a Bluetooth network device, which can be initiated by specific user-space actions or through the system's Bluetooth management process. The specific function call that is vulnerable is `device_for_each_child`",
    "required_capabilities": "An attacker needs to be able to interact with the system's Bluetooth functionality and trigger the unregistration of a Bluetooth connection while other references to child devices exist, possibly through crafted Bluetooth interactions or by manipulating the system's Bluetooth management tools."
  },
  "commits": [
    {
      "commit_id": "0f67ca2a80acf8b207240405b7f72d660665d3df",
       "message": "Bluetooth: fix use-after-free in device_for_each_child()\n\nIn 'hci_conn_del_sysfs()', 'device_unregister()' may be called when\nan underlying (kobject) reference counter is greater than 1. This\nmeans that reparenting (happened when the device is actually freed)\nis delayed and, during that delay, parent controller device (hciX)\nmay be deleted. Since the latter may create a dangling pointer to\nfreed parent, avoid that scenario by reparenting to NULL explicitly.\nReported-by: syzbot+6cf5652d3df49fae2e3f@syzkaller.appspotmail.com\nTested-by: syzbot+6cf5652d3df49fae2e3f@syzkaller.appspotmail.com\nCloses: https://syzkaller.appspot.com/bug?extid=6cf5652d3df49fae2e3f\nFixes: a85fb91e3d72 (\"Bluetooth: Fix double free in hci_conn_cleanup\")\nSigned-off-by: Dmitry Antipov <dmantipov@yandex.ru>\nSigned-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>\nSigned-off-by: Sasha Levin <sashal@kernel.org>"
     },
    {
      "commit_id": "7b277bd569bb6a2777f0014f84b4344f444fd49d",
       "message": "Bluetooth: fix use-after-free in device_for_each_child()\n\nIn 'hci_conn_del_sysfs()', 'device_unregister()' may be called when\nan underlying (kobject) reference counter is greater than 1. This\nmeans that reparenting (happened when the device is actually freed)\nis delayed and, during that delay, parent controller device (hciX)\nmay be deleted. Since the latter may create a dangling pointer to\nfreed parent, avoid that scenario by reparenting to NULL explicitly.\nReported-by: syzbot+6cf5652d3df49fae2e3f@syzkaller.appspotmail.com\nTested-by: syzbot+6cf5652d3df49fae2e3f@syzkaller.appspotmail.com\nCloses: https://syzkaller.appspot.com/bug?extid=6cf5652d3df49fae2e3f\nFixes: a85fb91e3d72 (\"Bluetooth: Fix double free in hci_conn_cleanup\")\nSigned-off-by: Dmitry Antipov <dmantipov@yandex.ru>\nSigned-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>\nSigned-off-by: Sasha Levin <sashal@kernel.org>"
    },
    {
      "commit_id": "91e2a2e4d1336333804cd31162984f01ad8cc70f",
       "message": "Bluetooth: fix use-after-free in device_for_each_child()\n\nIn 'hci_conn_del_sysfs()', 'device_unregister()' may be called when\nan underlying (kobject) reference counter is greater than 1. This\nmeans that reparenting (happened when the device is actually freed)\nis delayed and, during that delay, parent controller device (hciX)\nmay be deleted. Since the latter may create a dangling pointer to\nfreed parent, avoid that scenario by reparenting to NULL explicitly.\nReported-by: syzbot+6cf5652d3df49fae2e3f@syzkaller.appspotmail.com\nTested-by: syzbot+6cf5652d3df49fae2e3f@syzkaller.appspotmail.com\nCloses: https://syzkaller.appspot.com/bug?extid=6cf5652d3df49fae2e3f\nFixes: a85fb91e3d72 (\"Bluetooth: Fix double free in hci_conn_cleanup\")\nSigned-off-by: Dmitry Antipov <dmantipov@yandex.ru>\nSigned-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>\nSigned-off-by: Sasha Levin <sashal@kernel.org>"
     },
    {
      "commit_id":"fb91ce37dc9a37ea23cf32b6d7b667004e93d4c5",
      "message": "Bluetooth: fix use-after-free in device_for_each_child()\n\nIn 'hci_conn_del_sysfs()', 'device_unregister()' may be called when\nan underlying (kobject) reference counter is greater than 1. This\nmeans that reparenting (happened when the device is actually freed)\nis delayed and, during that delay, parent controller device (hciX)\nmay be deleted. Since the latter may create a dangling pointer to\nfreed parent, avoid that scenario by reparenting to NULL explicitly.\nReported-by: syzbot+6cf5652d3df49fae2e3f@syzkaller.appspotmail.com\nTested-by: syzbot+6cf5652d3df49fae2e3f@syzkaller.appspotmail.com\nCloses: https://syzkaller.appspot.com/bug?extid=6cf5652d3df49fae2e3f\nFixes: a85fb91e3d72 (\"Bluetooth: Fix double free in hci_conn_cleanup\")\nSigned-off-by: Dmitry Antipov <dmantipov@yandex.ru>\nSigned-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>\nSigned-off-by: Sasha Levin <sashal@kernel.org>"
     },
    {
      "commit_id": "de5a44f351ca7efd9add9851b218f5353e2224b7",
      "message": "Bluetooth: fix use-after-free in device_for_each_child()\n\nIn 'hci_conn_del_sysfs()', 'device_unregister()' may be called when\nan underlying (kobject) reference counter is greater than 1. This\nmeans that reparenting (happened when the device is actually freed)\nis delayed and, during that delay, parent controller device (hciX)\nmay be deleted. Since the latter may create a dangling pointer to\nfreed parent, avoid that scenario by reparenting to NULL explicitly.\nReported-by: syzbot+6cf5652d3df49fae2e3f@syzkaller.appspotmail.com\nTested-by: syzbot+6cf5652d3df49fae2e3f@syzkaller.appspotmail.com\nCloses: https://syzkaller.appspot.com/bug?extid=6cf5652d3df49fae2e3f\nFixes: a85fb91e3d72 (\"Bluetooth: Fix double free in hci_conn_cleanup\")\nSigned-off-by: Dmitry Antipov <dmantipov@yandex.ru>\nSigned-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>\nSigned-off-by: Sasha Levin <sashal@kernel.org>"
    },
   {
      "commit_id":"27aabf27fd014ae037cc179c61b0bee7cff55b3d",
      "message": "Bluetooth: fix use-after-free in device_for_each_child()\nSyzbot has reported the following KASAN splat:\nBUG: KASAN: slab-use-after-free in device_for_each_child+0x18f/0x1a0\nRead of size 8 at addr ffff88801f605308 by task kbnepd bnep0/4980\nCPU: 0 UID: 0 PID: 4980 Comm: kbnepd bnep0 Not tainted 6.12.0-rc4-00161-gae90f6a6170d #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-2.fc40 04/01/2014\nCall Trace:\n<TASK>\ndump_stack_lvl+0x100/0x190\n? device_for_each_child+0x18f/0x1a0\nprint_report+0x13a/0x4cb\n? __virt_addr_valid+0x5e/0x590\n? __phys_addr+0xc6/0x150\n? device_for_each_child+0x18f/0x1a0\nkasan_report+0xda/0x110\n? device_for_each_child+0x18f/0x1a0\n? __pfx_dev_memalloc_noio+0x10/0x10\ndevice_for_each_child+0x18f/0x1a0\n? __pfx_device_for_each_child+0x10/0x10\npm_runtime_set_memalloc_noio+0xf2/0x180\nnetdev_unregister_kobject+0x1ed/0x270\nunregister_netdevice_many_notify+0x123c/0x1d80\n? __mutex_trylock_common+0xde/0x250\n? __pfx_unregister_netdevice_many_notify+0x10/0x10\n? trace_contention_end+0xe6/0x140\n? __mutex_lock+0x4e7/0x8f0\n? __pfx_lock_acquire.part.0+0x10/0x10\n? rcu_is_watching+0x12/0xc0\n? unregister_netdev+0x12/0x30\nunregister_netdevice_queue+0x30d/0x3f0\n? __pfx_unregister_netdevice_queue+0x10/0x10\n? __pfx_down_write+0x10/0x10\nunregister_netdev+0x1c/0x30\nbnep_session+0x1fb3/0x2ab0\n? __pfx_bnep_session+0x10/0x10\n? __pfx_lock_release+0x10/0x10\n? __pfx_woken_wake_function+0x10/0x10\n? __kthread_parkme+0x132/0x200\n? __pfx_bnep_session+0x10/0x10\n? kthread+0x13a/0x370\n? __pfx_bnep_session+0x10/0x10\nkthread+0x2b7/0x370\n? __pfx_kthread+0x10/0x10\nret_from_fork+0x48/0x80\n? __pfx_kthread+0x10/0x10\nret_from_fork_asm+0x1a/0x30\n</TASK>\nAllocated by task 4974:\nkasan_save_stack+0x30/0x50\nkasan_save_track+0x14/0x30\n__kasan_kmalloc+0xaa/0xb0\n__kmalloc_noprof+0x1d1/0x440\nhci_alloc_dev_priv+0x1d/0x2820\n__vhci_create_device+0xef/0x7d0\nvhci_write+0x2c7/0x480\nvfs_write+0x6a0/0xfc0\nksys_write+0x12f/0x260\ndo_syscall_64+0xc7/0x250\nentry_SYSCALL_64_after_hwframe+0x77/0x7f\nFreed by task 4979:\nkasan_save_stack+0x30/0x50\nkasan_save_track+0x14/0x30\nkasan_save_free_info+0x3b/0x60\n__kasan_slab_free+0x4f/0x70\nkfree+0x141/0x490\nhci_release_dev+0x4d9/0x600\nbt_host_release+0x6a/0xb0\ndevice_release+0xa4/0x240\nkobject_put+0x1ec/0x5a0\nput_device+0x1f/0x30\nvhci_release+0x81/0xf0\n__fput+0x3f6/0xb30\ntask_work_run+0x151/0x250\ndo_exit+0xa79/0x2c30\ndo_group_exit+0xd5/0x2a0\nget_signal+0x1fcd/0x2210\narch_do_signal_or_restart+0x93/0x780\nsyscall_exit_to_user_mode+0x140/0x290\ndo_syscall_64+0xd4/0x250\nentry_SYSCALL_64_after_hwframe+0x77/0x7f\nIn 'hci_conn_del_sysfs()', 'device_unregister()' may be called when\nan underlying (kobject) reference counter is greater than 1. This\nmeans that reparenting (happened when the device is actually freed)\nis delayed and, during that delay, parent controller device (hciX)\nmay be deleted. Since the latter may create a dangling pointer to\nfreed parent, avoid that scenario by reparenting to NULL explicitly.\nReported-by: syzbot+6cf5652d3df49fae2e3f@syzkaller.appspotmail.com\nTested-by: syzbot+6cf5652d3df49fae2e3f@syzkaller.appspotmail.com\nCloses: https://syzkaller.appspot.com/bug?extid=6cf5652d3df49fae2e3f\nFixes: a85fb91e3d72 (\"Bluetooth: Fix double free in hci_conn_cleanup\")\nSigned-off-by: Dmitry Antipov <dmantipov@yandex.ru>\nSigned-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>"
    },
   {
      "commit_id":"a9584c897d1cba6265c78010bbb45ca5722c88bc",
      "message": "Bluetooth: fix use-after-free in device_for_each_child()\n\nIn 'hci_conn_del_sysfs()', 'device_unregister()' may be called when\nan underlying (kobject) reference counter is greater than 1. This\nmeans that reparenting (happened when the device is actually freed)\nis delayed and, during that delay, parent controller device (hciX)\nmay be deleted. Since the latter may create a dangling pointer to\nfreed parent, avoid that scenario by reparenting to NULL explicitly.\nReported-by: syzbot+6cf5652d3df49fae2e3f@syzkaller.appspotmail.com\nTested-by: syzbot+6cf5652d3df49fae2e3f@syzkaller.appspotmail.com\nCloses: https://syzkaller.appspot.com/bug?extid=6cf5652d3df49fae2e3f\nFixes: a85fb91e3d72 (\"Bluetooth: Fix double free in hci_conn_cleanup\")\nSigned-off-by: Dmitry Antipov <dmantipov@yandex.ru>\nSigned-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>\nSigned-off-by: Sasha Levin <sashal@kernel.org>"
     }
  ]
}
```

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 416 | Use After Free | Variant | Allowed | alternate_terms | 1.000 |
| 2 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.619 |
| 3 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.569 |
| 4 | 364 | Signal Handler Race Condition | Base | Allowed | sparse | 0.560 |
| 5 | 415 | Double Free | Variant | Allowed | sparse | 0.536 |
| 6 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.530 |
| 7 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.515 |
| 8 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | sparse | 0.505 |
| 9 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | dense | 0.528 |
| 10 | 123 | Write-what-where Condition | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-416: Use After Free

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-401: Missing Release of Memory after Effective Lifetime

CWE-364: Signal Handler Race Condition

CWE-415: Double Free

CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition

CWE-667: Improper Locking

CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer

CWE-909: Missing Initialization of Resource

CWE-123: Write-what-where Condition