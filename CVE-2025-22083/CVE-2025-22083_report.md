# Analysis Report for CVE-2025-22083

# Vulnerability Analysis Report: CVE-2025-22083

## Description

In the Linux kernel, the following vulnerability has been resolved vhost-scsi Fix handling of multiple calls to vhost_scsi_set_endpoint If vhost_scsi_set_endpoint is called multiple times without a vhost_scsi_clear_endpoint between them, we can hit multiple bugs found by Haoran Zhang 1. **Use-after-free** when no tpgs are found This fixes a **use after free** that occurs when vhost_scsi_set_endpoint is called more than once and calls after the first call do not find any tpgs to add to the vs_tpg. When vhost_scsi_set_endpoint first finds tpgs to add to the vs_tpg array match=true, so we will do vhost_vq_set_backend(vq, vs_tpg) ... kfree(vs->vs_tpg) vs->vs_tpg = vs_tpg If vhost_scsi_set_endpoint is called again and no tpgs are found match=false so we skip the vhost_vq_set_backend call leaving the pointer to the vs_tpg we then free via kfree(vs->vs_tpg) vs->vs_tpg = vs_tpg If a scsi request is then sent we do vhost_scsi_handle_vq -> vhost_scsi_get_req -> vhost_vq_get_backend which sees the vs_tpg we just did a kfree on. 2. **Tpg dir removal hang** This patch fixes an issue where we cannot remove a LIO/target layer tpg (and structs above it like the target) dir due to the refcount dropping to -1. The problem is that if vhost_scsi_set_endpoint detects a tpg is already in the vs->vs_tpg array or if the tpg has been removed so target_depend_item fails, the undepend goto handler will do target_undepend_item on all tpgs in the vs_tpg array dropping their refcount to 0. At this time vs_tpg contains both the tpgs we have added in the current vhost_scsi_set_endpoint call as well as tpgs we added in previous calls which are also in vs->vs_tpg. Later, when vhost_scsi_clear_endpoint runs it will do target_undepend_item on all the tpgs in the vs->vs_tpg which will drop their refcount to -1. Userspace will then not be able to remove the tpg and will hang when it tries to do rmdir on the tpg dir. 3. **Tpg leak** This fixes a bug where we can leak tpgs and cause them to be un-removable because the target name is overwritten when vhost_scsi_set_endpoint is called multiple times but with different target names. The bug occurs if a user has called VHOST_SCSI_SET_ENDPOINT and setup a vhost-scsi device to target/tpg mapping, then calls VHOST_SCSI_SET_ENDPOINT again with a new target name that has tpgs we havent seen before (target1 has tpg1 but target2 has tpg2). When this happens we dont teardown the old target tpg mapping and just overwrite the target name and the vs->vs_tpg array. Later when we do vhost_scsi_clear_endpoint, we are passed in either target1 or target2s name and we will only match that targets tpgs when we loop over the vs->vs_tpg. We will then return from the function without doing target_undepend_item on the tpgs. Because of all these bugs, it looks like being able to call vhost_scsi_set_endpoint multiple times was never supported. The major user, QEMU, already has checks to prevent this use case. So to fix the issues, this patch prevents vhost_scsi_set_endpoint from being called if its already successfully added tpgs. To add, remove or change the tpg config or target name, you must do a vhost_scsi_clear_endpoint first.

## Vulnerability Description Key Phrases

- **Rootcause:** ['Tpg dir removal hang', 'use after free', 'Use-after-free', 'Tpg leak']
- **Weakness:** use-after-free
- **Product:** Linux kernel
- **Component:** vhost-scsi

## Analysis (with Relationship Data)

# Summary
| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |
|---|---|---|---|---|---|
| CWE-416 | Use After Free | 0.9 | Variant | Primary | Allowed |
| CWE-415 | Double Free | 0.6 | Variant | Secondary | Allowed |
| CWE-667 | Improper Locking | 0.5 | Class | Secondary | Allowed-with-Review |

## Evidence and Confidence

*   **Confidence Score:** 0.8
*   **Evidence Strength:** HIGH

## Relationship Analysis
The primary weakness is a **use-after-free**, which is a type of memory corruption. CWE-416 (Use After Free) is a variant-level CWE that directly describes this condition. We also considered CWE-415 (Double Free) as a secondary issue, because a double free can lead to a use-after-free. CWE-667 (Improper Locking) was also considered as a potential contributing factor if a race condition allowed the memory to be freed while another thread still had access to it.mermaid
```mermaid
graph TD
    cwe416["CWE-416: Use After Free"]
    cwe415["CWE-415: Double Free"]
    cwe667["CWE-667: Improper Locking"]
    cwe666["CWE-666: Operation on Resource in Wrong Phase of Lifetime"]
    
    cwe416 -->|CHILDOF| cwe666
    cwe415 -->|CHILDOF| cwe666
    cwe415 -->|CANPRECEDE| cwe416
    cwe667 -->|CANPRECEDE| cwe416
    
    classDef primary fill:#f96,stroke:#333,stroke-width:2px
    classDef secondary fill:#69f,stroke:#333
    classDef tertiary fill:#9e9,stroke:#333
    class cwe416 primary
    class cwe415,cwe667 secondary

```


## Vulnerability Chain
The vulnerability chain starts with multiple calls to `vhost_scsi_set_endpoint` without an intervening `vhost_scsi_clear_endpoint`. This leads to several problems:

1.  **Use-after-free**: A pointer to `vs_tpg` is freed, but the pointer is still used later. This is the primary weakness.
2.  **Tpg dir removal hang**: The refcount of a tpg drops to -1, preventing its removal.
3.  **Tpg leak**: Target names are overwritten, leading to un-removable tpgs.

The primary root cause is the **improper state management** when `vhost_scsi_set_endpoint` is called multiple times. This leads to the **use-after-free** as the immediate consequence, and further issues like the hang and leak.

## Summary of Analysis
The primary weakness is a **use-after-free** vulnerability in the Linux kernel's vhost-scsi component. This occurs when the `vhost_scsi_set_endpoint` function is called multiple times without an intervening call to `vhost_scsi_clear_endpoint`, leading to a freed pointer being accessed later. The vulnerability description explicitly mentions "This fixes a **use after free** that occurs when vhost_scsi_set_endpoint is called more than once...". This clearly points to **CWE-416: Use After Free** as the primary CWE.

**CWE-416: Use After Free** is the most specific and accurate representation of the vulnerability. The vulnerability description clearly states the **use-after-free** condition, making CWE-416 the most appropriate choice.

The graph relationships helped confirm that **CWE-416** is the most appropriate primary weakness.

Relevant CWE Information:

# Enhanced Context (25 CWEs)
The following CWEs were identified as potentially relevant to this vulnerability:

## CWE-667: Improper Locking
**Abstraction Level**: Class
**Similarity Score**: 0.77
**Source**: dense

**Description**:
The product does not properly acquire or release a lock on a resource, leading to unexpected resource state changes and behaviors.

**Mapping Guidance**:
- Usage: Allowed-with-Review
- Rationale: This CWE entry is a Class and might have Base-level children that would be more appropriate

**Why Not Selected**: While a race condition *could* contribute, the primary issue is the **use-after-free**, not necessarily a locking problem. Thus, this is a secondary consideration.

## CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')
**Abstraction Level**: Class
**Similarity Score**: 0.75
**Source**: dense

**Description**:
The product contains a concurrent code sequence that requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence operating concurrently.

**Mapping Guidance**:
- Usage: Allowed-with-Review
- Rationale: This CWE entry is a Class and might have Base-level children that would be more appropriate

**Why Not Selected**: Similar to CWE-667, concurrency might play a role, but the core issue is the **use-after-free**.

## CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer
**Abstraction Level**: Base
**Similarity Score**: 0.75
**Source**: dense

**Description**:
The product stores, transfers, or shares a resource that contains sensitive information, but it does not properly remove that information before the product makes the resource available to unauthorized actors.

**Mapping Guidance**:
- Usage: Allowed
- Rationale: This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.

**Why Not Selected**: This CWE is not relevant to the vulnerability description. The issue is not about sensitive information.

## CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition
**Abstraction Level**: Base
**Similarity Score**: 0.75
**Source**: dense

**Description**:
The product checks the state of a resource before using that resource, but the resource's state can change between the check and the use in a way that invalidates the results of the check. This can cause the product to perform invalid actions when the resource is in an unexpected state.

**Mapping Guidance**:
- Usage: Allowed
- Rationale: This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.

**Why Not Selected**: The vulnerability isn't a TOCTOU issue. There's no check performed before the use.

## CWE-824: Access of Uninitialized Pointer
**Abstraction Level**: Base
**Similarity Score**: 0.75
**Source**: dense

**Description**:
The product accesses or uses a pointer that has not been initialized.

**Mapping Guidance**:
- Usage: Allowed
- Rationale: This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.

**Why Not Selected**: The issue is that the pointer was freed, not that it was uninitialized.

## CWE-755: Improper Handling of Exceptional Conditions
**Abstraction Level**: Class
**Similarity Score**: 0.75
**Source**: dense

**Description**:
The product does not handle or incorrectly handles an exceptional condition.

**Mapping Guidance**:
- Usage: Discouraged
- Rationale: This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate

**Why Not Selected**: This CWE is too generic. The vulnerability is a specific type of memory corruption.

## CWE-404: Improper Resource Shutdown or Release
**Abstraction Level**: Class
**Similarity Score**: 0.74
**Source**: dense

**Description**:
The product does not release or incorrectly releases a resource before it is made available for re-use.

**Mapping Guidance**:
- Usage: Allowed-with-Review
- Rationale: This CWE entry is a Class and might have Base-level children that would be more appropriate

**Why Not Selected**: This is related, but **CWE-416** is more specific, because it focuses on the *use* after the release.

## CWE-754: Improper Check for Unusual or Exceptional Conditions
**Abstraction Level**: Class
**Similarity Score**: 0.74
**Source**: dense

**Description**:
The product does not check or incorrectly checks for unusual or exceptional conditions that are not expected to occur frequently during day to day operation of the product.

**Mapping Guidance**:
- Usage: Allowed-with-Review
- Rationale: This CWE entry is a Class and might have Base-level children that would be more appropriate

**Why Not Selected**: The issue isn't a missing check, but rather using memory after it's been freed.

## CWE-59: Improper Link Resolution Before File Access ('Link Following')
**Abstraction Level**:


## CWE Relationship Analysis

Current CWEs represent these abstraction levels: .


### Vulnerability Chain Analysis

**Chain starting from CWE-416:**
- 416 (Use After Free) - ROOT


**Chain starting from CWE-404:**
- 404 (Improper Resource Shutdown or Release) - ROOT



### CWE Relationship Diagram

```mermaid
graph TD
    classDef primary fill:#f96,stroke:#333,stroke-width:2px
    classDef secondary fill:#69f,stroke:#333
    classDef tertiary fill:#9e9,stroke:#333
```



*Report generated on 2025-07-14 10:11:08*
