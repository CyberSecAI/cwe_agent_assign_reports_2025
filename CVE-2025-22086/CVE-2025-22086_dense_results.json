{
  "query": "In the Linux kernel, the following vulnerability has been resolved RDMA/mlx5 Fix mlx5_poll_one() cur_qp update flow When cur_qp isnt NULL, in order to avoid fetching the QP from the radix tree again we check if the next cqe QP is identical to the one we already have. The bug however is that we are checking if the QP is identical by checking the QP number inside the CQE against the QP number inside the mlx5_ib_qp, but thats wrong since the QP number from the CQE is from FW so it should be matched against mlx5_core_qp which is our FW QP number. Otherwise we could use the wrong QP when handling a CQE which could cause the kernel trace below. This issue is mainly noticeable over QPs 0 & 1, since for now they are the only QPs in our driver whereas the QP number inside mlx5_ib_qp doesnt match the QP number inside mlx5_core_qp.",
  "count": 20,
  "results": [
    {
      "cwe_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "abstraction": "Base",
      "score": 0.5311844793563001,
      "original_score": 0.5311844793563001,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "413",
      "name": "Improper Resource Locking",
      "abstraction": "Base",
      "score": 0.5079863658033785,
      "original_score": 0.5079863658033785,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "909",
      "name": "Missing Initialization of Resource",
      "abstraction": "Class",
      "score": 0.5001885692821684,
      "original_score": 0.5001885692821684,
      "mapping_usage": "Allowed-with-Review"
    },
    {
      "cwe_id": "696",
      "name": "Incorrect Behavior Order",
      "abstraction": "Class",
      "score": 0.4944157723932405,
      "original_score": 0.4944157723932405,
      "mapping_usage": "Allowed-with-Review"
    },
    {
      "cwe_id": "911",
      "name": "Improper Update of Reference Count",
      "abstraction": "Base",
      "score": 0.49118460347277,
      "original_score": 0.49118460347277,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "606",
      "name": "Unchecked Input for Loop Condition",
      "abstraction": "Base",
      "score": 0.49021993510936834,
      "original_score": 0.49021993510936834,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "191",
      "name": "Integer Underflow (Wrap or Wraparound)",
      "abstraction": "Base",
      "score": 0.4895795853514427,
      "original_score": 0.4895795853514427,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "822",
      "name": "Untrusted Pointer Dereference",
      "abstraction": "Base",
      "score": 0.48864099442354475,
      "original_score": 0.48864099442354475,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "1260",
      "name": "Improper Handling of Overlap Between Protected Memory Ranges",
      "abstraction": "Base",
      "score": 0.4882865478326862,
      "original_score": 0.4882865478326862,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "abstraction": "Class",
      "score": 0.48732143532043604,
      "original_score": 0.48732143532043604,
      "mapping_usage": "Allowed-with-Review"
    },
    {
      "cwe_id": "131",
      "name": "Incorrect Calculation of Buffer Size",
      "abstraction": "Base",
      "score": 0.46510566853710356,
      "original_score": 0.46510566853710356,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "835",
      "name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
      "abstraction": "Base",
      "score": 0.4637910956625036,
      "original_score": 0.4637910956625036,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "1332",
      "name": "Improper Handling of Faults that Lead to Instruction Skips",
      "abstraction": "Base",
      "score": 0.4617223540169163,
      "original_score": 0.4617223540169163,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "401",
      "name": "Missing Release of Memory after Effective Lifetime",
      "abstraction": "Variant",
      "score": 0.4604199013780441,
      "original_score": 0.4604199013780441,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "1342",
      "name": "Information Exposure through Microarchitectural State after Transient Execution",
      "abstraction": "Base",
      "score": 0.4597872463373287,
      "original_score": 0.4597872463373287,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "abstraction": "Base",
      "score": 0.4593542844398324,
      "original_score": 0.4593542844398324,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "abstraction": "Class",
      "score": 0.4589657434406367,
      "original_score": 0.4589657434406367,
      "mapping_usage": "Allowed-with-Review"
    },
    {
      "cwe_id": "190",
      "name": "Integer Overflow or Wraparound",
      "abstraction": "Base",
      "score": 0.45867657488915087,
      "original_score": 0.45867657488915087,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "1264",
      "name": "Hardware Logic with Insecure De-Synchronization between Control and Data Channels",
      "abstraction": "Base",
      "score": 0.45827633172316995,
      "original_score": 0.45827633172316995,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "1250",
      "name": "Improper Preservation of Consistency Between Independent Representations of Shared State",
      "abstraction": "Base",
      "score": 0.4559348447824154,
      "original_score": 0.4559348447824154,
      "mapping_usage": "Allowed"
    }
  ],
  "statistics": {
    "min": 0.4559348447824154,
    "max": 0.5311844793563001,
    "mean": 0.47855211667762176,
    "median": 0.4762135519287698,
    "count": 20
  }
}