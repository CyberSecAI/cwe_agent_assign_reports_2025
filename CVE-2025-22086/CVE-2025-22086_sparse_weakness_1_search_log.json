{
  "method": "sparse_weakness_1",
  "query": "In the Linux kernel, the following vulnerability has been resolved RDMA/mlx5 Fix mlx5_poll_one() cur_qp update flow When cur_qp isnt NULL, in order to avoid fetching the QP from the radix tree again we check if the next cqe QP is identical to the one we already have. The bug however is that we are checking if the QP is identical by checking the QP number inside the CQE against the QP number inside the mlx5_ib_qp, but thats wrong since the QP number from the CQE is from FW so it should be matched against mlx5_core_qp which is our FW QP number. Otherwise we could use the wrong QP when handling a CQE which could cause the kernel trace below. This issue is mainly noticeable over QPs 0 & 1, since for now they are the only QPs in our driver whereas the QP number inside mlx5_ib_qp doesnt match the QP number inside mlx5_core_qp.",
  "keyphrases": {
    "weakness": "QP number mismatch"
  },
  "timestamp": "2025-07-14T10:11:30.901090",
  "results_count": 10,
  "results_summary": [
    {
      "doc_id": "335",
      "name": "Incorrect Usage of Seeds in Pseudo-Random Number Generator (PRNG)",
      "score": 703.9620953991234
    },
    {
      "doc_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "score": 648.92163463046
    },
    {
      "doc_id": "476",
      "name": "NULL Pointer Dereference",
      "score": 615.9973312956323
    },
    {
      "doc_id": "125",
      "name": "Out-of-bounds Read",
      "score": 610.0121580632483
    },
    {
      "doc_id": "130",
      "name": "Improper Handling of Length Parameter Inconsistency",
      "score": 600.8312535764705
    }
  ]
}