{
  "cve_id": "CVE-2025-1744",
  "description": "Out-of-bounds Write vulnerability in radareorg radare2 allows **heap-based buffer over-read** or buffer overflow.This issue affects radare2 before <5.9.9.",
  "key_phrases": {
    "rootcause": "",
    "weakness": [
      "heap-based buffer over-read",
      "heap-based buffer overflow"
    ],
    "impact": "",
    "vector": "",
    "attacker": "",
    "product": "radareorg radare2",
    "version": "before <5.9.9",
    "component": ""
  },
  "reference_content": "CVE-2025-1744 - radare2 zlib Vulnerability\n\n**Root cause of vulnerability:**\nThe vulnerability stems from a missing security patch in the zlib library used by radare2. Specifically, the issue arose because the cloned zlib version hadn't received a security fix (eff308af425b67093bab25f80f1ae950166bece1) present in the original zlib.\n\n**Weaknesses/vulnerabilities present:**\n- Buffer overflow in `inflate()` function when handling gzip header extra fields. If the extra field is larger than the allocated space, and multiple calls to `inflate()` deliver the extra header data, a buffer overflow can occur.\n- A potential segmentation fault was introduced by the initial patch (eff308af425b67093bab25f80f1ae950166bece1) and later fixed in a follow-up commit (1eb7682f845ac9e9bf9ae35bbfb3bad5dacbd91d) which was not included in the initial fix.\n\n**Impact of exploitation:**\n- Buffer overflow could lead to crashes or potentially arbitrary code execution.\n\n**Attack vectors:**\n- Processing a specially crafted gzip file with a large extra field in the header.\n\n**Required attacker capabilities/position:**\n- Ability to provide a malicious gzip file as input to radare2.\n\n**Mitigation or fix:**\n- The pull request #23969 applied the patch from madler/zlib@eff308af425b67093bab25f80f1ae950166bece1 to address the buffer overflow.\n- A follow-up patch (1eb7682f845ac9e9bf9ae35bbfb3bad5dacbd91d) to address a segmentation fault introduced by the initial patch is suggested but not yet implemented.\n- Backporting the patch to distribution packages is recommended until the next radare2 release (6.0.0).\n\n**Note:** The content provides more detail than the official CVE description, detailing the specific commits and the potential for a segmentation fault.",
  "similar_info": {
    "cwe_distribution": {},
    "cwe_consensus": "",
    "similarity_stats": {
      "thresholds": [],
      "total_samples_by_threshold": {},
      "top_cwes_by_threshold": {}
    }
  },
  "similarity_summary": {
    "consensus_cwe": "",
    "top_cwes": [],
    "confidence_levels": {},
    "total_samples": 0
  },
  "analysis": "# Summary\n| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |\n|---|---|---|---|---|---|\n| CWE-126 | Buffer Over-read | 1.0 | Variant | Allowed | Primary CWE |\n| CWE-122 | Heap-based Buffer Overflow | 0.7 | Base | Allowed | Secondary Candidate |\n\n## Evidence and Confidence\n\n*   **Confidence Score:** 0.9\n*   **Evidence Strength:** HIGH\n\n## Relationship Analysis\nThe primary CWE is CWE-126, which is a variant of the base CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer). CWE-122 is a base CWE that describes a specific type of buffer overflow occurring in the heap, making it a good secondary candidate. CWE-126 directly addresses the **buffer over-read** aspect of the vulnerability, while CWE-122 highlights that it is heap-based.\n\n```mermaid\ngraph TD\n    cwe126[\"CWE-126: Buffer Over-read\"]\n    cwe122[\"CWE-122: Heap-based Buffer Overflow\"]\n    cwe119[\"CWE-119: Improper Restriction of Operations\"]\n    \n    cwe126 -->|CHILDOF| cwe119\n    cwe122 -->|\"Occurs on the heap\"| cwe126\n    \n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    class cwe126 primary\n    class cwe122 secondary\n    class cwe119 secondary\n```\n\n## Vulnerability Chain\nThe vulnerability chain involves a **heap-based buffer over-read** or buffer overflow, ultimately leading to an out-of-bounds write.\n1.  The root cause is an **improper restriction of operations** within the bounds of a heap-allocated buffer (potentially due to **incorrect calculation of buffer size**, an **off-by-one error**, or an **integer overflow**).\n2.  This leads to a **buffer over-read** or **buffer overflow** condition.\n3.  The impact is a potential out-of-bounds write, leading to arbitrary code execution or denial of service.\n\n## Summary of Analysis\nThe analysis is based on the provided vulnerability description, focusing on the key phrases \"**heap-based buffer over-read**\" and \"**heap-based buffer overflow**\". The retriever results strongly suggest CWE-126 (Buffer Over-read) and CWE-122 (Heap-based Buffer Overflow).\n\nThe description explicitly states \"**heap-based buffer over-read** or buffer overflow,\" making CWE-126 the most precise classification for the **over-read** aspect and CWE-122 highlighting it is **heap-based**.\n\nCWE-126 is at the Variant level, which is preferred for specificity. CWE-122 provides additional context by specifying the memory region (heap).\n\nOther CWEs considered but not used:\n\n*   CWE-193 (Off-by-one Error): While an off-by-one error could contribute to a buffer over-read or overflow, the description does not explicitly mention it.\n*   CWE-190 (Integer Overflow or Wraparound): Similar to CWE-193, an integer overflow could lead to an incorrect buffer size calculation, but it is not explicitly stated in the description.\n*   CWE-131 (Incorrect Calculation of Buffer Size): Although this could be the root cause, the description focuses on the manifestation (over-read/overflow) rather than the calculation error itself.\n*   CWE-125 (Out-of-bounds Read): Similar to CWE-126, but CWE-126 is more specific.\n*   CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer): This is a parent of CWE-126, and while relevant, CWE-126 provides more specific details.\n*   CWE-805 (Buffer Access with Incorrect Length Value): This could be a contributing factor, but the description highlights the over-read/overflow, making CWE-126/CWE-122 more appropriate.\n* CWE-788: Access of Memory Location After End of Buffer - overlaps with CWE-126 and CWE-125\n* CWE-805: Buffer Access with Incorrect Length Value - possible but lacks direct evidence.\n* CWE-129: Improper Validation of Array Index - unlikely as this vulnerability has heap-based implications rather than array-based.\n* CWE-824: Access of Uninitialized Pointer - Possible root cause, but no direct evidence.\n* CWE-703: Improper Check or Handling of Exceptional Conditions - Too abstract, not specific enough.\n* CWE-191: Integer Underflow (Wrap or Wraparound) - Possible root cause, but no direct evidence.\n* CWE-682: Incorrect Calculation - Too abstract, not specific enough.\n* CWE-839: Numeric Range Comparison Without Minimum Check - does not apply.\n* CWE-1339: Insufficient Precision or Accuracy of a Real Number - does not apply.\n* CWE-128: Wrap-around Error - does not apply.\n* CWE-825: Expired Pointer Dereference - Possible root cause, but no direct evidence.\n* CWE-823: Use of Out-of-range Pointer Offset - Possible root cause, but no direct evidence.",
  "analysis_with_relationships": "# Summary\n| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |\n|---|---|---|---|---|---|\n| CWE-126 | Buffer Over-read | 1.0 | Variant | Allowed | Primary CWE |\n| CWE-122 | Heap-based Buffer Overflow | 0.7 | Base | Allowed | Secondary Candidate |\n\n## Evidence and Confidence\n\n*   **Confidence Score:** 0.9\n*   **Evidence Strength:** HIGH\n\n## Relationship Analysis\nThe primary CWE is CWE-126, which is a variant of the base CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer). CWE-122 is a base CWE that describes a specific type of buffer overflow occurring in the heap, making it a good secondary candidate. CWE-126 directly addresses the **buffer over-read** aspect of the vulnerability, while CWE-122 highlights that it is heap-based.\n\n```mermaid\ngraph TD\n    cwe126[\"CWE-126: Buffer Over-read\"]\n    cwe122[\"CWE-122: Heap-based Buffer Overflow\"]\n    cwe119[\"CWE-119: Improper Restriction of Operations\"]\n    \n    cwe126 -->|CHILDOF| cwe119\n    cwe122 -->|\"Occurs on the heap\"| cwe126\n    \n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    class cwe126 primary\n    class cwe122 secondary\n    class cwe119 secondary\n```\n\n## Vulnerability Chain\nThe vulnerability chain involves a **heap-based buffer over-read** or buffer overflow, ultimately leading to an out-of-bounds write.\n1.  The root cause is an **improper restriction of operations** within the bounds of a heap-allocated buffer (potentially due to **incorrect calculation of buffer size**, an **off-by-one error**, or an **integer overflow**).\n2.  This leads to a **buffer over-read** or **buffer overflow** condition.\n3.  The impact is a potential out-of-bounds write, leading to arbitrary code execution or denial of service.\n\n## Summary of Analysis\nThe analysis is based on the provided vulnerability description, focusing on the key phrases \"**heap-based buffer over-read**\" and \"**heap-based buffer overflow**\". The retriever results strongly suggest CWE-126 (Buffer Over-read) and CWE-122 (Heap-based Buffer Overflow).\n\nThe description explicitly states \"**heap-based buffer over-read** or buffer overflow,\" making CWE-126 the most precise classification for the **over-read** aspect and CWE-122 highlighting it is **heap-based**.\n\nCWE-126 is at the Variant level, which is preferred for specificity. CWE-122 provides additional context by specifying the memory region (heap).\n\nOther CWEs considered but not used:\n\n*   CWE-193 (Off-by-one Error): While an off-by-one error could contribute to a buffer over-read or overflow, the description does not explicitly mention it.\n*   CWE-190 (Integer Overflow or Wraparound): Similar to CWE-193, an integer overflow could lead to an incorrect buffer size calculation, but it is not explicitly stated in the description.\n*   CWE-131 (Incorrect Calculation of Buffer Size): Although this could be the root cause, the description focuses on the manifestation (over-read/overflow) rather than the calculation error itself.\n*   CWE-125 (Out-of-bounds Read): Similar to CWE-126, but CWE-126 is more specific.\n*   CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer): This is a parent of CWE-126, and while relevant, CWE-126 provides more specific details.\n*   CWE-805 (Buffer Access with Incorrect Length Value): This could be a contributing factor, but the description highlights the over-read/overflow, making CWE-126/CWE-122 more appropriate.\n* CWE-788: Access of Memory Location After End of Buffer - overlaps with CWE-126 and CWE-125\n* CWE-805: Buffer Access with Incorrect Length Value - possible but lacks direct evidence.\n* CWE-129: Improper Validation of Array Index - unlikely as this vulnerability has heap-based implications rather than array-based.\n* CWE-824: Access of Uninitialized Pointer - Possible root cause, but no direct evidence.\n* CWE-703: Improper Check or Handling of Exceptional Conditions - Too abstract, not specific enough.\n* CWE-191: Integer Underflow (Wrap or Wraparound) - Possible root cause, but no direct evidence.\n* CWE-682: Incorrect Calculation - Too abstract, not specific enough.\n* CWE-839: Numeric Range Comparison Without Minimum Check - does not apply.\n* CWE-1339: Insufficient Precision or Accuracy of a Real Number - does not apply.\n* CWE-128: Wrap-around Error - does not apply.\n* CWE-825: Expired Pointer Dereference - Possible root cause, but no direct evidence.\n* CWE-823: Use of Out-of-range Pointer Offset - Possible root cause, but no direct evidence.\n\n\n## CWE Relationship Analysis\n\nCurrent CWEs represent these abstraction levels: .\n\n\n### Vulnerability Chain Analysis\n\n**Chain starting from CWE-125:**\n- 125 (Out-of-bounds Read) - ROOT\n\n\n**Chain starting from CWE-131:**\n- 131 (Incorrect Calculation of Buffer Size) - ROOT\n\n\n\n### CWE Relationship Diagram\n\n```mermaid\ngraph TD\n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    classDef tertiary fill:#9e9,stroke:#333\n```",
  "criticism": "",
  "resolution": "",
  "relevant_cwes": [
    {
      "metadata": {
        "doc_id": "126",
        "name": "Buffer Over-read",
        "source": "sparse",
        "original_content": "The product reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations after the targeted buffer.",
        "keyphrase_sources": [
          {
            "id": "weakness:heap-based buffer over-read",
            "keyphrase": "heap-based buffer over-read",
            "type": "weakness"
          },
          {
            "id": "weakness:heap-based buffer overflow",
            "keyphrase": "heap-based buffer overflow",
            "type": "weakness"
          },
          {
            "id": "product:radareorg radare2",
            "keyphrase": "radareorg radare2",
            "type": "product"
          },
          {
            "id": "version:before <5.9.9",
            "keyphrase": "before <5.9.9",
            "type": "version"
          }
        ]
      },
      "similarity": 281.7757753605898
    },
    {
      "metadata": {
        "doc_id": "122",
        "name": "Heap-based Buffer Overflow",
        "source": "sparse",
        "original_content": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
        "keyphrase_sources": [
          {
            "id": "weakness:heap-based buffer over-read",
            "keyphrase": "heap-based buffer over-read",
            "type": "weakness"
          },
          {
            "id": "weakness:heap-based buffer overflow",
            "keyphrase": "heap-based buffer overflow",
            "type": "weakness"
          },
          {
            "id": "product:radareorg radare2",
            "keyphrase": "radareorg radare2",
            "type": "product"
          },
          {
            "id": "version:before <5.9.9",
            "keyphrase": "before <5.9.9",
            "type": "version"
          }
        ]
      },
      "similarity": 275.3543217665666
    },
    {
      "metadata": {
        "doc_id": "193",
        "name": "Off-by-one Error",
        "source": "sparse",
        "original_content": "A product calculates or uses an incorrect maximum or minimum value that is 1 more, or 1 less, than the correct value.",
        "keyphrase_sources": [
          {
            "id": "weakness:heap-based buffer over-read",
            "keyphrase": "heap-based buffer over-read",
            "type": "weakness"
          },
          {
            "id": "weakness:heap-based buffer overflow",
            "keyphrase": "heap-based buffer overflow",
            "type": "weakness"
          },
          {
            "id": "version:before <5.9.9",
            "keyphrase": "before <5.9.9",
            "type": "version"
          }
        ]
      },
      "similarity": 245.24211543765185
    },
    {
      "metadata": {
        "doc_id": "190",
        "name": "Integer Overflow or Wraparound",
        "source": "sparse",
        "original_content": "The product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.",
        "keyphrase_sources": [
          {
            "id": "weakness:heap-based buffer over-read",
            "keyphrase": "heap-based buffer over-read",
            "type": "weakness"
          },
          {
            "id": "weakness:heap-based buffer overflow",
            "keyphrase": "heap-based buffer overflow",
            "type": "weakness"
          },
          {
            "id": "version:before <5.9.9",
            "keyphrase": "before <5.9.9",
            "type": "version"
          }
        ]
      },
      "similarity": 239.70937433152304
    },
    {
      "metadata": {
        "doc_id": "131",
        "name": "Incorrect Calculation of Buffer Size",
        "source": "sparse",
        "original_content": "The product does not correctly calculate the size to be used when allocating a buffer, which could lead to a buffer overflow.",
        "keyphrase_sources": [
          {
            "id": "weakness:heap-based buffer overflow",
            "keyphrase": "heap-based buffer overflow",
            "type": "weakness"
          }
        ]
      },
      "similarity": 226.19775641378112
    },
    {
      "metadata": {
        "doc_id": "125",
        "name": "Out-of-bounds Read",
        "source": "sparse",
        "original_content": "The product reads data past the end, or before the beginning, of the intended buffer.",
        "keyphrase_sources": [
          {
            "id": "weakness:heap-based buffer over-read",
            "keyphrase": "heap-based buffer over-read",
            "type": "weakness"
          }
        ]
      },
      "similarity": 218.42457242736737
    },
    {
      "metadata": {
        "doc_id": "805",
        "name": "Buffer Access with Incorrect Length Value",
        "source": "sparse",
        "original_content": "The product uses a sequential operation to read or write a buffer, but it uses an incorrect length value that causes it to access memory that is outside of the bounds of the buffer.",
        "keyphrase_sources": [
          {
            "id": "product:radareorg radare2",
            "keyphrase": "radareorg radare2",
            "type": "product"
          }
        ]
      },
      "similarity": 75.97053641344424
    },
    {
      "metadata": {
        "doc_id": "476",
        "name": "NULL Pointer Dereference",
        "source": "sparse",
        "original_content": "The product dereferences a pointer that it expects to be valid but is NULL.",
        "keyphrase_sources": [
          {
            "id": "product:radareorg radare2",
            "keyphrase": "radareorg radare2",
            "type": "product"
          }
        ]
      },
      "similarity": 74.46745104232448
    },
    {
      "metadata": {
        "doc_id": "119",
        "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
        "source": "sparse",
        "original_content": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
        "keyphrase_sources": [
          {
            "id": "product:radareorg radare2",
            "keyphrase": "radareorg radare2",
            "type": "product"
          },
          {
            "id": "version:before <5.9.9",
            "keyphrase": "before <5.9.9",
            "type": "version"
          }
        ]
      },
      "similarity": 57.34555849002585
    }
  ],
  "identified_cwes": {
    "analyzer": [
      "CWE-125",
      "CWE-131",
      "CWE-682",
      "CWE-193",
      "CWE-788",
      "CWE-126",
      "CWE-191",
      "CWE-1339",
      "CWE-129",
      "CWE-128",
      "CWE-839",
      "CWE-805",
      "CWE-823",
      "CWE-825",
      "CWE-122",
      "CWE-824",
      "CWE-703",
      "CWE-190",
      "CWE-119"
    ],
    "critic_additional": []
  },
  "keyphrase_cwe_mapping": {
    "126": [
      {
        "id": "weakness:heap-based buffer over-read",
        "keyphrase": "heap-based buffer over-read",
        "type": "weakness"
      },
      {
        "id": "weakness:heap-based buffer overflow",
        "keyphrase": "heap-based buffer overflow",
        "type": "weakness"
      },
      {
        "id": "product:radareorg radare2",
        "keyphrase": "radareorg radare2",
        "type": "product"
      },
      {
        "id": "version:before <5.9.9",
        "keyphrase": "before <5.9.9",
        "type": "version"
      }
    ],
    "122": [
      {
        "id": "weakness:heap-based buffer over-read",
        "keyphrase": "heap-based buffer over-read",
        "type": "weakness"
      },
      {
        "id": "weakness:heap-based buffer overflow",
        "keyphrase": "heap-based buffer overflow",
        "type": "weakness"
      },
      {
        "id": "product:radareorg radare2",
        "keyphrase": "radareorg radare2",
        "type": "product"
      },
      {
        "id": "version:before <5.9.9",
        "keyphrase": "before <5.9.9",
        "type": "version"
      }
    ],
    "193": [
      {
        "id": "weakness:heap-based buffer over-read",
        "keyphrase": "heap-based buffer over-read",
        "type": "weakness"
      },
      {
        "id": "weakness:heap-based buffer overflow",
        "keyphrase": "heap-based buffer overflow",
        "type": "weakness"
      },
      {
        "id": "version:before <5.9.9",
        "keyphrase": "before <5.9.9",
        "type": "version"
      }
    ],
    "190": [
      {
        "id": "weakness:heap-based buffer over-read",
        "keyphrase": "heap-based buffer over-read",
        "type": "weakness"
      },
      {
        "id": "weakness:heap-based buffer overflow",
        "keyphrase": "heap-based buffer overflow",
        "type": "weakness"
      },
      {
        "id": "version:before <5.9.9",
        "keyphrase": "before <5.9.9",
        "type": "version"
      }
    ],
    "125": [
      {
        "id": "weakness:heap-based buffer over-read",
        "keyphrase": "heap-based buffer over-read",
        "type": "weakness"
      }
    ],
    "131": [
      {
        "id": "weakness:heap-based buffer overflow",
        "keyphrase": "heap-based buffer overflow",
        "type": "weakness"
      }
    ],
    "805": [
      {
        "id": "product:radareorg radare2",
        "keyphrase": "radareorg radare2",
        "type": "product"
      }
    ],
    "476": [
      {
        "id": "product:radareorg radare2",
        "keyphrase": "radareorg radare2",
        "type": "product"
      }
    ],
    "119": [
      {
        "id": "product:radareorg radare2",
        "keyphrase": "radareorg radare2",
        "type": "product"
      },
      {
        "id": "version:before <5.9.9",
        "keyphrase": "before <5.9.9",
        "type": "version"
      }
    ]
  }
}