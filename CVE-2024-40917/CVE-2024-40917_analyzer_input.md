# Vulnerability Information: CVE-2024-40917

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved memblock make memblock_set_node() also warn about use of MAX_NUMNODES On an (old) x86 system with SRAT just covering space above 4Gb ACPI SRAT Node 0 PXM 0 [mem 0x100000000-0xfffffffff] hotplug the commit referenced below leads to this NUMA configuration no longer being refused by a CONFIG_NUMA=y kernel (previously NUMA nodes only cover 6144MB of your 8185MB e820 RAM. Not used. No NUMA configuration found Faking a node at [mem 0x0000000000000000-0x000000027fffffff] was seen in the log directly after the message quoted above), because of memblock_validate_numa_coverage() checking for NUMA_NO_NODE (only). This in turn led to memblock_alloc_range_nid()s warning about MAX_NUMNODES triggering, followed by a NULL deref in memmap_init() when trying to access node 64s (NODE_SHIFT=6) node data. To compensate said change, make memblock_set_node() warn on and adjust a passed in value of MAX_NUMNODES, just like various other functions already do.

### Vulnerability Description Key Phrases
- **rootcause:** **faking a node at [mem 0x0000000000000000-0x000000027fffffff] was seen**
- **impact:** NULL dereference
- **product:** Linux kernel
- **component:** memblock_set_node()

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of the vulnerability:

**Root Cause:**
The vulnerability arises from a flaw in how the Linux kernel handles NUMA (Non-Uniform Memory Access) configurations on x86 systems with SRAT (System Resource Affinity Table) configurations. Specifically, a recent change (commit ff6c3d81f2e8) optimized NUMA memory detection. This change caused the `memblock_validate_numa_coverage()` to only check for `NUMA_NO_NODE`. In cases where SRAT only covers memory above 4GB, the previous mechanism to refuse this configuration no longer happens, resulting in `memblock_alloc_range_nid()` warning about `MAX_NUMNODES`. Subsequently, this leads to a NULL pointer dereference in `memmap_init()` when it attempts to access node data for the node that has id `MAX_NUMNODES`, which is beyond the valid node ids.

**Weaknesses/Vulnerabilities:**
-   **Incorrect NUMA node assignment:** The kernel incorrectly interprets the NUMA configuration when SRAT only describes memory regions above 4GB. It proceeds with a configuration using a node ID equal to `MAX_NUMNODES` which is not valid.
-   **Lack of proper bounds checking:** There is insufficient validation in `memblock_set_node` when a node id equals `MAX_NUMNODES` is used.
-   **NULL Pointer Dereference:** The vulnerability leads to a NULL pointer dereference when `memmap_init()` tries to access the memory map for the invalid node.

**Impact of Exploitation:**
-   **Kernel crash:** The NULL pointer dereference in `memmap_init()` results in a kernel crash, leading to a denial of service (DoS).

**Attack Vectors:**
-   **System configuration:** The vulnerability is triggered by a specific system configuration: an older x86 system with an SRAT that only covers memory above 4GB.

**Required Attacker Capabilities/Position:**
-   **No direct attacker action is needed**. The vulnerability is triggered by the system's configuration, and arises during the kernel's initialization process.

**Additional Notes:**
- The provided patches address the vulnerability by making `memblock_set_node()` issue a warning and adjust the passed-in `MAX_NUMNODES` value to `NUMA_NO_NODE`, thus preventing the use of the invalid node id.
- The fix aims to prevent the crash and maintain compatibility with the optimized NUMA memory detection logic.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 201 | Insertion of Sensitive Information Into Sent Data | Base | Allowed | sparse | 0.609 |
| 2 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.603 |
| 3 | 214 | Invocation of Process Using Visible Sensitive Information | Base | Allowed | sparse | 0.602 |
| 4 | 863 | Incorrect Authorization | Class | Allowed-with-Review | sparse | 0.585 |
| 5 | 400 | Uncontrolled Resource Consumption | Class | Discouraged | sparse | 0.571 |
| 6 | 1390 | Weak Authentication | Class | Allowed-with-Review | sparse | 0.565 |
| 7 | 476 | NULL Pointer Dereference | Base | Allowed | sparse | 0.560 |
| 8 | 1333 | Inefficient Regular Expression Complexity | Base | Allowed | sparse | 0.560 |
| 9 | 1260 | Improper Handling of Overlap Between Protected Memory Ranges | Base | Allowed | dense | 0.492 |
| 10 | 410 | Insufficient Resource Pool | Base | Allowed | graph | 0.002 |

