{
  "retriever": "graph",
  "query": "In the Linux kernel, the following vulnerability has been resolved md fix mddev uaf while iterating all_mddevs list While iterating all_mddevs list from md_notify_reboot() and md_exit(), list_for_each_entry_safe is used, and this can race with deletint the next mddev, causing UAF t1 spin_lock //list_for_each_entry_safe(mddev, n, ...) mddev_get(mddev1) // assume mddev2 is the next entry spin_unlock t2 //remove mddev2 ... mddev_free spin_lock list_del spin_unlock kfree(mddev2) mddev_put(mddev1) spin_lock //continue dereference mddev2->all_mddevs The old helper for_each_mddev() actually grab the reference of mddev2 while holding the lock, to prevent from being freed. This problem can be fixed the same way, however, the code will be complex. Hence switch to use list_for_each_entry, in this case mddev_put() can free the mddev1 and its not safe as well. Refer to md_seq_show(), also factor out a helper mddev_put_locked() to fix this problem. Consider specifically these CWEs: CWE-366 CWE-367 CWE-476 CWE-416 CWE-362 CWE-909 CWE-667 CWE-833",
  "keyphrases": {
    "original_query": "In the Linux kernel, the following vulnerability has been resolved md fix mddev uaf while iterating all_mddevs list While iterating all_mddevs list from md_notify_reboot() and md_exit(), list_for_each_entry_safe is used, and this can race with deletint the next mddev, causing UAF t1 spin_lock //list_for_each_entry_safe(mddev, n, ...) mddev_get(mddev1) // assume mddev2 is the next entry spin_unlock t2 //remove mddev2 ... mddev_free spin_lock list_del spin_unlock kfree(mddev2) mddev_put(mddev1) spin_lock //continue dereference mddev2->all_mddevs The old helper for_each_mddev() actually grab the reference of mddev2 while holding the lock, to prevent from being freed. This problem can be fixed the same way, however, the code will be complex. Hence switch to use list_for_each_entry, in this case mddev_put() can free the mddev1 and its not safe as well. Refer to md_seq_show(), also factor out a helper mddev_put_locked() to fix this problem.",
    "enhanced_query": "In the Linux kernel, the following vulnerability has been resolved md fix mddev uaf while iterating all_mddevs list While iterating all_mddevs list from md_notify_reboot() and md_exit(), list_for_each_entry_safe is used, and this can race with deletint the next mddev, causing UAF t1 spin_lock //list_for_each_entry_safe(mddev, n, ...) mddev_get(mddev1) // assume mddev2 is the next entry spin_unlock t2 //remove mddev2 ... mddev_free spin_lock list_del spin_unlock kfree(mddev2) mddev_put(mddev1) spin_lock //continue dereference mddev2->all_mddevs The old helper for_each_mddev() actually grab the reference of mddev2 while holding the lock, to prevent from being freed. This problem can be fixed the same way, however, the code will be complex. Hence switch to use list_for_each_entry, in this case mddev_put() can free the mddev1 and its not safe as well. Refer to md_seq_show(), also factor out a helper mddev_put_locked() to fix this problem. Consider specifically these CWEs: CWE-366 CWE-367 CWE-476 CWE-416 CWE-362 CWE-909 CWE-667 CWE-833",
    "cwe_mentions": [
      "CWE-366",
      "CWE-367",
      "CWE-476",
      "CWE-416",
      "CWE-362",
      "CWE-909",
      "CWE-667",
      "CWE-833"
    ],
    "search_time": 3.020794630050659
  },
  "timestamp": "2025-07-12 10:03:32",
  "cve_id": "CVE-2025-22126",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "364",
      "name": "Signal Handler Race Condition",
      "type": "base",
      "score": 2.8651999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "609",
      "name": "Double-Checked Locking",
      "type": "base",
      "score": 2.8651999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "type": "Base",
      "score": 2.802633344890089,
      "relationship_count": 0
    },
    {
      "cwe_id": "123",
      "name": "Write-what-where Condition",
      "type": "base",
      "score": 2.7014000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "386",
      "name": "Symbolic Name not Mapping to Correct Object",
      "type": "base",
      "score": 2.3764000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "1265",
      "name": "Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "1325",
      "name": "Improperly Controlled Sequential Memory Allocation",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "120",
      "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "456",
      "name": "Missing Initialization of a Variable",
      "type": "variant",
      "score": 2.1936,
      "relationship_count": 0
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "type": "Variant",
      "score": 2.1458968796017377,
      "relationship_count": 0
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 1.7527060460496486,
      "relationship_count": 0
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 1.7048841118567908,
      "relationship_count": 0
    },
    {
      "cwe_id": "366",
      "name": "Race Condition within a Thread",
      "type": "Base",
      "score": 1.6999651191745548,
      "relationship_count": 0
    },
    {
      "cwe_id": "367",
      "name": "Time-of-check Time-of-use (TOCTOU) Race Condition",
      "type": "Base",
      "score": 1.6875728309707276,
      "relationship_count": 0
    },
    {
      "cwe_id": "134",
      "name": "Use of Externally-Controlled Format String",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "170",
      "name": "Improper Null Termination",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "61",
      "name": "UNIX Symbolic Link (Symlink) Following",
      "type": "compound",
      "score": 1.61,
      "relationship_count": 0
    },
    {
      "cwe_id": "479",
      "name": "Signal Handler Use of a Non-reentrant Function",
      "type": "variant",
      "score": 1.5552000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "590",
      "name": "Free of Memory not on the Heap",
      "type": "variant",
      "score": 1.5552000000000004,
      "relationship_count": 0
    }
  ]
}