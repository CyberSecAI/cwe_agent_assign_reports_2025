# Vulnerability Information: CVE-2024-50110

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved xfrm fix one more kernel-infoleak in algo dumping During fuzz testing, the following issue was discovered BUG KMSAN kernel-infoleak in _copy_to_iter+0x598/0x2a30 _copy_to_iter+0x598/0x2a30 __skb_datagram_iter+0x168/0x1060 skb_copy_datagram_iter+0x5b/0x220 netlink_recvmsg+0x362/0x1700 sock_recvmsg+0x2dc/0x390 __sys_recvfrom+0x381/0x6d0 __x64_sys_recvfrom+0x130/0x200 x64_sys_call+0x32c8/0x3cc0 do_syscall_64+0xd8/0x1c0 entry_SYSCALL_64_after_hwframe+0x79/0x81 Uninit was stored to memory at copy_to_user_state_extra+0xcc1/0x1e00 dump_one_state+0x28c/0x5f0 xfrm_state_walk+0x548/0x11e0 xfrm_dump_sa+0x1e0/0x840 netlink_dump+0x943/0x1c40 __netlink_dump_start+0x746/0xdb0 xfrm_user_rcv_msg+0x429/0xc00 netlink_rcv_skb+0x613/0x780 xfrm_netlink_rcv+0x77/0xc0 netlink_unicast+0xe90/0x1280 netlink_sendmsg+0x126d/0x1490 __sock_sendmsg+0x332/0x3d0 ____sys_sendmsg+0x863/0xc30 ___sys_sendmsg+0x285/0x3e0 __x64_sys_sendmsg+0x2d6/0x560 x64_sys_call+0x1316/0x3cc0 do_syscall_64+0xd8/0x1c0 entry_SYSCALL_64_after_hwframe+0x79/0x81 Uninit was created at __kmalloc+0x571/0xd30 attach_auth+0x106/0x3e0 xfrm_add_sa+0x2aa0/0x4230 xfrm_user_rcv_msg+0x832/0xc00 netlink_rcv_skb+0x613/0x780 xfrm_netlink_rcv+0x77/0xc0 netlink_unicast+0xe90/0x1280 netlink_sendmsg+0x126d/0x1490 __sock_sendmsg+0x332/0x3d0 ____sys_sendmsg+0x863/0xc30 ___sys_sendmsg+0x285/0x3e0 __x64_sys_sendmsg+0x2d6/0x560 x64_sys_call+0x1316/0x3cc0 do_syscall_64+0xd8/0x1c0 entry_SYSCALL_64_after_hwframe+0x79/0x81 Bytes 328-379 of 732 are uninitialized Memory access of size 732 starts at ffff88800e18e000 Data copied to user address 00007ff30f48aff0 CPU 2 PID 18167 Comm syz-executor.0 Not tainted 6.8.11 #1 Hardware name QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014 Fixes copying of xfrm algorithms where some random data of the structure fields can end up in userspace. Padding in structures may be filled with random (possibly sensitve) data and should never be given directly to user-space. A similar issue was resolved in the commit 8222d5910dae (xfrm Zero padding when dumping algos and encap) Found by Linux Verification Center (linuxtesting.org) with Syzkaller.

### Vulnerability Description Key Phrases
- **rootcause:** **Uninitialized memory being copied to user space when dumping xfrm algorithms.**
- **weakness:** **Padding in structures may contain random or sensitive data, which should not be exposed to user space.**
- **impact:** Information leak of kernel memory to user space.
- **vector:** Netlink interface used for xfrm configuration
- **attacker:** A local attacker with the ability to send netlink messages.
- **product:** Linux Kernel
- **version:** 6.8.11
- **component:** xfrm subsystem

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of the vulnerability:

**Root Cause:**
The vulnerability stems from how the Linux kernel copies `xfrm` (IPsec) algorithm data to userspace. Specifically, the `copy_to_user_auth` function directly copies the `xfrm_algo_auth` structure, including padding bytes, to userspace. These padding bytes may contain uninitialized kernel memory, potentially leaking sensitive information.

**Weaknesses/Vulnerabilities:**
- **Kernel Information Leak:** The primary weakness is the exposure of uninitialized kernel memory to user space. The `memcpy` operation copies the entire `xfrm_algo_auth` struct, including padding, allowing sensitive data to be leaked.
- **Insecure Data Handling:** The kernel directly copies a structure without sanitizing the data, failing to zero out padding or redact sensitive fields.

**Impact of Exploitation:**
- **Information Disclosure:** An attacker can potentially gain access to sensitive data from the kernel memory. While the exact content of this leaked data is not explicitly defined in this text, the description suggests it could be random, and possibly sensitive.
- **Potential for Further Exploitation:**  Knowledge gained from leaked kernel memory might be used to bypass security measures or escalate privileges.

**Attack Vectors:**
- **Netlink Interface:** The vulnerability is triggered when the kernel dumps `xfrm` algorithm information to userspace through the netlink interface. A user can initiate this process by querying the kernel about the currently configured IPsec security associations.

**Required Attacker Capabilities/Position:**
- **Local User:** An attacker needs to have local access to the system to make the necessary Netlink requests. The vulnerability does not seem to be remotely exploitable.
- **Netlink Access:** An attacker also needs the ability to interact with the netlink socket, which might require specific capabilities or privileges, although this is typically accessible to users.

**Technical Details:**
- The vulnerability is located in the `copy_to_user_auth` function within `net/xfrm/xfrm_user.c`.
- The `memcpy` operation is replaced with `strscpy_pad` to copy the algorithm name, and individual assignments to copy other fields of the struct. This prevents the uninitialized padding from being copied.
- The fix also ensures that the `alg_key` field, when redacted, is zeroed out in the user space copy.

**Additional Notes:**
- The fix was identified using Syzkaller, a kernel fuzzer, highlighting the value of fuzzing for finding such vulnerabilities.
- The fix has been backported to stable branches of the Linux Kernel.
- This commit addresses a similar issue that was addressed in a prior commit (8222d5910dae) that zeroed the padding for algos and encap.

In summary, this is a kernel information leak vulnerability within the `xfrm` subsystem. The fix replaces the vulnerable `memcpy` with more secure alternatives to avoid leaking uninitialized padding.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | sparse | 0.714 |
| 2 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.655 |
| 3 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.630 |
| 4 | 226 | Sensitive Information in Resource Not Removed Before Reuse | Base | Allowed | sparse | 0.614 |
| 5 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.609 |
| 6 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | sparse | 0.606 |
| 7 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.605 |
| 8 | 476 | NULL Pointer Dereference | Base | Allowed | sparse | 0.596 |
| 9 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | Allowed | dense | 0.627 |
| 10 | 1339 | Insufficient Precision or Accuracy of a Real Number | Base | Allowed | graph | 0.002 |

