# Vulnerability Information: CVE-2024-41000

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolvedblock/ioctl prefer different overflow checkRunning syzkaller with the newly reintroduced signed integer overflowsanitizer shows this report[ 62.982337] ------------[ cut here ]------------[ 62.985692] cgroup Invalid name[ 62.986211] UBSAN signed-integer-overflow in ../block/ioctl.c3646[ 62.989370] 9pnet_fd p9_fd_create_tcp (7343) problem connecting socket to 127.0.0.1[ 62.992992] 9223372036854775807 + 4095 cannot be represented in type long long[ 62.997827] 9pnet_fd p9_fd_create_tcp (7345) problem connecting socket to 127.0.0.1[ 62.999369] random crng reseeded on system resumption[ 63.000634] GUP no longer grows the stack in syz-executor.2 (7353) 20002000-20003000 (20001000)[ 63.000668] CPU 0 PID 7353 Comm syz-executor.2 Not tainted 6.8.0-rc2-00035-gb3ef86b5a957 #1[ 63.000677] Hardware name QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014[ 63.000682] Call Trace[ 63.000686] [ 63.000731] dump_stack_lvl+0x93/0xd0[ 63.000919] __get_user_pages+0x903/0xd30[ 63.001030] __gup_longterm_locked+0x153e/0x1ba0[ 63.001041] ? _raw_read_unlock_irqrestore+0x17/0x50[ 63.001072] ? try_get_folio+0x29c/0x2d0[ 63.001083] internal_get_user_pages_fast+0x1119/0x1530[ 63.001109] iov_iter_extract_pages+0x23b/0x580[ 63.001206] bio_iov_iter_get_pages+0x4de/0x1220[ 63.001235] iomap_dio_bio_iter+0x9b6/0x1410[ 63.001297] __iomap_dio_rw+0xab4/0x1810[ 63.001316] iomap_dio_rw+0x45/0xa0[ 63.001328] ext4_file_write_iter+0xdde/0x1390[ 63.001372] vfs_write+0x599/0xbd0[ 63.001394] ksys_write+0xc8/0x190[ 63.001403] do_syscall_64+0xd4/0x1b0[ 63.001421] ? arch_exit_to_user_mode_prepare+0x3a/0x60[ 63.001479] entry_SYSCALL_64_after_hwframe+0x6f/0x77[ 63.001535] RIP 00330x7f7fd3ebf539[ 63.001551] Code 28 00 00 00 75 05 48 83 c4 28 c3 e8 f1 14 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48[ 63.001562] RSP 002b00007f7fd32570c8 EFLAGS 00000246 ORIG_RAX 0000000000000001[ 63.001584] RAX ffffffffffffffda RBX 00007f7fd3ff3f80 RCX 00007f7fd3ebf539[ 63.001590] RDX 4db6d1e4f7e43360 RSI 0000000020000000 RDI 0000000000000004[ 63.001595] RBP 00007f7fd3f1e496 R08 0000000000000000 R09 0000000000000000[ 63.001599] R10 0000000000000000 R11 0000000000000246 R12 0000000000000000[ 63.001604] R13 0000000000000006 R14 00007f7fd3ff3f80 R15 00007ffd415ad2b8...[ 63.018142] ---[ end trace ]---Historically, the signed integer overflow sanitizer did not work in thekernel due to its interaction with `-fwrapv` but this has since beenchanged [1] in the newest version of Clang It was re-enabled in thekernel with Commit 557f8c582a9ba8ab (ubsan Reintroduce signed overflowsanitizer).Lets rework this overflow checking logic to not actually perform anoverflow during the check itself, thus avoiding the UBSAN splat.[1] https//github.com/llvm/llvm-project/pull/82432

### Vulnerability Description Key Phrases
- **rootcause:** **Signed integer overflow during overflow check in block/ioctl.c**
- **weakness:** **Incorrect overflow check logic leading to an actual overflow during the check itself.**
- **impact:** Kernel crash due to signed-integer-overflow sanitizer.
- **vector:** ioctl system call with specific parameters.
- **attacker:** Local user.
- **product:** Linux Kernel
- **version:** 6.8.0-rc2-00035-gb3ef86b5a957
- **component:** block/ioctl.c

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of the vulnerability addressed by the commits:

**Root Cause of Vulnerability:**
The vulnerability arises from a signed integer overflow in the `blkpg_do_ioctl` function within the Linux kernel's block layer. Specifically, the code was performing a sum of `p.start` and `p.length` without proper checks, and if this sum overflowed, it would become negative, potentially leading to other issues. The overflow occurred during a check that was intended to ensure that a partition's start and length were valid.

**Weaknesses/Vulnerabilities Present:**
- **Signed Integer Overflow:** The core issue was the potential for a signed integer overflow when calculating `p.start + p.length`. This occurs because the kernel was using a signed long long integer and the values of `p.start` and `p.length` could combine such that they resulted in a negative value due to the overflow, bypassing the check.
- **Incorrect Validation Logic:**  The check `p.start + p.length < 0` was intended to detect an invalid partition range, but it was flawed because it relied on the overflow behavior to trigger, while the overflow was a bug.

**Impact of Exploitation:**
- **Kernel Panic/Crash:** The integer overflow was caught by the UBSAN (Undefined Behavior Sanitizer), which is used for detecting undefined behaviors, indicating the original code would have resulted in a kernel panic.
- **Incorrect Partition Handling:** In a non-debug kernel build without UBSAN, this flaw could have led to incorrect handling of disk partitions due to the bypassed check, potentially resulting in unexpected behavior, data corruption, or other issues.
- **Potential for Further Exploitation:** While this specific overflow was caught, such bugs are generally considered exploitable by an attacker with control over the input values and can potentially lead to arbitrary code execution.

**Attack Vectors:**
- **`BLKPG_ADD_PARTITION` ioctl:** This issue is triggered by the `BLKPG_ADD_PARTITION` ioctl call which takes a start and length of a partition in its arguments, which become the `p.start` and `p.length` variables.
- **User-Space Interaction:** An attacker with the ability to make ioctl calls on a block device can exploit this vulnerability by crafting specific `p.start` and `p.length` values.

**Required Attacker Capabilities/Position:**
- The attacker needs to be able to execute ioctl calls on block devices on the system, which typically requires administrative privileges or a specific capability.
- The attacker also needs to know the required input arguments to trigger this vulnerability.

**Fix:**
The fix replaces the overflow-prone sum check with an equivalent check that doesn't cause an overflow:

```c
-if (p.start < 0 || p.length <= 0 || p.start + p.length < 0)
+if (p.start < 0 || p.length <= 0 || LLONG_MAX - p.length < p.start)
```
The new check `LLONG_MAX - p.length < p.start` achieves the same purpose without relying on overflow behavior which was triggering the UBSAN.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 190 | Integer Overflow or Wraparound | Base | Allowed | alternate_terms | 0.800 |
| 2 | 197 | Numeric Truncation Error | Base | Allowed | sparse | 1.114 |
| 3 | 288 | Authentication Bypass Using an Alternate Path or Channel | Base | Allowed | sparse | 0.934 |
| 4 | 409 | Improper Handling of Highly Compressed Data (Data Amplification) | Base | Allowed | sparse | 0.931 |
| 5 | 121 | Stack-based Buffer Overflow | Variant | Allowed | sparse | 0.853 |
| 6 | 400 | Uncontrolled Resource Consumption | Class | Discouraged | sparse | 0.848 |
| 7 | 126 | Buffer Over-read | Variant | Allowed | sparse | 0.809 |
| 8 | 61 | UNIX Symbolic Link (Symlink) Following | Compound | Allowed | sparse | 0.779 |
| 9 | 191 | Integer Underflow (Wrap or Wraparound) | Base | Allowed | dense | 0.620 |
| 10 | 364 | Signal Handler Race Condition | Base | Allowed | graph | 0.002 |

