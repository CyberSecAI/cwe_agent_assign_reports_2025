{
  "retriever": "graph",
  "query": "In the Linux kernel, the following vulnerability has been resolved ext4 fix off-by-one error in do_split Syzkaller detected a use-after-free issue in ext4_insert_dentry that was caused by out-of-bounds access due to incorrect splitting in do_split. BUG KASAN use-after-free in ext4_insert_dentry+0x36a/0x6d0 fs/ext4/namei.c2109 Write of size 251 at addr ffff888074572f14 by task syz-executor335/5847 CPU 0 UID 0 PID 5847 Comm syz-executor335 Not tainted 6.12.0-rc6-syzkaller-00318-ga9cda7c0ffed #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 10/30/2024 Call Trace __dump_stack lib/dump_stack.c94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c120 print_address_description mm/kasan/report.c377 [inline] print_report+0x169/0x550 mm/kasan/report.c488 kasan_report+0x143/0x180 mm/kasan/report.c601 kasan_check_range+0x282/0x290 mm/kasan/generic.c189 __asan_memcpy+0x40/0x70 mm/kasan/shadow.c106 ext4_insert_dentry+0x36a/0x6d0 fs/ext4/namei.c2109 add_dirent_to_buf+0x3d9/0x750 fs/ext4/namei.c2154 make_indexed_dir+0xf98/0x1600 fs/ext4/namei.c2351 ext4_add_entry+0x222a/0x25d0 fs/ext4/namei.c2455 ext4_add_nondir+0x8d/0x290 fs/ext4/namei.c2796 ext4_symlink+0x920/0xb50 fs/ext4/namei.c3431 vfs_symlink+0x137/0x2e0 fs/namei.c4615 do_symlinkat+0x222/0x3a0 fs/namei.c4641 __do_sys_symlink fs/namei.c4662 [inline] __se_sys_symlink fs/namei.c4660 [inline] __x64_sys_symlink+0x7a/0x90 fs/namei.c4660 do_syscall_x64 arch/x86/entry/common.c52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c83 entry_SYSCALL_64_after_hwframe+0x77/0x7f The following loop is located right above if statement. for (i = count-1 i >= 0 i--) { /* is more than half of this entry in 2nd half of the block? */ if (size + map[i].size/2 > blocksize/2) break size += map[i].size move++ } i in this case could go down to -1, in which case sum of active entries wouldnt exceed half the block size, but previous behaviour would also do split in half if sum would exceed at the very last block, which in case of having too many long name files in a single block could lead to out-of-bounds access and following use-after-free. Found by Linux Verification Center (linuxtesting.org) with Syzkaller. Consider specifically these CWEs: CWE-416 CWE-131 CWE-667 CWE-909 CWE-193 CWE-835 CWE-362 CWE-367",
  "keyphrases": {
    "original_query": "In the Linux kernel, the following vulnerability has been resolved ext4 fix off-by-one error in do_split Syzkaller detected a use-after-free issue in ext4_insert_dentry that was caused by out-of-bounds access due to incorrect splitting in do_split. BUG KASAN use-after-free in ext4_insert_dentry+0x36a/0x6d0 fs/ext4/namei.c2109 Write of size 251 at addr ffff888074572f14 by task syz-executor335/5847 CPU 0 UID 0 PID 5847 Comm syz-executor335 Not tainted 6.12.0-rc6-syzkaller-00318-ga9cda7c0ffed #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 10/30/2024 Call Trace __dump_stack lib/dump_stack.c94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c120 print_address_description mm/kasan/report.c377 [inline] print_report+0x169/0x550 mm/kasan/report.c488 kasan_report+0x143/0x180 mm/kasan/report.c601 kasan_check_range+0x282/0x290 mm/kasan/generic.c189 __asan_memcpy+0x40/0x70 mm/kasan/shadow.c106 ext4_insert_dentry+0x36a/0x6d0 fs/ext4/namei.c2109 add_dirent_to_buf+0x3d9/0x750 fs/ext4/namei.c2154 make_indexed_dir+0xf98/0x1600 fs/ext4/namei.c2351 ext4_add_entry+0x222a/0x25d0 fs/ext4/namei.c2455 ext4_add_nondir+0x8d/0x290 fs/ext4/namei.c2796 ext4_symlink+0x920/0xb50 fs/ext4/namei.c3431 vfs_symlink+0x137/0x2e0 fs/namei.c4615 do_symlinkat+0x222/0x3a0 fs/namei.c4641 __do_sys_symlink fs/namei.c4662 [inline] __se_sys_symlink fs/namei.c4660 [inline] __x64_sys_symlink+0x7a/0x90 fs/namei.c4660 do_syscall_x64 arch/x86/entry/common.c52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c83 entry_SYSCALL_64_after_hwframe+0x77/0x7f The following loop is located right above if statement. for (i = count-1 i >= 0 i--) { /* is more than half of this entry in 2nd half of the block? */ if (size + map[i].size/2 > blocksize/2) break size += map[i].size move++ } i in this case could go down to -1, in which case sum of active entries wouldnt exceed half the block size, but previous behaviour would also do split in half if sum would exceed at the very last block, which in case of having too many long name files in a single block could lead to out-of-bounds access and following use-after-free. Found by Linux Verification Center (linuxtesting.org) with Syzkaller.",
    "enhanced_query": "In the Linux kernel, the following vulnerability has been resolved ext4 fix off-by-one error in do_split Syzkaller detected a use-after-free issue in ext4_insert_dentry that was caused by out-of-bounds access due to incorrect splitting in do_split. BUG KASAN use-after-free in ext4_insert_dentry+0x36a/0x6d0 fs/ext4/namei.c2109 Write of size 251 at addr ffff888074572f14 by task syz-executor335/5847 CPU 0 UID 0 PID 5847 Comm syz-executor335 Not tainted 6.12.0-rc6-syzkaller-00318-ga9cda7c0ffed #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 10/30/2024 Call Trace __dump_stack lib/dump_stack.c94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c120 print_address_description mm/kasan/report.c377 [inline] print_report+0x169/0x550 mm/kasan/report.c488 kasan_report+0x143/0x180 mm/kasan/report.c601 kasan_check_range+0x282/0x290 mm/kasan/generic.c189 __asan_memcpy+0x40/0x70 mm/kasan/shadow.c106 ext4_insert_dentry+0x36a/0x6d0 fs/ext4/namei.c2109 add_dirent_to_buf+0x3d9/0x750 fs/ext4/namei.c2154 make_indexed_dir+0xf98/0x1600 fs/ext4/namei.c2351 ext4_add_entry+0x222a/0x25d0 fs/ext4/namei.c2455 ext4_add_nondir+0x8d/0x290 fs/ext4/namei.c2796 ext4_symlink+0x920/0xb50 fs/ext4/namei.c3431 vfs_symlink+0x137/0x2e0 fs/namei.c4615 do_symlinkat+0x222/0x3a0 fs/namei.c4641 __do_sys_symlink fs/namei.c4662 [inline] __se_sys_symlink fs/namei.c4660 [inline] __x64_sys_symlink+0x7a/0x90 fs/namei.c4660 do_syscall_x64 arch/x86/entry/common.c52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c83 entry_SYSCALL_64_after_hwframe+0x77/0x7f The following loop is located right above if statement. for (i = count-1 i >= 0 i--) { /* is more than half of this entry in 2nd half of the block? */ if (size + map[i].size/2 > blocksize/2) break size += map[i].size move++ } i in this case could go down to -1, in which case sum of active entries wouldnt exceed half the block size, but previous behaviour would also do split in half if sum would exceed at the very last block, which in case of having too many long name files in a single block could lead to out-of-bounds access and following use-after-free. Found by Linux Verification Center (linuxtesting.org) with Syzkaller. Consider specifically these CWEs: CWE-416 CWE-131 CWE-667 CWE-909 CWE-193 CWE-835 CWE-362 CWE-367",
    "cwe_mentions": [
      "CWE-416",
      "CWE-131",
      "CWE-667",
      "CWE-909",
      "CWE-193",
      "CWE-835",
      "CWE-362",
      "CWE-367"
    ],
    "search_time": 3.26265287399292
  },
  "timestamp": "2025-07-14 11:02:12",
  "cve_id": "CVE-2025-23150",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "364",
      "name": "Signal Handler Race Condition",
      "type": "base",
      "score": 2.8651999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "609",
      "name": "Double-Checked Locking",
      "type": "base",
      "score": 2.8651999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "123",
      "name": "Write-what-where Condition",
      "type": "base",
      "score": 2.7014000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "193",
      "name": "Off-by-one Error",
      "type": "Base",
      "score": 2.527447456819222,
      "relationship_count": 0
    },
    {
      "cwe_id": "131",
      "name": "Incorrect Calculation of Buffer Size",
      "type": "Base",
      "score": 2.3837967278189316,
      "relationship_count": 0
    },
    {
      "cwe_id": "386",
      "name": "Symbolic Name not Mapping to Correct Object",
      "type": "base",
      "score": 2.3764000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "1265",
      "name": "Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "120",
      "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "170",
      "name": "Improper Null Termination",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "617",
      "name": "Reachable Assertion",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "1322",
      "name": "Use of Blocking Code in Single-threaded, Non-blocking Context",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "456",
      "name": "Missing Initialization of a Variable",
      "type": "variant",
      "score": 2.1936,
      "relationship_count": 0
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "type": "Variant",
      "score": 2.179572676091664,
      "relationship_count": 0
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 1.7777319555637556,
      "relationship_count": 0
    },
    {
      "cwe_id": "367",
      "name": "Time-of-check Time-of-use (TOCTOU) Race Condition",
      "type": "Base",
      "score": 1.7156906182596106,
      "relationship_count": 0
    },
    {
      "cwe_id": "134",
      "name": "Use of Externally-Controlled Format String",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "1325",
      "name": "Improperly Controlled Sequential Memory Allocation",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "1257",
      "name": "Improper Access Control Applied to Mirrored or Aliased Memory Regions",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "1260",
      "name": "Improper Handling of Overlap Between Protected Memory Ranges",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "128",
      "name": "Wrap-around Error",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    }
  ]
}