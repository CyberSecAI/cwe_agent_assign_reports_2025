## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved netfilter nf_tables unconditionally flush pending work before notifier syzbot reports **KASAN slab-uaf** in nft_ctx_update include/net/netfilter/nf_tables.h1831 **KASAN slab-uaf** in nft_commit_release net/netfilter/nf_tables_api.c9530 **KASAN slab-uaf** int nf_tables_trans_destroy_work+0x152b/0x1750 net/netfilter/nf_tables_api.c9597 Read of size 2 at addr ffff88802b0051c4 by task kworker/11/45 [..] Workqueue events nf_tables_trans_destroy_work Call Trace nft_ctx_update include/net/netfilter/nf_tables.h1831 [inline] nft_commit_release net/netfilter/nf_tables_api.c9530 [inline] nf_tables_trans_destroy_work+0x152b/0x1750 net/netfilter/nf_tables_api.c9597 Problem is that the notifier does a conditional flush, but its possible that the table-to-be-removed is still referenced by transactions being processed by the worker, so we need to flush unconditionally. We could make the flush_work depend on whether we found a table to delete in nf-next to avoid the flush for most cases. AFAICS this problem is only exposed in nf-next, with commit e169285f8c56 (netfilter nf_tables do not store nft_ctx in transaction objects), with this commit applied there is an unconditional fetch of table->family which is whats triggering the above splat.

### Vulnerability Description Key Phrases
- **weakness:** **KASAN slab-uaf**
- **product:** Linux kernel
- **component:** netfilter nf_tables

## CVE Reference Links Content Summary
The provided content relates to CVE-2024-42109.

**Root cause of vulnerability:**
The vulnerability is caused by a conditional flush of pending work related to table removal in the netfilter nf_tables module. When a table is removed, transactions being processed by worker threads might still reference it. The conditional flush doesn't ensure that these transactions complete before the table is completely removed, leading to a use-after-free condition. This issue is exposed in nf-next due to commit e169285f8c56, which changes how `nft_ctx` is handled in transactions, resulting in an unconditional fetch of `table->family` which triggers the vulnerability if the table is already freed.

**Weaknesses/vulnerabilities present:**
- Use-after-free: The primary weakness is a use-after-free condition. Specifically, a table is freed while worker threads may still hold references to it and try to access it.

**Impact of exploitation:**
- Kernel panic/crash: The vulnerability leads to a kernel panic, as evident from the KASAN reports that show slab-uaf errors. This would result in denial of service by crashing the system.
- Potential for arbitrary code execution: While the provided information doesn't detail the ability to leverage this into arbitrary code execution, use-after-free vulnerabilities are often targets for such exploits.

**Attack vectors:**
- Netlink interface: The vulnerability is triggered via the netlink interface, which can be used to manipulate nf_tables configurations, such as creating and deleting tables. An attacker could create a table, then attempt to delete it while worker threads are still processing transactions that reference the table, thus triggering the use-after-free.

**Required attacker capabilities/position:**
- Local or remote access: The attacker needs to be able to send netlink messages to the kernel. This could be achieved via local access or remote access if an interface is exposed (e.g., via network).
- Knowledge of nf_tables: The attacker needs knowledge of how nf_tables works to craft the right sequence of netlink commands to trigger the vulnerability.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 416 | Use After Free | Variant | Allowed | alternate_terms | 0.800 |
| 2 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | sparse | 0.849 |
| 3 | 675 | Multiple Operations on Resource in Single-Operation Context | Class | Allowed-with-Review | sparse | 0.645 |
| 4 | 843 | Access of Resource Using Incompatible Type ('Type Confusion') | Base | Allowed | sparse | 0.614 |
| 5 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.612 |
| 6 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.610 |
| 7 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | sparse | 0.607 |
| 8 | 502 | Deserialization of Untrusted Data | Base | Allowed | sparse | 0.598 |
| 9 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | dense | 0.522 |
| 10 | 364 | Signal Handler Race Condition | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-416: Use After Free

CWE-909: Missing Initialization of Resource

CWE-675: Multiple Operations on Resource in Single-Operation Context

CWE-843: Access of Resource Using Incompatible Type ('Type Confusion')

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-667: Improper Locking

CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer

CWE-502: Deserialization of Untrusted Data

CWE-1284: Improper Validation of Specified Quantity in Input

CWE-364: Signal Handler Race Condition