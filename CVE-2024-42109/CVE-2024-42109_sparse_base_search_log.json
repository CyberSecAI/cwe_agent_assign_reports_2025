{
  "method": "sparse_base",
  "query": "In the Linux kernel, the following vulnerability has been resolved netfilter nf_tables unconditionally flush pending work before notifier syzbot reports KASAN slab-uaf in nft_ctx_update include/net/netfilter/nf_tables.h1831 KASAN slab-uaf in nft_commit_release net/netfilter/nf_tables_api.c9530 KASAN slab-uaf int nf_tables_trans_destroy_work+0x152b/0x1750 net/netfilter/nf_tables_api.c9597 Read of size 2 at addr ffff88802b0051c4 by task kworker/11/45 [..] Workqueue events nf_tables_trans_destroy_work Call Trace nft_ctx_update include/net/netfilter/nf_tables.h1831 [inline] nft_commit_release net/netfilter/nf_tables_api.c9530 [inline] nf_tables_trans_destroy_work+0x152b/0x1750 net/netfilter/nf_tables_api.c9597 Problem is that the notifier does a conditional flush, but its possible that the table-to-be-removed is still referenced by transactions being processed by the worker, so we need to flush unconditionally. We could make the flush_work depend on whether we found a table to delete in nf-next to avoid the flush for most cases. AFAICS this problem is only exposed in nf-next, with commit e169285f8c56 (netfilter nf_tables do not store nft_ctx in transaction objects), with this commit applied there is an unconditional fetch of table->family which is whats triggering the above splat.",
  "keyphrases": {
    "base_query": "In the Linux kernel, the following vulnerability has been resolved netfilter nf_tables unconditionally flush pending work before notifier syzbot reports KASAN slab-uaf in nft_ctx_update include/net/netfilter/nf_tables.h1831 KASAN slab-uaf in nft_commit_release net/netfilter/nf_tables_api.c9530 KASAN slab-uaf int nf_tables_trans_destroy_work+0x152b/0x1750 net/netfilter/nf_tables_api.c9597 Read of size 2 at addr ffff88802b0051c4 by task kworker/11/45 [..] Workqueue events nf_tables_trans_destroy_work Call Trace nft_ctx_update include/net/netfilter/nf_tables.h1831 [inline] nft_commit_release net/netfilter/nf_tables_api.c9530 [inline] nf_tables_trans_destroy_work+0x152b/0x1750 net/netfilter/nf_tables_api.c9597 Problem is that the notifier does a conditional flush, but its possible that the table-to-be-removed is still referenced by transactions being processed by the worker, so we need to flush unconditionally. We could make the flush_work depend on whether we found a table to delete in nf-next to avoid the flush for most cases. AFAICS this problem is only exposed in nf-next, with commit e169285f8c56 (netfilter nf_tables do not store nft_ctx in transaction objects), with this commit applied there is an unconditional fetch of table->family which is whats triggering the above splat."
  },
  "timestamp": "2025-07-12T03:39:08.331170",
  "results_count": 10,
  "results_summary": [
    {
      "doc_id": "909",
      "name": "Missing Initialization of Resource",
      "score": 303.0664222400444
    },
    {
      "doc_id": "675",
      "name": "Multiple Operations on Resource in Single-Operation Context",
      "score": 230.29219222441407
    },
    {
      "doc_id": "843",
      "name": "Access of Resource Using Incompatible Type ('Type Confusion')",
      "score": 219.4023992282038
    },
    {
      "doc_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "score": 218.70095798025125
    },
    {
      "doc_id": "667",
      "name": "Improper Locking",
      "score": 217.92413314752824
    }
  ]
}