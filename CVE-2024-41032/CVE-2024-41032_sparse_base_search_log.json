{
  "method": "sparse_base",
  "query": "In the Linux kernel, the following vulnerability has been resolved mm vmalloc check if a hash-index is in cpu_possible_mask The problem is that there are systems where cpu_possible_mask has gaps between set CPUs, for example SPARC. In this scenario addr_to_vb_xa() hash function can return an index which accesses to not-possible and not setup CPU area using per_cpu() macro. This results in an oops on SPARC. A per-cpu vmap_block_queue is also used as hash table, incorrectly assuming the cpu_possible_mask has no gaps. Fix it by adjusting an index to a next possible CPU.",
  "keyphrases": {
    "base_query": "In the Linux kernel, the following vulnerability has been resolved mm vmalloc check if a hash-index is in cpu_possible_mask The problem is that there are systems where cpu_possible_mask has gaps between set CPUs, for example SPARC. In this scenario addr_to_vb_xa() hash function can return an index which accesses to not-possible and not setup CPU area using per_cpu() macro. This results in an oops on SPARC. A per-cpu vmap_block_queue is also used as hash table, incorrectly assuming the cpu_possible_mask has no gaps. Fix it by adjusting an index to a next possible CPU."
  },
  "timestamp": "2025-07-12T03:21:45.061317",
  "results_count": 10,
  "results_summary": [
    {
      "doc_id": "407",
      "name": "Inefficient Algorithmic Complexity",
      "score": 170.2852353531658
    },
    {
      "doc_id": "328",
      "name": "Use of Weak Hash",
      "score": 158.17633334183486
    },
    {
      "doc_id": "1176",
      "name": "Inefficient CPU Computation",
      "score": 156.34798665228823
    },
    {
      "doc_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "score": 152.74603998482382
    },
    {
      "doc_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "score": 152.33718575002607
    }
  ]
}