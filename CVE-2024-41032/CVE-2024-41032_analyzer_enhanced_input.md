## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved mm vmalloc check if a hash-index is in cpu_possible_mask The problem is that there are systems where cpu_possible_mask has gaps between set CPUs, for example SPARC. In this scenario addr_to_vb_xa() hash function can return an index which accesses to not-possible and not setup CPU area using per_cpu() macro. This results in an oops on SPARC. A per-cpu vmap_block_queue is also used as hash table, incorrectly assuming the cpu_possible_mask has no gaps. Fix it by adjusting an index to a next possible CPU.

### Vulnerability Description Key Phrases
- **rootcause:** **incorrect assumption about cpu_possible_mask**
- **impact:** oops
- **product:** Linux kernel
- **component:** mm vmalloc check

## CVE Reference Links Content Summary
The provided content relates to a vulnerability in the Linux kernel's vmalloc subsystem, specifically how it handles CPU masks when calculating hash indexes for per-CPU data.

**Root Cause of Vulnerability:**

The root cause is an incorrect assumption in the `addr_to_vb_xa()` hash function. It uses `num_possible_cpus()` to calculate the hash index, which doesn't account for systems where `cpu_possible_mask` has gaps between set CPUs (e.g., SPARC). This can result in an index that points to a non-existent CPU area when using the `per_cpu()` macro, causing a kernel oops. The per-cpu `vmap_block_queue` is also incorrectly used as a hash table, assuming no gaps in the `cpu_possible_mask`.

**Weaknesses/Vulnerabilities Present:**

*   **Incorrect Hash Index Calculation:** The hash function does not properly check if the calculated index is within the range of actually available CPUs as indicated by `cpu_possible_mask`.
*   **Use of `num_possible_cpus()`:** The use of `num_possible_cpus()` is inadequate, as it may include CPUs that are not online or that are not part of the active set.
*   **Incorrect Assumption about cpu_possible_mask:** The code assumes that the `cpu_possible_mask` has no gaps, which is not always the case in certain architectures like SPARC.

**Impact of Exploitation:**

*   **Kernel Oops:** Exploiting this vulnerability leads to a kernel oops (a type of kernel panic). This will result in a denial of service because the system will likely crash or become unstable.

**Attack Vectors:**

*   The vulnerability is triggered by the `addr_to_vb_xa()` function, which is part of the vmalloc subsystem. It's triggered when the system allocates memory using vmalloc.

**Required Attacker Capabilities/Position:**

*   An attacker needs to be able to trigger vmalloc allocations, which is commonly done through normal system operations.
*   The attacker doesn't need special privileges beyond the ability to allocate memory.
*   This is a local vulnerability meaning the attacker must have the ability to execute code on the system.

**Fix:**
The fix replaces the use of `num_possible_cpus()` with `nr_cpu_ids` and checks if the index is valid using `cpu_possible(index)`. If not, it adjusts the index to the next possible CPU using `cpumask_next(index, cpu_possible_mask)`. This ensures the index is always valid for systems with gapped CPU masks, thereby avoiding the oops.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 407 | Inefficient Algorithmic Complexity | Class | Allowed-with-Review | sparse | 0.511 |
| 2 | 328 | Use of Weak Hash | Base | Allowed | sparse | 0.480 |
| 3 | 1176 | Inefficient CPU Computation | Class | Allowed-with-Review | sparse | 0.469 |
| 4 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.462 |
| 5 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.461 |
| 6 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | Allowed | sparse | 0.461 |
| 7 | 476 | NULL Pointer Dereference | Base | Allowed | sparse | 0.460 |
| 8 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.456 |
| 9 | 1260 | Improper Handling of Overlap Between Protected Memory Ranges | Base | Allowed | dense | 0.575 |
| 10 | 416 | Use After Free | Variant | Allowed | graph | 0.002 |



# Complete CWE Specifications

CWE-407: Inefficient Algorithmic Complexity

CWE-328: Use of Weak Hash

CWE-1176: Inefficient CPU Computation

CWE-1284: Improper Validation of Specified Quantity in Input

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-1285: Improper Validation of Specified Index, Position, or Offset in Input

CWE-476: NULL Pointer Dereference

CWE-667: Improper Locking

CWE-1260: Improper Handling of Overlap Between Protected Memory Ranges

CWE-416: Use After Free