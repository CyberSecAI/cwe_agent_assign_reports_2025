{
  "method": "sparse_base",
  "query": "In the Linux kernel, the following vulnerability has been resolved bpf Scrub packet on bpf_redirect_peer When bpf_redirect_peer is used to redirect packets to a device in another network namespace, the skb isnt scrubbed. That can lead skb information from one namespace to be misused in another namespace. As one example, this is causing Cilium to drop traffic when using bpf_redirect_peer to redirect packets that just went through IPsec decryption to a container namespace. The following pwru trace shows (1) the packet path from the hosts XFRM layer to the containers XFRM layer where its dropped and (2) the number of active skb extensions at each function. NETNS MARK IFACE TUPLE FUNC 4026533547 d00 eth0 10.244.3.12435473->10.244.2.15853 xfrm_rcv_cb .active_extensions = (__u8)2, 4026533547 d00 eth0 10.244.3.12435473->10.244.2.15853 xfrm4_rcv_cb .active_extensions = (__u8)2, 4026533547 d00 eth0 10.244.3.12435473->10.244.2.15853 gro_cells_receive .active_extensions = (__u8)2, [...] 4026533547 0 eth0 10.244.3.12435473->10.244.2.15853 skb_do_redirect .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 ip_rcv .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 ip_rcv_core .active_extensions = (__u8)2, [...] 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 udp_queue_rcv_one_skb .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 __xfrm_policy_check .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 __xfrm_decode_session .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 security_xfrm_decode_session .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 kfree_skb_reason(SKB_DROP_REASON_XFRM_POLICY) .active_extensions = (__u8)2, In this case, there are no XFRM policies in the containers network namespace so the drop is unexpected. When we decrypt the IPsec packet, the XFRM state used for decryption is set in the skb extensions. This information is preserved across the netns switch. When we reach the XFRM policy check in the containers netns, __xfrm_policy_check drops the packet with LINUX_MIB_XFRMINNOPOLS because a (container-side) XFRM policy cant be found that matches the (host-side) XFRM state used for decryption. This patch fixes this by scrubbing the packet when using bpf_redirect_peer, as is done on typical netns switches via veth devices except skb->mark and skb->tstamp are not zeroed.",
  "keyphrases": {
    "base_query": "In the Linux kernel, the following vulnerability has been resolved bpf Scrub packet on bpf_redirect_peer When bpf_redirect_peer is used to redirect packets to a device in another network namespace, the skb isnt scrubbed. That can lead skb information from one namespace to be misused in another namespace. As one example, this is causing Cilium to drop traffic when using bpf_redirect_peer to redirect packets that just went through IPsec decryption to a container namespace. The following pwru trace shows (1) the packet path from the hosts XFRM layer to the containers XFRM layer where its dropped and (2) the number of active skb extensions at each function. NETNS MARK IFACE TUPLE FUNC 4026533547 d00 eth0 10.244.3.12435473->10.244.2.15853 xfrm_rcv_cb .active_extensions = (__u8)2, 4026533547 d00 eth0 10.244.3.12435473->10.244.2.15853 xfrm4_rcv_cb .active_extensions = (__u8)2, 4026533547 d00 eth0 10.244.3.12435473->10.244.2.15853 gro_cells_receive .active_extensions = (__u8)2, [...] 4026533547 0 eth0 10.244.3.12435473->10.244.2.15853 skb_do_redirect .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 ip_rcv .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 ip_rcv_core .active_extensions = (__u8)2, [...] 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 udp_queue_rcv_one_skb .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 __xfrm_policy_check .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 __xfrm_decode_session .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 security_xfrm_decode_session .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 kfree_skb_reason(SKB_DROP_REASON_XFRM_POLICY) .active_extensions = (__u8)2, In this case, there are no XFRM policies in the containers network namespace so the drop is unexpected. When we decrypt the IPsec packet, the XFRM state used for decryption is set in the skb extensions. This information is preserved across the netns switch. When we reach the XFRM policy check in the containers netns, __xfrm_policy_check drops the packet with LINUX_MIB_XFRMINNOPOLS because a (container-side) XFRM policy cant be found that matches the (host-side) XFRM state used for decryption. This patch fixes this by scrubbing the packet when using bpf_redirect_peer, as is done on typical netns switches via veth devices except skb->mark and skb->tstamp are not zeroed."
  },
  "timestamp": "2025-07-12T13:31:20.210525",
  "results_count": 10,
  "results_summary": [
    {
      "doc_id": "833",
      "name": "Deadlock",
      "score": 480.321724130335
    },
    {
      "doc_id": "770",
      "name": "Allocation of Resources Without Limits or Throttling",
      "score": 428.8705241552001
    },
    {
      "doc_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "score": 427.019502861674
    },
    {
      "doc_id": "244",
      "name": "Improper Clearing of Heap Memory Before Release ('Heap Inspection')",
      "score": 424.67002005046913
    },
    {
      "doc_id": "863",
      "name": "Incorrect Authorization",
      "score": 419.9680431367026
    }
  ]
}