{
  "method": "sparse_combined",
  "query": "In the Linux kernel, the following vulnerability has been resolved thermal/debugfs Fix two locking issues with thermal zone debug With the current thermal zone locking arrangement in the debugfs code, user space can open the mitigations file for a thermal zone before the zones debugfs pointer is set which will result in a NULL pointer dereference in tze_seq_start(). Moreover, thermal_debug_tz_remove() is not called under the thermal zone lock, so it can run in parallel with the other functions accessing the thermal zones struct thermal_debugfs object. Then, it may clear tz->debugfs after one of those functions has checked it and the struct thermal_debugfs object may be freed prematurely. To address the first problem, pass a pointer to the thermal zones struct thermal_debugfs object to debugfs_create_file() in thermal_debug_tz_add() and make tze_seq_start(), tze_seq_next(), tze_seq_stop(), and tze_seq_show() retrieve it from s->private instead of a pointer to the thermal zone object. This will ensure that tz_debugfs will be valid across the mitigations file accesses until thermal_debugfs_remove_id() called by thermal_debug_tz_remove() removes that file. To address the second problem, use tz->lock in thermal_debug_tz_remove() around the tz->debugfs value check (in case the same thermal zone is removed at the same time in two different threads) and its reset to NULL. Cc 6.8+ # 6.8+",
  "keyphrases": {
    "rootcause": [
      "NULL pointer dereference"
    ]
  },
  "timestamp": "2025-07-12T02:13:45.427066",
  "results_count": 11,
  "results_summary": [
    {
      "doc_id": "639",
      "name": "Authorization Bypass Through User-Controlled Key",
      "score": 1024.6233153488424
    },
    {
      "doc_id": "252",
      "name": "Unchecked Return Value",
      "score": 1015.0157233225784
    },
    {
      "doc_id": "476",
      "name": "NULL Pointer Dereference",
      "score": 1008.7186027749492
    },
    {
      "doc_id": "667",
      "name": "Improper Locking",
      "score": 998.0996806827729
    },
    {
      "doc_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "score": 992.1231735076683
    }
  ]
}