{
  "retriever": "sparse",
  "query": "In the Linux kernel, the following vulnerability has been resolved thermal/debugfs Fix two locking issues with thermal zone debug With the current thermal zone locking arrangement in the debugfs code, user space can open the mitigations file for a thermal zone before the zones debugfs pointer is set which will result in a NULL pointer dereference in tze_seq_start(). Moreover, thermal_debug_tz_remove() is not called under the thermal zone lock, so it can run in parallel with the other functions accessing the thermal zones struct thermal_debugfs object. Then, it may clear tz->debugfs after one of those functions has checked it and the struct thermal_debugfs object may be freed prematurely. To address the first problem, pass a pointer to the thermal zones struct thermal_debugfs object to debugfs_create_file() in thermal_debug_tz_add() and make tze_seq_start(), tze_seq_next(), tze_seq_stop(), and tze_seq_show() retrieve it from s->private instead of a pointer to the thermal zone object. This will ensure that tz_debugfs will be valid across the mitigations file accesses until thermal_debugfs_remove_id() called by thermal_debug_tz_remove() removes that file. To address the second problem, use tz->lock in thermal_debug_tz_remove() around the tz->debugfs value check (in case the same thermal zone is removed at the same time in two different threads) and its reset to NULL. Cc 6.8+ # 6.8+",
  "keyphrases": {
    "rootcause": [
      "NULL pointer dereference"
    ]
  },
  "timestamp": "2025-07-12 02:13:45",
  "cve_id": "CVE-2024-36961",
  "result_count": 11,
  "results": [
    {
      "cwe_id": "639",
      "name": "Authorization Bypass Through User-Controlled Key",
      "score": 1024.6233153488424,
      "search_source": "rootcause:NULL pointer dereference"
    },
    {
      "cwe_id": "252",
      "name": "Unchecked Return Value",
      "score": 1015.0157233225784,
      "search_source": "rootcause:NULL pointer dereference"
    },
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "score": 1008.7186027749492,
      "search_source": "rootcause:NULL pointer dereference"
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "score": 998.0996806827729,
      "search_source": "rootcause:NULL pointer dereference"
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "score": 992.1231735076683,
      "search_source": "rootcause:NULL pointer dereference"
    },
    {
      "cwe_id": "415",
      "name": "Double Free",
      "score": 973.2201596990913,
      "search_source": "rootcause:NULL pointer dereference"
    },
    {
      "cwe_id": "1338",
      "name": "Improper Protections Against Hardware Overheating",
      "score": 963.6166153603758,
      "search_source": "rootcause:NULL pointer dereference"
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "score": 960.7450262663438,
      "search_source": "rootcause:NULL pointer dereference"
    },
    {
      "cwe_id": "824",
      "name": "Access of Uninitialized Pointer",
      "score": 942.4923799278582,
      "search_source": "rootcause:NULL pointer dereference"
    },
    {
      "cwe_id": "835",
      "name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
      "score": 935.3199901238663,
      "search_source": "rootcause:NULL pointer dereference"
    },
    {
      "cwe_id": "863",
      "name": "Incorrect Authorization",
      "score": 306.57954318876784,
      "search_source": "base_query"
    }
  ]
}