# Vulnerability Information: CVE-2024-56547

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved rcu/nocb Fix **missed RCU barrier on deoffloading** Currently, running rcutorture test with torture_type=rcu fwd_progress=8 n_barrier_cbs=8 nocbs_nthreads=8 nocbs_toggle=100 onoff_interval=60 test_boost=2, will trigger the following warning WARNING CPU 19 PID 100 at kernel/rcu/tree_nocb.h1061 rcu_nocb_rdp_deoffload+0x292/0x2a0 RIP 0010rcu_nocb_rdp_deoffload+0x292/0x2a0 Call Trace ? __warn+0x7e/0x120 ? rcu_nocb_rdp_deoffload+0x292/0x2a0 ? report_bug+0x18e/0x1a0 ? handle_bug+0x3d/0x70 ? exc_invalid_op+0x18/0x70 ? asm_exc_invalid_op+0x1a/0x20 ? rcu_nocb_rdp_deoffload+0x292/0x2a0 rcu_nocb_cpu_deoffload+0x70/0xa0 rcu_nocb_toggle+0x136/0x1c0 ? __pfx_rcu_nocb_toggle+0x10/0x10 kthread+0xd1/0x100 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x2f/0x50 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 CPU0 CPU2 CPU3 //rcu_nocb_toggle //nocb_cb_wait //rcutorture // deoffload CPU1 // process CPU1s rdp rcu_barrier() rcu_segcblist_entrain() rcu_segcblist_add_len(1) // len == 2 // enqueue barrier // callback to CPU1s // rdp->cblist rcu_do_batch() // invoke CPU1s rdp->cblist // callback rcu_barrier_callback() rcu_barrier() mutex_lock(&rcu_state.barrier_mutex) // still see len == 2 // enqueue barrier callback // to CPU1s rdp->cblist rcu_segcblist_entrain() rcu_segcblist_add_len(1) // len == 3 // decrement len rcu_segcblist_add_len(-2) kthread_parkme() // CPU1s rdp->cblist len == 1 // Warn because there is // still a pending barrier // trigger warning WARN_ON_ONCE(rcu_segcblist_n_cbs(&rdp->cblist)) cpus_read_unlock() // wait CPU1 to comes online and // invoke barrier callback on // CPU1 rdps->cblist wait_for_completion(&rcu_state.barrier_completion) // deoffload CPU4 cpus_read_lock() rcu_barrier() mutex_lock(&rcu_state.barrier_mutex) // block on barrier_mutex // wait rcu_barrier() on // CPU3 to unlock barrier_mutex // but CPU3 unlock barrier_mutex // need to wait CPU1 comes online // when CPU1 going online will block on cpus_write_lock The above scenario will not only trigger a WARN_ON_ONCE(), but also trigger a deadlock. Thanks to nocb locking, a second racing rcu_barrier() on an offline CPU will either observe the decremented callback counter down to 0 and spare the callback enqueue, or rcuo will observe the new callback and keep rdp->nocb_cb_sleep to false. Therefore check rdp->nocb_cb_sleep before parking to make sure no further rcu_barrier() is waiting on the rdp.

### Vulnerability Description Key Phrases
- **rootcause:** **missed RCU barrier on deoffloading**
- **impact:** deadlock
- **product:** Linux kernel

## CVE Reference Links Content Summary
The provided content relates to a fix for a race condition and potential deadlock in the Linux kernel's RCU (Read-Copy-Update) implementation, specifically within the `nocb` (No-Callback) feature.

**Root cause of vulnerability:**
The issue arises during CPU deoffloading within the RCU nocb mechanism. A race condition can occur where a second `rcu_barrier()` on an offline CPU might either incorrectly observe a decremented callback counter, leading to a missed callback enqueue, or `rcuo` might see a new callback, keeping `rdp->nocb_cb_sleep` false. This happens because `kthread_parkme()` isn't preceded by a check of `rdp->nocb_cb_sleep` potentially causing the cpu to park with a pending barrier. This leads to the following problems:
1.  A `WARN_ON_ONCE()` is triggered in `rcu_nocb_rdp_deoffload` when there is still a pending barrier
2.  A deadlock can occur due to the race condition when a CPU tries to come online and blocks on a `cpus_write_lock`

**Weaknesses/vulnerabilities present:**
- Race condition in RCU nocb CPU deoffloading
- Missing check for pending RCU barriers before parking a kthread
- Potential deadlock during CPU online/offline transitions

**Impact of exploitation:**
- Kernel warning (`WARN_ON_ONCE()`)
- Kernel deadlock

**Attack vectors:**
- Triggering the race condition through specific RCU torture test configurations (`torture_type=rcu fwd_progress=8 n_barrier_cbs=8 nocbs_nthreads=8 nocbs_toggle=100 onoff_interval=60 test_boost=2`). This is not a traditional attack vector, but a means of triggering the bug during testing.

**Required attacker capabilities/position:**
- The attacker needs to be able to configure and run the Linux kernel with specific RCU torture test parameters.
- This issue would most likely be triggered by an internal process or kernel module attempting to manage CPU state.

**Technical details**
- The fix involves checking `rdp->nocb_cb_sleep` before parking the kthread using `kthread_parkme()`. If `rdp->nocb_cb_sleep` is true, it indicates there might be a pending barrier callback, so a lock is acquired, the pending callbacks are checked using `WARN_ON_ONCE(rcu_segcblist_n_cbs(&rdp->cblist))`, and then the kthread is parked. This ensures that the CPU doesn't go to sleep with a pending barrier.
- The problematic code was in `kernel/rcu/tree_nocb.h`
- The fix targets the `nocb_cb_wait` function.
- The fix was introduced to address a scenario where a `rcu_barrier()` might sneak in between the barrier callback execution and the callback counter decrement.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 1390 | Weak Authentication | Class | Allowed-with-Review | sparse | 0.722 |
| 2 | 775 | Missing Release of File Descriptor or Handle after Effective Lifetime | Variant | Allowed | sparse | 0.710 |
| 3 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.688 |
| 4 | 230 | Improper Handling of Missing Values | Variant | Allowed | sparse | 0.679 |
| 5 | 400 | Uncontrolled Resource Consumption | Class | Discouraged | sparse | 0.677 |
| 6 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | sparse | 0.667 |
| 7 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.667 |
| 8 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.664 |
| 9 | 833 | Deadlock | Base | Allowed | dense | 0.523 |
| 10 | 364 | Signal Handler Race Condition | Base | Allowed | graph | 0.002 |

