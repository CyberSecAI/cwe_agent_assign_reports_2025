# Raw Retriever Results for CVE-2024-56547

# Raw Retriever Results for CVE-2024-56547
## Query
In the Linux kernel, the following vulnerability has been resolved rcu/nocb Fix missed RCU barrier on deoffloading Currently, running rcutorture test with torture_type=rcu fwd_progress=8 n_barrier_cbs=8 nocbs_nthreads=8 nocbs_toggle=100 onoff_interval=60 test_boost=2, will trigger the following warning WARNING CPU 19 PID 100 at kernel/rcu/tree_nocb.h1061 rcu_nocb_rdp_deoffload+0x292/0x2a0 RIP 0010rcu_nocb_rdp_deoffload+0x292/0x2a0 Call Trace ? __warn+0x7e/0x120 ? rcu_nocb_rdp_deoffload+0x292/0x2a0 ? report_bug+0x18e/0x1a0 ? handle_bug+0x3d/0x70 ? exc_invalid_op+0x18/0x70 ? asm_exc_invalid_op+0x1a/0x20 ? rcu_nocb_rdp_deoffload+0x292/0x2a0 rcu_nocb_cpu_deoffload+0x70/0xa0 rcu_nocb_toggle+0x136/0x1c0 ? __pfx_rcu_nocb_toggle+0x10/0x10 kthread+0xd1/0x100 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x2f/0x50 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 CPU0 CPU2 CPU3 //rcu_nocb_toggle //nocb_cb_wait //rcutorture // deoffload CPU1 // process CPU1s rdp rcu_barrier() rcu_segcblist_entrain() rcu_segcblist_add_len(1) // len == 2 // enqueue barrier // callback to CPU1s // rdp->cblist rcu_do_batch() // invoke CPU1s rdp->cblist // callback rcu_barrier_callback() rcu_barrier() mutex_lock(&rcu_state.barrier_mutex) // still see len == 2 // enqueue barrier callback // to CPU1s rdp->cblist rcu_segcblist_entrain() rcu_segcblist_add_len(1) // len == 3 // decrement len rcu_segcblist_add_len(-2) kthread_parkme() // CPU1s rdp->cblist len == 1 // Warn because there is // still a pending barrier // trigger warning WARN_ON_ONCE(rcu_segcblist_n_cbs(&rdp->cblist)) cpus_read_unlock() // wait CPU1 to comes online and // invoke barrier callback on // CPU1 rdps->cblist wait_for_completion(&rcu_state.barrier_completion) // deoffload CPU4 cpus_read_lock() rcu_barrier() mutex_lock(&rcu_state.barrier_mutex) // block on barrier_mutex // wait rcu_barrier() on // CPU3 to unlock barrier_mutex // but CPU3 unlock barrier_mutex // need to wait CPU1 comes online // when CPU1 going online will block on cpus_write_lock The above scenario will not only trigger a WARN_ON_ONCE(), but also trigger a deadlock. Thanks to nocb locking, a second racing rcu_barrier() on an offline CPU will either observe the decremented callback counter down to 0 and spare the callback enqueue, or rcuo will observe the new callback and keep rdp->nocb_cb_sleep to false. Therefore check rdp->nocb_cb_sleep before parking to make sure no further rcu_barrier() is waiting on the rdp.

## Keyphrases
- **rootcause**: 'missed RCU barrier on deoffloading'

## Score Statistics
| Retriever | Min | Max | Mean | Median | Count |
|-----------|-----|-----|------|--------|-------|
| Dense | 0.4479 | 0.5223 | 0.4681 | 0.4640 | 20 |
| Sparse | 654.6368 | 722.0122 | 678.6164 | 672.1587 | 10 |
| Graph | 1.5271 | 2.2479 | 1.7979 | 1.7039 | 20 |

## Graph Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Mapping Usage |
|---|--------|------|-------------|-------|---------------|
| 1 | 1284 | Improper Validation of Specified Quantity in Input | Base | 2.2479 | Allowed |
| 2 | 410 | Insufficient Resource Pool | base | 2.2100 | Allowed |
| 3 | 772 | Missing Release of Resource after Effective Lifetime | base | 2.2100 | Allowed |
| 4 | 911 | Improper Update of Reference Count | Base | 2.0463 | Allowed |
| 5 | 416 | Use After Free | variant | 2.0400 | Allowed |
| 6 | 120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | base | 1.7680 | Allowed-with-Review |
| 7 | 123 | Write-what-where Condition | base | 1.7680 | Allowed |
| 8 | 364 | Signal Handler Race Condition | base | 1.7550 | Allowed |
| 9 | 789 | Memory Allocation with Excessive Size Value | Variant | 1.7253 | Allowed |
| 10 | 833 | Deadlock | Base | 1.7120 | Allowed |
| 11 | 413 | Improper Resource Locking | Base | 1.6958 | Allowed |
| 12 | 826 | Premature Release of Resource During Expected Lifetime | base | 1.6848 | Allowed |
| 13 | 1265 | Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls | base | 1.6848 | Allowed |
| 14 | 1341 | Multiple Releases of Same Resource or Handle | base | 1.6848 | Allowed |
| 15 | 562 | Return of Stack Variable Address | base | 1.6848 | Allowed |

## Dense Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Original Score | Mapping Usage |
|---|--------|------|-------------|-------|----------------|---------------|
| 1 | 833 | Deadlock | Base | 0.5223 | 0.5223 | Allowed |
| 2 | 667 | Improper Locking | Class | 0.5104 | 0.5104 | Allowed-with-Review |
| 3 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | 0.4890 | 0.4890 | Allowed-with-Review |
| 4 | 413 | Improper Resource Locking | Base | 0.4849 | 0.4849 | Allowed |
| 5 | 911 | Improper Update of Reference Count | Base | 0.4829 | 0.4829 | Allowed |
| 6 | 366 | Race Condition within a Thread | Base | 0.4780 | 0.4780 | Allowed |
| 7 | 909 | Missing Initialization of Resource | Class | 0.4734 | 0.4734 | Allowed-with-Review |
| 8 | 606 | Unchecked Input for Loop Condition | Base | 0.4671 | 0.4671 | Allowed |
| 9 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | 0.4671 | 0.4671 | Allowed |
| 10 | 191 | Integer Underflow (Wrap or Wraparound) | Base | 0.4665 | 0.4665 | Allowed |
| 11 | 1260 | Improper Handling of Overlap Between Protected Memory Ranges | Base | 0.4615 | 0.4615 | Allowed |
| 12 | 126 | Buffer Over-read | Variant | 0.4594 | 0.4594 | Allowed |
| 13 | 1281 | Sequence of Processor Instructions Leads to Unexpected Behavior | Base | 0.4533 | 0.4533 | Allowed |
| 14 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | 0.4533 | 0.4533 | Allowed |
| 15 | 1342 | Information Exposure through Microarchitectural State after Transient Execution | Base | 0.4506 | 0.4506 | Allowed |

## Sparse Retriever Results (10)
| # | CWE ID | Name | Score | Original Score | Mapping Usage |
|---|--------|------|-------|---------------|---------------|
| 1 | 1390 | Weak Authentication | 722.0122 | 722.0122 | Allowed-with-Review |
| 2 | 775 | Missing Release of File Descriptor or Handle after Effective Lifetime | 710.0339 | 710.0339 | Allowed |
| 3 | 1284 | Improper Validation of Specified Quantity in Input | 687.8948 | 687.8948 | Allowed |
| 4 | 230 | Improper Handling of Missing Values | 679.1484 | 679.1484 | Allowed |
| 5 | 400 | Uncontrolled Resource Consumption | 677.1738 | 677.1738 | Discouraged |
| 6 | 789 | Memory Allocation with Excessive Size Value | 667.1436 | 667.1436 | Allowed |
| 7 | 667 | Improper Locking | 667.0543 | 667.0543 | Allowed-with-Review |
| 8 | 125 | Out-of-bounds Read | 663.7807 | 663.7807 | Allowed |
| 9 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | 657.2859 | 657.2859 | Allowed-with-Review |
| 10 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | 654.6368 | 654.6368 | Allowed |
