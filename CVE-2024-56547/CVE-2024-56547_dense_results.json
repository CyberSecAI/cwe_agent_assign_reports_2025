{
  "query": "In the Linux kernel, the following vulnerability has been resolved rcu/nocb Fix missed RCU barrier on deoffloading Currently, running rcutorture test with torture_type=rcu fwd_progress=8 n_barrier_cbs=8 nocbs_nthreads=8 nocbs_toggle=100 onoff_interval=60 test_boost=2, will trigger the following warning WARNING CPU 19 PID 100 at kernel/rcu/tree_nocb.h1061 rcu_nocb_rdp_deoffload+0x292/0x2a0 RIP 0010rcu_nocb_rdp_deoffload+0x292/0x2a0 Call Trace ? __warn+0x7e/0x120 ? rcu_nocb_rdp_deoffload+0x292/0x2a0 ? report_bug+0x18e/0x1a0 ? handle_bug+0x3d/0x70 ? exc_invalid_op+0x18/0x70 ? asm_exc_invalid_op+0x1a/0x20 ? rcu_nocb_rdp_deoffload+0x292/0x2a0 rcu_nocb_cpu_deoffload+0x70/0xa0 rcu_nocb_toggle+0x136/0x1c0 ? __pfx_rcu_nocb_toggle+0x10/0x10 kthread+0xd1/0x100 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x2f/0x50 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 CPU0 CPU2 CPU3 //rcu_nocb_toggle //nocb_cb_wait //rcutorture // deoffload CPU1 // process CPU1s rdp rcu_barrier() rcu_segcblist_entrain() rcu_segcblist_add_len(1) // len == 2 // enqueue barrier // callback to CPU1s // rdp->cblist rcu_do_batch() // invoke CPU1s rdp->cblist // callback rcu_barrier_callback() rcu_barrier() mutex_lock(&rcu_state.barrier_mutex) // still see len == 2 // enqueue barrier callback // to CPU1s rdp->cblist rcu_segcblist_entrain() rcu_segcblist_add_len(1) // len == 3 // decrement len rcu_segcblist_add_len(-2) kthread_parkme() // CPU1s rdp->cblist len == 1 // Warn because there is // still a pending barrier // trigger warning WARN_ON_ONCE(rcu_segcblist_n_cbs(&rdp->cblist)) cpus_read_unlock() // wait CPU1 to comes online and // invoke barrier callback on // CPU1 rdps->cblist wait_for_completion(&rcu_state.barrier_completion) // deoffload CPU4 cpus_read_lock() rcu_barrier() mutex_lock(&rcu_state.barrier_mutex) // block on barrier_mutex // wait rcu_barrier() on // CPU3 to unlock barrier_mutex // but CPU3 unlock barrier_mutex // need to wait CPU1 comes online // when CPU1 going online will block on cpus_write_lock The above scenario will not only trigger a WARN_ON_ONCE(), but also trigger a deadlock. Thanks to nocb locking, a second racing rcu_barrier() on an offline CPU will either observe the decremented callback counter down to 0 and spare the callback enqueue, or rcuo will observe the new callback and keep rdp->nocb_cb_sleep to false. Therefore check rdp->nocb_cb_sleep before parking to make sure no further rcu_barrier() is waiting on the rdp.",
  "count": 20,
  "results": [
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "abstraction": "Base",
      "score": 0.5225067847640074,
      "original_score": 0.5225067847640074,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "abstraction": "Class",
      "score": 0.5103420159870657,
      "original_score": 0.5103420159870657,
      "mapping_usage": "Allowed-with-Review"
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "abstraction": "Class",
      "score": 0.488810330595855,
      "original_score": 0.488810330595855,
      "mapping_usage": "Allowed-with-Review"
    },
    {
      "cwe_id": "413",
      "name": "Improper Resource Locking",
      "abstraction": "Base",
      "score": 0.484886875576085,
      "original_score": 0.484886875576085,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "911",
      "name": "Improper Update of Reference Count",
      "abstraction": "Base",
      "score": 0.48276957029761813,
      "original_score": 0.48276957029761813,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "366",
      "name": "Race Condition within a Thread",
      "abstraction": "Base",
      "score": 0.47791168887374025,
      "original_score": 0.47791168887374025,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "909",
      "name": "Missing Initialization of Resource",
      "abstraction": "Class",
      "score": 0.4732832043826306,
      "original_score": 0.4732832043826306,
      "mapping_usage": "Allowed-with-Review"
    },
    {
      "cwe_id": "835",
      "name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
      "abstraction": "Base",
      "score": 0.46695486899693495,
      "original_score": 0.46695486899693495,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "606",
      "name": "Unchecked Input for Loop Condition",
      "abstraction": "Base",
      "score": 0.4668933069196025,
      "original_score": 0.4668933069196025,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "191",
      "name": "Integer Underflow (Wrap or Wraparound)",
      "abstraction": "Base",
      "score": 0.46625896995925903,
      "original_score": 0.46625896995925903,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "1260",
      "name": "Improper Handling of Overlap Between Protected Memory Ranges",
      "abstraction": "Base",
      "score": 0.46146576838967535,
      "original_score": 0.46146576838967535,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "126",
      "name": "Buffer Over-read",
      "abstraction": "Variant",
      "score": 0.45944312063586323,
      "original_score": 0.45944312063586323,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "1281",
      "name": "Sequence of Processor Instructions Leads to Unexpected Behavior",
      "abstraction": "Base",
      "score": 0.45356453562764876,
      "original_score": 0.45356453562764876,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "367",
      "name": "Time-of-check Time-of-use (TOCTOU) Race Condition",
      "abstraction": "Base",
      "score": 0.4533580795403297,
      "original_score": 0.4533580795403297,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "1342",
      "name": "Information Exposure through Microarchitectural State after Transient Execution",
      "abstraction": "Base",
      "score": 0.45074259135280864,
      "original_score": 0.45074259135280864,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "abstraction": "Base",
      "score": 0.44947837689713976,
      "original_score": 0.44947837689713976,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "119",
      "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
      "abstraction": "Class",
      "score": 0.4489899147673345,
      "original_score": 0.4489899147673345,
      "mapping_usage": "Discouraged"
    },
    {
      "cwe_id": "1331",
      "name": "Improper Isolation of Shared Resources in Network On Chip (NoC)",
      "abstraction": "Base",
      "score": 0.4486074401319887,
      "original_score": 0.4486074401319887,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "401",
      "name": "Missing Release of Memory after Effective Lifetime",
      "abstraction": "Variant",
      "score": 0.44806238402596116,
      "original_score": 0.44806238402596116,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "663",
      "name": "Use of a Non-reentrant Function in a Concurrent Context",
      "abstraction": "Base",
      "score": 0.44795750371471266,
      "original_score": 0.44795750371471266,
      "mapping_usage": "Allowed"
    }
  ],
  "statistics": {
    "min": 0.44795750371471266,
    "max": 0.5225067847640074,
    "mean": 0.4681143665718131,
    "median": 0.4638623691744672,
    "count": 20
  }
}