{
  "cve_id": "CVE-2024-38602",
  "description": "In the Linux kernel, the following vulnerability has been resolved ax25 Fix **reference count leak** issues of ax25_dev The ax25_addr_ax25dev() and ax25_dev_device_down() exist a **reference count leak** issue of the object ax25_dev. **Memory leak** issue in ax25_addr_ax25dev() The reference count of the object ax25_dev can be increased multiple times in ax25_addr_ax25dev(). This will cause a memory leak. **Memory leak** issues in ax25_dev_device_down() The reference count of ax25_dev is set to 1 in ax25_dev_device_up() and then increase the reference count when ax25_dev is added to ax25_dev_list. As a result, the reference count of ax25_dev is 2. But when the device is shutting down. The ax25_dev_device_down() drops the reference count once or twice depending on if we goto unlock_put or not, which will cause memory leak. As for the issue of ax25_addr_ax25dev(), it is impossible for one pointer to be on a list twice. So add a break in ax25_addr_ax25dev(). As for the issue of ax25_dev_device_down(), increase the reference count of ax25_dev once in ax25_dev_device_up() and decrease the reference count of ax25_dev after it is removed from the ax25_dev_list.",
  "key_phrases": {
    "rootcause": "",
    "weakness": [
      "Memory leak",
      "reference count leak"
    ],
    "impact": "memory leak",
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": [
      "ax25_addr_ax25dev()",
      "ax25_dev_device_down()"
    ]
  },
  "reference_content": "Based on the provided information, the content relates to CVE-2024-38602.\n\n**Root cause of vulnerability:**\nThe vulnerability stems from reference count leaks in the `ax25_dev` object within the Linux kernel's AX.25 networking module. Specifically, the functions `ax25_addr_ax25dev()` and `ax25_dev_device_down()` incorrectly manage the reference count of `ax25_dev`, leading to memory leaks.\n\n**Weaknesses/vulnerabilities present:**\n1.  **Multiple reference count increments in `ax25_addr_ax25dev()`:** The `ax25_addr_ax25dev()` function could increment the reference count of an `ax25_dev` object multiple times if the same device address was found multiple times, leading to a memory leak because the object will not be properly freed.\n2.  **Incorrect reference counting in `ax25_dev_device_down()`:** The `ax25_dev_device_up()` function sets the reference count of `ax25_dev` to 1 and then increments it again when adding `ax25_dev` to `ax25_dev_list`, resulting in a reference count of 2. The corresponding shutdown function `ax25_dev_device_down()` then decrements the reference count only once or twice which depending on code path, which could result in a memory leak or use-after-free.\n\n**Impact of exploitation:**\nThe impact is a memory leak. Repeatedly triggering the vulnerable code paths will lead to memory exhaustion, potentially leading to system instability and denial of service.\n\n**Attack vectors:**\nThe attack vectors involve triggering the vulnerable functions. Specifically,\n*   Calling `ax25_addr_ax25dev` multiple times for the same `ax25_dev` will trigger the first vulnerability\n*  Bringing ax25 network devices up and down will trigger the second.\n\n**Required attacker capabilities/position:**\nAn attacker would require the ability to interact with the AX.25 network stack to trigger the vulnerable code paths, meaning they would need some level of control or access to network configuration.",
  "similar_info": {
    "cwe_distribution": {},
    "cwe_consensus": "",
    "similarity_stats": {
      "thresholds": [],
      "total_samples_by_threshold": {},
      "top_cwes_by_threshold": {}
    }
  },
  "similarity_summary": {
    "consensus_cwe": "",
    "top_cwes": [],
    "confidence_levels": {},
    "total_samples": 0
  },
  "analysis": "# Summary\n| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |\n|---|---|---|---|---|---|\n| CWE-911 | Improper Update of Reference Count | 1.0 | Base | Primary | Allowed |\n| CWE-401 | Missing Release of Memory after Effective Lifetime | 0.8 | Base | Secondary | Allowed-with-Review |\n\n## Evidence and Confidence\n\n*   **Confidence Score:** 0.9\n*   **Evidence Strength:** HIGH\n\n## Relationship Analysis\nThe primary weakness identified is **CWE-911 (Improper Update of Reference Count)**. This CWE is at the Base level, which is the preferred level of abstraction. The vulnerability description explicitly mentions \"**reference count leak** issues,\" which aligns directly with the description of CWE-911.\n\nCWE-401 (Missing Release of Memory after Effective Lifetime) is a potential secondary CWE, due to the **memory leak** that occurs.\n\n```mermaid\ngraph TD\n    cwe911[\"CWE-911: Improper Update of Reference Count\"]\n    cwe401[\"CWE-401: Missing Release of Memory after Effective Lifetime\"]\n    cwe404[\"CWE-404: Improper Resource Shutdown or Release\"]\n\n    cwe911 -->|CANPRECEDE| cwe401\n    cwe401 -->|CHILDOF| cwe404\n\n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    classDef tertiary fill:#9e9,stroke:#333\n    class cwe911 primary\n    class cwe401 secondary\n    class cwe404 tertiary\n```\n\n## Vulnerability Chain\nThe vulnerability chain starts with an **improper update of the reference count** (**CWE-911**). When the reference count is not correctly decremented, the memory is not released, leading to a **memory leak** (**CWE-401**), potentially an improper resource shutdown (**CWE-404**).\n\n## Summary of Analysis\nThe analysis is based on the provided evidence, specifically the vulnerability description highlighting \"**reference count leak** issues\" and \"**memory leak**.\" The primary CWE, **CWE-911 (Improper Update of Reference Count)**, directly addresses the root cause of the vulnerability.\n\nThe vulnerability description explicitly states:\n\"ax25 Fix **reference count leak** issues of ax25_dev The ax25_addr_ax25dev() and ax25_dev_device_down() exist a **reference count leak** issue of the object ax25_dev. **Memory leak** issue in ax25_addr_ax25dev() The reference count of the object ax25_dev can be increased multiple times in ax25_addr_ax25dev(). This will cause a memory leak. **Memory leak** issues in ax25_dev_device_down() The reference count of ax25_dev is set to 1 in ax25_dev_device_up() and then increase the reference count when ax25_dev is added to ax25_dev_list. As a result, the reference count of ax25_dev is 2. But when the device is shutting down. The ax25_dev_device_down() drops the reference count once or twice depending on if we goto unlock_put or not, which will cause memory leak.\"\n\n**CWE-911** is at the optimal level of specificity (Base) as it accurately describes the **root cause** of the vulnerability. The high retriever scores for **CWE-911** across all keyphrases further support this decision.\n\n**CWE-401 (Missing Release of Memory after Effective Lifetime)** is considered because the **improper update of the reference count** leads to a **memory leak** which is a result of the resource not being released.\n\nCWEs considered but not used:\n*   CWE-190: Integer Overflow or Wraparound - While present in the retriever results, there is no mention of integer overflows or wraparounds in the vulnerability description.\n*   CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') - There is no mention of race conditions or concurrency issues.\n*   CWE-415: Double Free - There is no mention of the free function being called twice on the same memory address.\n*   CWE-639: Authorization Bypass Through User-Controlled Key - There is no mention of the system's authorization functionality being bypassed.\n*   CWE-404: Improper Resource Shutdown or Release - Considered as a secondary weakness, but the primary focus is on the reference count issue, so it's less directly relevant than CWE-401.\n*   CWE-772: Missing Release of Resource after Effective Lifetime - Similar to CWE-401, but less specific to memory.\n*   CWE-667: Improper Locking - Not related to the root cause or the impact of the vulnerability.\n*   CWE-131: Incorrect Calculation of Buffer Size - Not related to the root cause or the impact of the vulnerability.\n*   CWE-824: Access of Uninitialized Pointer - Not related to the root cause or the impact of the vulnerability.\n*   CWE-226: Sensitive Information in Resource Not Removed Before Reuse - Not related to the root cause or the impact of the vulnerability.\n*   CWE-665: Improper Initialization - Not related to the root cause or the impact of the vulnerability.\n*   CWE-703: Improper Check or Handling of Exceptional Conditions - Too high-level and not specific to the vulnerability.\n*   CWE-909: Missing Initialization of Resource - Not related to the root cause or the impact of the vulnerability.\n*   CWE-754: Improper Check for Unusual or Exceptional Conditions - Not specific to the vulnerability.\n*   CWE-364: Signal Handler Race Condition - Irrelevant to the vulnerability description.\n*   CWE-416: Use After Free - No indication of use-after-free conditions.\n*   CWE-123: Write-what-where Condition - No indication of arbitrary memory writes.\n*   CWE-128: Wrap-around Error - Not applicable to the vulnerability.\n*   CWE-1339: Insufficient Precision or Accuracy of a Real Number - Irrelevant to the vulnerability.\n*   CWE-390: Detection of Error Condition Without Action - Irrelevant to the vulnerability.",
  "analysis_with_relationships": "# Summary\n| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |\n|---|---|---|---|---|---|\n| CWE-911 | Improper Update of Reference Count | 1.0 | Base | Primary | Allowed |\n| CWE-401 | Missing Release of Memory after Effective Lifetime | 0.8 | Base | Secondary | Allowed-with-Review |\n\n## Evidence and Confidence\n\n*   **Confidence Score:** 0.9\n*   **Evidence Strength:** HIGH\n\n## Relationship Analysis\nThe primary weakness identified is **CWE-911 (Improper Update of Reference Count)**. This CWE is at the Base level, which is the preferred level of abstraction. The vulnerability description explicitly mentions \"**reference count leak** issues,\" which aligns directly with the description of CWE-911.\n\nCWE-401 (Missing Release of Memory after Effective Lifetime) is a potential secondary CWE, due to the **memory leak** that occurs.\n\n```mermaid\ngraph TD\n    cwe911[\"CWE-911: Improper Update of Reference Count\"]\n    cwe401[\"CWE-401: Missing Release of Memory after Effective Lifetime\"]\n    cwe404[\"CWE-404: Improper Resource Shutdown or Release\"]\n\n    cwe911 -->|CANPRECEDE| cwe401\n    cwe401 -->|CHILDOF| cwe404\n\n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    classDef tertiary fill:#9e9,stroke:#333\n    class cwe911 primary\n    class cwe401 secondary\n    class cwe404 tertiary\n```\n\n## Vulnerability Chain\nThe vulnerability chain starts with an **improper update of the reference count** (**CWE-911**). When the reference count is not correctly decremented, the memory is not released, leading to a **memory leak** (**CWE-401**), potentially an improper resource shutdown (**CWE-404**).\n\n## Summary of Analysis\nThe analysis is based on the provided evidence, specifically the vulnerability description highlighting \"**reference count leak** issues\" and \"**memory leak**.\" The primary CWE, **CWE-911 (Improper Update of Reference Count)**, directly addresses the root cause of the vulnerability.\n\nThe vulnerability description explicitly states:\n\"ax25 Fix **reference count leak** issues of ax25_dev The ax25_addr_ax25dev() and ax25_dev_device_down() exist a **reference count leak** issue of the object ax25_dev. **Memory leak** issue in ax25_addr_ax25dev() The reference count of the object ax25_dev can be increased multiple times in ax25_addr_ax25dev(). This will cause a memory leak. **Memory leak** issues in ax25_dev_device_down() The reference count of ax25_dev is set to 1 in ax25_dev_device_up() and then increase the reference count when ax25_dev is added to ax25_dev_list. As a result, the reference count of ax25_dev is 2. But when the device is shutting down. The ax25_dev_device_down() drops the reference count once or twice depending on if we goto unlock_put or not, which will cause memory leak.\"\n\n**CWE-911** is at the optimal level of specificity (Base) as it accurately describes the **root cause** of the vulnerability. The high retriever scores for **CWE-911** across all keyphrases further support this decision.\n\n**CWE-401 (Missing Release of Memory after Effective Lifetime)** is considered because the **improper update of the reference count** leads to a **memory leak** which is a result of the resource not being released.\n\nCWEs considered but not used:\n*   CWE-190: Integer Overflow or Wraparound - While present in the retriever results, there is no mention of integer overflows or wraparounds in the vulnerability description.\n*   CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') - There is no mention of race conditions or concurrency issues.\n*   CWE-415: Double Free - There is no mention of the free function being called twice on the same memory address.\n*   CWE-639: Authorization Bypass Through User-Controlled Key - There is no mention of the system's authorization functionality being bypassed.\n*   CWE-404: Improper Resource Shutdown or Release - Considered as a secondary weakness, but the primary focus is on the reference count issue, so it's less directly relevant than CWE-401.\n*   CWE-772: Missing Release of Resource after Effective Lifetime - Similar to CWE-401, but less specific to memory.\n*   CWE-667: Improper Locking - Not related to the root cause or the impact of the vulnerability.\n*   CWE-131: Incorrect Calculation of Buffer Size - Not related to the root cause or the impact of the vulnerability.\n*   CWE-824: Access of Uninitialized Pointer - Not related to the root cause or the impact of the vulnerability.\n*   CWE-226: Sensitive Information in Resource Not Removed Before Reuse - Not related to the root cause or the impact of the vulnerability.\n*   CWE-665: Improper Initialization - Not related to the root cause or the impact of the vulnerability.\n*   CWE-703: Improper Check or Handling of Exceptional Conditions - Too high-level and not specific to the vulnerability.\n*   CWE-909: Missing Initialization of Resource - Not related to the root cause or the impact of the vulnerability.\n*   CWE-754: Improper Check for Unusual or Exceptional Conditions - Not specific to the vulnerability.\n*   CWE-364: Signal Handler Race Condition - Irrelevant to the vulnerability description.\n*   CWE-416: Use After Free - No indication of use-after-free conditions.\n*   CWE-123: Write-what-where Condition - No indication of arbitrary memory writes.\n*   CWE-128: Wrap-around Error - Not applicable to the vulnerability.\n*   CWE-1339: Insufficient Precision or Accuracy of a Real Number - Irrelevant to the vulnerability.\n*   CWE-390: Detection of Error Condition Without Action - Irrelevant to the vulnerability.\n\n\n## CWE Relationship Analysis\n\nCurrent CWEs represent these abstraction levels: .\n\n\n### Vulnerability Chain Analysis\n\n**Chain starting from CWE-390:**\n- 390 (Detection of Error Condition Without Action) - ROOT\n\n\n**Chain starting from CWE-416:**\n- 416 (Use After Free) - ROOT\n\n\n\n### CWE Relationship Diagram\n\n```mermaid\ngraph TD\n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    classDef tertiary fill:#9e9,stroke:#333\n```",
  "criticism": "",
  "resolution": "",
  "relevant_cwes": [
    {
      "metadata": {
        "doc_id": "911",
        "name": "Improper Update of Reference Count",
        "source": "sparse",
        "original_content": "The product uses a reference count to manage a resource, but it does not update or incorrectly updates the reference count.",
        "keyphrase_sources": [
          {
            "id": "weakness:Memory leak",
            "keyphrase": "Memory leak",
            "type": "weakness"
          },
          {
            "id": "weakness:reference count leak",
            "keyphrase": "reference count leak",
            "type": "weakness"
          },
          {
            "id": "impact:memory leak",
            "keyphrase": "memory leak",
            "type": "impact"
          },
          {
            "id": "product:Linux kernel",
            "keyphrase": "Linux kernel",
            "type": "product"
          },
          {
            "id": "component:ax25_addr_ax25dev()",
            "keyphrase": "ax25_addr_ax25dev()",
            "type": "component"
          },
          {
            "id": "component:ax25_dev_device_down()",
            "keyphrase": "ax25_dev_device_down()",
            "type": "component"
          }
        ]
      },
      "similarity": 1277.341978210383
    },
    {
      "metadata": {
        "doc_id": "190",
        "name": "Integer Overflow or Wraparound",
        "source": "sparse",
        "original_content": "The product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.",
        "keyphrase_sources": [
          {
            "id": "weakness:Memory leak",
            "keyphrase": "Memory leak",
            "type": "weakness"
          },
          {
            "id": "weakness:reference count leak",
            "keyphrase": "reference count leak",
            "type": "weakness"
          },
          {
            "id": "impact:memory leak",
            "keyphrase": "memory leak",
            "type": "impact"
          },
          {
            "id": "product:Linux kernel",
            "keyphrase": "Linux kernel",
            "type": "product"
          },
          {
            "id": "component:ax25_addr_ax25dev()",
            "keyphrase": "ax25_addr_ax25dev()",
            "type": "component"
          },
          {
            "id": "component:ax25_dev_device_down()",
            "keyphrase": "ax25_dev_device_down()",
            "type": "component"
          }
        ]
      },
      "similarity": 1002.7754254248769
    },
    {
      "metadata": {
        "doc_id": "401",
        "name": "Missing Release of Memory after Effective Lifetime",
        "source": "sparse",
        "original_content": "The product does not sufficiently track and release allocated memory after it has been used, which slowly consumes remaining memory.",
        "keyphrase_sources": [
          {
            "id": "weakness:Memory leak",
            "keyphrase": "Memory leak",
            "type": "weakness"
          },
          {
            "id": "weakness:reference count leak",
            "keyphrase": "reference count leak",
            "type": "weakness"
          },
          {
            "id": "impact:memory leak",
            "keyphrase": "memory leak",
            "type": "impact"
          },
          {
            "id": "product:Linux kernel",
            "keyphrase": "Linux kernel",
            "type": "product"
          },
          {
            "id": "component:ax25_addr_ax25dev()",
            "keyphrase": "ax25_addr_ax25dev()",
            "type": "component"
          },
          {
            "id": "component:ax25_dev_device_down()",
            "keyphrase": "ax25_dev_device_down()",
            "type": "component"
          }
        ]
      },
      "similarity": 1002.146936937412
    },
    {
      "metadata": {
        "doc_id": "362",
        "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
        "source": "sparse",
        "original_content": "The product contains a concurrent code sequence that requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence operating concurrently.",
        "keyphrase_sources": [
          {
            "id": "weakness:Memory leak",
            "keyphrase": "Memory leak",
            "type": "weakness"
          },
          {
            "id": "weakness:reference count leak",
            "keyphrase": "reference count leak",
            "type": "weakness"
          },
          {
            "id": "impact:memory leak",
            "keyphrase": "memory leak",
            "type": "impact"
          },
          {
            "id": "product:Linux kernel",
            "keyphrase": "Linux kernel",
            "type": "product"
          },
          {
            "id": "component:ax25_addr_ax25dev()",
            "keyphrase": "ax25_addr_ax25dev()",
            "type": "component"
          },
          {
            "id": "component:ax25_dev_device_down()",
            "keyphrase": "ax25_dev_device_down()",
            "type": "component"
          }
        ]
      },
      "similarity": 966.4245577346248
    },
    {
      "metadata": {
        "doc_id": "639",
        "name": "Authorization Bypass Through User-Controlled Key",
        "source": "sparse",
        "original_content": "The system's authorization functionality does not prevent one user from gaining access to another user's data or record by modifying the key value identifying the data.",
        "keyphrase_sources": [
          {
            "id": "weakness:reference count leak",
            "keyphrase": "reference count leak",
            "type": "weakness"
          }
        ]
      },
      "similarity": 931.8091206576074
    },
    {
      "metadata": {
        "doc_id": "415",
        "name": "Double Free",
        "source": "sparse",
        "original_content": "The product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.",
        "keyphrase_sources": [
          {
            "id": "weakness:Memory leak",
            "keyphrase": "Memory leak",
            "type": "weakness"
          },
          {
            "id": "impact:memory leak",
            "keyphrase": "memory leak",
            "type": "impact"
          },
          {
            "id": "product:Linux kernel",
            "keyphrase": "Linux kernel",
            "type": "product"
          },
          {
            "id": "component:ax25_addr_ax25dev()",
            "keyphrase": "ax25_addr_ax25dev()",
            "type": "component"
          },
          {
            "id": "component:ax25_dev_device_down()",
            "keyphrase": "ax25_dev_device_down()",
            "type": "component"
          }
        ]
      },
      "similarity": 928.0961459038543
    }
  ],
  "identified_cwes": {
    "analyzer": [
      "CWE-390",
      "CWE-416",
      "CWE-226",
      "CWE-639",
      "CWE-131",
      "CWE-364",
      "CWE-772",
      "CWE-665",
      "CWE-123",
      "CWE-911",
      "CWE-1339",
      "CWE-415",
      "CWE-128",
      "CWE-667",
      "CWE-401",
      "CWE-824",
      "CWE-703",
      "CWE-404",
      "CWE-909",
      "CWE-190",
      "CWE-362",
      "CWE-754"
    ],
    "critic_additional": []
  },
  "keyphrase_cwe_mapping": {
    "911": [
      {
        "id": "weakness:Memory leak",
        "keyphrase": "Memory leak",
        "type": "weakness"
      },
      {
        "id": "weakness:reference count leak",
        "keyphrase": "reference count leak",
        "type": "weakness"
      },
      {
        "id": "impact:memory leak",
        "keyphrase": "memory leak",
        "type": "impact"
      },
      {
        "id": "product:Linux kernel",
        "keyphrase": "Linux kernel",
        "type": "product"
      },
      {
        "id": "component:ax25_addr_ax25dev()",
        "keyphrase": "ax25_addr_ax25dev()",
        "type": "component"
      },
      {
        "id": "component:ax25_dev_device_down()",
        "keyphrase": "ax25_dev_device_down()",
        "type": "component"
      }
    ],
    "190": [
      {
        "id": "weakness:Memory leak",
        "keyphrase": "Memory leak",
        "type": "weakness"
      },
      {
        "id": "weakness:reference count leak",
        "keyphrase": "reference count leak",
        "type": "weakness"
      },
      {
        "id": "impact:memory leak",
        "keyphrase": "memory leak",
        "type": "impact"
      },
      {
        "id": "product:Linux kernel",
        "keyphrase": "Linux kernel",
        "type": "product"
      },
      {
        "id": "component:ax25_addr_ax25dev()",
        "keyphrase": "ax25_addr_ax25dev()",
        "type": "component"
      },
      {
        "id": "component:ax25_dev_device_down()",
        "keyphrase": "ax25_dev_device_down()",
        "type": "component"
      }
    ],
    "401": [
      {
        "id": "weakness:Memory leak",
        "keyphrase": "Memory leak",
        "type": "weakness"
      },
      {
        "id": "weakness:reference count leak",
        "keyphrase": "reference count leak",
        "type": "weakness"
      },
      {
        "id": "impact:memory leak",
        "keyphrase": "memory leak",
        "type": "impact"
      },
      {
        "id": "product:Linux kernel",
        "keyphrase": "Linux kernel",
        "type": "product"
      },
      {
        "id": "component:ax25_addr_ax25dev()",
        "keyphrase": "ax25_addr_ax25dev()",
        "type": "component"
      },
      {
        "id": "component:ax25_dev_device_down()",
        "keyphrase": "ax25_dev_device_down()",
        "type": "component"
      }
    ],
    "362": [
      {
        "id": "weakness:Memory leak",
        "keyphrase": "Memory leak",
        "type": "weakness"
      },
      {
        "id": "weakness:reference count leak",
        "keyphrase": "reference count leak",
        "type": "weakness"
      },
      {
        "id": "impact:memory leak",
        "keyphrase": "memory leak",
        "type": "impact"
      },
      {
        "id": "product:Linux kernel",
        "keyphrase": "Linux kernel",
        "type": "product"
      },
      {
        "id": "component:ax25_addr_ax25dev()",
        "keyphrase": "ax25_addr_ax25dev()",
        "type": "component"
      },
      {
        "id": "component:ax25_dev_device_down()",
        "keyphrase": "ax25_dev_device_down()",
        "type": "component"
      }
    ],
    "415": [
      {
        "id": "weakness:Memory leak",
        "keyphrase": "Memory leak",
        "type": "weakness"
      },
      {
        "id": "impact:memory leak",
        "keyphrase": "memory leak",
        "type": "impact"
      },
      {
        "id": "product:Linux kernel",
        "keyphrase": "Linux kernel",
        "type": "product"
      },
      {
        "id": "component:ax25_addr_ax25dev()",
        "keyphrase": "ax25_addr_ax25dev()",
        "type": "component"
      },
      {
        "id": "component:ax25_dev_device_down()",
        "keyphrase": "ax25_dev_device_down()",
        "type": "component"
      }
    ],
    "639": [
      {
        "id": "weakness:reference count leak",
        "keyphrase": "reference count leak",
        "type": "weakness"
      }
    ]
  }
}