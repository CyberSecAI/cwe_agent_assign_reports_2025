## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved pinctrl fix **deadlock** in create_pinctrl() when handling -EPROBE_DEFER In create_pinctrl(), pinctrl_maps_mutex is acquired before calling add_setting(). If add_setting() returns -EPROBE_DEFER, create_pinctrl() calls pinctrl_free(). However, pinctrl_free() attempts to acquire pinctrl_maps_mutex, which is already held by create_pinctrl(), leading to a potential **deadlock**. This patch resolves the issue by releasing pinctrl_maps_mutex before calling pinctrl_free(), preventing the **deadlock**. This bug was discovered and resolved using Coverity Static Analysis Security Testing (SAST) by Synopsys, Inc.

### Vulnerability Description Key Phrases
- **rootcause:** **pinctrl_maps_mutex acquired before calling add_setting() and add_setting() returns -EPROBE_DEFER**
- **weakness:** **deadlock**
- **product:** Linux kernel
- **component:** create_pinctrl()

## CVE Reference Links Content Summary
- **Root cause of vulnerability:** A deadlock occurs in the `create_pinctrl()` function when handling the `-EPROBE_DEFER` return value from the `add_setting()` function.
- **Weaknesses/vulnerabilities present:**
    - The `pinctrl_maps_mutex` is acquired before calling `add_setting()`.
    - If `add_setting()` returns `-EPROBE_DEFER`, `create_pinctrl()` calls `pinctrl_free()`.
    - `pinctrl_free()` attempts to acquire `pinctrl_maps_mutex`, which is already held by `create_pinctrl()`, resulting in a deadlock.
-   **Impact of exploitation:** A deadlock scenario is triggered, which can halt the system or make it unresponsive, causing a denial of service.
-   **Attack vectors:** The attack vector involves triggering the scenario where the `add_setting()` function returns `-EPROBE_DEFER` during the `create_pinctrl` process. This can occur when a resource is temporarily unavailable, and the system has not set up the pinctrl subsystem properly.
-   **Required attacker capabilities/position:** An attacker does not require any special capabilities. Triggering the scenario can likely be accomplished by an unprivileged user or by a driver loading a device.

The provided patches modify the `create_pinctrl()` function in `drivers/pinctrl/core.c` to release the `pinctrl_maps_mutex` before calling `pinctrl_free()` if `-EPROBE_DEFER` is returned from `add_setting()`. This prevents the deadlock.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.425 |
| 2 | 833 | Deadlock | Base | Allowed | sparse | 0.418 |
| 3 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.346 |
| 4 | 88 | Improper Neutralization of Argument Delimiters in a Command ('Argument Injection') | Base | Allowed | sparse | 0.307 |
| 5 | 663 | Use of a Non-reentrant Function in a Concurrent Context | Base | Allowed | sparse | 0.304 |
| 6 | 415 | Double Free | Variant | Allowed | sparse | 0.301 |
| 7 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.299 |
| 8 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.299 |
| 9 | 413 | Improper Resource Locking | Base | Allowed | dense | 0.505 |
| 10 | 1265 | Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls | Base | Allowed | graph | 0.002 |



# Complete CWE Specifications

CWE-667: Improper Locking

CWE-833: Deadlock

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-88: Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')

CWE-663: Use of a Non-reentrant Function in a Concurrent Context

CWE-415: Double Free

CWE-401: Missing Release of Memory after Effective Lifetime

CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition

CWE-413: Improper Resource Locking

CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls