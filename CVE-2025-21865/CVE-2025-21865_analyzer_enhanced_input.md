## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved gtp Suppress list corruption splat in gtp_net_exit_batch_rtnl(). Brad Spengler reported the list_del() corruption splat in gtp_net_exit_batch_rtnl(). [0] Commit eb28fd76c0a0 (gtp Destroy device along with udp sockets netns dismantle.) added the for_each_netdev() loop in gtp_net_exit_batch_rtnl() to destroy devices in each netns as done in geneve and ip tunnels. However, this could trigger ->dellink() twice for the same device during ->exit_batch_rtnl(). Say we have two netns A & B and gtp device B that resides in netns B but whose UDP socket is in netns A. 1. cleanup_net() processes netns A and then B. 2. gtp_net_exit_batch_rtnl() finds the device B while iterating netns As gn->gtp_dev_list and calls ->dellink(). [ device B is not yet unlinked from netns B as unregister_netdevice_many() has not been called. ] 3. gtp_net_exit_batch_rtnl() finds the device B while iterating netns Bs for_each_netdev() and calls ->dellink(). gtp_dellink() cleans up the devices hash table, unlinks the dev from gn->gtp_dev_list, and calls unregister_netdevice_queue(). Basically, calling gtp_dellink() multiple times is fine unless CONFIG_DEBUG_LIST is enabled. Lets remove for_each_netdev() in gtp_net_exit_batch_rtnl() and delegate the destruction to default_device_exit_batch() as done in bareudp. [0] list_del corruption, ffff8880aaa62c00->next (autoslab_size_M_dev_P_net_core_dev_11127_8_1328_8_S_4096_A_64_n_139+0xc00/0x1000 [slab object]) is LIST_POISON1 (ffffffffffffff02) (prev is 0xffffffffffffff04) kernel BUG at lib/list_debug.c58! Oops invalid opcode 0000

### Vulnerability Description Key Phrases
- **impact:** kernel BUG and Oops
- **product:** Linux kernel
- **component:** gtp_net_exit_batch_rtnl()

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 415 | Double Free | Variant | Allowed | sparse | 0.264 |
| 2 | 120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | Base | Allowed-with-Review | sparse | 0.262 |
| 3 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.258 |
| 4 | 203 | Observable Discrepancy | Base | Allowed | sparse | 0.257 |
| 5 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.257 |
| 6 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.248 |
| 7 | 335 | Incorrect Usage of Seeds in Pseudo-Random Number Generator (PRNG) | Base | Allowed | sparse | 0.247 |
| 8 | 787 | Out-of-bounds Write | Base | Allowed | sparse | 0.245 |
| 9 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | dense | 0.531 |
| 10 | 123 | Write-what-where Condition | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-415: Double Free

CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')

CWE-770: Allocation of Resources Without Limits or Throttling

CWE-203: Observable Discrepancy

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-667: Improper Locking

CWE-335: Incorrect Usage of Seeds in Pseudo-Random Number Generator (PRNG)

CWE-787: Out-of-bounds Write

CWE-401: Missing Release of Memory after Effective Lifetime

CWE-123: Write-what-where Condition