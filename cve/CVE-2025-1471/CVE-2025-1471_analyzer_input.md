# Vulnerability Information: CVE-2025-1471

## Vulnerability Description
In Eclipse OMR versions 0.2.0 to 0.4.0, some of the z/OS atoe print functions use a **constant length buffer for string conversion**. If the input format string and arguments are larger than the buffer size then **buffer overflow** occurs. Beginning in version 0.5.0, the conversion buffers are sized correctly and checked appropriately to prevent **buffer overflow**s.

### Vulnerability Description Key Phrases
- **rootcause:** **constant length buffer for string conversion**
- **weakness:** **buffer overflow**
- **product:** Eclipse OMR
- **version:** 0.2.0 to 0.4.0
- **component:** z/OS atoe print functions

## CVE Reference Links Content Summary
## Analysis of CVE-2025-1471 Content (github.com_df29b1a0_20250624_130257.html)

This content **IS RELATED** to a potential vulnerability, though it doesn't explicitly reference CVE-2025-1471. It details a fix for a buffer overflow issue in the eclipse-omr project.  It provides more detail than a typical CVE description.

**Root cause of vulnerability:**

The `atoe` methods were using a constant length buffer for string conversion.

**Weaknesses/vulnerabilities present:**

*   **Buffer Overflow:** If the input format string and arguments were larger than the constant length buffer, a buffer overflow would occur.

**Impact of exploitation:**

The content doesn't explicitly state the impact, but a buffer overflow could lead to crashes, denial of service, or potentially arbitrary code execution.

**Attack vectors:**

An attacker could provide a format string and arguments to the `atoe` methods that exceed the buffer size, triggering the overflow.

**Required attacker capabilities/position:**

The attacker needs to be able to control the input to the `atoe` methods. The specific requirements depend on where these methods are called within the application.

**Mitigation or fix:**

The bug was fixed by:

1.  Calling `atoe_vsnprintf` with a `NULL` buffer to determine the required buffer size.
2.  Creating a buffer of the required size.
3.  Writing the formatted string into the newly allocated buffer.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | alternate_terms | 1.000 |
| 2 | 190 | Integer Overflow or Wraparound | Base | Allowed | alternate_terms | 0.800 |
| 3 | 120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | Base | Allowed-with-Review | alternate_terms | 0.700 |
| 4 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.400 |
| 5 | 681 | Incorrect Conversion between Numeric Types | Base | Allowed | sparse | 0.391 |
| 6 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.387 |
| 7 | 193 | Off-by-one Error | Base | Allowed | sparse | 0.373 |
| 8 | 124 | Buffer Underwrite ('Buffer Underflow') | Base | Allowed | sparse | 0.369 |
| 9 | 806 | Buffer Access Using Size of Source Buffer | Variant | Allowed | dense | 0.462 |
| 10 | 1339 | Insufficient Precision or Accuracy of a Real Number | Base | Allowed | graph | 0.003 |

