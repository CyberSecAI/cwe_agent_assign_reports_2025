## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved tcp/dccp Dont use timer_pending() in reqsk_queue_unlink(). Martin KaFai Lau reported use-after-free [0] in reqsk_timer_handler(). We are seeing a use-after-free from a bpf prog attached to trace_tcp_retransmit_synack. The program passes the req->sk to the bpf_sk_storage_get_tracing kernel helper which does check for null before using it. The commit 83fccfc3940c (inet fix potential deadlock in reqsk_queue_unlink()) added timer_pending() in reqsk_queue_unlink() not to call del_timer_sync() from reqsk_timer_handler(), but it introduced a small race window. Before the timer is called, expire_timers() calls detach_timer(timer, true) to clear timer->entry.pprev and marks it as not pending. If reqsk_queue_unlink() checks timer_pending() just after expire_timers() calls detach_timer(), TCP will miss del_timer_sync() the reqsk timer will continue running and send multiple SYN+ACKs until it expires. The reported UAF could happen if req->sk is close()d earlier than the timer expiration, which is 63s by default. The scenario would be 1. inet_csk_complete_hashdance() calls inet_csk_reqsk_queue_drop(), but del_timer_sync() is missed 2. reqsk timer is executed and scheduled again 3. req->sk is accept()ed and reqsk_put() decrements rsk_refcnt, but reqsk timer still has another one, and inet_csk_accept() does not clear req->sk for non-TFO sockets 4. sk is close()d 5. reqsk timer is executed again, and BPF touches req->sk Lets not use timer_pending() by passing the caller context to __inet_csk_reqsk_queue_drop(). Note that reqsk timer is pinned, so the issue does not happen in most use cases. [1] [0] BUG KFENCE use-after-free read in bpf_sk_storage_get_tracing+0x2e/0x1b0 Use-after-free read at 0x00000000a891fb3a (in kfence-#1) bpf_sk_storage_get_tracing+0x2e/0x1b0 bpf_prog_5ea3e95db6da0438_tcp_retransmit_synack+0x1d20/0x1dda bpf_trace_run2+0x4c/0xc0 tcp_rtx_synack+0xf9/0x100 reqsk_timer_handler+0xda/0x3d0 run_timer_softirq+0x292/0x8a0 irq_exit_rcu+0xf5/0x320 sysvec_apic_timer_interrupt+0x6d/0x80 asm_sysvec_apic_timer_interrupt+0x16/0x20 intel_idle_irq+0x5a/0xa0 cpuidle_enter_state+0x94/0x273 cpu_startup_entry+0x15e/0x260 start_secondary+0x8a/0x90 secondary_startup_64_no_verify+0xfa/0xfb kfence-#1 0x00000000a72cc7b6-0x00000000d97616d9, size=2376, cache=TCPv6 allocated by task 0 on cpu 9 at 260507.901592s sk_prot_alloc+0x35/0x140 sk_clone_lock+0x1f/0x3f0 inet_csk_clone_lock+0x15/0x160 tcp_create_openreq_child+0x1f/0x410 tcp_v6_syn_recv_sock+0x1da/0x700 tcp_check_req+0x1fb/0x510 tcp_v6_rcv+0x98b/0x1420 ipv6_list_rcv+0x2258/0x26e0 napi_complete_done+0x5b1/0x2990 mlx5e_napi_poll+0x2ae/0x8d0 net_rx_action+0x13e/0x590 irq_exit_rcu+0xf5/0x320 common_interrupt+0x80/0x90 asm_common_interrupt+0x22/0x40 cpuidle_enter_state+0xfb/0x273 cpu_startup_entry+0x15e/0x260 start_secondary+0x8a/0x90 secondary_startup_64_no_verify+0xfa/0xfb freed by task 0 on cpu 9 at 260507.927527s rcu_core_si+0x4ff/0xf10 irq_exit_rcu+0xf5/0x320 sysvec_apic_timer_interrupt+0x6d/0x80 asm_sysvec_apic_timer_interrupt+0x16/0x20 cpuidle_enter_state+0xfb/0x273 cpu_startup_entry+0x15e/0x260 start_secondary+0x8a/0x90 secondary_startup_64_no_verify+0xfa/0xfb

### Vulnerability Description Key Phrases
- **rootcause:** **The commit 83fccfc3940c introduced a race condition by using timer_pending() in reqsk_queue_unlink(), which could lead to missing del_timer_sync() calls, and subsequently, a use-after-free.**
- **weakness:** **Race condition in timer handling within reqsk_queue_unlink(). The check for timer_pending() can return an incorrect value if it happens immediately after detach_timer(), leading to the timer not being properly cancelled. The use of a bpf prog attached to trace_tcp_retransmit_synack triggers the bug.**
- **impact:** Use-after-free vulnerability, which could lead to system instability or crash. The vulnerability is triggered if the req->sk is close()d before the timer expires, causing the BPF program to access the freed memory.
- **vector:** The vulnerability is triggered through the TCP stack when a connection is established using SYN cookies (TFO sockets may not clear req->sk). Specifically, during retransmission of SYN+ACK when a bpf program is attached to trace_tcp_retransmit_synack.
- **attacker:** An attacker could trigger the vulnerability by establishing multiple TCP connections and forcing retransmissions of SYN-ACKs, eventually triggering the race condition which leads to the UAF.
- **product:** Linux Kernel
- **version:** Likely present in versions with commit 83fccfc3940c and before the fix
- **component:** TCP/IP Stack, specifically the reqsk timer and related functions (reqsk_queue_unlink, reqsk_timer_handler, inet_csk_complete_hashdance, inet_csk_reqsk_queue_drop, etc)

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of the vulnerability:

**Root Cause:**
The vulnerability stems from a race condition introduced by the commit `83fccfc3940c`, which aimed to fix a potential deadlock in `reqsk_queue_unlink()`. This commit added a check using `timer_pending()` to avoid calling `del_timer_sync()` from `reqsk_timer_handler()`. However, a race window exists where `reqsk_queue_unlink()` might check `timer_pending()` immediately after `expire_timers()` calls `detach_timer()`, which clears the timer's pending status, causing `del_timer_sync()` to be skipped.

**Weaknesses/Vulnerabilities:**
- **Race Condition:** A race condition exists between `expire_timers()` detaching a timer and `reqsk_queue_unlink()` checking if the timer is pending.
- **Use-After-Free:** If `del_timer_sync()` is skipped, the request socket (req) timer continues running, potentially accessing the socket (req->sk) after it has been closed, leading to a use-after-free.

**Impact of Exploitation:**
- **Use-After-Free:** Exploitation results in a use-after-free condition when a BPF program attached to `trace_tcp_retransmit_synack` tries to access the freed socket via `req->sk`.
- **Kernel Crash:** The use-after-free can lead to a kernel crash due to accessing invalid memory.
- **Potential for other issues:** The missed `del_timer_sync()` can cause the timer to run again, sending multiple SYN+ACKs and potentially leading to other unexpected behavior.

**Attack Vectors:**
- **BPF Program:** A malicious or buggy BPF program attached to `trace_tcp_retransmit_synack` can trigger the vulnerability.
- **TCP Connection Handling:** The vulnerability is triggered during specific TCP connection handling scenarios involving retransmissions, connection completion, and socket closing.

**Required Attacker Capabilities/Position:**
- **Kernel Code Execution:** The attacker needs to be able to load and attach a BPF program that uses `bpf_sk_storage_get_tracing` to `trace_tcp_retransmit_synack`. This may require root or admin privileges.
- **Network Activity:** The attacker also needs to be able to initiate TCP connections that lead to retransmissions and trigger the race condition, which is a fairly common scenario.

**Technical Details:**
- The vulnerability occurs because `reqsk_queue_unlink()` uses `timer_pending()` which can return a false negative after `detach_timer()` is called by `expire_timers()`.
- The `reqsk` timer is pinned, which means the issue might not occur in all use cases, but the race condition can still occur.
- The `req->sk` is not cleared in non-TFO sockets after `accept()` and `reqsk_put()`, making the UAF possible if the socket is closed while the timer is still running.

The provided patches address this by modifying `inet_csk_reqsk_queue_drop` to accept a `from_timer` argument. When called from timer context (i.e. `reqsk_timer_handler`), the timer will not be deleted again. In other cases, it will use `timer_delete_sync()` instead of `timer_pending` to avoid the race condition. This ensures the timer is always properly cleaned up.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | alternate_terms | 0.800 |
| 2 | 416 | Use After Free | Variant | Allowed | alternate_terms | 0.800 |
| 3 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 1.179 |
| 4 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 1.154 |
| 5 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 1.148 |
| 6 | 863 | Incorrect Authorization | Class | Allowed-with-Review | sparse | 1.100 |
| 7 | 364 | Signal Handler Race Condition | Base | Allowed | sparse | 1.086 |
| 8 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 1.082 |
| 9 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | dense | 0.565 |
| 10 | 609 | Double-Checked Locking | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-416: Use After Free

CWE-667: Improper Locking

CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition

CWE-401: Missing Release of Memory after Effective Lifetime

CWE-863: Incorrect Authorization

CWE-364: Signal Handler Race Condition

CWE-1284: Improper Validation of Specified Quantity in Input

CWE-909: Missing Initialization of Resource

CWE-609: Double-Checked Locking