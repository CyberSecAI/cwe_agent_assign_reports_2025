# Vulnerability Information: CVE-2024-40910

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved ax25 Fix **refcount imbalance** on inbound connections When releasing a socket in ax25_release(), we call netdev_put() to decrease the refcount on the associated ax.25 device. However, the execution path for accepting an incoming connection never calls netdev_hold(). This imbalance leads to refcount errors, and ultimately to kernel crashes. A typical call trace for the above situation will start with one of the following errors refcount_t decrement hit 0 leaking memory. refcount_t underflow use-after-free. And will then have a trace like Call Trace ? show_regs+0x64/0x70 ? __warn+0x83/0x120 ? refcount_warn_saturate+0xb2/0x100 ? report_bug+0x158/0x190 ? prb_read_valid+0x20/0x30 ? handle_bug+0x3e/0x70 ? exc_invalid_op+0x1c/0x70 ? asm_exc_invalid_op+0x1f/0x30 ? refcount_warn_saturate+0xb2/0x100 ? refcount_warn_saturate+0xb2/0x100 ax25_release+0x2ad/0x360 __sock_release+0x35/0xa0 sock_close+0x19/0x20 [...] On reboot (or any attempt to remove the interface), the kernel gets stuck in an infinite loop unregister_netdevice waiting for ax0 to become free. Usage count = 0 This patch corrects these issues by ensuring that we call netdev_hold() and ax25_dev_hold() for new connections in ax25_accept(). This makes the logic leading to ax25_accept() match the logic for ax25_bind() in both cases we increment the refcount, which

### Vulnerability Description Key Phrases
- **rootcause:** **refcount imbalance**
- **impact:** kernel crashes and infinite loop
- **product:** Linux kernel
- **component:** ax25

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of the vulnerability:

**Root Cause:**
The root cause of the vulnerability is a refcount imbalance in the ax25 networking module of the Linux kernel. When a socket is released in `ax25_release()`, `netdev_put()` is called to decrement the reference count on the associated ax.25 device. However, the code path for accepting incoming connections in `ax25_accept()` was missing a corresponding call to `netdev_hold()` to increment the reference count. This discrepancy leads to a refcount imbalance.

**Weaknesses/Vulnerabilities:**
- **Refcount Imbalance:** The primary vulnerability is a missing reference count increment when accepting incoming ax25 connections, specifically on the network device.
- **Use-after-free:**  The refcount imbalance can lead to a use-after-free condition when the network device's refcount drops to zero prematurely.

**Impact of Exploitation:**
- **Kernel Crash:** The refcount errors can lead to kernel crashes, with messages like "refcount_t: decrement hit 0; leaking memory." or "refcount_t: underflow; use-after-free."
- **Infinite Loop on Interface Removal:** When trying to remove or unregister the network interface, the kernel may get stuck in an infinite loop, unable to proceed.

**Attack Vectors:**
- **Inbound Connections:** The vulnerability is triggered by accepting incoming ax25 connections.
- **Triggering Socket Release:** Closing a socket after accepting an incoming connection triggers the vulnerability.

**Required Attacker Capabilities/Position:**
- An attacker needs to be able to send ax25 connection requests to a vulnerable system.

**Additional Notes:**
- The fix ensures that `netdev_hold()` and `ax25_dev_hold()` are called in `ax25_accept()` for new connections, matching the logic of `ax25_bind()`. This ensures that reference counts are appropriately managed and decremented in `ax25_release()`.
- The provided information includes multiple commits that resolve the same issue. This highlights the vulnerability's severity.
- The vulnerability was present in the Linux kernel's ax25 networking implementation, specifically in the `af_ax25.c` file.
- The issue is resolved by adding 2 calls: `netdev_hold(ax25_dev->dev, &ax25->dev_tracker, GFP_ATOMIC);` and `ax25_dev_hold(ax25_dev);` in `ax25_accept()`.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 415 | Double Free | Variant | Allowed | sparse | 0.830 |
| 2 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.763 |
| 3 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | Allowed | sparse | 0.755 |
| 4 | 911 | Improper Update of Reference Count | Base | Allowed | sparse | 0.755 |
| 5 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.746 |
| 6 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.721 |
| 7 | 617 | Reachable Assertion | Base | Allowed | sparse | 0.715 |
| 8 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.711 |
| 9 | 833 | Deadlock | Base | Allowed | dense | 0.517 |
| 10 | 364 | Signal Handler Race Condition | Base | Allowed | graph | 0.003 |

