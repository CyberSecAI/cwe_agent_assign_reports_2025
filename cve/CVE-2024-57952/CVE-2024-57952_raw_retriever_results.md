# Raw Retriever Results for CVE-2024-57952

# Raw Retriever Results for CVE-2024-57952
## Query
In the Linux kernel, the following vulnerability has been resolved Revert libfs fix infinite directory reads for offset dir The current directory offset allocator (based on mtree_alloc_cyclic) stores the next offset value to return in octx->next_offset. This mechanism typically returns values that increase monotonically over time. Eventually, though, the newly allocated offset value wraps back to a low number (say, 2) which is smaller than other already- allocated offset values. Yu Kuai reports that, after commit 64a7ce76fb90 (libfs fix infinite directory reads for offset dir), if a directorys offset allocator wraps, existing entries are no longer visible via readdir/getdents because offset_readdir() stops listing entries once an entrys offset is larger than octx->next_offset. These entries vanish persistently -- they can be looked up, but will never again appear in readdir(3) output. The reason for this is that the commit treats directory offsets as monotonically increasing integer values rather than opaque cookies, and introduces this comparison if (dentry2offset(dentry) >= last_index) { On 64-bit platforms, the directory offset value upper bound is 2^63 - 1. Directory offsets will monotonically increase for millions of years without wrapping. On 32-bit platforms, however, LONG_MAX is 2^31 - 1. The allocator can wrap after only a few weeks (at worst). Revert commit 64a7ce76fb90 (libfs fix infinite directory reads for offset dir) to prepare for a fix that can work properly on 32-bit systems and might apply to recent LTS kernels where shmem employs the simple_offset mechanism.

## Keyphrases
- **rootcause**: 'directory offset value wraps back'

## Score Statistics
| Retriever | Min | Max | Mean | Median | Count |
|-----------|-----|-----|------|--------|-------|
| Dense | 0.4464 | 0.5098 | 0.4660 | 0.4634 | 20 |
| Sparse | 279.7508 | 1117.2815 | 879.9494 | 901.7429 | 11 |
| Graph | 1.6848 | 2.8678 | 2.2031 | 2.2100 | 20 |

## Graph Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Mapping Usage |
|---|--------|------|-------------|-------|---------------|
| 1 | 839 | Numeric Range Comparison Without Minimum Check | base | 2.8678 | Allowed |
| 2 | 823 | Use of Out-of-range Pointer Offset | Base | 2.8186 | Allowed |
| 3 | 125 | Out-of-bounds Read | Base | 2.7970 | Allowed |
| 4 | 129 | Improper Validation of Array Index | variant | 2.6784 | Allowed |
| 5 | 190 | Integer Overflow or Wraparound | Base | 2.4910 | Allowed |
| 6 | 128 | Wrap-around Error | base | 2.3868 | Allowed |
| 7 | 1339 | Insufficient Precision or Accuracy of a Real Number | base | 2.3868 | Allowed |
| 8 | 781 | Improper Address Validation in IOCTL with METHOD_NEITHER I/O Control Code | variant | 2.2704 | Allowed |
| 9 | 124 | Buffer Underwrite ('Buffer Underflow') | base | 2.2100 | Allowed |
| 10 | 787 | Out-of-bounds Write | base | 2.2100 | Allowed |
| 11 | 824 | Access of Uninitialized Pointer | base | 2.2100 | Allowed |
| 12 | 772 | Missing Release of Resource after Effective Lifetime | base | 2.2100 | Allowed |
| 13 | 1322 | Use of Blocking Code in Single-threaded, Non-blocking Context | base | 2.2100 | Allowed |
| 14 | 195 | Signed to Unsigned Conversion Error | variant | 2.0400 | Allowed |
| 15 | 170 | Improper Null Termination | base | 1.7680 | Allowed |

## Dense Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Original Score | Mapping Usage |
|---|--------|------|-------------|-------|----------------|---------------|
| 1 | 823 | Use of Out-of-range Pointer Offset | Base | 0.5098 | 0.5098 | Allowed |
| 2 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | 0.4966 | 0.4966 | Allowed |
| 3 | 190 | Integer Overflow or Wraparound | Base | 0.4841 | 0.4841 | Allowed |
| 4 | 911 | Improper Update of Reference Count | Base | 0.4777 | 0.4777 | Allowed |
| 5 | 191 | Integer Underflow (Wrap or Wraparound) | Base | 0.4725 | 0.4725 | Allowed |
| 6 | 126 | Buffer Over-read | Variant | 0.4707 | 0.4707 | Allowed |
| 7 | 909 | Missing Initialization of Resource | Class | 0.4695 | 0.4695 | Allowed-with-Review |
| 8 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | 0.4694 | 0.4694 | Allowed-with-Review |
| 9 | 62 | UNIX Hard Link | Variant | 0.4679 | 0.4679 | Allowed |
| 10 | 193 | Off-by-one Error | Base | 0.4671 | 0.4671 | Allowed |
| 11 | 122 | Heap-based Buffer Overflow | Variant | 0.4596 | 0.4596 | Allowed |
| 12 | 277 | Insecure Inherited Permissions | Variant | 0.4585 | 0.4585 | Allowed |
| 13 | 667 | Improper Locking | Class | 0.4567 | 0.4567 | Allowed-with-Review |
| 14 | 908 | Use of Uninitialized Resource | Base | 0.4545 | 0.4545 | Allowed |
| 15 | 775 | Missing Release of File Descriptor or Handle after Effective Lifetime | Variant | 0.4541 | 0.4541 | Allowed |

## Sparse Retriever Results (11)
| # | CWE ID | Name | Score | Original Score | Mapping Usage |
|---|--------|------|-------|---------------|---------------|
| 1 | 823 | Use of Out-of-range Pointer Offset | 1117.2815 | 1117.2815 | Allowed |
| 2 | 125 | Out-of-bounds Read | 1031.5321 | 1031.5321 | Allowed |
| 3 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | 979.9339 | 979.9339 | Allowed |
| 4 | 190 | Integer Overflow or Wraparound | 944.3429 | 944.3429 | Allowed |
| 5 | 839 | Numeric Range Comparison Without Minimum Check | 933.2671 | 933.2671 | Allowed |
| 6 | 1284 | Improper Validation of Specified Quantity in Input | 901.7429 | 901.7429 | Allowed |
| 7 | 681 | Incorrect Conversion between Numeric Types | 899.8627 | 899.8627 | Allowed |
| 8 | 194 | Unexpected Sign Extension | 890.5533 | 890.5533 | Allowed |
| 9 | 22 | Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') | 854.6373 | 854.6373 | Allowed |
| 10 | 61 | UNIX Symbolic Link (Symlink) Following | 846.5390 | 846.5390 | Allowed |
| 11 | 197 | Numeric Truncation Error | 279.7508 | 279.7508 | Allowed |
