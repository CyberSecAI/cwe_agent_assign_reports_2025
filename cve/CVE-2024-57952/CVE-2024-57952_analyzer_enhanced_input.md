## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved Revert libfs fix infinite directory reads for offset dir The current directory offset allocator (based on mtree_alloc_cyclic) stores the next offset value to return in octx->next_offset. This mechanism typically returns values that increase monotonically over time. Eventually, though, the newly allocated offset value wraps back to a low number (say, 2) which is smaller than other already- allocated offset values. Yu Kuai reports that, after commit 64a7ce76fb90 (libfs fix infinite directory reads for offset dir), if a directorys offset allocator wraps, existing entries are no longer visible via readdir/getdents because offset_readdir() stops listing entries once an entrys offset is larger than octx->next_offset. These entries vanish persistently -- they can be looked up, but will never again appear in readdir(3) output. The reason for this is that the commit treats directory offsets as monotonically increasing integer values rather than opaque cookies, and introduces this comparison if (dentry2offset(dentry) >= last_index) { On 64-bit platforms, the directory offset value upper bound is 2^63 - 1. Directory offsets will monotonically increase for millions of years without wrapping. On 32-bit platforms, however, LONG_MAX is 2^31 - 1. The allocator can wrap after only a few weeks (at worst). Revert commit 64a7ce76fb90 (libfs fix infinite directory reads for offset dir) to prepare for a fix that can work properly on 32-bit systems and might apply to recent LTS kernels where shmem employs the simple_offset mechanism.

### Vulnerability Description Key Phrases
- **rootcause:** **directory offset value wraps back**
- **impact:** existing entries are no longer visible via readdir/getdents
- **product:** Linux kernel
- **component:** readdir/getdents

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 190 | Integer Overflow or Wraparound | Base | Allowed | alternate_terms | 0.800 |
| 2 | 823 | Use of Out-of-range Pointer Offset | Base | Allowed | sparse | 1.117 |
| 3 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 1.032 |
| 4 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | Allowed | sparse | 0.980 |
| 5 | 839 | Numeric Range Comparison Without Minimum Check | Base | Allowed | sparse | 0.933 |
| 6 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.902 |
| 7 | 681 | Incorrect Conversion between Numeric Types | Base | Allowed | sparse | 0.900 |
| 8 | 194 | Unexpected Sign Extension | Variant | Allowed | sparse | 0.891 |
| 9 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | Allowed | dense | 0.497 |
| 10 | 129 | Improper Validation of Array Index | Variant | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-190: Integer Overflow or Wraparound

CWE-823: Use of Out-of-range Pointer Offset

CWE-125: Out-of-bounds Read

CWE-1285: Improper Validation of Specified Index, Position, or Offset in Input

CWE-839: Numeric Range Comparison Without Minimum Check

CWE-1284: Improper Validation of Specified Quantity in Input

CWE-681: Incorrect Conversion between Numeric Types

CWE-194: Unexpected Sign Extension

CWE-835: Loop with Unreachable Exit Condition ('Infinite Loop')

CWE-129: Improper Validation of Array Index