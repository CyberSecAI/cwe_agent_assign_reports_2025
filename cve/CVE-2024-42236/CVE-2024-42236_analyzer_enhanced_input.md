## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved usb gadget configfs Prevent **OOB read/write** in usb_string_copy() Userspace provided string s could trivially have the length zero. Left unchecked this will firstly result in an OOB read in the form `if (str[0 - 1] == \n) followed closely by an OOB write in the form `str[0 - 1] = \0`. There is already a validating check to catch strings that are too long. Lets supply an additional check for invalid strings that are too short.

### Vulnerability Description Key Phrases
- **weakness:** **OOB read/write**
- **vector:** zero-length string
- **product:** Linux kernel
- **component:** usb gadget configfs

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of the vulnerability:

**Root Cause:**

- The `usb_string_copy()` function in the Linux kernel's USB gadget configfs implementation did not properly validate the length of user-provided strings. Specifically, it failed to check for zero-length strings.

**Weaknesses/Vulnerabilities:**

- **Out-of-bounds Read:** If a zero-length string was provided, the code would attempt to read `str[0 - 1]`, resulting in an out-of-bounds read. This happens when checking for a newline character (`\n`).
- **Out-of-bounds Write:** Following the out-of-bounds read, the code would also attempt to write `str[0 - 1] = '\0'`, resulting in an out-of-bounds write.

**Impact of Exploitation:**

- The out-of-bounds read/write could lead to memory corruption, potentially causing a kernel crash or other undefined behavior. In a more severe scenario, this could potentially be exploited for privilege escalation.

**Attack Vectors:**

- A user with the ability to interact with the USB gadget configfs interface can provide a crafted zero-length string.

**Required Attacker Capabilities/Position:**

- The attacker must have the ability to interact with the USB gadget configfs interface.
- No specific position/location is required, as long as the user can send the crafted input to the affected driver.

**Additional Details:**
- The fix adds a check to ensure the string length is greater than 0 which will return `-EINVAL` when a zero length string is provided. This prevents the out-of-bounds access.
- The patch was backported to multiple stable branches of the Linux kernel, highlighting the wide impact of the issue.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 125 | Out-of-bounds Read | Base | Allowed | alternate_terms | 1.000 |
| 2 | 621 | Variable Extraction Error | Variant | Allowed | alternate_terms | 0.700 |
| 3 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.401 |
| 4 | 476 | NULL Pointer Dereference | Base | Allowed | sparse | 0.381 |
| 5 | 1333 | Inefficient Regular Expression Complexity | Base | Allowed | sparse | 0.380 |
| 6 | 191 | Integer Underflow (Wrap or Wraparound) | Base | Allowed | sparse | 0.375 |
| 7 | 129 | Improper Validation of Array Index | Variant | Allowed | sparse | 0.371 |
| 8 | 190 | Integer Overflow or Wraparound | Base | Allowed | sparse | 0.370 |
| 9 | 134 | Use of Externally-Controlled Format String | Base | Allowed | dense | 0.542 |
| 10 | 805 | Buffer Access with Incorrect Length Value | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-125: Out-of-bounds Read

CWE-621: Variable Extraction Error

CWE-1284: Improper Validation of Specified Quantity in Input

CWE-476: NULL Pointer Dereference

CWE-1333: Inefficient Regular Expression Complexity

CWE-191: Integer Underflow (Wrap or Wraparound)

CWE-129: Improper Validation of Array Index

CWE-190: Integer Overflow or Wraparound

CWE-134: Use of Externally-Controlled Format String

CWE-805: Buffer Access with Incorrect Length Value