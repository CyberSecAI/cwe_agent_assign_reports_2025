# Vulnerability Information: CVE-2024-56592

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved bpf Call free_htab_elem() after htab_unlock_bucket() For htab of maps, when the map is removed from the htab, it may hold the last reference of the map. bpf_map_fd_put_ptr() will invoke bpf_map_free_id() to free the id of the removed map element. However, bpf_map_fd_put_ptr() is invoked while holding a bucket lock (raw_spin_lock_t), and bpf_map_free_id() attempts to acquire map_idr_lock (spinlock_t), triggering the following lockdep warning ============================= [ BUG **Invalid wait context** ] 6.11.0-rc4+ #49 Not tainted ----------------------------- test_maps/4881 is trying to lock ffffffff84884578 (map_idr_lock){+...}-{33}, at bpf_map_free_id.part.0+0x21/0x70 other info that might help us debug this context-{55} 2 locks held by test_maps/4881 #0 ffffffff846caf60 (rcu_read_lock){....}-{13}, at bpf_fd_htab_map_update_elem+0xf9/0x270 #1 ffff888149ced148 (&htab->lockdep_key#2){....}-{22}, at htab_map_update_elem+0x178/0xa80 stack backtrace CPU 0 UID 0 PID 4881 Comm test_maps Not tainted 6.11.0-rc4+ #49 Hardware name QEMU Standard PC (i440FX + PIIX, 1996), ... Call Trace dump_stack_lvl+0x6e/0xb0 dump_stack+0x10/0x20 __lock_acquire+0x73e/0x36c0 lock_acquire+0x182/0x450 _raw_spin_lock_irqsave+0x43/0x70 bpf_map_free_id.part.0+0x21/0x70 bpf_map_put+0xcf/0x110 bpf_map_fd_put_ptr+0x9a/0xb0 free_htab_elem+0x69/0xe0 htab_map_update_elem+0x50f/0xa80 bpf_fd_htab_map_update_elem+0x131/0x270 htab_map_update_elem+0x50f/0xa80 bpf_fd_htab_map_update_elem+0x131/0x270 bpf_map_update_value+0x266/0x380 __sys_bpf+0x21bb/0x36b0 __x64_sys_bpf+0x45/0x60 x64_sys_call+0x1b2a/0x20d0 do_syscall_64+0x5d/0x100 entry_SYSCALL_64_after_hwframe+0x76/0x7e One way to fix the lockdep warning is using raw_spinlock_t for map_idr_lock as well. However, bpf_map_alloc_id() invokes idr_alloc_cyclic() after acquiring map_idr_lock, it will trigger a similar lockdep warning because the slabs lock (s->cpu_slab->lock) is still a spinlock. Instead of changing map_idr_locks type, fix the issue by invoking htab_put_fd_value() after htab_unlock_bucket(). However, only deferring the invocation of htab_put_fd_value() is not enough, because the old map pointers in htab of maps can not be saved during batched deletion. Therefore, also defer the invocation of free_htab_elem(), so these to-be-freed elements could be linked together similar to lru map. There are four callers for ->map_fd_put_ptr (1) alloc_htab_elem() (through htab_put_fd_value()) It invokes ->map_fd_put_ptr() under a raw_spinlock_t. The invocation of htab_put_fd_value() can not simply move after htab_unlock_bucket(), because the old element has already been stashed in htab->extra_elems. It may be reused immediately after htab_unlock_bucket() and the invocation of htab_put_fd_value() after htab_unlock_bucket() may release the newly-added element incorrectly. Therefore, saving the map pointer of the old element for htab of maps before unlocking the bucket and releasing the map_ptr after unlock. Beside the map pointer in the old element, should do the same thing for the special fields in the old element as well. (2) free_htab_elem() (through htab_put_fd_value()) Its caller includes __htab_map_lookup_and_delete_elem(), htab_map_delete_elem() and __htab_map_lookup_and_delete_batch(). For htab_map_delete_elem(), simply invoke free_htab_elem() after htab_unlock_bucket(). For __htab_map_lookup_and_delete_batch(), just like lru map, linking the to-be-freed element into node_to_free list and invoking free_htab_elem() for these element after unlock. It is safe to reuse batch_flink as the link for node_to_free, because these elements have been removed from the hash llist. Because htab of maps doesnt support lookup_and_delete operation, __htab_map_lookup_and_delete_elem() doesnt have the problem, so kept it as ---truncated---

### Vulnerability Description Key Phrases
- **rootcause:** **Invalid wait context**
- **product:** Linux kernel
- **version:** 6.11.0-rc4+
- **component:** bpf

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of the vulnerability:

**Root Cause:**

The root cause lies in a locking conflict within the Linux kernel's BPF (Berkeley Packet Filter) subsystem, specifically when dealing with hash table (htab) maps. When a map is removed from a htab, it might hold the last reference to the map. This triggers `bpf_map_fd_put_ptr()`, which then calls `bpf_map_free_id()` to free the map's ID. However, `bpf_map_fd_put_ptr()` is invoked while holding a bucket lock (`raw_spin_lock_t`), and `bpf_map_free_id()` attempts to acquire `map_idr_lock` (a `spinlock_t`). This creates a lock ordering violation leading to a deadlock situation, which is detected by the kernel's lockdep mechanism.

**Weaknesses/Vulnerabilities Present:**

- **Lock Ordering Violation:** The core issue is the inconsistent locking order, where a raw spinlock is held while attempting to acquire a regular spinlock. This violates lockdep rules and can lead to deadlocks.
- **Incorrect Resource Release:** The timing of releasing the map resources (`bpf_map_fd_put_ptr()`) was coupled with holding a spinlock. This caused the lockdep warning and could have potentially lead to other race conditions or memory corruption.

**Impact of Exploitation:**

- **Deadlock:** The primary impact is a kernel deadlock. The system will likely hang and become unresponsive, requiring a reboot to recover.
- **Denial of Service:** This issue effectively causes a denial of service by making the system unusable.
- **Potential for Other Issues:** Although not stated directly, the text implies that this locking issue might have other race condition or memory corruption consequences due to the incorrect resource release.

**Attack Vectors:**

- **BPF Map Operations:** The attack vector involves manipulating BPF maps, specifically by removing maps from hash tables (`htab`). This can be triggered through the `bpf()` syscall.
- **Specific Map Type:** The vulnerability is specific to the "htab of maps" type.
- **Specific operations:** The vulnerability is triggered during map removal or update operations

**Required Attacker Capabilities/Position:**

- **Ability to use the BPF syscall:** The attacker needs to be able to make use of the `bpf()` system call to create and manipulate BPF maps.
- **Local Access:** The attacker likely needs local access to the system.

**Mitigation:**

The patch addresses this by deferring the call to `free_htab_elem()` and `map->ops->map_fd_put_ptr`  until *after* the bucket lock is released (`htab_unlock_bucket()`). This is achieved by saving the old map pointer and special fields before releasing the lock, then freeing them after the lock is released.

**Additional Details:**

- The fix involves modifying `htab_map_update_elem` and `htab_map_delete_elem`.
- The patch also changes `__pcpu_freelist_push()` to `pcpu_freelist_push()` to disable interrupts and uses `migrate_disable/enable` around `bpf_mem_cache_free()` calls.
- The original vulnerability report is for Linux kernel version 6.11.0-rc4+, but the fix appears in stable branches across multiple versions.

The provided content gives more context and technical detail than the original CVE description typically provides.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 1.678 |
| 2 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 1.665 |
| 3 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | sparse | 1.636 |
| 4 | 22 | Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') | Base | Allowed | sparse | 1.634 |
| 5 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 1.619 |
| 6 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 1.612 |
| 7 | 824 | Access of Uninitialized Pointer | Base | Allowed | sparse | 1.612 |
| 8 | 226 | Sensitive Information in Resource Not Removed Before Reuse | Base | Allowed | sparse | 1.611 |
| 9 | 911 | Improper Update of Reference Count | Base | Allowed | dense | 0.485 |
| 10 | 364 | Signal Handler Race Condition | Base | Allowed | graph | 0.002 |

