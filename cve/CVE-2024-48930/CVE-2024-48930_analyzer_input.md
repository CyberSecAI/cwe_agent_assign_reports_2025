# Vulnerability Information: CVE-2024-48930

## Vulnerability Description
secp256k1-node is a Node.js binding for an Optimized C library for EC operations on curve secp256k1. In `elliptic`-based version, `loadUncompressedPublicKey` has a check that the public key is on the curve. Prior to versions 5.0.1, 4.0.4, and 3.8.1, however, `loadCompressedPublicKey` is missing that check. That allows the attacker to use public keys on low-cardinality curves to extract enough information to fully restore the private key from as little as 11 ECDH sessions, and very cheaply on compute power. Other operations on public keys are also affected, including e.g. `publicKeyVerify()` incorrectly returning `true` on those invalid keys, and e.g. `publicKeyTweakMul()` also returning predictable outcomes allowing to restore the tweak. Versions 5.0.1, 4.0.4, and 3.8.1 contain a fix for the issue.

### Vulnerability Description Key Phrases
- **rootcause:** **missing public key curve check**
- **impact:** extract private key from public keys on low-cardinality curves
- **product:** secp256k1-node
- **version:** prior to 5.0.1, 4.0.4, and 3.8.1
- **component:** loadCompressedPublicKey

## CVE Reference Links Content Summary
Based on the provided information, here's a breakdown of the vulnerability:

**Root Cause:**

The vulnerability lies in the `loadCompressedPublicKey` function within the `elliptic.js` file of the `secp256k1-node` library. This function is responsible for loading a public key from its compressed representation.  The vulnerability exists because this function lacks a check to ensure that the computed Y-coordinate is a valid solution for the curve equation Y^2 = X^3 + 7. Specifically, the code calculates `Y = sqrt(X^3 + 7)` but does not verify if Y is a valid point on the secp256k1 curve.  When no valid Y value exists for the given X coordinate, the function incorrectly uses a solution for `-Y^2 = X^3 + 7`. This leads to the use of points that are not on the standard secp256k1 curve, and may be on low-cardinality curves.

**Weaknesses/Vulnerabilities:**

*   **Missing Curve Validation:** The `loadCompressedPublicKey` function omits a crucial check to confirm if the recovered Y-coordinate satisfies the curve equation Y^2 = X^3 + 7. This validation *is* present in the `loadUncompressedPublicKey` function, highlighting an inconsistency in handling compressed vs uncompressed public keys.
*   **Use of Invalid Points:** The lack of validation leads to the acceptance of points that lie on curves with low-order, meaning there are only a small number of possible values.
*   **Incorrect Public Key Verification:** The `publicKeyVerify` function relies on `loadPublicKey`, which does not validate compressed public keys correctly, causing it to return true even for invalid public keys. This allows attacker to use invalid public keys with the library.
*   **Predictable Outcomes:**  Operations like `publicKeyTweakMul` also return predictable outputs when using these crafted, invalid public keys.

**Impact of Exploitation:**

*   **Private Key Extraction:** An attacker can use specially crafted public keys that are not on the standard secp256k1 curve, to extract a target's private key over a small number of ECDH sessions (as few as 11).
*  **ECDH compromise**: Since the output of ECDH with these public keys are predictable, the attacker can precompute the possible outputs, and then verify those outputs to extract the private key.
*   **Misleading `publicKeyVerify()`:** The `publicKeyVerify()` function incorrectly reports malicious public keys as valid, misleading users into using invalid keys.
*   **Compromised Key Operations:** Operations that use public keys are affected.
*   **Tweak Extraction**:  Tweak values for public keys can be extracted from the results of functions like `publicKeyTweakMul`.

**Attack Vectors:**

*   **Manipulated Public Keys:** The attacker needs to craft specific X values that will result in invalid Y values during the compression phase, leading to low-order points.
*   **ECDH Sessions:** The attacker needs to engage in multiple ECDH sessions with the victim, using the malicious public keys. The number of sessions needed is around 11.
*   **Confirmation of ECDH Output:** The attacker doesn't need to obtain the actual ECDH shared secret, but needs to confirm/validate the shared secret against a list of possible, precomputed candidates.

**Required Attacker Capabilities/Position:**

*   **Ability to initiate ECDH sessions:** The attacker must be able to initiate ECDH sessions with a victim that is using the vulnerable library.
*   **Precomputation:** The attacker needs to precompute the possible ECDH outputs for the specially crafted public keys (this takes a few days on a standard laptop).
*   **Confirmation of ECDH results:** The attacker needs a way to confirm or identify the correct ECDH value produced for each session.  This doesn't need to involve a transmitted value, as the attacker can use an output based on the ECDH, such as a cipher output.

**Additional Details:**

*   The vulnerability is present in the elliptic-based version of the library but not in the gyp-based one. Node.js can use both, while web/RN/bundles will always use the elliptic version.
*   The vulnerability was fixed in commit `e256905ee649a7caacc251f7c964667195a52221` by adding a check to `loadCompressedPublicKey` to validate the point.
*   The vulnerability was also fixed in commit `9a15fff274f83a6ec7f675f1121babcc0c42292f` and commit `8bd6446e000fa59df3cda0ae3e424300747ea5ed`

The provided content gives a detailed explanation of the root cause and impact of the vulnerability, a proof of concept, and also the fix in the code and the affected versions.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 295 | Improper Certificate Validation | Base | Allowed | sparse | 0.696 |
| 2 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.679 |
| 3 | 325 | Missing Cryptographic Step | Base | Allowed | sparse | 0.677 |
| 4 | 201 | Insertion of Sensitive Information Into Sent Data | Base | Allowed | sparse | 0.671 |
| 5 | 203 | Observable Discrepancy | Base | Allowed | sparse | 0.668 |
| 6 | 327 | Use of a Broken or Risky Cryptographic Algorithm | Class | Allowed-with-Review | sparse | 0.665 |
| 7 | 347 | Improper Verification of Cryptographic Signature | Base | Allowed | sparse | 0.646 |
| 8 | 863 | Incorrect Authorization | Class | Allowed-with-Review | sparse | 0.642 |
| 9 | 335 | Incorrect Usage of Seeds in Pseudo-Random Number Generator (PRNG) | Base | Allowed | dense | 0.449 |
| 10 | 226 | Sensitive Information in Resource Not Removed Before Reuse | Base | Allowed | graph | 0.002 |

