{
  "retriever": "graph",
  "query": "In the Linux kernel, the following vulnerability has been resolved bpf Scrub packet on bpf_redirect_peer When bpf_redirect_peer is used to redirect packets to a device in another network namespace, the skb isnt scrubbed. That can lead skb information from one namespace to be misused in another namespace. As one example, this is causing Cilium to drop traffic when using bpf_redirect_peer to redirect packets that just went through IPsec decryption to a container namespace. The following pwru trace shows (1) the packet path from the hosts XFRM layer to the containers XFRM layer where its dropped and (2) the number of active skb extensions at each function. NETNS MARK IFACE TUPLE FUNC 4026533547 d00 eth0 10.244.3.12435473->10.244.2.15853 xfrm_rcv_cb .active_extensions = (__u8)2, 4026533547 d00 eth0 10.244.3.12435473->10.244.2.15853 xfrm4_rcv_cb .active_extensions = (__u8)2, 4026533547 d00 eth0 10.244.3.12435473->10.244.2.15853 gro_cells_receive .active_extensions = (__u8)2, [...] 4026533547 0 eth0 10.244.3.12435473->10.244.2.15853 skb_do_redirect .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 ip_rcv .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 ip_rcv_core .active_extensions = (__u8)2, [...] 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 udp_queue_rcv_one_skb .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 __xfrm_policy_check .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 __xfrm_decode_session .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 security_xfrm_decode_session .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 kfree_skb_reason(SKB_DROP_REASON_XFRM_POLICY) .active_extensions = (__u8)2, In this case, there are no XFRM policies in the containers network namespace so the drop is unexpected. When we decrypt the IPsec packet, the XFRM state used for decryption is set in the skb extensions. This information is preserved across the netns switch. When we reach the XFRM policy check in the containers netns, __xfrm_policy_check drops the packet with LINUX_MIB_XFRMINNOPOLS because a (container-side) XFRM policy cant be found that matches the (host-side) XFRM state used for decryption. This patch fixes this by scrubbing the packet when using bpf_redirect_peer, as is done on typical netns switches via veth devices except skb->mark and skb->tstamp are not zeroed. Consider specifically these CWEs: CWE-244 CWE-863 CWE-1284 CWE-770 CWE-406 CWE-833 CWE-401 CWE-1285 CWE-362",
  "keyphrases": {
    "original_query": "In the Linux kernel, the following vulnerability has been resolved bpf Scrub packet on bpf_redirect_peer When bpf_redirect_peer is used to redirect packets to a device in another network namespace, the skb isnt scrubbed. That can lead skb information from one namespace to be misused in another namespace. As one example, this is causing Cilium to drop traffic when using bpf_redirect_peer to redirect packets that just went through IPsec decryption to a container namespace. The following pwru trace shows (1) the packet path from the hosts XFRM layer to the containers XFRM layer where its dropped and (2) the number of active skb extensions at each function. NETNS MARK IFACE TUPLE FUNC 4026533547 d00 eth0 10.244.3.12435473->10.244.2.15853 xfrm_rcv_cb .active_extensions = (__u8)2, 4026533547 d00 eth0 10.244.3.12435473->10.244.2.15853 xfrm4_rcv_cb .active_extensions = (__u8)2, 4026533547 d00 eth0 10.244.3.12435473->10.244.2.15853 gro_cells_receive .active_extensions = (__u8)2, [...] 4026533547 0 eth0 10.244.3.12435473->10.244.2.15853 skb_do_redirect .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 ip_rcv .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 ip_rcv_core .active_extensions = (__u8)2, [...] 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 udp_queue_rcv_one_skb .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 __xfrm_policy_check .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 __xfrm_decode_session .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 security_xfrm_decode_session .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 kfree_skb_reason(SKB_DROP_REASON_XFRM_POLICY) .active_extensions = (__u8)2, In this case, there are no XFRM policies in the containers network namespace so the drop is unexpected. When we decrypt the IPsec packet, the XFRM state used for decryption is set in the skb extensions. This information is preserved across the netns switch. When we reach the XFRM policy check in the containers netns, __xfrm_policy_check drops the packet with LINUX_MIB_XFRMINNOPOLS because a (container-side) XFRM policy cant be found that matches the (host-side) XFRM state used for decryption. This patch fixes this by scrubbing the packet when using bpf_redirect_peer, as is done on typical netns switches via veth devices except skb->mark and skb->tstamp are not zeroed.",
    "enhanced_query": "In the Linux kernel, the following vulnerability has been resolved bpf Scrub packet on bpf_redirect_peer When bpf_redirect_peer is used to redirect packets to a device in another network namespace, the skb isnt scrubbed. That can lead skb information from one namespace to be misused in another namespace. As one example, this is causing Cilium to drop traffic when using bpf_redirect_peer to redirect packets that just went through IPsec decryption to a container namespace. The following pwru trace shows (1) the packet path from the hosts XFRM layer to the containers XFRM layer where its dropped and (2) the number of active skb extensions at each function. NETNS MARK IFACE TUPLE FUNC 4026533547 d00 eth0 10.244.3.12435473->10.244.2.15853 xfrm_rcv_cb .active_extensions = (__u8)2, 4026533547 d00 eth0 10.244.3.12435473->10.244.2.15853 xfrm4_rcv_cb .active_extensions = (__u8)2, 4026533547 d00 eth0 10.244.3.12435473->10.244.2.15853 gro_cells_receive .active_extensions = (__u8)2, [...] 4026533547 0 eth0 10.244.3.12435473->10.244.2.15853 skb_do_redirect .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 ip_rcv .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 ip_rcv_core .active_extensions = (__u8)2, [...] 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 udp_queue_rcv_one_skb .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 __xfrm_policy_check .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 __xfrm_decode_session .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 security_xfrm_decode_session .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.12435473->10.244.2.15853 kfree_skb_reason(SKB_DROP_REASON_XFRM_POLICY) .active_extensions = (__u8)2, In this case, there are no XFRM policies in the containers network namespace so the drop is unexpected. When we decrypt the IPsec packet, the XFRM state used for decryption is set in the skb extensions. This information is preserved across the netns switch. When we reach the XFRM policy check in the containers netns, __xfrm_policy_check drops the packet with LINUX_MIB_XFRMINNOPOLS because a (container-side) XFRM policy cant be found that matches the (host-side) XFRM state used for decryption. This patch fixes this by scrubbing the packet when using bpf_redirect_peer, as is done on typical netns switches via veth devices except skb->mark and skb->tstamp are not zeroed. Consider specifically these CWEs: CWE-244 CWE-863 CWE-1284 CWE-770 CWE-406 CWE-833 CWE-401 CWE-1285 CWE-362",
    "cwe_mentions": [
      "CWE-244",
      "CWE-863",
      "CWE-1284",
      "CWE-770",
      "CWE-406",
      "CWE-833",
      "CWE-401",
      "CWE-1285",
      "CWE-362"
    ],
    "search_time": 3.974371910095215
  },
  "timestamp": "2025-07-14 22:00:17",
  "cve_id": "CVE-2025-37959",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "789",
      "name": "Memory Allocation with Excessive Size Value",
      "type": "variant",
      "score": 2.6784000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "base",
      "score": 2.3998000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "1325",
      "name": "Improperly Controlled Sequential Memory Allocation",
      "type": "base",
      "score": 2.3400000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "390",
      "name": "Detection of Error Condition Without Action",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "129",
      "name": "Improper Validation of Array Index",
      "type": "variant",
      "score": 2.1936,
      "relationship_count": 0
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "type": "Base",
      "score": 2.0073374103198343,
      "relationship_count": 0
    },
    {
      "cwe_id": "41",
      "name": "Improper Resolution of Path Equivalence",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "120",
      "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "123",
      "name": "Write-what-where Condition",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "364",
      "name": "Signal Handler Race Condition",
      "type": "base",
      "score": 1.7550000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "1265",
      "name": "Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "386",
      "name": "Symbolic Name not Mapping to Correct Object",
      "type": "base",
      "score": 1.6744000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "662",
      "name": "Improper Synchronization",
      "type": "class",
      "score": 1.6736000000000002,
      "relationship_count": 0
    },
    {
      "cwe_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "type": "Base",
      "score": 1.652237036373432,
      "relationship_count": 0
    },
    {
      "cwe_id": "770",
      "name": "Allocation of Resources Without Limits or Throttling",
      "type": "Base",
      "score": 1.6476118977147867,
      "relationship_count": 0
    },
    {
      "cwe_id": "61",
      "name": "UNIX Symbolic Link (Symlink) Following",
      "type": "compound",
      "score": 1.61,
      "relationship_count": 0
    },
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "type": "Base",
      "score": 1.5281156079033844,
      "relationship_count": 0
    },
    {
      "cwe_id": "941",
      "name": "Incorrectly Specified Destination in a Communication Channel",
      "type": "Base",
      "score": 1.521016659932034,
      "relationship_count": 0
    },
    {
      "cwe_id": "669",
      "name": "Incorrect Resource Transfer Between Spheres",
      "type": "class",
      "score": 1.5136640000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 1.4913280617611828,
      "relationship_count": 0
    }
  ]
}