## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved media s5p-jpeg prevent **buffer overflows** The current logic allows word to be less than 2. If this happens, there will be **buffer overflows**, as reported by smatch. Add extra checks to prevent it. While here, remove an unused word = 0 assignment.

### Vulnerability Description Key Phrases
- **weakness:** **buffer overflows**
- **product:** Linux kernel
- **component:** media s5p-jpeg

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of the vulnerability:

**Root cause of vulnerability:**

The root cause is the insufficient validation of the "word" variable when parsing JPEG headers within the `s5p-jpeg` driver in the Linux kernel. The code reads a 2-byte word from the input stream, which is used to determine the length of subsequent data. If this "word" is less than 2, calculating the data length by subtracting 2 leads to a negative value which causes the `jpeg_buffer.size` to have an incorrect value, causing a buffer overflow when the driver attempts to read the subsequent data.

**Weaknesses/vulnerabilities present:**

-   **Buffer Overflow:** The primary weakness is a buffer overflow vulnerability. By crafting a malicious JPEG file where the "word" is less than 2, an attacker can cause the driver to read beyond the intended bounds of the buffer, leading to a crash or potentially arbitrary code execution.
-   **Insufficient input validation:** The code lacks proper checks to ensure the "word" is greater than or equal to 2 before calculating `jpeg_buffer.size`, which allows a crafted JPEG to cause a buffer overflow.

**Impact of exploitation:**

-   **Crash:** The most likely outcome of exploiting this vulnerability is a kernel crash due to the buffer overflow.
-   **Potential Code Execution:** In certain scenarios, a carefully crafted payload could potentially be placed into the overflowed buffer, leading to arbitrary code execution with kernel privileges.

**Attack vectors:**

-   **Malicious JPEG File:** An attacker could exploit this vulnerability by providing a maliciously crafted JPEG file to a system using the vulnerable `s5p-jpeg` driver.

**Required attacker capabilities/position:**

-   **Ability to provide input to the system:** The attacker needs to be able to supply a specially crafted JPEG file to the affected system. This could be done through various means, such as:
    -   An application that processes JPEG images.
    -   A network service that accepts JPEG uploads
    -   A storage device containing the malicious file.
    -   A web browser that renders a page that includes a malicious JPEG.
-   No specific privilege level is needed to trigger the vulnerability, but code execution would happen within the kernel space.

**Additional Details**

The provided commit messages and diffs detail the fix for this vulnerability:

*   The fix includes adding a check `if (word < 2)` to handle cases where the word is less than 2. In this situation, `jpeg_buffer.size` is set to 0 to avoid the buffer overflow. Also adds checks to verify that `length` is not less than or equal to 0 in multiple parsing functions.
*   The fix also removes an unused `word = 0;` assignment.
*   The commits reference the original buggy code using the commit ID `6c96dbbc2aa9`, which added the vulnerable functionality.
*   The vulnerability was discovered by `smatch`, a static analysis tool.

The fix is applied to `drivers/media/platform/s5p-jpeg/jpeg-core.c` and `drivers/media/platform/samsung/s5p-jpeg/jpeg-core.c` showing that the driver has been moved under different directories and the fix has been applied to both locations.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | alternate_terms | 0.800 |
| 2 | 190 | Integer Overflow or Wraparound | Base | Allowed | alternate_terms | 0.800 |
| 3 | 120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | Base | Allowed-with-Review | sparse | 0.278 |
| 4 | 191 | Integer Underflow (Wrap or Wraparound) | Base | Allowed | sparse | 0.252 |
| 5 | 121 | Stack-based Buffer Overflow | Variant | Allowed | sparse | 0.243 |
| 6 | 193 | Off-by-one Error | Base | Allowed | sparse | 0.236 |
| 7 | 122 | Heap-based Buffer Overflow | Variant | Allowed | sparse | 0.236 |
| 8 | 226 | Sensitive Information in Resource Not Removed Before Reuse | Base | Allowed | sparse | 0.233 |
| 9 | 126 | Buffer Over-read | Variant | Allowed | dense | 0.613 |
| 10 | 128 | Wrap-around Error | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer

CWE-190: Integer Overflow or Wraparound

CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')

CWE-191: Integer Underflow (Wrap or Wraparound)

CWE-121: Stack-based Buffer Overflow

CWE-193: Off-by-one Error

CWE-122: Heap-based Buffer Overflow

CWE-226: Sensitive Information in Resource Not Removed Before Reuse

CWE-126: Buffer Over-read

CWE-128: Wrap-around Error