# Vulnerability Information: CVE-2024-40918

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved parisc Try to fix random segmentation faults in package builds PA-RISC systems with PA8800 and PA8900 processors have had problems with random segmentation faults for many years. Systems with earlier processors are much more stable. Systems with PA8800 and PA8900 processors have a large L2 cache which needs per page flushing for decent performance when a large range is flushed. The combined cache in these systems is also more sensitive to **non-equivalent aliases** than the caches in earlier systems. The majority of random segmentation faults that I have looked at appear to be **memory corruption** in memory allocated using mmap and malloc. My first attempt at fixing the random faults didnt work. On reviewing the cache code, I realized that there were two issues which the existing code didnt handle correctly. Both relate to cache move-in. Another issue is that the present bit in PTEs is racy. 1) PA-RISC caches have a mind of their own and they can speculatively load data and instructions for a page as long as there is a entry in the TLB for the page which allows move-in. TLBs are local to each CPU. Thus, the TLB entry for a page must be purged before flushing the page. This is particularly important on SMP systems. In some of the flush routines, the flush routine would be called and then the TLB entry would be purged. This was because the flush routine needed the TLB entry to do the flush. 2) My initial a

### Vulnerability Description Key Phrases
- **rootcause:** **non-equivalent aliases**
- **weakness:** **memory corruption**
- **impact:** random segmentation faults
- **product:** Linux kernel
- **component:** cache code

## CVE Reference Links Content Summary
```
{
  "vulnerability": {
    "root_cause": "Inadequate cache flushing on PA-RISC systems with PA8800 and PA8900 processors, specifically related to TLB entries and PTE clearing. The processors' large L2 caches require per-page flushing, and they are more sensitive to non-equivalent aliases. Speculative loading of data and instructions from the cache, combined with racy PTE checks and improper handling of TLB entries during flushes leads to memory corruption.",
    "weaknesses": [
      "Incorrect cache flush implementation",
      "Racy PTE checks",
      "Improper TLB entry purging",
      "Lack of synchronization when setting/clearing page access bits",
      "Insufficient handling of non-equivalent aliases"
    ],
    "impact": "Random segmentation faults and memory corruption, primarily affecting memory allocated through `mmap` and `malloc`. Stale cache lines cause data corruption, leading to application crashes and unpredictable behavior.",
    "attack_vectors": "Exploitation requires triggering specific memory operations that involve frequent page mapping changes and cache flushes. The vulnerability is present within the kernel's cache management routines, making it potentially exploitable by any process that allocates and manipulates memory.",
    "required_capabilities": "Exploitation can be achieved by any user or process capable of performing memory operations such as allocations and mapping changes, thus the attacker does not need specific or elevated privileges"
  },
  "resolution": "The issue is addressed by implementing more robust cache flushing mechanisms. Key fixes include:\n\n*   Purging TLB entries before flushing pages to prevent speculative loads.\n*   Using tmpalias routines for all flush operations to ensure lines are removed from the cache.\n*   Implementing a PA-RISC specific version of `ptep_clear_flush` to flush the cache page when a PTE is cleared.\n*   Flushing the cache when the accessed bit is cleared in `ptep_clear_flush_young`.\n*   Revising `flush_kernel_vmap_range` and `invalidate_kernel_vmap_range` to use full data cache flushes.\n*   Moving `flush_cache_vmap` and `flush_cache_vunmap` to `cache.c` and handling `VM_IOREMAP` cases in `flush_cache_vmap`.\n\nThese changes ensure that cache lines are properly invalidated, preventing stale data from causing corruption."
}
```

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 787 | Out-of-bounds Write | Base | Allowed | alternate_terms | 1.000 |
| 2 | 190 | Integer Overflow or Wraparound | Base | Allowed | sparse | 1.216 |
| 3 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 1.199 |
| 4 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 1.197 |
| 5 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 1.192 |
| 6 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 1.184 |
| 7 | 1250 | Improper Preservation of Consistency Between Independent Representations of Shared State | Base | Allowed | sparse | 1.182 |
| 8 | 923 | Improper Restriction of Communication Channel to Intended Endpoints | Class | Allowed-with-Review | sparse | 1.182 |
| 9 | 1342 | Information Exposure through Microarchitectural State after Transient Execution | Base | Allowed | dense | 0.575 |
| 10 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | graph | 0.003 |

