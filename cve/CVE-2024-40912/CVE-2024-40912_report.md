# Analysis Report for CVE-2024-40912

# Vulnerability Analysis Report: CVE-2024-40912

## Description

In the Linux kernel, the following vulnerability has been resolvedwifi mac80211 Fix deadlock in ieee80211_sta_ps_deliver_wakeup()The ieee80211_sta_ps_deliver_wakeup() function takes sta->ps_lock tosynchronizes with ieee80211_tx_h_unicast_ps_buf() which is called fromsoftirq context. However using only spin_lock() to get sta->ps_lock inieee80211_sta_ps_deliver_wakeup() does not prevent softirq to executeon this same CPU, to run ieee80211_tx_h_unicast_ps_buf() and try totake this same lock ending in deadlock. Below is an example of rcu stallthat arises in such situation. rcu INFO rcu_sched self-detected stall on CPU rcu 2-.... (42413413 ticks this GP) idle=b154/1/0x4000000000000000 softirq=1763/1765 fqs=21206996 rcu (t=42586894 jiffies g=2057 q=362405 ncpus=4) CPU 2 PID 719 Comm wpa_supplicant Tainted G W 6.4.0-02158-g1b062f552873 #742 Hardware name RPT (r1) (DT) pstate 00000005 (nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc queued_spin_lock_slowpath+0x58/0x2d0 lr invoke_tx_handlers_early+0x5b4/0x5c0 sp ffff00001ef64660 x29 ffff00001ef64660 x28 ffff000009bc1070 x27 ffff000009bc0ad8 x26 ffff000009bc0900 x25 ffff00001ef647a8 x24 0000000000000000 x23 ffff000009bc0900 x22 ffff000009bc0900 x21 ffff00000ac0e000 x20 ffff00000a279e00 x19 ffff00001ef646e8 x18 0000000000000000 x17 ffff800016468000 x16 ffff00001ef608c0 x15 0010533c93f64f80 x14 0010395c9faa3946 x13 0000000000000000 x12 00000000fa83b2da x11 000000012edeceea x10 ffff0000010fbe00 x9 0000000000895440 x8 000000000010533c x7 ffff00000ad8b740 x6 ffff00000c350880 x5 0000000000000007 x4 0000000000000001 x3 0000000000000000 x2 0000000000000000 x1 0000000000000001 x0 ffff00000ac0e0e8 Call trace queued_spin_lock_slowpath+0x58/0x2d0 ieee80211_tx+0x80/0x12c ieee80211_tx_pending+0x110/0x278 tasklet_action_common.constprop.0+0x10c/0x144 tasklet_action+0x20/0x28 _stext+0x11c/0x284 ____do_softirq+0xc/0x14 call_on_irq_stack+0x24/0x34 do_softirq_own_stack+0x18/0x20 do_softirq+0x74/0x7c __local_bh_enable_ip+0xa0/0xa4 _ieee80211_wake_txqs+0x3b0/0x4b8 __ieee80211_wake_queue+0x12c/0x168 ieee80211_add_pending_skbs+0xec/0x138 ieee80211_sta_ps_deliver_wakeup+0x2a4/0x480 ieee80211_mps_sta_status_update.part.0+0xd8/0x11c ieee80211_mps_sta_status_update+0x18/0x24 sta_apply_parameters+0x3bc/0x4c0 ieee80211_change_station+0x1b8/0x2dc nl80211_set_station+0x444/0x49c genl_family_rcv_msg_doit.isra.0+0xa4/0xfc genl_rcv_msg+0x1b0/0x244 netlink_rcv_skb+0x38/0x10c genl_rcv+0x34/0x48 netlink_unicast+0x254/0x2bc netlink_sendmsg+0x190/0x3b4 ____sys_sendmsg+0x1e8/0x218 ___sys_sendmsg+0x68/0x8c __sys_sendmsg+0x44/0x84 __arm64_sys_sendmsg+0x20/0x28 do_el0_svc+0x6c/0xe8 el0_svc+0x14/0x48 el0t_64_sync_handler+0xb0/0xb4 el0t_64_sync+0x14c/0x150Using spin_lock_bh()/spin_unlock_bh() instead prevents softirq to raiseon the same CPU that is holding the lock.

## Vulnerability Description Key Phrases

- **Rootcause:** The function ieee80211_sta_ps_deliver_wakeup() uses spin_lock() to synchronize with ieee80211_tx_h_unicast_ps_buf(), but does not prevent softirq from executing on the same CPU, leading to a deadlock.
- **Weakness:** The usage of spin_lock() in ieee80211_sta_ps_deliver_wakeup() does not prevent softirqs from interrupting the critical section on the same CPU, which leads to a deadlock when the softirq context attempts to acquire the same lock.
- **Impact:** Deadlock, causing the system to become unresponsive.
- **Vector:** Local
- **Attacker:** Local attacker, through a crafted netlink message.
- **Product:** Linux Kernel
- **Version:** 6.4.0-02158-g1b062f552873
- **Component:** mac80211

## Analysis (with Relationship Data)

# Summary
| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |
|---|---|---|---|---|---|
| CWE-833 | Deadlock | 1.0 | Base | Allowed | Primary CWE: The vulnerability description explicitly mentions a deadlock scenario, making this the most accurate primary CWE. |
| CWE-413 | Improper Resource Locking | 0.8 | Base | Allowed | Secondary Candidate: The root cause involves using the wrong type of lock, leading to the deadlock. |
| CWE-362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | 0.6 | Class | Allowed-with-Review | Secondary Candidate: This is a more general classification that applies because the **improper locking** leads to a race condition.|

## Evidence and Confidence

*   **Confidence Score:** 0.9
*   **Evidence Strength:** HIGH

## Relationship Analysis
The primary relationship is between **CWE-833** Deadlock and **CWE-413** Improper Resource Locking. The **improper locking** (specifically, using `spin_lock` instead of `spin_lock_bh`) **caused** the deadlock. **CWE-362** is a more general class that encompasses the concurrency issue.

```mermaid
graph TD
    cwe833["CWE-833: Deadlock"]
    cwe413["CWE-413: Improper Resource Locking"]
    cwe362["CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')"]

    cwe833 <--|CAUSED_BY| cwe413
    cwe413 -->|PART_OF| cwe362

    classDef primary fill:#f96,stroke:#333,stroke-width:2px
    classDef secondary fill:#69f,stroke:#333
    classDef tertiary fill:#9e9,stroke:#333
    class cwe833 primary
    class cwe413,cwe362 secondary
```

## Vulnerability Chain
The vulnerability chain starts with **CWE-413** (Improper Resource Locking), which leads directly to **CWE-833** (Deadlock). The use of the wrong spinlock primitive allowed a softirq to interrupt the critical section, causing the deadlock.
  - **CWE-413**: The **root cause** is the **incorrect usage of `spin_lock()` instead of `spin_lock_bh()`**, which doesn't prevent softirqs from running.
  - **CWE-833**: The direct **impact** of the incorrect locking is a **deadlock** when the softirq attempts to acquire the same lock.

## Summary of Analysis
The analysis is based on the vulnerability description and CVE reference summary, which clearly outline the **root cause** as an **improper locking** mechanism leading to a deadlock. The description states, "The function ieee80211_sta_ps_deliver_wakeup() uses spin_lock() to synchronize with ieee80211_tx_h_unicast_ps_buf(), but does not prevent softirq from executing on the same CPU, leading to a deadlock."

The relationship graph shows that **CWE-413** contributes to **CWE-833**. While **CWE-362** is related, it is less specific than **CWE-413** and **CWE-833**.

The selected CWEs are at the optimal level of specificity because they directly address the root cause (improper locking) and the resulting impact (deadlock). The use of `spin_lock()` instead of `spin_lock_bh()` is a clear instance of **improper resource locking**.

**CWEs Considered But Not Used:**

*   **CWE-119 Improper Restriction of Operations within the Bounds of a Memory Buffer**: This CWE is not appropriate because the vulnerability is not related to memory buffer boundaries.
*   **CWE-400 Uncontrolled Resource Consumption**: This CWE is not appropriate because the vulnerability does not involve the uncontrolled consumption of resources.
*   **CWE-125 Out-of-bounds Read** and **CWE-787 Out-of-bounds Write**: These CWEs are not appropriate as they are memory corruption issues and not directly related to the described deadlock.
*   **CWE-416 Use After Free**: This CWE is not relevant as the vulnerability doesn't involve using memory after it has been freed.
*   **CWE-770 Allocation of Resources Without Limits or Throttling**: This is not relevant because the issue isn't related to allocating resources without limits.


## CWE Relationship Analysis

Current CWEs represent these abstraction levels: .


### Vulnerability Chain Analysis

**Chain starting from CWE-400:**
- 400 (Uncontrolled Resource Consumption) - ROOT


**Chain starting from CWE-416:**
- 416 (Use After Free) - ROOT



### CWE Relationship Diagram

```mermaid
graph TD
    classDef primary fill:#f96,stroke:#333,stroke-width:2px
    classDef secondary fill:#69f,stroke:#333
    classDef tertiary fill:#9e9,stroke:#333
```



*Report generated on 2025-07-13 12:41:57*
