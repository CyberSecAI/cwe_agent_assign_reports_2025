{
  "retriever": "graph",
  "query": "In the Linux kernel, the following vulnerability has been resolved KVM arm64 Get rid of userspace_irqchip_in_use Improper use of userspace_irqchip_in_use led to syzbot hitting the following WARN_ON() in kvm_timer_update_irq() WARNING CPU 0 PID 3281 at arch/arm64/kvm/arch_timer.c459 kvm_timer_update_irq+0x21c/0x394 Call trace kvm_timer_update_irq+0x21c/0x394 arch/arm64/kvm/arch_timer.c459 kvm_timer_vcpu_reset+0x158/0x684 arch/arm64/kvm/arch_timer.c968 kvm_reset_vcpu+0x3b4/0x560 arch/arm64/kvm/reset.c264 kvm_vcpu_set_target arch/arm64/kvm/arm.c1553 [inline] kvm_arch_vcpu_ioctl_vcpu_init arch/arm64/kvm/arm.c1573 [inline] kvm_arch_vcpu_ioctl+0x112c/0x1b3c arch/arm64/kvm/arm.c1695 kvm_vcpu_ioctl+0x4ec/0xf74 virt/kvm/kvm_main.c4658 vfs_ioctl fs/ioctl.c51 [inline] __do_sys_ioctl fs/ioctl.c907 [inline] __se_sys_ioctl fs/ioctl.c893 [inline] __arm64_sys_ioctl+0x108/0x184 fs/ioctl.c893 __invoke_syscall arch/arm64/kernel/syscall.c35 [inline] invoke_syscall+0x78/0x1b8 arch/arm64/kernel/syscall.c49 el0_svc_common+0xe8/0x1b0 arch/arm64/kernel/syscall.c132 do_el0_svc+0x40/0x50 arch/arm64/kernel/syscall.c151 el0_svc+0x54/0x14c arch/arm64/kernel/entry-common.c712 el0t_64_sync_handler+0x84/0xfc arch/arm64/kernel/entry-common.c730 el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S598 The following sequence led to the scenario - Userspace creates a VM and a vCPU. - The vCPU is initialized with KVM_ARM_VCPU_PMU_V3 during KVM_ARM_VCPU_INIT. - Without any other setup, such as vGIC or vPMU, userspace issues KVM_RUN on the vCPU. Since the vPMU is requested, but not setup, kvm_arm_pmu_v3_enable() fails in kvm_arch_vcpu_run_pid_change(). As a result, KVM_RUN returns after enabling the timer, but before incrementing userspace_irqchip_in_use kvm_arch_vcpu_run_pid_change() ret = kvm_arm_pmu_v3_enable() if (!vcpu->arch.pmu.created) return -EINVAL if (ret) return ret [...] if (!irqchip_in_kernel(kvm)) static_branch_inc(&userspace_irqchip_in_use) - Userspace ignores the error and issues KVM_ARM_VCPU_INIT again. Since the timer is already enabled, control moves through the following flow, ultimately hitting the WARN_ON() kvm_timer_vcpu_reset() if (timer->enabled) kvm_timer_update_irq() if (!userspace_irqchip()) ret = kvm_vgic_inject_irq() ret = vgic_lazy_init() if (unlikely(!vgic_initialized(kvm))) if (kvm->arch.vgic.vgic_model != KVM_DEV_TYPE_ARM_VGIC_V2) return -EBUSY WARN_ON(ret) Theoretically, since userspace_irqchip_in_uses functionality can be simply replaced by !irqchip_in_kernel(), get rid of the static key to avoid the mismanagement, which also helps with the syzbot issue. Consider specifically these CWEs: CWE-226 CWE-733 CWE-667 CWE-393 CWE-909 CWE-1256 CWE-1342 CWE-362 CWE-367",
  "keyphrases": {
    "original_query": "In the Linux kernel, the following vulnerability has been resolved KVM arm64 Get rid of userspace_irqchip_in_use Improper use of userspace_irqchip_in_use led to syzbot hitting the following WARN_ON() in kvm_timer_update_irq() WARNING CPU 0 PID 3281 at arch/arm64/kvm/arch_timer.c459 kvm_timer_update_irq+0x21c/0x394 Call trace kvm_timer_update_irq+0x21c/0x394 arch/arm64/kvm/arch_timer.c459 kvm_timer_vcpu_reset+0x158/0x684 arch/arm64/kvm/arch_timer.c968 kvm_reset_vcpu+0x3b4/0x560 arch/arm64/kvm/reset.c264 kvm_vcpu_set_target arch/arm64/kvm/arm.c1553 [inline] kvm_arch_vcpu_ioctl_vcpu_init arch/arm64/kvm/arm.c1573 [inline] kvm_arch_vcpu_ioctl+0x112c/0x1b3c arch/arm64/kvm/arm.c1695 kvm_vcpu_ioctl+0x4ec/0xf74 virt/kvm/kvm_main.c4658 vfs_ioctl fs/ioctl.c51 [inline] __do_sys_ioctl fs/ioctl.c907 [inline] __se_sys_ioctl fs/ioctl.c893 [inline] __arm64_sys_ioctl+0x108/0x184 fs/ioctl.c893 __invoke_syscall arch/arm64/kernel/syscall.c35 [inline] invoke_syscall+0x78/0x1b8 arch/arm64/kernel/syscall.c49 el0_svc_common+0xe8/0x1b0 arch/arm64/kernel/syscall.c132 do_el0_svc+0x40/0x50 arch/arm64/kernel/syscall.c151 el0_svc+0x54/0x14c arch/arm64/kernel/entry-common.c712 el0t_64_sync_handler+0x84/0xfc arch/arm64/kernel/entry-common.c730 el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S598 The following sequence led to the scenario - Userspace creates a VM and a vCPU. - The vCPU is initialized with KVM_ARM_VCPU_PMU_V3 during KVM_ARM_VCPU_INIT. - Without any other setup, such as vGIC or vPMU, userspace issues KVM_RUN on the vCPU. Since the vPMU is requested, but not setup, kvm_arm_pmu_v3_enable() fails in kvm_arch_vcpu_run_pid_change(). As a result, KVM_RUN returns after enabling the timer, but before incrementing userspace_irqchip_in_use kvm_arch_vcpu_run_pid_change() ret = kvm_arm_pmu_v3_enable() if (!vcpu->arch.pmu.created) return -EINVAL if (ret) return ret [...] if (!irqchip_in_kernel(kvm)) static_branch_inc(&userspace_irqchip_in_use) - Userspace ignores the error and issues KVM_ARM_VCPU_INIT again. Since the timer is already enabled, control moves through the following flow, ultimately hitting the WARN_ON() kvm_timer_vcpu_reset() if (timer->enabled) kvm_timer_update_irq() if (!userspace_irqchip()) ret = kvm_vgic_inject_irq() ret = vgic_lazy_init() if (unlikely(!vgic_initialized(kvm))) if (kvm->arch.vgic.vgic_model != KVM_DEV_TYPE_ARM_VGIC_V2) return -EBUSY WARN_ON(ret) Theoretically, since userspace_irqchip_in_uses functionality can be simply replaced by !irqchip_in_kernel(), get rid of the static key to avoid the mismanagement, which also helps with the syzbot issue.",
    "enhanced_query": "In the Linux kernel, the following vulnerability has been resolved KVM arm64 Get rid of userspace_irqchip_in_use Improper use of userspace_irqchip_in_use led to syzbot hitting the following WARN_ON() in kvm_timer_update_irq() WARNING CPU 0 PID 3281 at arch/arm64/kvm/arch_timer.c459 kvm_timer_update_irq+0x21c/0x394 Call trace kvm_timer_update_irq+0x21c/0x394 arch/arm64/kvm/arch_timer.c459 kvm_timer_vcpu_reset+0x158/0x684 arch/arm64/kvm/arch_timer.c968 kvm_reset_vcpu+0x3b4/0x560 arch/arm64/kvm/reset.c264 kvm_vcpu_set_target arch/arm64/kvm/arm.c1553 [inline] kvm_arch_vcpu_ioctl_vcpu_init arch/arm64/kvm/arm.c1573 [inline] kvm_arch_vcpu_ioctl+0x112c/0x1b3c arch/arm64/kvm/arm.c1695 kvm_vcpu_ioctl+0x4ec/0xf74 virt/kvm/kvm_main.c4658 vfs_ioctl fs/ioctl.c51 [inline] __do_sys_ioctl fs/ioctl.c907 [inline] __se_sys_ioctl fs/ioctl.c893 [inline] __arm64_sys_ioctl+0x108/0x184 fs/ioctl.c893 __invoke_syscall arch/arm64/kernel/syscall.c35 [inline] invoke_syscall+0x78/0x1b8 arch/arm64/kernel/syscall.c49 el0_svc_common+0xe8/0x1b0 arch/arm64/kernel/syscall.c132 do_el0_svc+0x40/0x50 arch/arm64/kernel/syscall.c151 el0_svc+0x54/0x14c arch/arm64/kernel/entry-common.c712 el0t_64_sync_handler+0x84/0xfc arch/arm64/kernel/entry-common.c730 el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S598 The following sequence led to the scenario - Userspace creates a VM and a vCPU. - The vCPU is initialized with KVM_ARM_VCPU_PMU_V3 during KVM_ARM_VCPU_INIT. - Without any other setup, such as vGIC or vPMU, userspace issues KVM_RUN on the vCPU. Since the vPMU is requested, but not setup, kvm_arm_pmu_v3_enable() fails in kvm_arch_vcpu_run_pid_change(). As a result, KVM_RUN returns after enabling the timer, but before incrementing userspace_irqchip_in_use kvm_arch_vcpu_run_pid_change() ret = kvm_arm_pmu_v3_enable() if (!vcpu->arch.pmu.created) return -EINVAL if (ret) return ret [...] if (!irqchip_in_kernel(kvm)) static_branch_inc(&userspace_irqchip_in_use) - Userspace ignores the error and issues KVM_ARM_VCPU_INIT again. Since the timer is already enabled, control moves through the following flow, ultimately hitting the WARN_ON() kvm_timer_vcpu_reset() if (timer->enabled) kvm_timer_update_irq() if (!userspace_irqchip()) ret = kvm_vgic_inject_irq() ret = vgic_lazy_init() if (unlikely(!vgic_initialized(kvm))) if (kvm->arch.vgic.vgic_model != KVM_DEV_TYPE_ARM_VGIC_V2) return -EBUSY WARN_ON(ret) Theoretically, since userspace_irqchip_in_uses functionality can be simply replaced by !irqchip_in_kernel(), get rid of the static key to avoid the mismanagement, which also helps with the syzbot issue. Consider specifically these CWEs: CWE-226 CWE-733 CWE-667 CWE-393 CWE-909 CWE-1256 CWE-1342 CWE-362 CWE-367",
    "cwe_mentions": [
      "CWE-226",
      "CWE-733",
      "CWE-667",
      "CWE-393",
      "CWE-909",
      "CWE-1256",
      "CWE-1342",
      "CWE-362",
      "CWE-367"
    ],
    "search_time": 2.5316624641418457
  },
  "timestamp": "2025-07-13 21:45:39",
  "cve_id": "CVE-2024-53195",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "609",
      "name": "Double-Checked Locking",
      "type": "base",
      "score": 2.8651999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "226",
      "name": "Sensitive Information in Resource Not Removed Before Reuse",
      "type": "base",
      "score": 2.4699999999999998,
      "relationship_count": 0
    },
    {
      "cwe_id": "386",
      "name": "Symbolic Name not Mapping to Correct Object",
      "type": "base",
      "score": 2.3764000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "201",
      "name": "Insertion of Sensitive Information Into Sent Data",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "393",
      "name": "Return of Wrong Status Code",
      "type": "base",
      "score": 2.1189999999999998,
      "relationship_count": 0
    },
    {
      "cwe_id": "367",
      "name": "Time-of-check Time-of-use (TOCTOU) Race Condition",
      "type": "Base",
      "score": 2.036474648843715,
      "relationship_count": 0
    },
    {
      "cwe_id": "120",
      "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "123",
      "name": "Write-what-where Condition",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "364",
      "name": "Signal Handler Race Condition",
      "type": "base",
      "score": 1.7550000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "1342",
      "name": "Information Exposure through Microarchitectural State after Transient Execution",
      "type": "Base",
      "score": 1.7091790760896892,
      "relationship_count": 0
    },
    {
      "cwe_id": "1265",
      "name": "Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "1325",
      "name": "Improperly Controlled Sequential Memory Allocation",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "61",
      "name": "UNIX Symbolic Link (Symlink) Following",
      "type": "compound",
      "score": 1.61,
      "relationship_count": 0
    },
    {
      "cwe_id": "212",
      "name": "Improper Removal of Sensitive Information Before Storage or Transfer",
      "type": "base",
      "score": 1.6094,
      "relationship_count": 0
    },
    {
      "cwe_id": "789",
      "name": "Memory Allocation with Excessive Size Value",
      "type": "variant",
      "score": 1.5552000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "908",
      "name": "Use of Uninitialized Resource",
      "type": "Base",
      "score": 1.521720022990278,
      "relationship_count": 0
    },
    {
      "cwe_id": "456",
      "name": "Missing Initialization of a Variable",
      "type": "variant",
      "score": 1.51536,
      "relationship_count": 0
    },
    {
      "cwe_id": "1256",
      "name": "Improper Restriction of Software Interfaces to Hardware Features",
      "type": "Base",
      "score": 1.4849891012511403,
      "relationship_count": 0
    },
    {
      "cwe_id": "415",
      "name": "Double Free",
      "type": "variant",
      "score": 1.4784000000000002,
      "relationship_count": 0
    }
  ]
}