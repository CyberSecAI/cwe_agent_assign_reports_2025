# Vulnerability Information: CVE-2024-40900

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved cachefiles remove requests from xarray during flushing requests Even with CACHEFILES_DEAD set, we can still read the requests, so in the following concurrency the request may be used after it has been freed mount | daemon_thread1 | daemon_thread2 ------------------------------------------------------------ cachefiles_ondemand_init_object cachefiles_ondemand_send_req REQ_A = kzalloc(sizeof(*req) + data_len) wait_for_completion(&REQ_A->done) cachefiles_daemon_read cachefiles_ondemand_daemon_read // close dev fd cachefiles_flush_reqs complete(&REQ_A->done) kfree(REQ_A) xa_lock(&cache->reqs) cachefiles_ondemand_select_req req->msg.opcode != CACHEFILES_OP_READ // req **use-after-free** !!! xa_unlock(&cache->reqs) xa_destroy(&cache->reqs) Hence remove requests from cache->reqs when flushing them to avoid accessing freed requests.

### Vulnerability Description Key Phrases
- **weakness:** **use-after-free**
- **product:** Linux kernel

## CVE Reference Links Content Summary
Based on the provided information, all of the content is related to the same vulnerability.

**Root cause of vulnerability:**
A use-after-free vulnerability exists in the cachefiles module of the Linux kernel due to a race condition in handling requests during cache flushing.

**Weaknesses/vulnerabilities present:**
- Use-after-free: The vulnerability occurs when a request is freed but subsequently accessed by another thread in the `cachefiles_ondemand_select_req` function

**Impact of exploitation:**
- The primary impact is a use-after-free condition that can lead to a system crash or other unpredictable behavior, potentially allowing for arbitrary code execution.

**Attack vectors:**
- The vulnerability is triggered by concurrent operations involving mounting, daemon threads, and cache flushing.
- The attacker needs to cause a race condition between the cache flushing operation and the use of the request by the `cachefiles_ondemand_select_req` function after it has been freed.

**Required attacker capabilities/position:**
- An attacker needs to have the ability to mount cachefiles and trigger cache flush operations in a way that causes the race condition.
- The attacker needs to be able to control or influence the timing of operations by different threads to trigger the use-after-free.

**Detailed Explanation:**
The vulnerability occurs because the cachefiles module does not remove requests from the `cache->reqs` xarray before freeing them during cache flushing. The following sequence of events demonstrates the vulnerability.

1. A mount operation initiates `cachefiles_ondemand_init_object` and sends a request using `cachefiles_ondemand_send_req`. A request (REQ_A) is allocated and added to the cache's request xarray. The calling thread waits for completion of the request.
2. A daemon thread reads the request using `cachefiles_daemon_read` which calls `cachefiles_ondemand_daemon_read`. The file descriptor used for communication is closed.
3. In another thread, `cachefiles_flush_reqs` is called. This function iterates through all requests in the cache's xarray, sets an error for each, completes the request using `complete(&req->done)`, and frees the request using `kfree(REQ_A)`.
4. Simultaneously, another daemon thread might be trying to use the request via `cachefiles_ondemand_select_req`. Because the xarray still contains the request at this point, this code path can execute and use the request even though it has already been freed, resulting in use-after-free.

The fix is to remove the request from the xarray using `__xa_erase(xa, index)` during flushing before completing the request and freeing it, preventing access to the freed memory.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 416 | Use After Free | Variant | Allowed | alternate_terms | 1.000 |
| 2 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.314 |
| 3 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.307 |
| 4 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.296 |
| 5 | 404 | Improper Resource Shutdown or Release | Class | Allowed-with-Review | sparse | 0.295 |
| 6 | 364 | Signal Handler Race Condition | Base | Allowed | sparse | 0.295 |
| 7 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.292 |
| 8 | 226 | Sensitive Information in Resource Not Removed Before Reuse | Base | Allowed | sparse | 0.286 |
| 9 | 366 | Race Condition within a Thread | Base | Allowed | dense | 0.490 |
| 10 | 609 | Double-Checked Locking | Base | Allowed | graph | 0.003 |

