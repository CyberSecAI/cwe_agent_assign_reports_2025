# Vulnerability Information: CVE-2024-45056

## Vulnerability Description
zksolc is a Solidity compiler for ZKsync. All LLVM versions since 2015 fold `(xor (shl 1, x), -1)` to `(rotl ~1, x)` if run with optimizations enabled. Here `~1` is generated as an unsigned 64 bits number (`2^64-1`). This number is zero-extended to 256 bits on EraVM target while it should have been sign-extended. Thus instead of producing `roti 2^256 - 1, x` the compiler produces `rotl 2^64 - 1, x`. Analysis has shown that no contracts were affected by the date of publishing this advisory. This issue has been addressed in version 1.5.3. Users are advised to upgrade and redeploy all contracts. There are no known workarounds for this vulnerability.

### Vulnerability Description Key Phrases
- **rootcause:** **incorrect sign extension of LLVM constant folding optimization**
- **impact:** produces `rotl 2^64 - 1, x` instead of `roti 2^256 - 1, x`
- **product:** zksolc
- **version:** prior to 1.5.3

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of CVE-2024-45056:

**Root Cause of Vulnerability:**

The vulnerability stems from a misoptimization in the LLVM compiler. Specifically, the compiler incorrectly folds the expression `(xor (shl 1, x), -1)` into `(rotl ~1, x)` when optimizations are enabled. The issue is that when targeting EraVM, the `~1` (which is `2^64 -1` as an unsigned 64-bit number) is zero-extended to 256 bits instead of sign-extended. This leads to using `rotl 2^64 - 1, x` instead of `rotl 2^256 - 1, x`.

**Weaknesses/Vulnerabilities Present:**

*   **Incorrect Optimization:** The compiler performs an optimization that is not correct for the specific target architecture (EraVM), resulting in an incorrect rotation operation.
*   **Type Conversion Issue**:  The compiler incorrectly handles type extension (zero-extension instead of sign-extension) for constant values when translating it to the target architecture.

**Impact of Exploitation:**

The incorrect rotation operation causes incorrect bit manipulation. In the specific Solidity example given, the code intended to clear a bit at a specific index in the input `data` will instead clear the bit at an incorrect location due to the shortened rotation. This may lead to unexpected behavior of smart contracts. The provided advisory states that analysis showed no contracts were affected by the date of publishing this advisory.

**Attack Vectors:**

*   The vulnerability is triggered when compiling Solidity code using the zksolc compiler with optimizations enabled.
*   The vulnerable code pattern is a bitwise operation with a shift and then a bitwise not.
*   An attacker could potentially exploit this vulnerability by crafting smart contracts that rely on correct bit manipulation using the identified pattern.

**Required Attacker Capabilities/Position:**

*   The attacker needs to be able to deploy or interact with smart contracts compiled with a vulnerable version of the `zksolc` compiler (prior to 1.5.3).
*   The attacker must craft or find a smart contract that uses the specific bit manipulation pattern which triggers the misoptimization.
*  The attacker doesn't require special privileges to trigger the vulnerability, if such contracts are deployed.

**Additional Details:**

*   The vulnerability is present in LLVM versions since 2015, but its impact is limited to the EraVM target in the context of `zksolc` compiler.
*   The fix involves correcting the type extension during code generation for the EraVM target.
*   The provided commit diff shows the LLVM code where the optimization was introduced.
*   The provided Solidity code example illustrates how the vulnerability can be triggered.
*   The vulnerability is rated as "Moderate" severity.

**Summary of Technical Details:**

The core technical detail lies in the LLVM's DAG combiner folding the XOR and SHL operations to ROTL in a way that assumes a specific representation of -1 and a sign-extended value when it is not the case. This misoptimization causes a significant bug in the compilation process when targeting the EraVM due to the zero-extension of a 64 bit value to a 256 bit one.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 194 | Unexpected Sign Extension | Variant | Allowed | sparse | 0.620 |
| 2 | 201 | Insertion of Sensitive Information Into Sent Data | Base | Allowed | sparse | 0.524 |
| 3 | 337 | Predictable Seed in Pseudo-Random Number Generator (PRNG) | Variant | Allowed | sparse | 0.521 |
| 4 | 1204 | Generation of Weak Initialization Vector (IV) | Base | Allowed | sparse | 0.515 |
| 5 | 863 | Incorrect Authorization | Class | Allowed-with-Review | sparse | 0.510 |
| 6 | 916 | Use of Password Hash With Insufficient Computational Effort | Base | Allowed | sparse | 0.510 |
| 7 | 1333 | Inefficient Regular Expression Complexity | Base | Allowed | sparse | 0.502 |
| 8 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.493 |
| 9 | 1335 | Incorrect Bitwise Shift of Integer | Base | Allowed | dense | 0.429 |
| 10 | 839 | Numeric Range Comparison Without Minimum Check | Base | Allowed | graph | 0.002 |

