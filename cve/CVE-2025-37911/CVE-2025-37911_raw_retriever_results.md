# Raw Retriever Results for CVE-2025-37911

# Raw Retriever Results for CVE-2025-37911
## Query
In the Linux kernel, the following vulnerability has been resolved bnxt_en Fix out-of-bound memcpy() during ethtool -w When retrieving the FW coredump using ethtool, it can sometimes cause memory corruption BUG KFENCE memory corruption in __bnxt_get_coredump+0x3ef/0x670 [bnxt_en] Corrupted memory at 0x000000008f0f30e8 [ ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ] (in kfence-#45) __bnxt_get_coredump+0x3ef/0x670 [bnxt_en] ethtool_get_dump_data+0xdc/0x1a0 __dev_ethtool+0xa1e/0x1af0 dev_ethtool+0xa8/0x170 dev_ioctl+0x1b5/0x580 sock_do_ioctl+0xab/0xf0 sock_ioctl+0x1ce/0x2e0 __x64_sys_ioctl+0x87/0xc0 do_syscall_64+0x5c/0xf0 entry_SYSCALL_64_after_hwframe+0x78/0x80 ... This happens when copying the coredump segment list in bnxt_hwrm_dbg_dma_data() with the HWRM_DBG_COREDUMP_LIST FW command. The info->dest_buf buffer is allocated based on the number of coredump segments returned by the FW. The segment list is then DMAed by the FW and the length of the DMA is returned by FW. The driver then copies this DMAed segment list to info->dest_buf. In some cases, this DMA length may exceed the info->dest_buf length and cause the above BUG condition. Fix it by capping the copy length to not exceed the length of info->dest_buf. The extra DMA data contains no useful information. This code path is shared for the HWRM_DBG_COREDUMP_LIST and the HWRM_DBG_COREDUMP_RETRIEVE FW commands. The buffering is different for these 2 FW commands. To simplify the logic, we need to move the line to adjust the buffer length for HWRM_DBG_COREDUMP_RETRIEVE up, so that the new check to cap the copy length will work for both commands.

## Keyphrases
- **weakness**: 'memory corruption'

## Score Statistics
| Retriever | Min | Max | Mean | Median | Count |
|-----------|-----|-----|------|--------|-------|
| Dense | 0.4978 | 0.5841 | 0.5274 | 0.5262 | 20 |
| Sparse | 334.9442 | 1028.6758 | 925.2555 | 977.1546 | 11 |
| Graph | 1.6833 | 2.5440 | 2.0633 | 2.2025 | 20 |

## Graph Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Mapping Usage |
|---|--------|------|-------------|-------|---------------|
| 1 | 787 | Out-of-bounds Write | Base | 2.5440 | Allowed |
| 2 | 1339 | Insufficient Precision or Accuracy of a Real Number | base | 2.3868 | Allowed |
| 3 | 128 | Wrap-around Error | base | 2.3868 | Allowed |
| 4 | 129 | Improper Validation of Array Index | variant | 2.2704 | Allowed |
| 5 | 781 | Improper Address Validation in IOCTL with METHOD_NEITHER I/O Control Code | variant | 2.2704 | Allowed |
| 6 | 170 | Improper Null Termination | base | 2.2100 | Allowed |
| 7 | 824 | Access of Uninitialized Pointer | base | 2.2100 | Allowed |
| 8 | 825 | Expired Pointer Dereference | base | 2.2100 | Allowed |
| 9 | 390 | Detection of Error Condition Without Action | base | 2.2100 | Allowed |
| 10 | 609 | Double-Checked Locking | base | 2.2100 | Allowed |
| 11 | 125 | Out-of-bounds Read | Base | 2.1951 | Allowed |
| 12 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | base | 2.1190 | Allowed |
| 13 | 190 | Integer Overflow or Wraparound | Base | 2.0492 | Allowed |
| 14 | 120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | base | 1.7680 | Allowed-with-Review |
| 15 | 562 | Return of Stack Variable Address | base | 1.7680 | Allowed |

## Dense Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Original Score | Mapping Usage |
|---|--------|------|-------------|-------|----------------|---------------|
| 1 | 805 | Buffer Access with Incorrect Length Value | Base | 0.5841 | 0.5841 | Allowed |
| 2 | 126 | Buffer Over-read | Variant | 0.5637 | 0.5637 | Allowed |
| 3 | 401 | Missing Release of Memory after Effective Lifetime | Variant | 0.5543 | 0.5543 | Allowed |
| 4 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | 0.5503 | 0.5503 | Allowed |
| 5 | 191 | Integer Underflow (Wrap or Wraparound) | Base | 0.5487 | 0.5487 | Allowed |
| 6 | 122 | Heap-based Buffer Overflow | Variant | 0.5477 | 0.5477 | Allowed |
| 7 | 789 | Memory Allocation with Excessive Size Value | Variant | 0.5389 | 0.5389 | Allowed |
| 8 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | 0.5375 | 0.5375 | Discouraged |
| 9 | 909 | Missing Initialization of Resource | Class | 0.5374 | 0.5374 | Allowed-with-Review |
| 10 | 190 | Integer Overflow or Wraparound | Base | 0.5369 | 0.5369 | Allowed |
| 11 | 124 | Buffer Underwrite ('Buffer Underflow') | Base | 0.5155 | 0.5155 | Allowed |
| 12 | 131 | Incorrect Calculation of Buffer Size | Base | 0.5148 | 0.5148 | Allowed |
| 13 | 130 | Improper Handling of Length Parameter Inconsistency | Base | 0.5098 | 0.5098 | Allowed |
| 14 | 787 | Out-of-bounds Write | Base | 0.5050 | 0.5050 | Allowed |
| 15 | 121 | Stack-based Buffer Overflow | Variant | 0.5041 | 0.5041 | Allowed |

## Sparse Retriever Results (11)
| # | CWE ID | Name | Score | Original Score | Mapping Usage |
|---|--------|------|-------|---------------|---------------|
| 1 | 1284 | Improper Validation of Specified Quantity in Input | 1028.6758 | 1028.6758 | Allowed |
| 2 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | 1000.0414 | 1000.0414 | Allowed |
| 3 | 787 | Out-of-bounds Write | 1000.0000 | 1000.0000 | Allowed |
| 4 | 125 | Out-of-bounds Read | 996.8078 | 996.8078 | Allowed |
| 5 | 190 | Integer Overflow or Wraparound | 983.9903 | 983.9903 | Allowed |
| 6 | 131 | Incorrect Calculation of Buffer Size | 977.1546 | 977.1546 | Allowed |
| 7 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | 971.8034 | 971.8034 | Allowed |
| 8 | 191 | Integer Underflow (Wrap or Wraparound) | 967.9530 | 967.9530 | Allowed |
| 9 | 401 | Missing Release of Memory after Effective Lifetime | 962.4775 | 962.4775 | Allowed |
| 10 | 476 | NULL Pointer Dereference | 953.9627 | 953.9627 | Allowed |
| 11 | 770 | Allocation of Resources Without Limits or Throttling | 334.9442 | 334.9442 | Allowed |
