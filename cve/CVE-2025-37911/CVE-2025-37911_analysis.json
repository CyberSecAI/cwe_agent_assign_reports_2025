{
  "cve_id": "CVE-2025-37911",
  "description": "In the Linux kernel, the following vulnerability has been resolved bnxt_en Fix out-of-bound memcpy() during ethtool -w When retrieving the FW coredump using ethtool, it can sometimes cause **memory corruption** BUG KFENCE **memory corruption** in __bnxt_get_coredump+0x3ef/0x670 [bnxt_en] Corrupted memory at 0x000000008f0f30e8 [ ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ] (in kfence-#45) __bnxt_get_coredump+0x3ef/0x670 [bnxt_en] ethtool_get_dump_data+0xdc/0x1a0 __dev_ethtool+0xa1e/0x1af0 dev_ethtool+0xa8/0x170 dev_ioctl+0x1b5/0x580 sock_do_ioctl+0xab/0xf0 sock_ioctl+0x1ce/0x2e0 __x64_sys_ioctl+0x87/0xc0 do_syscall_64+0x5c/0xf0 entry_SYSCALL_64_after_hwframe+0x78/0x80 ... This happens when copying the coredump segment list in bnxt_hwrm_dbg_dma_data() with the HWRM_DBG_COREDUMP_LIST FW command. The info->dest_buf buffer is allocated based on the number of coredump segments returned by the FW. The segment list is then DMAed by the FW and the length of the DMA is returned by FW. The driver then copies this DMAed segment list to info->dest_buf. In some cases, this DMA length may exceed the info->dest_buf length and cause the above BUG condition. Fix it by capping the copy length to not exceed the length of info->dest_buf. The extra DMA data contains no useful information. This code path is shared for the HWRM_DBG_COREDUMP_LIST and the HWRM_DBG_COREDUMP_RETRIEVE FW commands. The buffering is different for these 2 FW commands. To simplify the logic, we need to move the line to adjust the buffer length for HWRM_DBG_COREDUMP_RETRIEVE up, so that the new check to cap the copy length will work for both commands.",
  "key_phrases": {
    "rootcause": "",
    "weakness": "memory corruption",
    "impact": "",
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "bnxt_en"
  },
  "reference_content": null,
  "similar_info": {
    "cwe_distribution": {},
    "cwe_consensus": "",
    "similarity_stats": {
      "thresholds": [],
      "total_samples_by_threshold": {},
      "top_cwes_by_threshold": {}
    }
  },
  "similarity_summary": {
    "consensus_cwe": "",
    "top_cwes": [],
    "confidence_levels": {},
    "total_samples": 0
  },
  "analysis": "# Summary\n| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |\n|---|---|---|---|---|---|\n| CWE-787 | Out-of-bounds Write | 0.9 | Base | Allowed | Primary CWE. The driver copies data to a buffer without proper bounds checking, leading to memory corruption. |\n| CWE-131 | Incorrect Calculation of Buffer Size | 0.7 | Base | Allowed | Secondary CWE. The allocated buffer size is dependent on the number of coredump segments, which may not be sufficient to hold the DMAed data. |\n| CWE-1284 | Improper Validation of Specified Quantity in Input | 0.6 | Base | Allowed | Secondary CWE. The length of the DMA data is not validated against the allocated buffer size, which causes the out-of-bounds write. |\n\n## Evidence and Confidence\n\n*   **Confidence Score:** 0.8\n*   **Evidence Strength:** MEDIUM\n\n## Relationship Analysis\nThe primary weakness is CWE-787, which results from a **incorrect calculation of buffer size** (CWE-131) and **improper validation of specified quantity in input** (CWE-1284). CWE-787 is a child of CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer), indicating a general class of buffer-related errors. CWE-131 and CWE-1284 can precede CWE-787, as they set the stage for an out-of-bounds write.\n\n```mermaid\ngraph TD\n    cwe787[\"CWE-787: Out-of-bounds Write\"]\n    cwe131[\"CWE-131: Incorrect Calculation of Buffer Size\"]\n    cwe1284[\"CWE-1284: Improper Validation of Specified Quantity in Input\"]\n    cwe119[\"CWE-119: Improper Restriction of Operations\"]\n    \n    cwe787 -->|CHILDOF| cwe119\n    cwe131 -->|CANPRECEDE| cwe787\n    cwe1284 -->|CANPRECEDE| cwe787\n    \n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    classDef tertiary fill:#9e9,stroke:#333\n    class cwe787 primary\n    class cwe131,cwe1284,cwe119 secondary\n```\n\n## Vulnerability Chain\n1.  The driver calculates the buffer size based on the number of coredump segments (CWE-131).\n2.  The FW DMAs data, and the length is returned to the driver.\n3.  The driver copies the DMAed segment list to the buffer without validating that the DMA length does not exceed the buffer length (CWE-1284).\n4.  The DMA length exceeds the buffer length (CWE-131, CWE-1284).\n5.  An out-of-bounds write occurs, leading to **memory corruption** (CWE-787).\n\n## Summary of Analysis\nThe primary vulnerability is an out-of-bounds write (CWE-787) that leads to **memory corruption**. The root cause is a combination of **incorrect calculation of buffer size** (CWE-131) and **improper validation of specified quantity in input** (CWE-1284). The driver allocates a buffer and then copies data into it without properly checking the size of the data being copied, which results in writing past the end of the buffer.\n\nThe evidence from the vulnerability description is: \"In some cases, this DMA length may exceed the info->dest_buf length and cause the above BUG condition. Fix it by capping the copy length to not exceed the length of info->dest_buf.\" This clearly indicates that the DMA length sometimes exceeds the buffer length, and the fix involves limiting the copy length to the buffer length, supporting the assessment of CWE-787 and CWE-1284. The mention of `info->dest_buf buffer is allocated based on the number of coredump segments` supports the assessment of CWE-131, since the number of segments doesn't mean the resulting buffer size will be correct.\n\nThe graph relationships influenced the selection by highlighting the chain of events leading to the out-of-bounds write. The selected CWEs are at the optimal level of specificity because they accurately represent the technical details of the vulnerability and are base level CWEs.\n\nCWEs Considered but Not Used:\n\n*   CWE-125 (Out-of-bounds Read): While out-of-bounds read is related to buffer access issues, the vulnerability description specifically mentions an out-of-bounds *write*, making CWE-787 a more accurate fit.\n*   CWE-190 (Integer Overflow or Wraparound) and CWE-191 (Integer Underflow): These CWEs relate to integer calculation errors, but the core issue here is the lack of proper bounds checking during the data copy, not integer manipulation.\n*   CWE-362 (Race Condition): This CWE relates to concurrency issues, which are not mentioned in the vulnerability description.\n*   CWE-755 (Improper Handling of Exceptional Conditions): This is a general class and is less specific than the identified CWEs.\n*   CWE-805 (Buffer Access with Incorrect Length Value): Similar to CWE-787, but CWE-787 more directly captures the out-of-bounds write.",
  "analysis_with_relationships": "# Summary\n| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |\n|---|---|---|---|---|---|\n| CWE-787 | Out-of-bounds Write | 0.9 | Base | Allowed | Primary CWE. The driver copies data to a buffer without proper bounds checking, leading to memory corruption. |\n| CWE-131 | Incorrect Calculation of Buffer Size | 0.7 | Base | Allowed | Secondary CWE. The allocated buffer size is dependent on the number of coredump segments, which may not be sufficient to hold the DMAed data. |\n| CWE-1284 | Improper Validation of Specified Quantity in Input | 0.6 | Base | Allowed | Secondary CWE. The length of the DMA data is not validated against the allocated buffer size, which causes the out-of-bounds write. |\n\n## Evidence and Confidence\n\n*   **Confidence Score:** 0.8\n*   **Evidence Strength:** MEDIUM\n\n## Relationship Analysis\nThe primary weakness is CWE-787, which results from a **incorrect calculation of buffer size** (CWE-131) and **improper validation of specified quantity in input** (CWE-1284). CWE-787 is a child of CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer), indicating a general class of buffer-related errors. CWE-131 and CWE-1284 can precede CWE-787, as they set the stage for an out-of-bounds write.\n\n```mermaid\ngraph TD\n    cwe787[\"CWE-787: Out-of-bounds Write\"]\n    cwe131[\"CWE-131: Incorrect Calculation of Buffer Size\"]\n    cwe1284[\"CWE-1284: Improper Validation of Specified Quantity in Input\"]\n    cwe119[\"CWE-119: Improper Restriction of Operations\"]\n    \n    cwe787 -->|CHILDOF| cwe119\n    cwe131 -->|CANPRECEDE| cwe787\n    cwe1284 -->|CANPRECEDE| cwe787\n    \n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    classDef tertiary fill:#9e9,stroke:#333\n    class cwe787 primary\n    class cwe131,cwe1284,cwe119 secondary\n```\n\n## Vulnerability Chain\n1.  The driver calculates the buffer size based on the number of coredump segments (CWE-131).\n2.  The FW DMAs data, and the length is returned to the driver.\n3.  The driver copies the DMAed segment list to the buffer without validating that the DMA length does not exceed the buffer length (CWE-1284).\n4.  The DMA length exceeds the buffer length (CWE-131, CWE-1284).\n5.  An out-of-bounds write occurs, leading to **memory corruption** (CWE-787).\n\n## Summary of Analysis\nThe primary vulnerability is an out-of-bounds write (CWE-787) that leads to **memory corruption**. The root cause is a combination of **incorrect calculation of buffer size** (CWE-131) and **improper validation of specified quantity in input** (CWE-1284). The driver allocates a buffer and then copies data into it without properly checking the size of the data being copied, which results in writing past the end of the buffer.\n\nThe evidence from the vulnerability description is: \"In some cases, this DMA length may exceed the info->dest_buf length and cause the above BUG condition. Fix it by capping the copy length to not exceed the length of info->dest_buf.\" This clearly indicates that the DMA length sometimes exceeds the buffer length, and the fix involves limiting the copy length to the buffer length, supporting the assessment of CWE-787 and CWE-1284. The mention of `info->dest_buf buffer is allocated based on the number of coredump segments` supports the assessment of CWE-131, since the number of segments doesn't mean the resulting buffer size will be correct.\n\nThe graph relationships influenced the selection by highlighting the chain of events leading to the out-of-bounds write. The selected CWEs are at the optimal level of specificity because they accurately represent the technical details of the vulnerability and are base level CWEs.\n\nCWEs Considered but Not Used:\n\n*   CWE-125 (Out-of-bounds Read): While out-of-bounds read is related to buffer access issues, the vulnerability description specifically mentions an out-of-bounds *write*, making CWE-787 a more accurate fit.\n*   CWE-190 (Integer Overflow or Wraparound) and CWE-191 (Integer Underflow): These CWEs relate to integer calculation errors, but the core issue here is the lack of proper bounds checking during the data copy, not integer manipulation.\n*   CWE-362 (Race Condition): This CWE relates to concurrency issues, which are not mentioned in the vulnerability description.\n*   CWE-755 (Improper Handling of Exceptional Conditions): This is a general class and is less specific than the identified CWEs.\n*   CWE-805 (Buffer Access with Incorrect Length Value): Similar to CWE-787, but CWE-787 more directly captures the out-of-bounds write.\n\n\n## CWE Relationship Analysis\n\nCurrent CWEs represent these abstraction levels: .\n\n\n### Vulnerability Chain Analysis\n\n**Chain starting from CWE-1284:**\n- 1284 (Improper Validation of Specified Quantity in Input) - ROOT\n\n\n**Chain starting from CWE-805:**\n- 805 (Buffer Access with Incorrect Length Value) - ROOT\n\n\n\n### CWE Relationship Diagram\n\n```mermaid\ngraph TD\n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    classDef tertiary fill:#9e9,stroke:#333\n```",
  "criticism": "",
  "resolution": "",
  "relevant_cwes": [
    {
      "metadata": {
        "doc_id": "787",
        "name": "Out-of-bounds Write",
        "source": "alternate_terms",
        "original_matched_text": "AlternateTerms: Memory Corruption",
        "match_reason": "exact_match_whole_phrase"
      },
      "similarity": 1000.0,
      "alternate_term_match": true
    },
    {
      "metadata": {
        "doc_id": "1284",
        "name": "Improper Validation of Specified Quantity in Input",
        "source": "sparse"
      },
      "similarity": 1028.6757831541593
    },
    {
      "metadata": {
        "doc_id": "367",
        "name": "Time-of-check Time-of-use (TOCTOU) Race Condition",
        "source": "sparse"
      },
      "similarity": 1000.0413658732574
    },
    {
      "metadata": {
        "doc_id": "125",
        "name": "Out-of-bounds Read",
        "source": "sparse"
      },
      "similarity": 996.8078499707347
    },
    {
      "metadata": {
        "doc_id": "190",
        "name": "Integer Overflow or Wraparound",
        "source": "sparse"
      },
      "similarity": 983.9902940752582
    },
    {
      "metadata": {
        "doc_id": "131",
        "name": "Incorrect Calculation of Buffer Size",
        "source": "sparse"
      },
      "similarity": 977.1546058018099
    },
    {
      "metadata": {
        "doc_id": "1285",
        "name": "Improper Validation of Specified Index, Position, or Offset in Input",
        "source": "sparse"
      },
      "similarity": 971.8034009639396
    },
    {
      "metadata": {
        "doc_id": "191",
        "name": "Integer Underflow (Wrap or Wraparound)",
        "source": "sparse"
      },
      "similarity": 967.952980889213
    },
    {
      "metadata": {
        "doc_id": "805",
        "name": "Buffer Access with Incorrect Length Value",
        "type": "Base",
        "original_content": "The product uses a sequential operation to read or write a buffer, but it uses an incorrect length value that causes it to access memory that is outside of the bounds of the buffer.",
        "keyphrase_source": "weakness:memory corruption",
        "source": "dense",
        "mapping_notes": {
          "usage": "Allowed",
          "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
          "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
          "reasons": [
            "Acceptable-Use"
          ]
        },
        "score_info": {
          "retrievers": [
            "dense",
            "graph"
          ],
          "retriever_count": 2,
          "normalized_scores": {
            "dense": 0.5840649487045135,
            "graph": 1.6833315387764758
          }
        }
      },
      "similarity": 0.5840649487045135
    },
    {
      "doc_id": "1339",
      "text": "CWE-1339: Insufficient Precision or Accuracy of a Real Number",
      "score": 2.3868000000000005,
      "metadata": {
        "doc_id": "1339",
        "name": "Insufficient Precision or Accuracy of a Real Number",
        "type": "base",
        "original_content": "CWE-1339: Insufficient Precision or Accuracy of a Real Number",
        "relationships": [
          {
            "source_id": "1339",
            "target_id": "119",
            "label": "CANPRECEDE",
            "properties": {
              "view_id": "1000"
            }
          },
          {
            "source_id": "1339",
            "target_id": "834",
            "label": "CANPRECEDE",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          },
          {
            "source_id": "1339",
            "target_id": "190",
            "label": "PEEROF",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          },
          {
            "source_id": "1339",
            "target_id": "682",
            "label": "CHILDOF",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          },
          {
            "source_id": "834",
            "target_id": "1339",
            "label": "CANFOLLOW",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          },
          {
            "source_id": "682",
            "target_id": "1339",
            "label": "PARENTOF",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          },
          {
            "source_id": "119",
            "target_id": "1339",
            "label": "CANFOLLOW",
            "properties": {
              "view_id": "1000"
            }
          }
        ],
        "score_components": {
          "relationship_chain": 0.8,
          "sequence_path": 0.7200000000000001,
          "peer_group": 0.9
        },
        "abstraction_factor": 1.3,
        "graph_path_info": {
          "path_types": [
            "relationship_chain",
            "vulnerability_sequence_forward",
            "peer_relationship"
          ],
          "best_paths": {
            "relationship_chain": {
              "path": [
                [
                  "805",
                  "119",
                  "CHILDOF"
                ],
                [
                  "119",
                  "1339",
                  "CANFOLLOW"
                ]
              ],
              "score": 0.8,
              "type": "relationship_chain",
              "source": "805"
            },
            "vulnerability_sequence_forward": {
              "path": [
                [
                  "190",
                  "119",
                  "CANPRECEDE"
                ],
                [
                  "119",
                  "1339",
                  "CANFOLLOW"
                ]
              ],
              "score": 0.7200000000000001,
              "type": "vulnerability_sequence_forward",
              "source": "190"
            },
            "peer_relationship": {
              "path": [
                [
                  "1339",
                  "190",
                  "PEEROF"
                ]
              ],
              "score": 0.9,
              "type": "peer_relationship",
              "source": "190"
            }
          }
        },
        "position": "after",
        "sources": [
          "graph"
        ],
        "source": "graph",
        "mapping_notes": {
          "usage": "Allowed",
          "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
          "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
          "reasons": [
            "Acceptable-Use"
          ]
        },
        "score_info": {
          "retrievers": [
            "graph"
          ],
          "retriever_count": 1,
          "normalized_scores": {
            "graph": 2.3868000000000005
          }
        }
      },
      "similarity": 2.3868000000000005
    }
  ],
  "identified_cwes": {
    "analyzer": [
      "CWE-1284",
      "CWE-805",
      "CWE-125",
      "CWE-131",
      "CWE-787",
      "CWE-191",
      "CWE-190",
      "CWE-362",
      "CWE-755",
      "CWE-119"
    ],
    "critic_additional": []
  },
  "keyphrase_cwe_mapping": {}
}