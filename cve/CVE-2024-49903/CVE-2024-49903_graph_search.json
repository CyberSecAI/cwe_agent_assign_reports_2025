{
  "retriever": "graph",
  "query": "In the Linux kernel, the following vulnerability has been resolved jfs Fix uaf in dbFreeBits [syzbot reported] ================================================================== BUG KASAN slab-use-after-free in __mutex_lock_common kernel/locking/mutex.c587 [inline] BUG KASAN slab-use-after-free in __mutex_lock+0xfe/0xd70 kernel/locking/mutex.c752 Read of size 8 at addr ffff8880229254b0 by task syz-executor357/5216 CPU 0 UID 0 PID 5216 Comm syz-executor357 Not tainted 6.11.0-rc3-syzkaller-00156-gd7a5aa4b3c00 #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 06/27/2024 Call Trace __dump_stack lib/dump_stack.c93 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c119 print_address_description mm/kasan/report.c377 [inline] print_report+0x169/0x550 mm/kasan/report.c488 kasan_report+0x143/0x180 mm/kasan/report.c601 __mutex_lock_common kernel/locking/mutex.c587 [inline] __mutex_lock+0xfe/0xd70 kernel/locking/mutex.c752 dbFreeBits+0x7ea/0xd90 fs/jfs/jfs_dmap.c2390 dbFreeDmap fs/jfs/jfs_dmap.c2089 [inline] dbFree+0x35b/0x680 fs/jfs/jfs_dmap.c409 dbDiscardAG+0x8a9/0xa20 fs/jfs/jfs_dmap.c1650 jfs_ioc_trim+0x433/0x670 fs/jfs/jfs_discard.c100 jfs_ioctl+0x2d0/0x3e0 fs/jfs/ioctl.c131 vfs_ioctl fs/ioctl.c51 [inline] __do_sys_ioctl fs/ioctl.c907 [inline] __se_sys_ioctl+0xfc/0x170 fs/ioctl.c893 do_syscall_x64 arch/x86/entry/common.c52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c83 Freed by task 5218 kasan_save_stack mm/kasan/common.c47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c68 kasan_save_free_info+0x40/0x50 mm/kasan/generic.c579 poison_slab_object+0xe0/0x150 mm/kasan/common.c240 __kasan_slab_free+0x37/0x60 mm/kasan/common.c256 kasan_slab_free include/linux/kasan.h184 [inline] slab_free_hook mm/slub.c2252 [inline] slab_free mm/slub.c4473 [inline] kfree+0x149/0x360 mm/slub.c4594 dbUnmount+0x11d/0x190 fs/jfs/jfs_dmap.c278 jfs_mount_rw+0x4ac/0x6a0 fs/jfs/jfs_mount.c247 jfs_remount+0x3d1/0x6b0 fs/jfs/super.c454 reconfigure_super+0x445/0x880 fs/super.c1083 vfs_cmd_reconfigure fs/fsopen.c263 [inline] vfs_fsconfig_locked fs/fsopen.c292 [inline] __do_sys_fsconfig fs/fsopen.c473 [inline] __se_sys_fsconfig+0xb6e/0xf80 fs/fsopen.c345 do_syscall_x64 arch/x86/entry/common.c52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c83 entry_SYSCALL_64_after_hwframe+0x77/0x7f [Analysis] There are two paths (dbUnmount and jfs_ioc_trim) that generate race condition when accessing bmap, which leads to the occurrence of uaf. Use the lock s_umount to synchronize them, in order to avoid uaf caused by race condition. Consider specifically these CWEs: CWE-416 CWE-667 CWE-833 CWE-909 CWE-362 CWE-367",
  "keyphrases": {
    "original_query": "In the Linux kernel, the following vulnerability has been resolved jfs Fix uaf in dbFreeBits [syzbot reported] ================================================================== BUG KASAN slab-use-after-free in __mutex_lock_common kernel/locking/mutex.c587 [inline] BUG KASAN slab-use-after-free in __mutex_lock+0xfe/0xd70 kernel/locking/mutex.c752 Read of size 8 at addr ffff8880229254b0 by task syz-executor357/5216 CPU 0 UID 0 PID 5216 Comm syz-executor357 Not tainted 6.11.0-rc3-syzkaller-00156-gd7a5aa4b3c00 #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 06/27/2024 Call Trace __dump_stack lib/dump_stack.c93 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c119 print_address_description mm/kasan/report.c377 [inline] print_report+0x169/0x550 mm/kasan/report.c488 kasan_report+0x143/0x180 mm/kasan/report.c601 __mutex_lock_common kernel/locking/mutex.c587 [inline] __mutex_lock+0xfe/0xd70 kernel/locking/mutex.c752 dbFreeBits+0x7ea/0xd90 fs/jfs/jfs_dmap.c2390 dbFreeDmap fs/jfs/jfs_dmap.c2089 [inline] dbFree+0x35b/0x680 fs/jfs/jfs_dmap.c409 dbDiscardAG+0x8a9/0xa20 fs/jfs/jfs_dmap.c1650 jfs_ioc_trim+0x433/0x670 fs/jfs/jfs_discard.c100 jfs_ioctl+0x2d0/0x3e0 fs/jfs/ioctl.c131 vfs_ioctl fs/ioctl.c51 [inline] __do_sys_ioctl fs/ioctl.c907 [inline] __se_sys_ioctl+0xfc/0x170 fs/ioctl.c893 do_syscall_x64 arch/x86/entry/common.c52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c83 Freed by task 5218 kasan_save_stack mm/kasan/common.c47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c68 kasan_save_free_info+0x40/0x50 mm/kasan/generic.c579 poison_slab_object+0xe0/0x150 mm/kasan/common.c240 __kasan_slab_free+0x37/0x60 mm/kasan/common.c256 kasan_slab_free include/linux/kasan.h184 [inline] slab_free_hook mm/slub.c2252 [inline] slab_free mm/slub.c4473 [inline] kfree+0x149/0x360 mm/slub.c4594 dbUnmount+0x11d/0x190 fs/jfs/jfs_dmap.c278 jfs_mount_rw+0x4ac/0x6a0 fs/jfs/jfs_mount.c247 jfs_remount+0x3d1/0x6b0 fs/jfs/super.c454 reconfigure_super+0x445/0x880 fs/super.c1083 vfs_cmd_reconfigure fs/fsopen.c263 [inline] vfs_fsconfig_locked fs/fsopen.c292 [inline] __do_sys_fsconfig fs/fsopen.c473 [inline] __se_sys_fsconfig+0xb6e/0xf80 fs/fsopen.c345 do_syscall_x64 arch/x86/entry/common.c52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c83 entry_SYSCALL_64_after_hwframe+0x77/0x7f [Analysis] There are two paths (dbUnmount and jfs_ioc_trim) that generate race condition when accessing bmap, which leads to the occurrence of uaf. Use the lock s_umount to synchronize them, in order to avoid uaf caused by race condition.",
    "enhanced_query": "In the Linux kernel, the following vulnerability has been resolved jfs Fix uaf in dbFreeBits [syzbot reported] ================================================================== BUG KASAN slab-use-after-free in __mutex_lock_common kernel/locking/mutex.c587 [inline] BUG KASAN slab-use-after-free in __mutex_lock+0xfe/0xd70 kernel/locking/mutex.c752 Read of size 8 at addr ffff8880229254b0 by task syz-executor357/5216 CPU 0 UID 0 PID 5216 Comm syz-executor357 Not tainted 6.11.0-rc3-syzkaller-00156-gd7a5aa4b3c00 #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 06/27/2024 Call Trace __dump_stack lib/dump_stack.c93 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c119 print_address_description mm/kasan/report.c377 [inline] print_report+0x169/0x550 mm/kasan/report.c488 kasan_report+0x143/0x180 mm/kasan/report.c601 __mutex_lock_common kernel/locking/mutex.c587 [inline] __mutex_lock+0xfe/0xd70 kernel/locking/mutex.c752 dbFreeBits+0x7ea/0xd90 fs/jfs/jfs_dmap.c2390 dbFreeDmap fs/jfs/jfs_dmap.c2089 [inline] dbFree+0x35b/0x680 fs/jfs/jfs_dmap.c409 dbDiscardAG+0x8a9/0xa20 fs/jfs/jfs_dmap.c1650 jfs_ioc_trim+0x433/0x670 fs/jfs/jfs_discard.c100 jfs_ioctl+0x2d0/0x3e0 fs/jfs/ioctl.c131 vfs_ioctl fs/ioctl.c51 [inline] __do_sys_ioctl fs/ioctl.c907 [inline] __se_sys_ioctl+0xfc/0x170 fs/ioctl.c893 do_syscall_x64 arch/x86/entry/common.c52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c83 Freed by task 5218 kasan_save_stack mm/kasan/common.c47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c68 kasan_save_free_info+0x40/0x50 mm/kasan/generic.c579 poison_slab_object+0xe0/0x150 mm/kasan/common.c240 __kasan_slab_free+0x37/0x60 mm/kasan/common.c256 kasan_slab_free include/linux/kasan.h184 [inline] slab_free_hook mm/slub.c2252 [inline] slab_free mm/slub.c4473 [inline] kfree+0x149/0x360 mm/slub.c4594 dbUnmount+0x11d/0x190 fs/jfs/jfs_dmap.c278 jfs_mount_rw+0x4ac/0x6a0 fs/jfs/jfs_mount.c247 jfs_remount+0x3d1/0x6b0 fs/jfs/super.c454 reconfigure_super+0x445/0x880 fs/super.c1083 vfs_cmd_reconfigure fs/fsopen.c263 [inline] vfs_fsconfig_locked fs/fsopen.c292 [inline] __do_sys_fsconfig fs/fsopen.c473 [inline] __se_sys_fsconfig+0xb6e/0xf80 fs/fsopen.c345 do_syscall_x64 arch/x86/entry/common.c52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c83 entry_SYSCALL_64_after_hwframe+0x77/0x7f [Analysis] There are two paths (dbUnmount and jfs_ioc_trim) that generate race condition when accessing bmap, which leads to the occurrence of uaf. Use the lock s_umount to synchronize them, in order to avoid uaf caused by race condition. Consider specifically these CWEs: CWE-416 CWE-667 CWE-833 CWE-909 CWE-362 CWE-367",
    "cwe_mentions": [
      "CWE-416",
      "CWE-667",
      "CWE-833",
      "CWE-909",
      "CWE-362",
      "CWE-367"
    ],
    "search_time": 2.4255990982055664
  },
  "timestamp": "2025-07-13 19:40:28",
  "cve_id": "CVE-2024-49903",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "364",
      "name": "Signal Handler Race Condition",
      "type": "base",
      "score": 2.8651999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "609",
      "name": "Double-Checked Locking",
      "type": "base",
      "score": 2.8651999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "123",
      "name": "Write-what-where Condition",
      "type": "base",
      "score": 2.7014000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "386",
      "name": "Symbolic Name not Mapping to Correct Object",
      "type": "base",
      "score": 2.3764000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "1265",
      "name": "Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "120",
      "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "456",
      "name": "Missing Initialization of a Variable",
      "type": "variant",
      "score": 2.1936,
      "relationship_count": 0
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "type": "Variant",
      "score": 2.1807099345227554,
      "relationship_count": 0
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 1.7855591873485777,
      "relationship_count": 0
    },
    {
      "cwe_id": "367",
      "name": "Time-of-check Time-of-use (TOCTOU) Race Condition",
      "type": "Base",
      "score": 1.7182715874444197,
      "relationship_count": 0
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 1.707606598530254,
      "relationship_count": 0
    },
    {
      "cwe_id": "134",
      "name": "Use of Externally-Controlled Format String",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "170",
      "name": "Improper Null Termination",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "1325",
      "name": "Improperly Controlled Sequential Memory Allocation",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "662",
      "name": "Improper Synchronization",
      "type": "class",
      "score": 1.6736000000000002,
      "relationship_count": 0
    },
    {
      "cwe_id": "908",
      "name": "Use of Uninitialized Resource",
      "type": "Base",
      "score": 1.5559501959708473,
      "relationship_count": 0
    },
    {
      "cwe_id": "590",
      "name": "Free of Memory not on the Heap",
      "type": "variant",
      "score": 1.5552000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "479",
      "name": "Signal Handler Use of a Non-reentrant Function",
      "type": "variant",
      "score": 1.5552000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "231",
      "name": "Improper Handling of Extra Values",
      "type": "variant",
      "score": 1.5552000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "type": "Base",
      "score": 1.5452716923588927,
      "relationship_count": 0
    }
  ]
}