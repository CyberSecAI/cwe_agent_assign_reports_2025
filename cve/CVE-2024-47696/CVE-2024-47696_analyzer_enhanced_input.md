## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved RDMA/iwcm Fix WARNINGat_kernel/workqueue.c#check_flush_dependency In the commit aee2424246f9 (RDMA/iwcm Fix a use-after-free related to destroying CM IDs), the function flush_workqueue is invoked to flush the work queue iwcm_wq. But at that time, the work queue iwcm_wq was created via the function alloc_ordered_workqueue without the flag WQ_MEM_RECLAIM. Because the current process is trying to flush the whole iwcm_wq, if iwcm_wq doesnt have the flag WQ_MEM_RECLAIM, verify that the current process is not reclaiming memory or running on a workqueue which doesnt have the flag WQ_MEM_RECLAIM as that can break forward-progress guarantee leading to a deadlock. The call trace is as below [ 125.350876][ T1430] Call Trace [ 125.356281][ T1430] [ 125.361285][ T1430] ? __warn (kernel/panic.c693) [ 125.367640][ T1430] ? check_flush_dependency (kernel/workqueue.c3706 (discriminator 9)) [ 125.375689][ T1430] ? report_bug (lib/bug.c180 lib/bug.c219) [ 125.382505][ T1430] ? handle_bug (arch/x86/kernel/traps.c239) [ 125.388987][ T1430] ? exc_invalid_op (arch/x86/kernel/traps.c260 (discriminator 1)) [ 125.395831][ T1430] ? asm_exc_invalid_op (arch/x86/include/asm/idtentry.h621) [ 125.403125][ T1430] ? check_flush_dependency (kernel/workqueue.c3706 (discriminator 9)) [ 125.410984][ T1430] ? check_flush_dependency (kernel/workqueue.c3706 (discriminator 9)) [ 125.418764][ T1430] __flush_workqueue (kernel/workqueue.c3970) [ 125.426021][ T1430] ? __pfx___might_resched (kernel/sched/core.c10151) [ 125.433431][ T1430] ? destroy_cm_id (drivers/infiniband/core/iwcm.c375) iw_cm [ 125.441209][ T1430] ? __pfx___flush_workqueue (kernel/workqueue.c3910) [ 125.473900][ T1430] ? _raw_spin_lock_irqsave (arch/x86/include/asm/atomic.h107 include/linux/atomic/atomic-arch-fallback.h2170 include/linux/atomic/atomic-instrumented.h1302 include/asm-generic/qspinlock.h111 include/linux/spinlock.h187 include/linux/spinlock_api_smp.h111 kernel/locking/spinlock.c162) [ 125.473909][ T1430] ? __pfx__raw_spin_lock_irqsave (kernel/locking/spinlock.c161) [ 125.482537][ T1430] _destroy_id (drivers/infiniband/core/cma.c2044) rdma_cm [ 125.495072][ T1430] nvme_rdma_free_queue (drivers/nvme/host/rdma.c656 drivers/nvme/host/rdma.c650) nvme_rdma [ 125.505827][ T1430] nvme_rdma_reset_ctrl_work (drivers/nvme/host/rdma.c2180) nvme_rdma [ 125.505831][ T1430] process_one_work (kernel/workqueue.c3231) [ 125.515122][ T1430] worker_thread (kernel/workqueue.c3306 kernel/workqueue.c3393) [ 125.515127][ T1430] ? __pfx_worker_thread (kernel/workqueue.c3339) [ 125.531837][ T1430] kthread (kernel/kthread.c389) [ 125.539864][ T1430] ? __pfx_kthread (kernel/kthread.c342) [ 125.550628][ T1430] ret_from_fork (arch/x86/kernel/process.c147) [ 125.558840][ T1430] ? __pfx_kthread (kernel/kthread.c342) [ 125.558844][ T1430] ret_from_fork_asm (arch/x86/entry/entry_64.S257) [ 125.566487][ T1430] [ 125.566488][ T1430] ---[ end trace 0000000000000000 ]---

### Vulnerability Description Key Phrases
- **rootcause:** **The workqueue iwcm_wq was created without the WQ_MEM_RECLAIM flag, leading to a potential deadlock when trying to flush it during memory reclamation.**
- **weakness:** **The workqueue iwcm_wq lacks the WQ_MEM_RECLAIM flag, which is necessary for safe flushing during memory reclamation.**
- **impact:** A deadlock can occur, causing the system to become unresponsive.
- **vector:** The vulnerability is triggered when the function flush_workqueue is invoked to flush the work queue iwcm_wq during memory reclamation. The call chain includes destroy_cm_id which is part of the RDMA subsystem's connection management, and then nvme_rdma_free_queue which is part of the NVMe RDMA driver.
- **attacker:** An attacker cannot directly trigger this vulnerability as it's a race condition related to memory reclamation and the workqueue flush. The attacker needs to somehow trigger the call chain.
- **product:** Linux Kernel
- **version:** Not specified in the provided text, but it's likely a version before the fix commit aee2424246f9 was applied.
- **component:** RDMA/iwcm (InfiniBand Connection Manager), workqueue subsystem, and NVMe RDMA driver.

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of the vulnerability:

**Root Cause:**
The root cause lies in the incorrect initialization of the `iwcm_wq` workqueue. It was created using `alloc_ordered_workqueue` without the `WQ_MEM_RECLAIM` flag. This flag is crucial when flushing a workqueue that may be involved in memory reclamation.

**Weaknesses/Vulnerabilities:**
- **Missing `WQ_MEM_RECLAIM` flag:** The primary weakness is the omission of the `WQ_MEM_RECLAIM` flag when allocating the `iwcm_wq` workqueue. This omission means that the workqueue doesn't signal that it's safe to flush during memory reclaim operations, leading to potential deadlocks.
- **Potential Deadlock:** When a process attempts to flush `iwcm_wq` during memory reclamation or from within a workqueue that also lacks `WQ_MEM_RECLAIM`, the `check_flush_dependency` function within the kernel's workqueue logic detects the situation, triggering a warning and potentially leading to a deadlock.

**Impact of Exploitation:**
- **Denial of Service (DoS):** The primary impact of this vulnerability is a denial of service. The deadlock prevents the system from continuing normal operations as processes get stuck trying to flush the workqueue during memory reclaim scenarios.
- **System Instability:** The unhandled deadlock can destabilize the kernel, and the warning issued indicates a serious issue with forward progress, suggesting the possibility of other connected issues.

**Attack Vectors:**
- **Triggering Memory Reclaim Operations:** Attackers could potentially trigger this condition by forcing the system to engage in memory reclamation activities while also interacting with RDMA/iwcm functionalities.
- **Workqueue Manipulation:** While the description doesn't suggest explicit user-space triggers, any interaction with iwcm functionalities leading to the flushing of the problematic work queue in conjunction with memory reclamation activities would expose the vulnerability.

**Required Attacker Capabilities/Position:**
- **Ability to Trigger Memory Reclaim:** The attacker would need the ability to trigger memory reclaim events within the system while simultaneously using the RDMA/iwcm subsystem or trigger it via a process that uses the affected workqueue.
- **System Interaction:** The attacker does not necessarily need to be root, but would need to have sufficient privileges or means to interact with the RDMA/iwcm subsystem which indirectly triggers the vulnerable code path during memory reclamation.

**Additional Notes:**
- The provided commit messages fix this by adding the `WQ_MEM_RECLAIM` flag when allocating `iwcm_wq`. This flag signals the workqueue subsystem that it is safe to flush the queue, even during memory reclaim operations, thus preventing the reported deadlock.
- The call trace is important as it reveals the specific sequence of function calls leading to the warning, thereby identifying the vulnerable execution path.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 822 | Untrusted Pointer Dereference | Base | Allowed | sparse | 1.240 |
| 2 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 1.237 |
| 3 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 1.081 |
| 4 | 823 | Use of Out-of-range Pointer Offset | Base | Allowed | sparse | 1.060 |
| 5 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 1.014 |
| 6 | 416 | Use After Free | Variant | Allowed | sparse | 0.980 |
| 7 | 393 | Return of Wrong Status Code | Base | Allowed | sparse | 0.980 |
| 8 | 833 | Deadlock | Base | Allowed | sparse | 0.975 |
| 9 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | dense | 0.583 |
| 10 | 364 | Signal Handler Race Condition | Base | Allowed | graph | 0.002 |



# Complete CWE Specifications

CWE-822: Untrusted Pointer Dereference

CWE-125: Out-of-bounds Read

CWE-667: Improper Locking

CWE-823: Use of Out-of-range Pointer Offset

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-416: Use After Free

CWE-393: Return of Wrong Status Code

CWE-833: Deadlock

CWE-909: Missing Initialization of Resource

CWE-364: Signal Handler Race Condition