{
  "method": "sparse_weakness_2",
  "query": "In the Linux kernel, the following vulnerability has been resolved RDMA/iwcm Fix WARNINGat_kernel/workqueue.c#check_flush_dependency In the commit aee2424246f9 (RDMA/iwcm Fix a use-after-free related to destroying CM IDs), the function flush_workqueue is invoked to flush the work queue iwcm_wq. But at that time, the work queue iwcm_wq was created via the function alloc_ordered_workqueue without the flag WQ_MEM_RECLAIM. Because the current process is trying to flush the whole iwcm_wq, if iwcm_wq doesnt have the flag WQ_MEM_RECLAIM, verify that the current process is not reclaiming memory or running on a workqueue which doesnt have the flag WQ_MEM_RECLAIM as that can break forward-progress guarantee leading to a deadlock. The call trace is as below [ 125.350876][ T1430] Call Trace [ 125.356281][ T1430] [ 125.361285][ T1430] ? __warn (kernel/panic.c693) [ 125.367640][ T1430] ? check_flush_dependency (kernel/workqueue.c3706 (discriminator 9)) [ 125.375689][ T1430] ? report_bug (lib/bug.c180 lib/bug.c219) [ 125.382505][ T1430] ? handle_bug (arch/x86/kernel/traps.c239) [ 125.388987][ T1430] ? exc_invalid_op (arch/x86/kernel/traps.c260 (discriminator 1)) [ 125.395831][ T1430] ? asm_exc_invalid_op (arch/x86/include/asm/idtentry.h621) [ 125.403125][ T1430] ? check_flush_dependency (kernel/workqueue.c3706 (discriminator 9)) [ 125.410984][ T1430] ? check_flush_dependency (kernel/workqueue.c3706 (discriminator 9)) [ 125.418764][ T1430] __flush_workqueue (kernel/workqueue.c3970) [ 125.426021][ T1430] ? __pfx___might_resched (kernel/sched/core.c10151) [ 125.433431][ T1430] ? destroy_cm_id (drivers/infiniband/core/iwcm.c375) iw_cm [ 125.441209][ T1430] ? __pfx___flush_workqueue (kernel/workqueue.c3910) [ 125.473900][ T1430] ? _raw_spin_lock_irqsave (arch/x86/include/asm/atomic.h107 include/linux/atomic/atomic-arch-fallback.h2170 include/linux/atomic/atomic-instrumented.h1302 include/asm-generic/qspinlock.h111 include/linux/spinlock.h187 include/linux/spinlock_api_smp.h111 kernel/locking/spinlock.c162) [ 125.473909][ T1430] ? __pfx__raw_spin_lock_irqsave (kernel/locking/spinlock.c161) [ 125.482537][ T1430] _destroy_id (drivers/infiniband/core/cma.c2044) rdma_cm [ 125.495072][ T1430] nvme_rdma_free_queue (drivers/nvme/host/rdma.c656 drivers/nvme/host/rdma.c650) nvme_rdma [ 125.505827][ T1430] nvme_rdma_reset_ctrl_work (drivers/nvme/host/rdma.c2180) nvme_rdma [ 125.505831][ T1430] process_one_work (kernel/workqueue.c3231) [ 125.515122][ T1430] worker_thread (kernel/workqueue.c3306 kernel/workqueue.c3393) [ 125.515127][ T1430] ? __pfx_worker_thread (kernel/workqueue.c3339) [ 125.531837][ T1430] kthread (kernel/kthread.c389) [ 125.539864][ T1430] ? __pfx_kthread (kernel/kthread.c342) [ 125.550628][ T1430] ret_from_fork (arch/x86/kernel/process.c147) [ 125.558840][ T1430] ? __pfx_kthread (kernel/kthread.c342) [ 125.558844][ T1430] ret_from_fork_asm (arch/x86/entry/entry_64.S257) [ 125.566487][ T1430] [ 125.566488][ T1430] ---[ end trace 0000000000000000 ]---",
  "keyphrases": {
    "weakness": "which is necessary for safe flushing during memory reclamation."
  },
  "timestamp": "2025-07-13T18:21:10.167245",
  "results_count": 10,
  "results_summary": [
    {
      "doc_id": "822",
      "name": "Untrusted Pointer Dereference",
      "score": 1130.6524167949503
    },
    {
      "doc_id": "125",
      "name": "Out-of-bounds Read",
      "score": 1126.8089325658455
    },
    {
      "doc_id": "823",
      "name": "Use of Out-of-range Pointer Offset",
      "score": 966.2435677571962
    },
    {
      "doc_id": "667",
      "name": "Improper Locking",
      "score": 945.3433313861916
    },
    {
      "doc_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "score": 916.993304790763
    }
  ]
}