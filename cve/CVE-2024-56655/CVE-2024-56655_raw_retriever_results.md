# Raw Retriever Results for CVE-2024-56655

# Raw Retriever Results for CVE-2024-56655
## Query
In the Linux kernel, the following vulnerability has been resolved netfilter nf_tables do not defer rule destruction via call_rcu nf_tables_chain_destroy can sleep, it cant be used from call_rcu callbacks. Moreover, nf_tables_rule_release() is only safe for error unwinding, while transaction mutex is held and the to-be-desroyed rule was not exposed to either dataplane or dumps, as it deactives+frees without the required synchronize_rcu() in-between. nft_rule_expr_deactivate() callbacks will change ->use counters of other chains/sets, see e.g. nft_lookup .deactivate callback, these must be serialized via transaction mutex. Also add a few lockdep asserts to make this more explicit. Calling synchronize_rcu() isnt ideal, but fixing this without is hard and way more intrusive. As-is, we can get WARNING .. net/netfilter/nf_tables_api.c5515 nft_set_destroy+0x.. Workqueue events nf_tables_trans_destroy_work RIP 0010nft_set_destroy+0x3fe/0x5c0 Call Trace nf_tables_trans_destroy_work+0x6b7/0xad0 process_one_work+0x64a/0xce0 worker_thread+0x613/0x10d0 In case the synchronize_rcu becomes an issue, we can explore alternatives. One way would be to allocate nft_trans_rule objects + one nft_trans_chain object, deactivate the rules + the chain and then defer the freeing to the nft destroy workqueue. Wed still need to keep the synchronize_rcu path as a fallback to handle -ENOMEM corner cases though.

## Keyphrases
- **rootcause**: 'nf_tables_chain_destroy can sleep'

## Score Statistics
| Retriever | Min | Max | Mean | Median | Count |
|-----------|-----|-----|------|--------|-------|
| Dense | 0.4048 | 0.4557 | 0.4286 | 0.4284 | 20 |
| Sparse | 675.0195 | 736.1669 | 694.7920 | 686.4849 | 10 |
| Graph | 1.3954 | 2.2100 | 1.7014 | 1.6740 | 20 |

## Graph Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Mapping Usage |
|---|--------|------|-------------|-------|---------------|
| 1 | 212 | Improper Removal of Sensitive Information Before Storage or Transfer | base | 2.2100 | Allowed |
| 2 | 1322 | Use of Blocking Code in Single-threaded, Non-blocking Context | base | 2.2100 | Allowed |
| 3 | 502 | Deserialization of Untrusted Data | base | 2.1190 | Allowed |
| 4 | 201 | Insertion of Sensitive Information Into Sent Data | base | 2.1190 | Allowed |
| 5 | 120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | base | 1.7680 | Allowed-with-Review |
| 6 | 123 | Write-what-where Condition | base | 1.7680 | Allowed |
| 7 | 1265 | Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls | base | 1.6848 | Allowed |
| 8 | 1325 | Improperly Controlled Sequential Memory Allocation | base | 1.6848 | Allowed |
| 9 | 833 | Deadlock | Base | 1.6749 | Allowed |
| 10 | 386 | Symbolic Name not Mapping to Correct Object | base | 1.6744 | Allowed |
| 11 | 662 | Improper Synchronization | class | 1.6736 | Discouraged |
| 12 | 202 | Exposure of Sensitive Information Through Data Queries | base | 1.5210 | Allowed |
| 13 | 915 | Improperly Controlled Modification of Dynamically-Determined Object Attributes | base | 1.5210 | Allowed |
| 14 | 209 | Generation of Error Message Containing Sensitive Information | base | 1.5210 | Allowed |
| 15 | 456 | Missing Initialization of a Variable | variant | 1.5154 | Allowed |

## Dense Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Original Score | Mapping Usage |
|---|--------|------|-------------|-------|----------------|---------------|
| 1 | 833 | Deadlock | Base | 0.4557 | 0.4557 | Allowed |
| 2 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | 0.4513 | 0.4513 | Allowed-with-Review |
| 3 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | 0.4510 | 0.4510 | Allowed |
| 4 | 775 | Missing Release of File Descriptor or Handle after Effective Lifetime | Variant | 0.4456 | 0.4456 | Allowed |
| 5 | 667 | Improper Locking | Class | 0.4450 | 0.4450 | Allowed-with-Review |
| 6 | 401 | Missing Release of Memory after Effective Lifetime | Variant | 0.4421 | 0.4421 | Allowed |
| 7 | 617 | Reachable Assertion | Base | 0.4397 | 0.4397 | Allowed |
| 8 | 909 | Missing Initialization of Resource | Class | 0.4390 | 0.4390 | Allowed-with-Review |
| 9 | 911 | Improper Update of Reference Count | Base | 0.4354 | 0.4354 | Allowed |
| 10 | 1284 | Improper Validation of Specified Quantity in Input | Base | 0.4340 | 0.4340 | Allowed |
| 11 | 476 | NULL Pointer Dereference | Base | 0.4228 | 0.4228 | Allowed |
| 12 | 763 | Release of Invalid Pointer or Reference | Base | 0.4214 | 0.4214 | Allowed |
| 13 | 366 | Race Condition within a Thread | Base | 0.4186 | 0.4186 | Allowed |
| 14 | 606 | Unchecked Input for Loop Condition | Base | 0.4167 | 0.4167 | Allowed |
| 15 | 772 | Missing Release of Resource after Effective Lifetime | Base | 0.4122 | 0.4122 | Allowed |

## Sparse Retriever Results (10)
| # | CWE ID | Name | Score | Original Score | Mapping Usage |
|---|--------|------|-------|---------------|---------------|
| 1 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | 736.1669 | 736.1669 | Allowed-with-Review |
| 2 | 909 | Missing Initialization of Resource | 725.5963 | 725.5963 | Allowed-with-Review |
| 3 | 863 | Incorrect Authorization | 701.3427 | 701.3427 | Allowed-with-Review |
| 4 | 502 | Deserialization of Untrusted Data | 699.5325 | 699.5325 | Allowed |
| 5 | 201 | Insertion of Sensitive Information Into Sent Data | 688.6518 | 688.6518 | Allowed |
| 6 | 95 | Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection') | 684.3179 | 684.3179 | Allowed |
| 7 | 667 | Improper Locking | 681.6585 | 681.6585 | Allowed-with-Review |
| 8 | 639 | Authorization Bypass Through User-Controlled Key | 679.4158 | 679.4158 | Allowed |
| 9 | 347 | Improper Verification of Cryptographic Signature | 676.2182 | 676.2182 | Allowed |
| 10 | 617 | Reachable Assertion | 675.0195 | 675.0195 | Allowed |
