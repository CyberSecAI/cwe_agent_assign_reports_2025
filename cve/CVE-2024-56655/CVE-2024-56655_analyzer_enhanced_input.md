## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved netfilter nf_tables do not defer rule destruction via call_rcu **nf_tables_chain_destroy can sleep**, it cant be used from call_rcu callbacks. Moreover, nf_tables_rule_release() is only safe for error unwinding, while transaction mutex is held and the to-be-desroyed rule was not exposed to either dataplane or dumps, as it deactives+frees without the required synchronize_rcu() in-between. nft_rule_expr_deactivate() callbacks will change ->use counters of other chains/sets, see e.g. nft_lookup .deactivate callback, these must be serialized via transaction mutex. Also add a few lockdep asserts to make this more explicit. Calling synchronize_rcu() isnt ideal, but fixing this without is hard and way more intrusive. As-is, we can get WARNING .. net/netfilter/nf_tables_api.c5515 nft_set_destroy+0x.. Workqueue events nf_tables_trans_destroy_work RIP 0010nft_set_destroy+0x3fe/0x5c0 Call Trace nf_tables_trans_destroy_work+0x6b7/0xad0 process_one_work+0x64a/0xce0 worker_thread+0x613/0x10d0 In case the synchronize_rcu becomes an issue, we can explore alternatives. One way would be to allocate nft_trans_rule objects + one nft_trans_chain object, deactivate the rules + the chain and then defer the freeing to the nft destroy workqueue. Wed still need to keep the synchronize_rcu path as a fallback to handle -ENOMEM corner cases though.

### Vulnerability Description Key Phrases
- **rootcause:** **nf_tables_chain_destroy can sleep**
- **product:** Linux kernel
- **component:** netfilter nf_tables

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of the vulnerability addressed by the commits:

**Root cause of vulnerability:**

The vulnerability arises from the improper use of `call_rcu` for destroying nf_tables rules and chains. Specifically, `nf_tables_chain_destroy` can sleep, which is not allowed within `call_rcu` callbacks. Additionally, `nf_tables_rule_release()` deactivates and frees rules without the necessary `synchronize_rcu()`, making it unsafe for general use (only safe during error unwinding). The `nft_rule_expr_deactivate()` callbacks can also modify use counters of other chains/sets, which require serialization via a transaction mutex.

**Weaknesses/vulnerabilities present:**

1.  **Use of Sleepy Function in RCU Callback:** `nf_tables_chain_destroy` can sleep, violating the constraints of `call_rcu` and potentially leading to deadlocks or undefined behavior.
2.  **Race Condition in Rule Release:** `nf_tables_rule_release()` deactivates and frees rules without proper synchronization, making it vulnerable to race conditions if the rule is accessed concurrently, such as during dumps.
3.  **Missing Serialization:** Modifications to use counters in `nft_rule_expr_deactivate()` callbacks were not properly serialized, leading to potential race conditions when multiple operations modify the same chains/sets.
4. **Improper resource cleanup**: The cleanup logic was not correctly waiting for RCU grace periods, which could lead to use-after-free scenarios if resources were freed before readers completed their access.

**Impact of exploitation:**

The primary impact of these issues is a kernel crash. The race conditions and improper resource handling could lead to memory corruption, use-after-free, and other undefined behaviors, ultimately causing the kernel to panic. The specific example given in the commit message is an error in `nft_set_destroy`, which occurs during the `nf_tables_trans_destroy_work` workqueue processing.

**Attack vectors:**

The attack vector involves triggering the destruction of nf_tables rules and chains in a way that exposes the race conditions and improper synchronization. This could be done by:

1.  Manipulating network configurations involving nf_tables rules and chains.
2.  Initiating operations that lead to the deletion or modification of network devices.
3.  Using nf_tables API to rapidly create and delete rules, chains, sets, and other objects.
4. Triggering ruleset dumps concurrently while making changes to the rules.

**Required attacker capabilities/position:**

An attacker would need the ability to interact with the nf_tables subsystem, which typically requires `CAP_NET_ADMIN` capabilities. This typically implies a local user with the ability to configure networking. An attacker could also trigger this remotely by exploiting another vulnerability to gain the ability to execute privileged code with network administration rights.

**Additional details:**
The fix for this issue involves the following:

*   **No more `call_rcu`:** Removing the use of `call_rcu` for chain destruction and instead using `synchronize_rcu()` when needed after taking the transaction mutex.
*   **Locking Assertions:** Adding `lockdep_commit_lock_is_held` assertions to enforce proper locking during rule release.
* **Correct Synchronization:** Using synchronize_rcu() to wait for RCU grace periods when releasing base chains, ensuring that no readers access freed resources.

This fix ensures that chain and rule destruction are properly synchronized with RCU grace periods and that no operation that can sleep is called within an RCU callback. It also ensures correct serialization of use counter changes. This is an important fix for system stability.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.736 |
| 2 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | sparse | 0.726 |
| 3 | 863 | Incorrect Authorization | Class | Allowed-with-Review | sparse | 0.701 |
| 4 | 502 | Deserialization of Untrusted Data | Base | Allowed | sparse | 0.700 |
| 5 | 201 | Insertion of Sensitive Information Into Sent Data | Base | Allowed | sparse | 0.689 |
| 6 | 95 | Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection') | Variant | Allowed | sparse | 0.684 |
| 7 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.682 |
| 8 | 639 | Authorization Bypass Through User-Controlled Key | Base | Allowed | sparse | 0.679 |
| 9 | 833 | Deadlock | Base | Allowed | dense | 0.456 |
| 10 | 212 | Improper Removal of Sensitive Information Before Storage or Transfer | Base | Allowed | graph | 0.002 |



# Complete CWE Specifications

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-909: Missing Initialization of Resource

CWE-863: Incorrect Authorization

CWE-502: Deserialization of Untrusted Data

CWE-201: Insertion of Sensitive Information Into Sent Data

CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')

CWE-667: Improper Locking

CWE-639: Authorization Bypass Through User-Controlled Key

CWE-833: Deadlock

CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer