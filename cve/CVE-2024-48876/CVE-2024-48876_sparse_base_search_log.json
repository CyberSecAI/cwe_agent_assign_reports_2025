{
  "method": "sparse_base",
  "query": "In the Linux kernel, the following vulnerability has been resolved stackdepot fix stack_depot_save_flags() in NMI context Per documentation, stack_depot_save_flags() was meant to be usable from NMI context if STACK_DEPOT_FLAG_CAN_ALLOC is unset. However, it still would try to take the pool_lock in an attempt to save a stack trace in the current pool (if space is available). This could result in deadlock if an NMI is handled while pool_lock is already held. To avoid deadlock, only try to take the lock in NMI context and give up if unsuccessful. The documentation is fixed to clearly convey this.",
  "keyphrases": {
    "base_query": "In the Linux kernel, the following vulnerability has been resolved stackdepot fix stack_depot_save_flags() in NMI context Per documentation, stack_depot_save_flags() was meant to be usable from NMI context if STACK_DEPOT_FLAG_CAN_ALLOC is unset. However, it still would try to take the pool_lock in an attempt to save a stack trace in the current pool (if space is available). This could result in deadlock if an NMI is handled while pool_lock is already held. To avoid deadlock, only try to take the lock in NMI context and give up if unsuccessful. The documentation is fixed to clearly convey this."
  },
  "timestamp": "2025-07-13T18:59:19.376487",
  "results_count": 10,
  "results_summary": [
    {
      "doc_id": "667",
      "name": "Improper Locking",
      "score": 178.72536581665426
    },
    {
      "doc_id": "833",
      "name": "Deadlock",
      "score": 169.07533541215335
    },
    {
      "doc_id": "451",
      "name": "User Interface (UI) Misrepresentation of Critical Information",
      "score": 160.25866355172118
    },
    {
      "doc_id": "787",
      "name": "Out-of-bounds Write",
      "score": 154.7715709567367
    },
    {
      "doc_id": "674",
      "name": "Uncontrolled Recursion",
      "score": 152.9717355766916
    }
  ]
}