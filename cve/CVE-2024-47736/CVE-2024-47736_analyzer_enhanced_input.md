## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved erofs handle overlapped pclusters out of crafted images properly syzbot reported a task hang issue due to a deadlock case where it is waiting for the folio lock of a cached folio that will be used for cache I/Os. After looking into the crafted fuzzed image, I found its formed with several overlapped big pclusters as below Ext logical offset | length physical offset | length 0 0.. 16384 | 16384 151552.. 167936 | 16384 1 16384.. 32768 | 16384 155648.. 172032 | 16384 2 32768.. 49152 | 16384 537223168.. 537239552 | 16384 ... Here, extent 0/1 are physically overlapped although its entirely _impossible_ for normal filesystem images generated by mkfs. First, managed folios containing compressed data will be marked as up-to-date and then unlocked immediately (unlike in-place folios) when compressed I/Os are complete. If physical blocks are not submitted in the incremental order, there should be separate BIOs to avoid dependency issues. However, the current code mis-arranges z_erofs_fill_bio_vec() and BIO submission which causes unexpected BIO waits. Second, managed folios will be connected to their own pclusters for efficient inter-queries. However, this is somewhat hard to implement easily if overlapped big pclusters exist. Again, these only appear in fuzzed images so lets simply fall back to temporary short-lived pages

### Vulnerability Description Key Phrases
- **rootcause:** **task hang due to deadlock**
- **impact:** hang
- **vector:** crafted images
- **product:** Linux kernel

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of the vulnerability:

**Root Cause:**

The vulnerability stems from the way the erofs filesystem handles specially crafted images containing overlapping physical pclusters (physical clusters).  These overlapping pclusters are not something that would occur in normally generated erofs images, but can be created by fuzzers. This overlap leads to issues in how the filesystem manages cached folios and submits I/O operations, leading to deadlocks.

**Weaknesses/Vulnerabilities:**

1.  **Incorrect BIO submission:** The `z_erofs_fill_bio_vec()` function and the BIO submission logic are not correctly handling the out-of-order nature of physical blocks when there are overlapping pclusters. This mis-arrangement causes unexpected waits on BIOs, leading to a deadlock.

2.  **Managed Folio Handling with Overlaps:** The system attempts to connect managed folios to their respective pclusters for efficient access.  However, with overlapping pclusters, this becomes complex. The code doesn't handle the case when a managed folio might be associated with multiple overlapping pclusters, leading to incorrect folio management.

3. **Reusing truncated folios**: The code was attempting to reuse truncated folios, which is unsafe.

**Impact of Exploitation:**

*   **Task Hang (Deadlock):**  A task attempting to access data within the crafted erofs image will hang indefinitely due to a deadlock condition. This is because the task waits for a folio lock on a cached folio that will be used for cache I/Os but is never released due to the issue described. This can lead to denial of service.

**Attack Vectors:**

*   **Crafted Filesystem Image:** An attacker would need to provide a specially crafted erofs filesystem image containing overlapping physical pclusters. This crafted image would then need to be mounted by the vulnerable system.

**Required Attacker Capabilities/Position:**

*   An attacker needs the ability to create a malicious erofs image.
*   The attacker needs to be able to mount this image. This could be done through local access or potentially if the image is made accessible through another service.

**Additional Notes:**
* The provided diffstat shows a fix for `fs/erofs/zdata.c` file with changes in the  `z_erofs_fill_bio_vec()` and  `z_erofs_submit_queue()` functions to address the issues.

The fix includes:
    *  Using temporary short-lived pages when overlapped pclusters are detected.
    * Changes in submission of BIOs to avoid deadlock condition
    * Prevention of reusing truncated folios

This commit addresses the task hang issue by ensuring the correct management of folios and submission of BIOs with overlapped pclusters.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 833 | Deadlock | Base | Allowed | sparse | 0.776 |
| 2 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.753 |
| 3 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.750 |
| 4 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.748 |
| 5 | 120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | Base | Allowed-with-Review | sparse | 0.741 |
| 6 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.738 |
| 7 | 863 | Incorrect Authorization | Class | Allowed-with-Review | sparse | 0.736 |
| 8 | 347 | Improper Verification of Cryptographic Signature | Base | Allowed | sparse | 0.733 |
| 9 | 1260 | Improper Handling of Overlap Between Protected Memory Ranges | Base | Allowed | dense | 0.544 |
| 10 | 364 | Signal Handler Race Condition | Base | Allowed | graph | 0.002 |



# Complete CWE Specifications

CWE-833: Deadlock

CWE-667: Improper Locking

CWE-770: Allocation of Resources Without Limits or Throttling

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')

CWE-125: Out-of-bounds Read

CWE-863: Incorrect Authorization

CWE-347: Improper Verification of Cryptographic Signature

CWE-1260: Improper Handling of Overlap Between Protected Memory Ranges

CWE-364: Signal Handler Race Condition