## Vulnerability Description
A Buffer Overflow vulnerability in libcoap v4.3.5-rc2 and below allows a remote attacker to cause a denial of service via the coap_handle_request_put_block function in src/coap_block.c.

### Vulnerability Description Key Phrases
- **weakness:** **buffer overflow**
- **impact:** denial of service
- **attacker:** remote attacker
- **product:** libcoap
- **version:** v4.3.5-rc2 and below
- **component:** coap_handle_request_put_block function in src/coap_block.c

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of the vulnerability:

**Root Cause of Vulnerability:**
The root cause of the vulnerability is a null pointer dereference or access to an invalid memory location in the `coap_handle_request_put_block` function within the `coap_block.c` file. This function is responsible for handling PUT requests with block-wise transfers in the CoAP protocol. The issue arises when the function attempts to access a memory address that is very close to null, leading to a segmentation fault.

**Weaknesses/Vulnerabilities Present:**
-   **Null Pointer Dereference/Invalid Memory Access:** The code attempts to dereference a pointer that is either NULL or points to an invalid memory region. This happens during the processing of a PUT request with block-wise transfers.

**Impact of Exploitation:**
-   **Denial of Service (DoS):** Successful exploitation of this vulnerability leads to a segmentation fault, causing the CoAP server to crash. This results in a denial-of-service condition, rendering the server unavailable.

**Attack Vectors:**
-   **Network-Based:** The attack vector is network-based, involving sending a specially crafted PUT request with block-wise transfer to the vulnerable CoAP server.
-   **Fuzzing:** The vulnerability was discovered using a fuzzing tool which indicates that unusual/unexpected input sequences can trigger the vulnerability.

**Required Attacker Capabilities/Position:**
-   **Network Access:** An attacker needs to have network access to send CoAP requests to the targeted server.
-   **Knowledge of CoAP Protocol:** The attacker needs to understand the CoAP protocol and block-wise transfer mechanism to craft a request that triggers the vulnerability.

**Additional Details:**
-   The vulnerability was triggered after more than 13 hours of fuzzing.
-   The issue was found in `libcoap` version 4.3.5rc3, specifically commit `aac5de9`.
-   A fix was introduced in a later commit, specifically related to issue [#1483](https://github.com/obgm/libcoap/pull/1483) that addresses the `coap_handle_request_put_block` function.
-   The issue involves a race condition or incorrect handling of memory within the mentioned function that leads to a read access to an address close to NULL.
-   The AddressSanitizer tool was used to detect the memory violation.
-   The exact steps to reproduce the issue manually might not be straightforward and may require a series of crafted packets.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | alternate_terms | 1.000 |
| 2 | 190 | Integer Overflow or Wraparound | Base | Allowed | alternate_terms | 0.800 |
| 3 | 120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | Base | Allowed-with-Review | alternate_terms | 0.700 |
| 4 | 121 | Stack-based Buffer Overflow | Variant | Allowed | sparse | 0.226 |
| 5 | 122 | Heap-based Buffer Overflow | Variant | Allowed | sparse | 0.222 |
| 6 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | sparse | 0.199 |
| 7 | 193 | Off-by-one Error | Base | Allowed | sparse | 0.195 |
| 8 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.192 |
| 9 | 126 | Buffer Over-read | Variant | Allowed | dense | 0.562 |
| 10 | 128 | Wrap-around Error | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer

CWE-190: Integer Overflow or Wraparound

CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')

CWE-121: Stack-based Buffer Overflow

CWE-122: Heap-based Buffer Overflow

CWE-674: Uncontrolled Recursion

CWE-193: Off-by-one Error

CWE-125: Out-of-bounds Read

CWE-126: Buffer Over-read

CWE-128: Wrap-around Error