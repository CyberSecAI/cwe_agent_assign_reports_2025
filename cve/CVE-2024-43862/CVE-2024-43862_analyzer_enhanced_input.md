## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved net wan fsl_qmc_hdlc Convert carrier_lock spinlock to a mutex The carrier_lock spinlock protects the carrier detection. While it is held, framer_get_status() is called which in turn takes a mutex. This is not correct and can lead to a deadlock. A run with PROVE_LOCKING enabled detected the issue [ BUG Invalid wait context ] ... c204ddbc (&framer->mutex){+.+.}-{33}, at framer_get_status+0x40/0x78 other info that might help us debug this context-{44} 2 locks held by ifconfig/146 #0 c0926a38 (rtnl_mutex){+.+.}-{33}, at devinet_ioctl+0x12c/0x664 #1 c2006a40 (&qmc_hdlc->carrier_lock){....}-{22}, at qmc_hdlc_framer_set_carrier+0x30/0x98 Avoid the spinlock usage and convert carrier_lock to a mutex.

### Vulnerability Description Key Phrases
- **rootcause:** **Use of framer_get_status() while holding carrier_lock spinlock**
- **weakness:** **improper locking**
- **impact:** deadlock
- **product:** Linux kernel

## CVE Reference Links Content Summary
The provided content relates to CVE-2024-43862.

**Root cause of vulnerability:**
The `carrier_lock` was implemented as a spinlock. While this spinlock is held, the `framer_get_status()` function is called which in turn tries to acquire a mutex. This creates a lock inversion, which can lead to a deadlock.

**Weaknesses/vulnerabilities:**
- Improper locking mechanism: Using a spinlock where a mutex is needed.
- Potential deadlock: The lock inversion can lead to a system deadlock.

**Impact of exploitation:**
The deadlock caused by the lock inversion can lead to denial of service.

**Attack vectors:**
The vulnerability can be triggered by any operation that requires the `carrier_lock` and subsequently calls `framer_get_status()`, this can be achieved via standard network configuration tools like `ifconfig`

**Required attacker capabilities/position:**
An attacker would require the ability to trigger the condition that leads to acquiring the `carrier_lock` and calls `framer_get_status()`. No special privileges are required, standard network configuration tools can be used.

The provided content includes the patch which resolves the issue. The fix is to change the spinlock to a mutex which prevents the deadlock scenario from occurring.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.528 |
| 2 | 833 | Deadlock | Base | Allowed | sparse | 0.460 |
| 3 | 412 | Unrestricted Externally Accessible Lock | Base | Allowed | sparse | 0.450 |
| 4 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.434 |
| 5 | 662 | Improper Synchronization | Class | Discouraged | sparse | 0.434 |
| 6 | 787 | Out-of-bounds Write | Base | Allowed | sparse | 0.430 |
| 7 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.428 |
| 8 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | sparse | 0.426 |
| 9 | 413 | Improper Resource Locking | Base | Allowed | dense | 0.560 |
| 10 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | graph | 0.002 |



# Complete CWE Specifications

CWE-667: Improper Locking

CWE-833: Deadlock

CWE-412: Unrestricted Externally Accessible Lock

CWE-770: Allocation of Resources Without Limits or Throttling

CWE-662: Improper Synchronization

CWE-787: Out-of-bounds Write

CWE-401: Missing Release of Memory after Effective Lifetime

CWE-674: Uncontrolled Recursion

CWE-413: Improper Resource Locking

CWE-789: Memory Allocation with Excessive Size Value