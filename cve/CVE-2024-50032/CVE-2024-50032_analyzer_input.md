# Vulnerability Information: CVE-2024-50032

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved rcu/nocb Fix rcuog wake-up from offline softirq After a CPU has set itself offline and before it eventually calls rcutree_report_cpu_dead(), there are still opportunities for callbacks to be enqueued, for example from a softirq. When that happens on NOCB, the rcuog wake-up is deferred through an IPI to an online CPU in order not to call into the scheduler and risk arming the RT-bandwidth after hrtimers have been migrated out and disabled. But performing a synchronized IPI from a softirq is buggy as reported in the following scenario WARNING CPU 1 PID 26 at kernel/smp.c633 smp_call_function_single Modules linked in rcutorture torture CPU 1 UID 0 PID 26 Comm migration/1 Not tainted 6.11.0-rc1-00012-g9139f93209d1 #1 Stopper multi_cpu_stop+0x0/0x320 swake_up_one_online __call_rcu_nocb_wake __call_rcu_common ? rcu_torture_one_read call_timer_fn __run_timers run_timer_softirq handle_softirqs irq_exit_rcu ? tick_handle_periodic sysvec_apic_timer_interrupt Fix this with forcing deferred rcuog wake up through the NOCB timer when the CPU is offline. The actual wake up will happen from rcutree_report_cpu_dead().

### Vulnerability Description Key Phrases
- **rootcause:** **improper synchronization**
- **product:** Linux kernel
- **version:** 6.11.0-rc1-00012-g9139f93209d1

## CVE Reference Links Content Summary
The provided content relates to a fix for a race condition in the Linux kernel's RCU (Read-Copy-Update) subsystem, specifically within the non-callback (NOCB) implementation. This fix addresses a scenario where a CPU is in the process of going offline but still has pending RCU callbacks, leading to a buggy IPI (Inter-Processor Interrupt).

Here's a breakdown:

**Root Cause of Vulnerability:**

-   When a CPU is being taken offline, there's a window where RCU callbacks can still be enqueued (e.g., from a softirq).
-   In the NOCB implementation, these callbacks trigger an RCU grace period wake-up. This wake-up is deferred to an online CPU via IPI to avoid scheduler calls.
-   The issue arises because performing a synchronized IPI from a softirq during the CPU offline procedure is unsafe and can lead to a kernel warning and likely a crash.

**Weaknesses/Vulnerabilities Present:**

-   **Race Condition:** The primary vulnerability is a race condition between the CPU going offline and the enqueueing of RCU callbacks.
-   **Incorrect IPI Usage:** Attempting to send a synchronized IPI from within a softirq context during CPU offline is inherently unsafe.

**Impact of Exploitation:**

-   Kernel crash, as evidenced by the warning output
-   System instability due to the buggy IPI within a softirq

**Attack Vectors:**

-   The vulnerability is triggered by the normal process of taking a CPU offline while RCU callbacks are pending. Thus this is not a classic attack vector from an external attacker, but a flaw that arises during normal system operation, especially in scenarios involving CPU hotplug.

**Required Attacker Capabilities/Position:**

-   An attacker would not necessarily need to be in a special position to trigger this bug, as it arises during the process of taking a cpu offline while RCU callbacks are pending and is not dependent on user interaction, therefore this could be triggered unintentionally during normal operation.

**Fix:**

The fix changes the behavior of `__call_rcu_nocb_wake`:

-  Instead of sending the IPI to an online CPU immediately from the softirq, it forces a deferred RCU wake up through the NOCB timer.
-  The actual wake-up now happens from `rcutree_report_cpu_dead()`, which is called after the CPU is completely offline, ensuring that the IPI doesn't occur in the unsafe softirq context.

**Additional Details**
- The commit message references the following bug report: https://lore.kernel.org/oe-lkp/202409231644.4c55582d-lkp@intel.com
- The fix addresses an issue first introduced by commit `9139f93209d1` ("rcu/nocb: Fix RT throttling hrtimer armed from offline CPU")
- The changes are localized to the `kernel/rcu/tree_nocb.h` file.

In summary, this patch fixes a race condition that leads to a buggy IPI when a CPU goes offline, preventing a kernel crash. It's a fix for an internal race condition not an externally exploitable vulnerability in the traditional sense.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.669 |
| 2 | 400 | Uncontrolled Resource Consumption | Class | Discouraged | sparse | 0.660 |
| 3 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.642 |
| 4 | 863 | Incorrect Authorization | Class | Allowed-with-Review | sparse | 0.640 |
| 5 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | Allowed | sparse | 0.635 |
| 6 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.632 |
| 7 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.632 |
| 8 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | sparse | 0.631 |
| 9 | 1342 | Information Exposure through Microarchitectural State after Transient Execution | Base | Allowed | dense | 0.494 |
| 10 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | graph | 0.003 |

