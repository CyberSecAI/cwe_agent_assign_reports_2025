{
  "retriever": "sparse",
  "query": "In the Linux kernel, the following vulnerability has been resolved rcu/nocb Fix rcuog wake-up from offline softirq After a CPU has set itself offline and before it eventually calls rcutree_report_cpu_dead(), there are still opportunities for callbacks to be enqueued, for example from a softirq. When that happens on NOCB, the rcuog wake-up is deferred through an IPI to an online CPU in order not to call into the scheduler and risk arming the RT-bandwidth after hrtimers have been migrated out and disabled. But performing a synchronized IPI from a softirq is buggy as reported in the following scenario WARNING CPU 1 PID 26 at kernel/smp.c633 smp_call_function_single Modules linked in rcutorture torture CPU 1 UID 0 PID 26 Comm migration/1 Not tainted 6.11.0-rc1-00012-g9139f93209d1 #1 Stopper multi_cpu_stop+0x0/0x320 swake_up_one_online __call_rcu_nocb_wake __call_rcu_common ? rcu_torture_one_read call_timer_fn __run_timers run_timer_softirq handle_softirqs irq_exit_rcu ? tick_handle_periodic sysvec_apic_timer_interrupt Fix this with forcing deferred rcuog wake up through the NOCB timer when the CPU is offline. The actual wake up will happen from rcutree_report_cpu_dead().",
  "keyphrases": {
    "rootcause": [
      "improper synchronization"
    ]
  },
  "timestamp": "2025-07-13 19:46:27",
  "cve_id": "CVE-2024-50032",
  "result_count": 12,
  "results": [
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "score": 668.8458962563188,
      "search_source": "rootcause:improper synchronization"
    },
    {
      "cwe_id": "400",
      "name": "Uncontrolled Resource Consumption",
      "score": 660.0157942276036,
      "search_source": "rootcause:improper synchronization"
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "score": 642.3550870522641,
      "search_source": "rootcause:improper synchronization"
    },
    {
      "cwe_id": "863",
      "name": "Incorrect Authorization",
      "score": 640.2969380097979,
      "search_source": "rootcause:improper synchronization"
    },
    {
      "cwe_id": "835",
      "name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
      "score": 634.962336038028,
      "search_source": "rootcause:improper synchronization"
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "score": 631.8577192100249,
      "search_source": "rootcause:improper synchronization"
    },
    {
      "cwe_id": "367",
      "name": "Time-of-check Time-of-use (TOCTOU) Race Condition",
      "score": 631.8383753482105,
      "search_source": "rootcause:improper synchronization"
    },
    {
      "cwe_id": "119",
      "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
      "score": 631.3624009623221,
      "search_source": "rootcause:improper synchronization"
    },
    {
      "cwe_id": "639",
      "name": "Authorization Bypass Through User-Controlled Key",
      "score": 630.5413961150883,
      "search_source": "rootcause:improper synchronization"
    },
    {
      "cwe_id": "61",
      "name": "UNIX Symbolic Link (Symlink) Following",
      "score": 629.9112238604689,
      "search_source": "rootcause:improper synchronization"
    },
    {
      "cwe_id": "522",
      "name": "Insufficiently Protected Credentials",
      "score": 209.39154737750584,
      "search_source": "base_query"
    },
    {
      "cwe_id": "770",
      "name": "Allocation of Resources Without Limits or Throttling",
      "score": 208.7198635604272,
      "search_source": "base_query"
    }
  ]
}