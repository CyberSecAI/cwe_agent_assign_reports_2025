## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved io_uring/rw fix **missing NOWAIT check** for O_DIRECT start write When io_uring starts a write, itll call kiocb_start_write() to bump the super block rwsem, preventing any freezes from happening while that write is in-flight. The freeze side will grab that rwsem for writing, excluding any new writers from happening and waiting for existing writes to finish. But io_uring unconditionally uses kiocb_start_write(), which will block if someone is currently attempting to freeze the mount point. This causes a **deadlock** where freeze is waiting for previous writes to complete, but the previous writes cannot complete, as the task that is supposed to complete them is blocked waiting on starting a new write. This results in the following stuck trace showing that dependency with the write blocked starting a new write taskfio stateD stack0 pid886 tgid886 ppid876 Call trace __switch_to+0x1d8/0x348 __schedule+0x8e8/0x2248 schedule+0x110/0x3f0 percpu_rwsem_wait+0x1e8/0x3f8 __percpu_down_read+0xe8/0x500 io_write+0xbb8/0xff8 io_issue_sqe+0x10c/0x1020 io_submit_sqes+0x614/0x2110 __arm64_sys_io_uring_enter+0x524/0x1038 invoke_syscall+0x74/0x268 el0_svc_common.constprop.0+0x160/0x238 do_el0_svc+0x44/0x60 el0_svc+0x44/0xb0 el0t_64_sync_handler+0x118/0x128 el0t_64_sync+0x168/0x170 INFO task fsfreeze7364 blocked for more than 15 seconds. Not tainted 6.12.0-rc5-00063-g76aaf945701c #7963 with the attempting freezer stuck trying to grab the rwsem taskfsfreeze stateD stack0 pid7364 tgid7364 ppid995 Call trace __switch_to+0x1d8/0x348 __schedule+0x8e8/0x2248 schedule+0x110/0x3f0 percpu_down_write+0x2b0/0x680 freeze_super+0x248/0x8a8 do_vfs_ioctl+0x149c/0x1b18 __arm64_sys_ioctl+0xd0/0x1a0 invoke_syscall+0x74/0x268 el0_svc_common.constprop.0+0x160/0x238 do_el0_svc+0x44/0x60 el0_svc+0x44/0xb0 el0t_64_sync_handler+0x118/0x128 el0t_64_sync+0x168/0x170 Fix this by having the io_uring side honor IOCB_NOWAIT, and only attempt a blocking grab of the super block rwsem if it isnt set. For normal issue where IOCB_NOWAIT would always be set, this returns -EAGAIN which will have io_uring core issue a blocking attempt of the write. That will in turn also get completions run, ensuring forward progress. Since freezing requires CAP_SYS_ADMIN in the first place, this isnt something that can be triggered by a regular user.

### Vulnerability Description Key Phrases
- **rootcause:** **missing NOWAIT check**
- **weakness:** **deadlock**
- **product:** Linux kernel
- **component:** io_uring

## CVE Reference Links Content Summary
Based on the provided content, here's a breakdown of the vulnerability:

**Root Cause:**

- The `io_uring` subsystem in the Linux kernel was unconditionally calling `kiocb_start_write()` when initiating a write operation. This function attempts to acquire a superblock read/write semaphore (`rwsem`).
- When a mount point is being frozen (e.g., via `fsfreeze`), the process doing the freezing will attempt to acquire this same semaphore, but for writing.
- If the freeze operation attempts to acquire the semaphore while a write operation is in progress (or vice versa), a deadlock can occur. This is because the write operation might block waiting for the freezer to release the semaphore, while the freezer is waiting for the write operation to complete.

**Weaknesses/Vulnerabilities Present:**

- **Deadlock:** The primary vulnerability is a deadlock condition. The io_uring write operation and the mount point freeze operation can block each other indefinitely.
- **Missing `IOCB_NOWAIT` Check:** The `io_uring` subsystem was not respecting the `IOCB_NOWAIT` flag, which can be set on io_uring requests. This flag indicates that the operation should not block if it cannot immediately acquire the necessary resources (in this case, the superblock semaphore). The io_uring code was unconditionally trying to acquire the semaphore, even if `IOCB_NOWAIT` was set.

**Impact of Exploitation:**

- **Denial of Service (DoS):** The deadlock will cause the process initiating the `io_uring` write and the process freezing the filesystem to hang. This can lead to system instability and a denial of service.

**Attack Vectors:**

- **io_uring Write:** An attacker could trigger a vulnerable `io_uring` write operation, specifically an O_DIRECT write.
- **Filesystem Freeze:** Concurrently, an attacker with CAP_SYS_ADMIN privileges could attempt to freeze the filesystem the write is targeting. This could be initiated using the `fsfreeze` utility or the `ioctl` system call that freezes filesystems..

**Required Attacker Capabilities/Position:**

- **CAP_SYS_ADMIN:** The filesystem freeze operation requires `CAP_SYS_ADMIN` privileges, meaning only a user with root privileges (or a process with this capability) can trigger that part of the vulnerability. 
- **Ability to initiate io_uring writes:** The attacker needs to be able to issue io_uring write requests.

**Technical Details:**

- The fix involves checking for the `IOCB_NOWAIT` flag. If set, the code will first try a non-blocking attempt to acquire the superblock semaphore using `sb_start_write_trylock`. If the try lock fails, the function returns `-EAGAIN`.
- If the `IOCB_NOWAIT` flag is not set, the existing blocking call to `kiocb_start_write` occurs.
- The io_uring core will then handle the `-EAGAIN` return and attempt the blocking write to ensure forward progress.

**Additional Notes:**

- The vulnerability is not triggerable by regular users due to the requirement of CAP_SYS_ADMIN for the filesystem freeze operation.
- The provided content includes diffs of `io_uring/rw.c` and `io_uring/io_uring.c` files, showing the changes made to address the vulnerability in different kernel versions. The fix is the same for both files.
- The fix was backported to stable kernel releases 5.10 and later.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 863 | Incorrect Authorization | Class | Allowed-with-Review | sparse | 1.097 |
| 2 | 833 | Deadlock | Base | Allowed | sparse | 1.090 |
| 3 | 61 | UNIX Symbolic Link (Symlink) Following | Compound | Allowed | sparse | 1.079 |
| 4 | 1333 | Inefficient Regular Expression Complexity | Base | Allowed | sparse | 1.075 |
| 5 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | Allowed | sparse | 1.055 |
| 6 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 1.041 |
| 7 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 1.039 |
| 8 | 184 | Incomplete List of Disallowed Inputs | Base | Allowed | sparse | 1.038 |
| 9 | 667 | Improper Locking | Class | Allowed-with-Review | dense | 0.488 |
| 10 | 386 | Symbolic Name not Mapping to Correct Object | Base | Allowed | graph | 0.002 |



# Complete CWE Specifications

CWE-863: Incorrect Authorization

CWE-833: Deadlock

CWE-61: UNIX Symbolic Link (Symlink) Following

CWE-1333: Inefficient Regular Expression Complexity

CWE-835: Loop with Unreachable Exit Condition ('Infinite Loop')

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-1284: Improper Validation of Specified Quantity in Input

CWE-184: Incomplete List of Disallowed Inputs

CWE-667: Improper Locking

CWE-386: Symbolic Name not Mapping to Correct Object