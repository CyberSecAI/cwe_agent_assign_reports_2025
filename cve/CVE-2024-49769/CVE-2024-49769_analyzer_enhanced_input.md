## Vulnerability Description
Waitress is a Web Server Gateway Interface server for Python 2 and 3. When a remote client closes the connection before waitress has had the opportunity to call getpeername() waitress wont correctly clean up the connection leading to the main thread attempting to write to a socket that no longer exists, but not removing it from the list of sockets to attempt to process. This leads to a busy-loop calling the write function. A remote attacker could run waitress out of available sockets with very little resources required. Waitress 3.0.1 contains fixes that remove the **race condition**.

### Vulnerability Description Key Phrases
- **rootcause:** **race condition**
- **impact:** busy-loop, run waitress out of available sockets
- **attacker:** remote attacker
- **product:** Waitress
- **version:** before 3.0.1

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of the vulnerability:

**Root Cause:**

The root cause is a race condition during the creation of a new `HTTPChannel`. When a connection is accepted, `waitress` retrieves the remote address. However, it was calling `getpeername()` again, which could fail if the remote client closed the connection before `getpeername()` was called. This failure would set the channel's `connected` attribute to `False` while the socket was still considered writable by the `select` system call, leading to an infinite loop in the `handle_write` method.

**Weaknesses/Vulnerabilities Present:**

*   **Race Condition:** The primary vulnerability is a race condition where a client closing the connection rapidly after the initial connect can cause `getpeername()` to fail, leading to an inconsistent state.
*   **Inconsistent `connected` state:** The `connected` attribute of the channel was being set based on the result of `getpeername()`, which is unreliable as the connection could have been closed already.
*   **Incorrect Handling of Disconnected Sockets:** The code was not properly handling the scenario where a socket was considered writable but the connection was effectively closed or half-closed (e.g., shutdown for read).
*   **Busy Loop:** Due to the inconsistent state, the server would enter a tight loop calling `handle_write` repeatedly, consuming excessive CPU resources.

**Impact of Exploitation:**

*   **Denial of Service (DoS):** A remote attacker could cause a denial of service by sending a crafted request to the server and immediately closing the connection. This would lead to the server consuming 100% CPU on one thread, or possibly running out of available sockets.
*   **Resource Exhaustion:** The busy loop would cause the server to become unresponsive and consume excessive CPU resources.

**Attack Vectors:**

*   **Network:** The attack is carried out over the network.
*   The attacker needs to be able to establish a TCP connection to the server.
*   The attacker needs to be able to close the connection very quickly. This is generally done by sending an invalid request and shutting down the write side of the connection.

**Required Attacker Capabilities/Position:**

*   **Remote Access:** The attacker needs to have network access to the server.
*   **Basic Networking Skills:** The attacker needs to be able to initiate a TCP connection and close the connection quickly.
*   **Timing:**  The attacker needs to exploit the race condition by closing the connection very quickly after the initial connect, before waitress finishes setting up the channel.

**Additional Notes**

*   The vulnerability was triggered by a specific scenario discovered during pentesting, involving a client that closed the connection very quickly (possibly with a `shutdown` for read) after a connect, causing getpeername to fail, and leading to a busy loop when the server would try to write to a disconnected socket.
*   The fix involved removing the redundant call to `getpeername()` in `wasyncore.dispatcher`, setting `self.connected = True` during the `HTTPChannel` initialization and modifying the `writable()` method to return `False` when `self.connected` is `False`, preventing the loop.
*   The vulnerability was present in versions of `waitress` prior to 3.0.1, and fixed in version 3.0.1.
*   The fix also includes changes to `handle_close()` to prevent calling `close()` on a socket multiple times.
*   The issue was initially reported as 100% CPU usage due to not closing properly, and was addressed in pull request [#435](https://github.com/Pylons/waitress/pull/435).
*   The vulnerability is tracked as CVE-2024-49769 and GHSA-3f84-rpwh-47g6.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | alternate_terms | 1.000 |
| 2 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.516 |
| 3 | 476 | NULL Pointer Dereference | Base | Allowed | sparse | 0.510 |
| 4 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.500 |
| 5 | 833 | Deadlock | Base | Allowed | sparse | 0.493 |
| 6 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | Allowed | sparse | 0.492 |
| 7 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.487 |
| 8 | 404 | Improper Resource Shutdown or Release | Class | Allowed-with-Review | sparse | 0.486 |
| 9 | 1385 | Missing Origin Validation in WebSockets | Variant | Allowed | dense | 0.352 |
| 10 | 609 | Double-Checked Locking | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition

CWE-476: NULL Pointer Dereference

CWE-667: Improper Locking

CWE-833: Deadlock

CWE-835: Loop with Unreachable Exit Condition ('Infinite Loop')

CWE-770: Allocation of Resources Without Limits or Throttling

CWE-404: Improper Resource Shutdown or Release

CWE-1385: Missing Origin Validation in WebSockets

CWE-609: Double-Checked Locking