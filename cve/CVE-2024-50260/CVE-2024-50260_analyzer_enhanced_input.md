## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved sock_map fix a **NULL pointer dereference** in sock_map_link_update_prog() The following **race condition** could trigger a **NULL pointer dereference** sock_map_link_detach() sock_map_link_update_prog() mutex_lock(&sockmap_mutex) ... sockmap_link->map = NULL mutex_unlock(&sockmap_mutex) mutex_lock(&sockmap_mutex) ... sock_map_prog_link_lookup(sockmap_link->map) mutex_unlock(&sockmap_mutex) Fix it by adding a NULL pointer check. In this specific case, it makes no sense to update a link which is being released.

### Vulnerability Description Key Phrases
- **rootcause:** **race condition**
- **weakness:** **NULL pointer dereference**
- **product:** Linux kernel
- **component:** sock_map_link_update_prog() and sock_map_link_detach()

## CVE Reference Links Content Summary
The provided content describes a race condition vulnerability in the Linux kernel's `sock_map` functionality, specifically in the `sock_map_link_update_prog` function.

**Root Cause:**
A race condition exists between `sock_map_link_detach` and `sock_map_link_update_prog`. The detach function can set `sockmap_link->map` to NULL while `sock_map_link_update_prog` might be concurrently attempting to access this potentially NULL pointer. This results in a NULL pointer dereference.

**Vulnerabilities/Weaknesses:**
- **Race Condition:** The core vulnerability is a race condition where the shared resource `sockmap_link->map` is modified by one thread (`sock_map_link_detach`) while another thread (`sock_map_link_update_prog`) attempts to use it without proper synchronization.
- **NULL Pointer Dereference:** The lack of a check for NULL on `sockmap_link->map` in `sock_map_link_update_prog` leads to a dereference of a NULL pointer.

**Impact of Exploitation:**
- The primary impact of successful exploitation is a kernel crash due to the NULL pointer dereference.

**Attack Vectors:**
- The vulnerability is triggered by a specific sequence of events involving detachment and update operations on a sock map link, leading to a race condition.

**Required Attacker Capabilities/Position:**
- An attacker would need the ability to manipulate sock map links such that the detach and update operations race.
- It's likely that the attacker would need to be able to execute code in the context of a user with sufficient privileges to create and modify these objects.

The fix involves adding a check to verify that `sockmap_link->map` is not NULL before attempting to use it in `sock_map_link_update_prog`.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | alternate_terms | 1.000 |
| 2 | 476 | NULL Pointer Dereference | Base | Allowed | sparse | 0.443 |
| 3 | 252 | Unchecked Return Value | Base | Allowed | sparse | 0.384 |
| 4 | 665 | Improper Initialization | Class | Discouraged | sparse | 0.372 |
| 5 | 824 | Access of Uninitialized Pointer | Base | Allowed | sparse | 0.364 |
| 6 | 364 | Signal Handler Race Condition | Base | Allowed | sparse | 0.354 |
| 7 | 690 | Unchecked Return Value to NULL Pointer Dereference | Compound | Discouraged | sparse | 0.343 |
| 8 | 833 | Deadlock | Base | Allowed | sparse | 0.342 |
| 9 | 911 | Improper Update of Reference Count | Base | Allowed | dense | 0.571 |
| 10 | 1325 | Improperly Controlled Sequential Memory Allocation | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-476: NULL Pointer Dereference

CWE-252: Unchecked Return Value

CWE-665: Improper Initialization

CWE-824: Access of Uninitialized Pointer

CWE-364: Signal Handler Race Condition

CWE-690: Unchecked Return Value to NULL Pointer Dereference

CWE-833: Deadlock

CWE-911: Improper Update of Reference Count

CWE-1325: Improperly Controlled Sequential Memory Allocation