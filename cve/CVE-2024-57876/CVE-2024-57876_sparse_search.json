{
  "retriever": "sparse",
  "query": "In the Linux kernel, the following vulnerability has been resolved drm/dp_mst Fix resetting msg rx state after topology removal If the MST topology is removed during the reception of an MST down reply or MST up request sideband message, the drm_dp_mst_topology_mgrup_req_recv/down_rep_recv states could be reset from one thread via drm_dp_mst_topology_mgr_set_mst(false), racing with the reading/parsing of the message from another thread via drm_dp_mst_handle_down_rep() or drm_dp_mst_handle_up_req(). The race is possible since the reader/parser doesnt hold any lock while accessing the reception state. This in turn can lead to a memory corruption in the reader/parser as described by commit bd2fccac61b4 (drm/dp_mst Fix MST sideband message body length check). Fix the above by resetting the message reception state if needed before reading/parsing a message. Another solution would be to hold the drm_dp_mst_topology_mgrlock for the whole duration of the message reception/parsing in drm_dp_mst_handle_down_rep() and drm_dp_mst_handle_up_req(), however this would require a bigger change. Since the fix is also needed for stable, opting for the simpler solution in this patch.",
  "keyphrases": {
    "weakness": [
      "memory corruption"
    ]
  },
  "timestamp": "2025-07-14 00:33:02",
  "cve_id": "CVE-2024-57876",
  "result_count": 10,
  "results": [
    {
      "cwe_id": "787",
      "name": "Out-of-bounds Write",
      "score": 1000.0,
      "search_source": "alternate_term_match"
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "score": 819.1527307609766,
      "search_source": "weakness:memory corruption"
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "score": 797.0444228988931,
      "search_source": "weakness:memory corruption"
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "score": 776.6699063534536,
      "search_source": "weakness:memory corruption"
    },
    {
      "cwe_id": "125",
      "name": "Out-of-bounds Read",
      "score": 769.5731919332302,
      "search_source": "weakness:memory corruption"
    },
    {
      "cwe_id": "835",
      "name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
      "score": 765.6953408680693,
      "search_source": "weakness:memory corruption"
    },
    {
      "cwe_id": "190",
      "name": "Integer Overflow or Wraparound",
      "score": 752.3191507292333,
      "search_source": "weakness:memory corruption"
    },
    {
      "cwe_id": "674",
      "name": "Uncontrolled Recursion",
      "score": 751.3237001638881,
      "search_source": "weakness:memory corruption"
    },
    {
      "cwe_id": "367",
      "name": "Time-of-check Time-of-use (TOCTOU) Race Condition",
      "score": 748.7587265007998,
      "search_source": "weakness:memory corruption"
    },
    {
      "cwe_id": "789",
      "name": "Memory Allocation with Excessive Size Value",
      "score": 747.3920068295233,
      "search_source": "weakness:memory corruption"
    }
  ]
}