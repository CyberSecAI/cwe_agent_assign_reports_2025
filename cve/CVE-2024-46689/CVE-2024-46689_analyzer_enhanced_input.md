## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved soc qcom cmd-db Map shared memory as WC, not WB Linux does not write into cmd-db region. This region of memory is write protected by XPU. XPU may sometime falsely detect clean cache eviction as write into the write protected region leading to secure interrupt which causes an endless loop somewhere in Trust Zone. The only reason it is working right now is because Qualcomm Hypervisor maps the same region as Non-Cacheable memory in Stage 2 translation tables. The issue manifests if we want to use another hypervisor (like Xen or KVM), which does not know anything about those specific mappings. Changing the mapping of cmd-db memory from MEMREMAP_WB to MEMREMAP_WT/WC removes dependency on correct mappings in Stage 2 tables. This patch fixes the issue by updating the mapping to MEMREMAP_WC. I tested this on SA8155P with Xen.

### Vulnerability Description Key Phrases
- **rootcause:** **improper cache-write protection**
- **impact:** information disclosure
- **product:** Linux kernel
- **component:** soc qcom cmd-db Map

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of the vulnerability:

**Root Cause:**
The root cause of the vulnerability lies in the incorrect memory mapping of the command database (cmd-db) region in the Qualcomm System-on-Chip (SoC) driver. The cmd-db region is write-protected by the XPU (eXtended Processing Unit). However, the Linux kernel was mapping this region as Write-Back (MEMREMAP_WB), while it should have been mapped as Write-Combining/Write-Through (MEMREMAP_WT/WC). Due to the Write-Back mapping, a clean cache eviction could be misinterpreted by XPU as a write into the protected region.

**Weaknesses/Vulnerabilities:**
- **Incorrect Memory Mapping:** Using MEMREMAP_WB for a write-protected region leads to potential conflicts with the XPU.
- **XPU False Detection:** The XPU might incorrectly detect cache evictions as writes, triggering a secure interrupt.
- **Dependency on Hypervisor:** The original implementation relied on the Qualcomm Hypervisor to map this region as non-cacheable in Stage 2 translation tables. This creates a dependency, making other hypervisors vulnerable.

**Impact of Exploitation:**
- **Endless Loop/System Hang:** When the XPU falsely detects a write, it leads to a secure interrupt. The handling of this interrupt can result in an endless loop within the Trust Zone, effectively hanging the system.
- **System Instability:** The incorrect mapping creates system instability, and the issue is exposed when using other hypervisors like Xen or KVM.

**Attack Vectors:**
- **Hypervisor Use:** The issue is triggered when using a hypervisor other than the one provided by Qualcomm which is aware of the specific memory mappings.

**Required Attacker Capabilities/Position:**
- An attacker would need to be able to utilize a hypervisor other than the one provided by Qualcomm. The attacker would also need to have some form of execution within the kernel to cause memory activity that would result in the incorrect mapping being exposed.

**Additional Notes:**
- The fix involves changing the memory mapping from `MEMREMAP_WB` to `MEMREMAP_WC` in the `drivers/soc/qcom/cmd-db.c` file.
- The issue is specific to Qualcomm SoCs, particularly when used with hypervisors that do not know about specific memory mappings.
- The provided content includes multiple commits related to this fix, indicating it was backported to different kernel versions.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 404 | Improper Resource Shutdown or Release | Class | Allowed-with-Review | sparse | 0.755 |
| 2 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.718 |
| 3 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.656 |
| 4 | 1257 | Improper Access Control Applied to Mirrored or Aliased Memory Regions | Base | Allowed | sparse | 0.656 |
| 5 | 61 | UNIX Symbolic Link (Symlink) Following | Compound | Allowed | sparse | 0.637 |
| 6 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.632 |
| 7 | 863 | Incorrect Authorization | Class | Allowed-with-Review | sparse | 0.627 |
| 8 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.621 |
| 9 | 1260 | Improper Handling of Overlap Between Protected Memory Ranges | Base | Allowed | dense | 0.591 |
| 10 | 386 | Symbolic Name not Mapping to Correct Object | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-404: Improper Resource Shutdown or Release

CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-1257: Improper Access Control Applied to Mirrored or Aliased Memory Regions

CWE-61: UNIX Symbolic Link (Symlink) Following

CWE-667: Improper Locking

CWE-863: Incorrect Authorization

CWE-125: Out-of-bounds Read

CWE-1260: Improper Handling of Overlap Between Protected Memory Ranges

CWE-386: Symbolic Name not Mapping to Correct Object