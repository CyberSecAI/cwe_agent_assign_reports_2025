## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved ksmbd fix ****use-after-free**** in session logoff The sess->user object can currently be in use by another thread, for example if another connection has sent a session setup request to bind to the session being freed. The handler for that connection could be in the smb2_sess_setup function which makes use of sess->user.

### Vulnerability Description Key Phrases
- **rootcause:** **use-after-free**
- **weakness:** **use-after-free**
- **product:** Linux kernel
- **component:** ksmbd

## CVE Reference Links Content Summary
```text
The content is relevant to the specified CVE.

Here's the information extracted from the content:

*   **Vulnerability:** Use-after-free in the SMB ‘logoff’ command handler.
*   **Root cause of vulnerability:**
    *   While one ksmbd worker thread is still executing requests that use `sess->user`, another thread that processes an SMB2 LOGOFF for the same session frees that structure. No synchronization protects the pointer, so the first thread dereferences freed memory.
    *   The `ksmbd_session` struct's `user` member is freed in the `smb2_session_logoff` function, but the function doesn't wait for other connections using the session to finish.
*   **Weaknesses/vulnerabilities present:** Use-after-free, kernel memory corruption, arbitrary code execution in kernel context, and potential for NULL dereference leading to DoS.
*   **Impact of exploitation:** Kernel memory corruption and arbitrary code execution or a Denial of Service.
*   **Attack vectors:** A second transport is bound to an existing session (SMB 3.0 or later, `conn->binding == true`). A worker thread (Worker-A) receives a request, and while it is processing, another worker thread (Worker-B) processes an SMB2 LOGOFF for the same session.
*   **Required attacker capabilities/position:** Remote, network access to the SMB service.
*   **Mitigation or fix:** The article mentions a fix, and the author realized that the initial fix of setting `sess->user = NULL` was insufficient due to the possibility of session binding. The article also includes a code diff related to the fix.

More detail than the official CVE description.
```

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 416 | Use After Free | Variant | Allowed | alternate_terms | 1.000 |
| 2 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.392 |
| 3 | 364 | Signal Handler Race Condition | Base | Allowed | sparse | 0.368 |
| 4 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.356 |
| 5 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.351 |
| 6 | 415 | Double Free | Variant | Allowed | sparse | 0.342 |
| 7 | 614 | Sensitive Cookie in HTTPS Session Without 'Secure' Attribute | Variant | Allowed | sparse | 0.339 |
| 8 | 639 | Authorization Bypass Through User-Controlled Key | Base | Allowed | sparse | 0.339 |
| 9 | 384 | Session Fixation | Compound | Allowed | dense | 0.502 |
| 10 | 123 | Write-what-where Condition | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-416: Use After Free

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-364: Signal Handler Race Condition

CWE-667: Improper Locking

CWE-401: Missing Release of Memory after Effective Lifetime

CWE-415: Double Free

CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute

CWE-639: Authorization Bypass Through User-Controlled Key

CWE-384: Session Fixation

CWE-123: Write-what-where Condition