## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved drm/xe/client fix deadlock in show_meminfo() There is a real deadlock as well as sleeping in atomic() bug in here, if the bo put happens to be the last ref, since bo destruction wants to grab the same spinlock and sleeping locks. Fix that by dropping the ref using xe_bo_put_deferred(), and moving the final commit outside of the lock. Dropping the lock around the put is tricky since the bo can go out of scope and delete itself from the list, making it difficult to navigate to the next list entry. (cherry picked from commit 0083b8e6f11d7662283a267d4ce7c966812ffd8a)

### Vulnerability Description Key Phrases
- **rootcause:** **deadlock and sleeping in atomic() bug**
- **product:** Linux kernel
- **component:** drm/xe/client show_meminfo()

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of the vulnerability:

**Root Cause:**
- The vulnerability stems from a deadlock and potential "sleeping in atomic context" issue within the `show_meminfo()` function of the `xe_drm_client.c` driver.
- The `show_meminfo()` function iterates through a list of buffer objects (BOs) associated with a client. It acquires a spinlock (`client->bos_lock`) to protect the list during this iteration.
- The `xe_bo_put(bo)` function, used to decrement the reference count of each BO, can trigger the destruction of the BO if it's the last reference.
- The BO destruction process needs to acquire the same spinlock held by `show_meminfo()`, leading to a deadlock if `xe_bo_put()` triggers destruction.
- Additionally, the BO destruction process might also involve sleeping locks, which is problematic within an atomic context.

**Weaknesses/Vulnerabilities:**
- **Deadlock:** The primary vulnerability is a deadlock condition where `show_meminfo()` holds a spinlock while trying to decrement the reference count on a BO, and the BO's destruction tries to acquire the same lock, causing the system to hang.
- **Sleeping in Atomic Context:** The BO destruction path may involve operations that cause the calling thread to sleep, which is illegal within an atomic context protected by a spinlock.

**Impact of Exploitation:**
- The deadlock can cause a denial of service (DoS) by freezing the affected system. The system will be unresponsive until rebooted.

**Attack Vectors:**
- An attacker does not need any special privileges to trigger this bug.
- The vulnerability can be triggered by calling the `show_meminfo()` function, which is used to collect and display memory usage information for the xe driver. This function is called when information about the driver is requested.

**Required Attacker Capabilities/Position:**
- The attacker needs to be able to trigger the `show_meminfo()` function which is part of the debug functionality. The `xe` driver must be loaded and active on the system to trigger this vulnerability.

**Mitigation:**
- The patch introduces the following changes:
  - Instead of calling `xe_bo_put()` directly within the loop, it uses `xe_bo_put_deferred(bo, &deferred)`. This function defers the actual decrement of the reference count and potential BO destruction.
  - The reference count decrement and potential destruction of the buffer objects are moved outside of the spinlock using `xe_bo_put_commit(&deferred)`.
  - This prevents the deadlock because the BO destruction will not attempt to reacquire the lock that is already held by `show_meminfo`.

In summary, this vulnerability is a deadlock in the xe graphics driver when collecting memory info due to incorrect locking during BO destruction.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 833 | Deadlock | Base | Allowed | sparse | 0.595 |
| 2 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.579 |
| 3 | 61 | UNIX Symbolic Link (Symlink) Following | Compound | Allowed | sparse | 0.546 |
| 4 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.531 |
| 5 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.525 |
| 6 | 1390 | Weak Authentication | Class | Allowed-with-Review | sparse | 0.523 |
| 7 | 79 | Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') | Base | Allowed | sparse | 0.517 |
| 8 | 863 | Incorrect Authorization | Class | Allowed-with-Review | sparse | 0.512 |
| 9 | 413 | Improper Resource Locking | Base | Allowed | dense | 0.516 |
| 10 | 364 | Signal Handler Race Condition | Base | Allowed | graph | 0.002 |



# Complete CWE Specifications

CWE-833: Deadlock

CWE-667: Improper Locking

CWE-61: UNIX Symbolic Link (Symlink) Following

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-125: Out-of-bounds Read

CWE-1390: Weak Authentication

CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')

CWE-863: Incorrect Authorization

CWE-413: Improper Resource Locking

CWE-364: Signal Handler Race Condition