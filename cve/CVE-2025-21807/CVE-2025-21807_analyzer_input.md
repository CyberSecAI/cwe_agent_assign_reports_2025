# Vulnerability Information: CVE-2025-21807

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved block fix queue freeze vs limits **lock order** in sysfs store methods queue_attr_store() always freezes a device queue before calling the attribute store operation. For attributes that control queue limits, the store operation will also lock the queue limits with a call to queue_limits_start_update(). However, some drivers (e.g. SCSI sd) may need to issue commands to a device to obtain limit values from the hardware with the queue limits locked. This creates a potential **ABBA deadlock** situation if a user attempts to modify a limit (thus freezing the device queue) while the device driver starts a revalidation of the device queue limits. Avoid such deadlock by not freezing the queue before calling the ->store_limit() method in struct queue_sysfs_entry and instead use the queue_limits_commit_update_frozen helper to freeze the queue after taking the limits lock. This also removes taking the sysfs lock for the store_limit method as it doesnt protect anything here, but creates even more nesting. Hopefully it will go away from the actual sysfs methods entirely soon. (commit log adapted from a similar patch from Damien Le Moal)

### Vulnerability Description Key Phrases
- **rootcause:** **lock order**
- **weakness:** **ABBA deadlock**
- **product:** Linux kernel

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.888 |
| 2 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.884 |
| 3 | 606 | Unchecked Input for Loop Condition | Base | Allowed | sparse | 0.851 |
| 4 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | sparse | 0.847 |
| 5 | 833 | Deadlock | Base | Allowed | sparse | 0.836 |
| 6 | 319 | Cleartext Transmission of Sensitive Information | Base | Allowed | sparse | 0.823 |
| 7 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.821 |
| 8 | 774 | Allocation of File Descriptors or Handles Without Limits or Throttling | Variant | Allowed | sparse | 0.809 |
| 9 | 413 | Improper Resource Locking | Base | Allowed | dense | 0.463 |
| 10 | 129 | Improper Validation of Array Index | Variant | Allowed | graph | 0.003 |

