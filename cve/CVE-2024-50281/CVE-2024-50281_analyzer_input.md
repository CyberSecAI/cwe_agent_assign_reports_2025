# Vulnerability Information: CVE-2024-50281

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved KEYS trusted dcp fix **NULL dereference** in AEAD crypto operation When sealing or unsealing a key blob we currently do not wait for the AEAD cipher operation to finish and simply return after submitting the request. If there is some load on the system we can exit before the cipher operation is done and the buffer we read from/write to is already removed from the stack. This will e.g. result in NULL pointer dereference errors in the DCP driver during blob creation. Fix this by waiting for the AEAD cipher operation to finish before resuming the seal and unseal calls.

### Vulnerability Description Key Phrases
- **rootcause:** **NULL dereference**
- **impact:** NULL pointer dereference errors
- **product:** Linux kernel
- **component:** KEYS trusted dcp

## CVE Reference Links Content Summary
The provided content relates to a fix for a NULL pointer dereference vulnerability in the Linux kernel's trusted key handling, specifically within the Data Center Processor (DCP) driver. This is within the scope of the described CVE which is a placeholder.

Here's a breakdown:

**Root cause of vulnerability:**
- The vulnerability arises from not waiting for the AEAD (Authenticated Encryption with Associated Data) cipher operation to complete before returning from the seal or unseal functions of key blobs. This occurs when there is load on the system and the function returns before the cipher operation is done, leading to a stack-allocated buffer being accessed after it has been removed from the stack.

**Weaknesses/vulnerabilities present:**
- **Race Condition:** The code was vulnerable to a race condition where the AEAD cipher operation could be still in progress when the function returned.
- **Use-After-Free:**  When the function returns early, the memory allocated for the buffer is freed, and the ongoing AEAD operation would then try to access this invalid memory, leading to a NULL pointer dereference.

**Impact of exploitation:**
- **NULL pointer dereference:**  The most direct impact is a NULL pointer dereference, which can lead to a kernel crash.
- **Denial of service:** A kernel crash will disrupt the system's operation and cause a denial-of-service.

**Attack vectors:**
- The attack vector involves creating or processing key blobs using the trusted key infrastructure in the Linux kernel, triggering the vulnerable AEAD operations.
- The specific scenario involves sealing or unsealing a key blob.

**Required attacker capabilities/position:**
- The attacker needs to be able to trigger the key sealing or unsealing operation. This means the attacker must be in a position to interact with the trusted key subsystem of the kernel. This could be a privileged local user or through an exploit in another part of the system that allows interaction with the keys subsystem.

**Technical details:**
- The fix involves adding a `DECLARE_CRYPTO_WAIT(wait)` and setting the callback to `crypto_req_done` with the `wait` structure, followed by the use of `crypto_wait_req` in place of `crypto_aead_encrypt` and `crypto_aead_decrypt` to ensure that the function does not return until the AEAD operation is finished.
- The vulnerable code was in the `do_aead_crypto` function within `security/keys/trusted-keys/trusted_dcp.c`.
- The fix was applied to versions 6.10 and later.

**Additional Notes:**
- The commit message mentions `Fixes: 0e28bf61a5f9 ("KEYS: trusted: dcp: fix leak of blob encryption key")`, indicating this issue is a follow-up fix to a previous patch.
- The original report came from Parthiban N <parthiban@linumiz.com> and was discussed on the kernel mailing list.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 476 | NULL Pointer Dereference | Base | Allowed | alternate_terms | 0.800 |
| 2 | 824 | Access of Uninitialized Pointer | Base | Allowed | sparse | 0.630 |
| 3 | 908 | Use of Uninitialized Resource | Base | Allowed | sparse | 0.599 |
| 4 | 787 | Out-of-bounds Write | Base | Allowed | sparse | 0.588 |
| 5 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | Allowed | sparse | 0.588 |
| 6 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.585 |
| 7 | 252 | Unchecked Return Value | Base | Allowed | sparse | 0.576 |
| 8 | 617 | Reachable Assertion | Base | Allowed | sparse | 0.575 |
| 9 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | Allowed | dense | 0.548 |
| 10 | 822 | Untrusted Pointer Dereference | Base | Allowed | graph | 0.003 |

