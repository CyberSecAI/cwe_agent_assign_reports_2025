## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved udp Set SOCK_RCU_FREE earlier in udp_lib_get_port(). syzkaller triggered the warning [0] in udp_v4_early_demux(). In udp_v[46]_early_demux() and sk_lookup(), we do not touch the refcount of the looked-up sk and use sock_pfree() as skb->destructor, so we check SOCK_RCU_FREE to ensure that the sk is safe to access during the RCU grace period. Currently, SOCK_RCU_FREE is flagged for a bound socket after being put into the hash table. Moreover, the SOCK_RCU_FREE check is done too early in udp_v[46]_early_demux() and sk_lookup(), so there could be a small race window CPU1 CPU2 ---- ---- udp_v4_early_demux() udp_lib_get_port() | |- hlist_add_head_rcu() |- sk = __udp4_lib_demux_lookup() | |- DEBUG_NET_WARN_ON_ONCE(sk_is_refcounted(sk)) `- sock_set_flag(sk, SOCK_RCU_FREE) We had the same bug in TCP and fixed it in commit 871019b22d1b (net set SOCK_RCU_FREE before inserting socket into hashtable). Lets apply the same fix for UDP. [0] WARNING CPU 0 PID 11198 at net/ipv4/udp.c2599 udp_v4_early_demux+0x481/0xb70 net/ipv4/udp.c2599 Modules linked in CPU 0 PID 11198 Comm syz-executor.1 Not tainted 6.9.0-g93bda33046e7 #13 Hardware name QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2

### Vulnerability Description Key Phrases
- **rootcause:** **UDP SOCK_RCU_FREE check too early**
- **product:** Linux kernel
- **component:** udp_v4_early_demux() and sk_lookup()

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of the vulnerability:

**Root Cause:**

The root cause of the vulnerability is a race condition in the UDP socket handling within the Linux kernel. Specifically, the `SOCK_RCU_FREE` flag, which indicates that a socket is safe to access during an RCU (Read-Copy-Update) grace period, was being set *after* the socket was added to the hash table. This created a window where another CPU could attempt to access the socket via `udp_v4_early_demux()` or `sk_lookup()` before the `SOCK_RCU_FREE` flag was set, leading to a potential use-after-free condition.

**Weaknesses/Vulnerabilities Present:**

- **Race Condition:** A race condition exists between the process of binding a UDP socket (setting the `SOCK_RCU_FREE` flag) and the lookup operation that occurs when a UDP packet is received.
- **Incorrect Flag Timing:** The `SOCK_RCU_FREE` flag was being set too late in the socket binding process.
- **Use-After-Free Potential:** If the race condition is triggered, a CPU could access the socket after it has been freed, resulting in a use-after-free.

**Impact of Exploitation:**

- The primary impact is a kernel warning, which can lead to instability and potential crashes. This is evident in the provided syzkaller-triggered warning. The system might not always crash, but it indicates a potential vulnerability that can lead to more serious issues. The syzkaller report includes a stack trace when the race occurs

**Attack Vectors:**

- The vulnerability can be triggered by sending a UDP packet to a specific socket right after it is bound but before the SOCK_RCU_FREE flag is set.
- An attacker could attempt to trigger this by rapidly creating and binding a large number of UDP sockets while simultaneously sending UDP packets.

**Required Attacker Capabilities/Position:**

- The attacker needs the ability to send UDP packets to the target machine.
- The attacker would likely need to perform actions that can trigger the race condition, which includes binding to udp ports.
- No special privileges are required since this vulnerability is present in the kernel network handling logic itself.

**Technical Details:**

- The issue resides in `net/ipv4/udp.c` within the functions `udp_lib_get_port()` (where the socket is bound) and `udp_v4_early_demux()` (where the socket is looked up).
- The fix involves moving the `sock_set_flag(sk, SOCK_RCU_FREE)` call to *before* the `sk_add_node_rcu(sk, &hslot->head)` call, ensuring that the flag is set *before* the socket is added to the hash table.
- The code diff shows that three lines have been inserted and one line has been deleted to resolve this issue, specifically moving the `sock_set_flag(sk, SOCK_RCU_FREE);` call.

**Additional Notes:**

- The provided content includes a syzkaller report showing the warning. Syzkaller is a fuzzer used to find bugs in the Linux kernel.
- This vulnerability is similar to a previously fixed issue in TCP, highlighting a recurring pattern in the network stack.
- The fix is present in multiple commits, and the changes are identical in all of them.

In summary, this CVE describes a race condition vulnerability that can result in a kernel warning and potential crashes due to improper socket flag handling in the Linux kernel UDP stack.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.691 |
| 2 | 476 | NULL Pointer Dereference | Base | Allowed | sparse | 0.687 |
| 3 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.682 |
| 4 | 415 | Double Free | Variant | Allowed | sparse | 0.667 |
| 5 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.667 |
| 6 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | sparse | 0.662 |
| 7 | 923 | Improper Restriction of Communication Channel to Intended Endpoints | Class | Allowed-with-Review | sparse | 0.660 |
| 8 | 116 | Improper Encoding or Escaping of Output | Class | Allowed-with-Review | sparse | 0.654 |
| 9 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | dense | 0.531 |
| 10 | 123 | Write-what-where Condition | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-476: NULL Pointer Dereference

CWE-125: Out-of-bounds Read

CWE-415: Double Free

CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition

CWE-789: Memory Allocation with Excessive Size Value

CWE-923: Improper Restriction of Communication Channel to Intended Endpoints

CWE-116: Improper Encoding or Escaping of Output

CWE-401: Missing Release of Memory after Effective Lifetime

CWE-123: Write-what-where Condition