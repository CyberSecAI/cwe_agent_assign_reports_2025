# Vulnerability Information: CVE-2024-43863

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved drm/vmwgfx Fix a **deadlock in dma buf fence polling** Introduce a version of the fence ops that on release doesnt remove the fence from the pending list, and thus doesnt require a lock to fix poll->fence wait->fence unref deadlocks. vmwgfx overwrites the wait callback to iterate over the list of all fences and update their status, to do that it holds a lock to prevent the list modifcations from other threads. The fence destroy callback both deletes the fence and removes it from the list of pending fences, for which it holds a lock. dma buf polling cb unrefs a fence after its been signaled so the poll calls the wait, which signals the fences, which are being destroyed. The destruction tries to acquire the lock on the pending fences list which it can never get because its held by the wait from which it was called. Old bug, but not a lot of userspace apps were using dma-buf polling interfaces. Fix those, in particular this fixes KDE stalls/deadlock.

### Vulnerability Description Key Phrases
- **rootcause:** **deadlock in dma buf fence polling**
- **impact:** deadlock
- **product:** Linux kernel
- **component:** drm/vmwgfx

## CVE Reference Links Content Summary
```
{
  "vulnerability": {
    "root_cause": "A deadlock can occur in the vmwgfx driver when using dma-buf fence polling due to a locking conflict between fence destruction and fence wait/signal callbacks.",
    "weaknesses": [
      "The fence destroy callback attempts to acquire a lock on the pending fences list, while the wait callback, invoked by poll, holds the same lock. This leads to a deadlock as the destroy call is made from within the wait callback path."
    ],
    "impact": "The deadlock can cause system stalls, particularly in applications using dma-buf polling interfaces.",
     "attack_vectors": [
        "A user-space application using dma-buf polling interfaces can trigger the deadlock."
      ],
    "required_attacker_capabilities": "The attacker needs to be able to trigger dma-buf fence polling."
  },
  "fix": {
    "description": "A new version of fence operations was introduced that does not remove the fence from the pending list on release. This avoids the need for a lock during the fence unref operation within poll->fence wait->fence path.",
    "changes": [
      "Modified `vmw_fence_obj_destroy` to conditionally remove the fence from the pending list only if it's not empty, preventing the deadlock during destruction after a fence is signaled.",
       "Updated the fence iteration in `vmw_fence_goal_new_locked` to use `list_for_each_entry_safe` to handle potential fence deletion during iteration."
    ]
  }
}
```

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.927 |
| 2 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.920 |
| 3 | 833 | Deadlock | Base | Allowed | sparse | 0.913 |
| 4 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.900 |
| 5 | 863 | Incorrect Authorization | Class | Allowed-with-Review | sparse | 0.864 |
| 6 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | Allowed | sparse | 0.851 |
| 7 | 319 | Cleartext Transmission of Sensitive Information | Base | Allowed | sparse | 0.832 |
| 8 | 1390 | Weak Authentication | Class | Allowed-with-Review | sparse | 0.828 |
| 9 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | dense | 0.502 |
| 10 | 1325 | Improperly Controlled Sequential Memory Allocation | Base | Allowed | graph | 0.002 |

