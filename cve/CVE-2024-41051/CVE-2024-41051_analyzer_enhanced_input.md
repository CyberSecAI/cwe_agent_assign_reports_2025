## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved cachefiles wait for ondemand_object_worker to finish when dropping object When queuing ondemand_object_worker() to re-open the object, cachefiles_object is not pinned. The cachefiles_object may be freed when the pending read request is completed intentionally and the related erofs is umounted. If ondemand_object_worker() runs after the object is freed, it will incur **use-after-free** problem as shown below. process A processs B process C process D cachefiles_ondemand_send_req() // send a read req X // wait for its completion // close ondemand fd cachefiles_ondemand_fd_release() // set object as CLOSE cachefiles_ondemand_daemon_read() // set object as REOPENING queue_work(fscache_wq, &info->ondemand_work) // close /dev/cachefiles cachefiles_daemon_release cachefiles_flush_reqs complete(&req->done) // read req X is completed // umount the erofs fs cachefiles_put_object() // object will be freed cachefiles_ondemand_deinit_obj_info() kmem_cache_free(object) // both info and object are freed ondemand_object_worker() When dropping an object, it is no longer necessary to reopen the object, so use cancel_work_sync() to cancel or wait fo

### Vulnerability Description Key Phrases
- **rootcause:** **race condition**
- **weakness:** **use-after-free**
- **product:** Linux kernel

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of the vulnerability:

**Root Cause:**

The vulnerability is a use-after-free (UAF) condition in the `cachefiles` subsystem of the Linux kernel. Specifically, it arises when the `ondemand_object_worker()` function attempts to access a `cachefiles_object` after it has been freed.

**Vulnerabilities/Weaknesses:**

*   **Lack of Object Pinning:** The `cachefiles_object` is not pinned when `ondemand_object_worker()` is queued, creating a race condition.
*   **Race Condition:** The race condition exists between the completion of a read request (which can lead to unmounting of the related filesystem and freeing of the `cachefiles_object`) and the execution of the `ondemand_object_worker()`.
*   **Incorrect Object Lifetime Management:** The code doesn't properly manage the lifetime of the `cachefiles_object` when an on-demand reopen is pending.

**Impact of Exploitation:**

*   **Use-After-Free:** If the `ondemand_object_worker()` runs after the `cachefiles_object` is freed, it leads to a use-after-free vulnerability.
*   **System Instability:** This can result in system crashes, potential privilege escalation, or other undefined behavior due to memory corruption.

**Attack Vectors:**

The vulnerability can be triggered by a sequence of operations involving:

1.  Sending a read request to a cached object.
2.  Closing the on-demand file descriptor.
3.  The `cachefiles_ondemand_daemon_read()` function setting the object as REOPENING and queues the `ondemand_object_worker()`.
4.  Closing the `/dev/cachefiles` device.
5.  Unmounting the filesystem associated with the cached object
6.  The object is then freed by `cachefiles_put_object()` and `kmem_cache_free(object)`.
7.  The queued `ondemand_object_worker()` then attempts to access the freed memory.

**Required Attacker Capabilities/Position:**

*   An attacker would need to be able to trigger the specific sequence of operations that create a race condition. This might involve specific actions related to opening, reading, and closing files on a filesystem that is being cached with cachefiles.
*   The attacker must have the ability to interact with a cached filesystem and trigger its unmount.

**Mitigation:**
The patch addresses this issue by using `cancel_work_sync()` in `cachefiles_ondemand_clean_object()` to either cancel the `ondemand_object_worker()` or wait for it to complete before dropping the object. This ensures that `ondemand_object_worker()` never accesses a freed object.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | alternate_terms | 1.000 |
| 2 | 416 | Use After Free | Variant | Allowed | alternate_terms | 1.000 |
| 3 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.687 |
| 4 | 415 | Double Free | Variant | Allowed | sparse | 0.678 |
| 5 | 639 | Authorization Bypass Through User-Controlled Key | Base | Allowed | sparse | 0.671 |
| 6 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.634 |
| 7 | 911 | Improper Update of Reference Count | Base | Allowed | sparse | 0.634 |
| 8 | 1321 | Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution') | Variant | Allowed | sparse | 0.622 |
| 9 | 403 | Exposure of File Descriptor to Unintended Control Sphere ('File Descriptor Leak') | Base | Allowed | dense | 0.481 |
| 10 | 123 | Write-what-where Condition | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-416: Use After Free

CWE-401: Missing Release of Memory after Effective Lifetime

CWE-415: Double Free

CWE-639: Authorization Bypass Through User-Controlled Key

CWE-667: Improper Locking

CWE-911: Improper Update of Reference Count

CWE-1321: Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution')

CWE-403: Exposure of File Descriptor to Unintended Control Sphere ('File Descriptor Leak')

CWE-123: Write-what-where Condition