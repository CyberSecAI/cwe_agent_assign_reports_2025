{
  "retriever": "dense",
  "query": "In the Linux kernel, the following vulnerability has been resolved net_sched ets Fix double list add in class with netem as child qdisc As described in Gerrards report [1], there are use cases where a netem child qdisc will make the parent qdiscs enqueue callback reentrant. In the case of ets, there wont be a UAF, but the code will add the same classifier to the list twice, which will cause memory corruption. In addition to checking for qlen being zero, this patch checks whether the class was already added to the active_list (cl_is_active) before doing the addition to cater for the reentrant case. [1] https//lore.kernel.org/netdev/CAHcdcOm+03OD2j6R0=YHKqmy=VgJ8xEOKuP6c7mSgnp-TEJJbw@mail.gmail.com/",
  "keyphrases": {
    "weakness": [
      "memory corruption"
    ]
  },
  "timestamp": "2025-07-14 21:52:00",
  "cve_id": "CVE-2025-37914",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "401",
      "name": "Missing Release of Memory after Effective Lifetime",
      "type": "Variant",
      "score": 0.5001770618847668
    },
    {
      "cwe_id": "606",
      "name": "Unchecked Input for Loop Condition",
      "type": "Base",
      "score": 0.4987378858491238
    },
    {
      "cwe_id": "909",
      "name": "Missing Initialization of Resource",
      "type": "Class",
      "score": 0.49144450341015256
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 0.485043916611799
    },
    {
      "cwe_id": "1261",
      "name": "Improper Handling of Single Event Upsets",
      "type": "Base",
      "score": 0.4835346653441048
    },
    {
      "cwe_id": "911",
      "name": "Improper Update of Reference Count",
      "type": "Base",
      "score": 0.4802360588605913
    },
    {
      "cwe_id": "696",
      "name": "Incorrect Behavior Order",
      "type": "Class",
      "score": 0.47686987192757674
    },
    {
      "cwe_id": "364",
      "name": "Signal Handler Race Condition",
      "type": "Base",
      "score": 0.47354710499973685
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "type": "Class",
      "score": 0.4733418341789455
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 0.4706959076609716
    },
    {
      "cwe_id": "835",
      "name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
      "type": "Base",
      "score": 0.4504965492137678
    },
    {
      "cwe_id": "366",
      "name": "Race Condition within a Thread",
      "type": "Base",
      "score": 0.45042372045804596
    },
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "type": "Base",
      "score": 0.4475203131458073
    },
    {
      "cwe_id": "413",
      "name": "Improper Resource Locking",
      "type": "Base",
      "score": 0.44703129795645635
    },
    {
      "cwe_id": "131",
      "name": "Incorrect Calculation of Buffer Size",
      "type": "Base",
      "score": 0.4465487135625682
    },
    {
      "cwe_id": "617",
      "name": "Reachable Assertion",
      "type": "Base",
      "score": 0.4426462477966161
    },
    {
      "cwe_id": "1260",
      "name": "Improper Handling of Overlap Between Protected Memory Ranges",
      "type": "Base",
      "score": 0.44255692644864597
    },
    {
      "cwe_id": "226",
      "name": "Sensitive Information in Resource Not Removed Before Reuse",
      "type": "Base",
      "score": 0.44199980741899253
    },
    {
      "cwe_id": "191",
      "name": "Integer Underflow (Wrap or Wraparound)",
      "type": "Base",
      "score": 0.4394055948777693
    },
    {
      "cwe_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "type": "Base",
      "score": 0.43790240283777726
    }
  ]
}