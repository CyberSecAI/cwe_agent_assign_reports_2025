## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved PCI pciehp Avoid unnecessary device replacement check Hot-removal of nested PCI hotplug ports suffers from a long-standing **race condition** which can lead to a deadlock A parent hotplug port acquires pci_lock_rescan_remove(), then waits for pciehp to unbind from a child hotplug port. Meanwhile that child hotplug port tries to acquire pci_lock_rescan_remove() as well in order to remove its own children. The deadlock only occurs if the parent acquires pci_lock_rescan_remove() first, not if the child happens to acquire it first. Several workarounds to avoid the issue have been proposed and discarded over the years, e.g. https//lore.kernel.org/r/4c882e25194ba8282b78fe963fec8faae7cf23eb.1529173804.git.lukas@wunner.de/ A proper fix is being worked on, but needs more time as it is nontrivial and necessarily intrusive. Recent commit 9d573d19547b (PCI pciehp Detect device replacement during system sleep) provokes more frequent occurrence of the deadlock when removing more than one Thunderbolt device during system sleep. The commit sought to detect device replacement, but also triggered on device removal. Differentiating reliably between replacement and removal is impossible because pci_get_dsn() returns 0 both if the device was removed, as well as if it was replaced with one lacking a Device Serial Number. Avoid the more frequent occurrence of the deadlock by checking whether the hotplug port itself was hot-removed. If so, theres no sense in checking whether its child device was replaced. This works because the ->resume_noirq() callback is invoked in top-down order for the entire hierarchy A parent hotplug port detecting device replacement (or removal) marks all children as removed using pci_dev_set_disconnected() and a child hotplug port can then reliably detect being removed.

### Vulnerability Description Key Phrases
- **rootcause:** **race condition**
- **impact:** deadlock
- **product:** Linux kernel
- **component:** PCI pciehp

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | alternate_terms | 1.000 |
| 2 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 1.185 |
| 3 | 833 | Deadlock | Base | Allowed | sparse | 1.123 |
| 4 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 1.120 |
| 5 | 212 | Improper Removal of Sensitive Information Before Storage or Transfer | Base | Allowed | sparse | 1.114 |
| 6 | 863 | Incorrect Authorization | Class | Allowed-with-Review | sparse | 1.093 |
| 7 | 226 | Sensitive Information in Resource Not Removed Before Reuse | Base | Allowed | sparse | 1.063 |
| 8 | 59 | Improper Link Resolution Before File Access ('Link Following') | Base | Allowed | sparse | 1.056 |
| 9 | 1256 | Improper Restriction of Software Interfaces to Hardware Features | Base | Allowed | dense | 0.503 |
| 10 | 609 | Double-Checked Locking | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-667: Improper Locking

CWE-833: Deadlock

CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition

CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer

CWE-863: Incorrect Authorization

CWE-226: Sensitive Information in Resource Not Removed Before Reuse

CWE-59: Improper Link Resolution Before File Access ('Link Following')

CWE-1256: Improper Restriction of Software Interfaces to Hardware Features

CWE-609: Double-Checked Locking