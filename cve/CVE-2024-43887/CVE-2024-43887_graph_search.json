{
  "retriever": "graph",
  "query": "In the Linux kernel, the following vulnerability has been resolved net/tcp Disable TCP-AO static key after RCU grace period The lifetime of TCP-AO static_key is the same as the last tcp_ao_info. On the socket destruction tcp_ao_info ceases to be with RCU grace period, while tcp-ao static branch is currently deferred destructed. The static key definition is DEFINE_STATIC_KEY_DEFERRED_FALSE(tcp_ao_needed, HZ) which means that if RCU grace period is delayed by more than a second and tcp_ao_needed is in the process of disablement, other CPUs may yet see tcp_ao_info which atent dead, but soon-to-be. And that breaks the assumption of static_key_fast_inc_not_disabled(). See the comment near the definition > * The caller must make sure that the static key cant get disabled while > * in this function. It doesnt patch jump labels, only adds a user to > * an already enabled static key. Originally it was introduced in commit eb8c507296f6 (jump_label Prevent key->enabled int overflow), which is needed for the atomic contexts, one of which would be the creation of a full socket from a request socket. In that atomic context, its known by the presence of the key (md5/ao) that the static branch is already enabled. So, the ref counter for that static branch is just incremented instead of holding the proper mutex. static_key_fast_inc_not_disabled() is just a helper for such usage case. But it must not be used if the static branch could get disabled in parallel as its not prote Consider specifically these CWEs: CWE-321 CWE-911 CWE-327 CWE-775 CWE-639 CWE-1231 CWE-1204 CWE-1391 CWE-606 CWE-1233",
  "keyphrases": {
    "original_query": "In the Linux kernel, the following vulnerability has been resolved net/tcp Disable TCP-AO static key after RCU grace period The lifetime of TCP-AO static_key is the same as the last tcp_ao_info. On the socket destruction tcp_ao_info ceases to be with RCU grace period, while tcp-ao static branch is currently deferred destructed. The static key definition is DEFINE_STATIC_KEY_DEFERRED_FALSE(tcp_ao_needed, HZ) which means that if RCU grace period is delayed by more than a second and tcp_ao_needed is in the process of disablement, other CPUs may yet see tcp_ao_info which atent dead, but soon-to-be. And that breaks the assumption of static_key_fast_inc_not_disabled(). See the comment near the definition > * The caller must make sure that the static key cant get disabled while > * in this function. It doesnt patch jump labels, only adds a user to > * an already enabled static key. Originally it was introduced in commit eb8c507296f6 (jump_label Prevent key->enabled int overflow), which is needed for the atomic contexts, one of which would be the creation of a full socket from a request socket. In that atomic context, its known by the presence of the key (md5/ao) that the static branch is already enabled. So, the ref counter for that static branch is just incremented instead of holding the proper mutex. static_key_fast_inc_not_disabled() is just a helper for such usage case. But it must not be used if the static branch could get disabled in parallel as its not prote",
    "enhanced_query": "In the Linux kernel, the following vulnerability has been resolved net/tcp Disable TCP-AO static key after RCU grace period The lifetime of TCP-AO static_key is the same as the last tcp_ao_info. On the socket destruction tcp_ao_info ceases to be with RCU grace period, while tcp-ao static branch is currently deferred destructed. The static key definition is DEFINE_STATIC_KEY_DEFERRED_FALSE(tcp_ao_needed, HZ) which means that if RCU grace period is delayed by more than a second and tcp_ao_needed is in the process of disablement, other CPUs may yet see tcp_ao_info which atent dead, but soon-to-be. And that breaks the assumption of static_key_fast_inc_not_disabled(). See the comment near the definition > * The caller must make sure that the static key cant get disabled while > * in this function. It doesnt patch jump labels, only adds a user to > * an already enabled static key. Originally it was introduced in commit eb8c507296f6 (jump_label Prevent key->enabled int overflow), which is needed for the atomic contexts, one of which would be the creation of a full socket from a request socket. In that atomic context, its known by the presence of the key (md5/ao) that the static branch is already enabled. So, the ref counter for that static branch is just incremented instead of holding the proper mutex. static_key_fast_inc_not_disabled() is just a helper for such usage case. But it must not be used if the static branch could get disabled in parallel as its not prote Consider specifically these CWEs: CWE-321 CWE-911 CWE-327 CWE-775 CWE-639 CWE-1231 CWE-1204 CWE-1391 CWE-606 CWE-1233",
    "cwe_mentions": [
      "CWE-321",
      "CWE-911",
      "CWE-327",
      "CWE-775",
      "CWE-639",
      "CWE-1231",
      "CWE-1204",
      "CWE-1391",
      "CWE-606",
      "CWE-1233"
    ],
    "search_time": 2.6337883472442627
  },
  "timestamp": "2025-07-13 15:19:24",
  "cve_id": "CVE-2024-43887",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "259",
      "name": "Use of Hard-coded Password",
      "type": "variant",
      "score": 2.68272,
      "relationship_count": 0
    },
    {
      "cwe_id": "208",
      "name": "Observable Timing Discrepancy",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "639",
      "name": "Authorization Bypass Through User-Controlled Key",
      "type": "base",
      "score": 2.1189999999999998,
      "relationship_count": 0
    },
    {
      "cwe_id": "472",
      "name": "External Control of Assumed-Immutable Web Parameter",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "385",
      "name": "Covert Timing Channel",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "826",
      "name": "Premature Release of Resource During Expected Lifetime",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "562",
      "name": "Return of Stack Variable Address",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "1341",
      "name": "Multiple Releases of Same Resource or Handle",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "1339",
      "name": "Insufficient Precision or Accuracy of a Real Number",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "1233",
      "name": "Security-Sensitive Hardware Controls with Missing Lock Bit Protection",
      "type": "Base",
      "score": 1.6247359152958791,
      "relationship_count": 0
    },
    {
      "cwe_id": "1231",
      "name": "Improper Prevention of Lock Bit Modification",
      "type": "Base",
      "score": 1.619505070748026,
      "relationship_count": 0
    },
    {
      "cwe_id": "1204",
      "name": "Generation of Weak Initialization Vector (IV)",
      "type": "Base",
      "score": 1.5748251230353136,
      "relationship_count": 0
    },
    {
      "cwe_id": "1291",
      "name": "Public Key Re-Use for Signing both Debug and Production Code",
      "type": "base",
      "score": 1.521,
      "relationship_count": 0
    },
    {
      "cwe_id": "301",
      "name": "Reflection Attack in an Authentication Protocol",
      "type": "base",
      "score": 1.521,
      "relationship_count": 0
    },
    {
      "cwe_id": "772",
      "name": "Missing Release of Resource after Effective Lifetime",
      "type": "Base",
      "score": 1.4965264369849591,
      "relationship_count": 0
    },
    {
      "cwe_id": "911",
      "name": "Improper Update of Reference Count",
      "type": "Base",
      "score": 1.4628136653312331,
      "relationship_count": 0
    },
    {
      "cwe_id": "606",
      "name": "Unchecked Input for Loop Condition",
      "type": "Base",
      "score": 1.4583067612570235,
      "relationship_count": 0
    },
    {
      "cwe_id": "1391",
      "name": "Use of Weak Credentials",
      "type": "class",
      "score": 1.3648,
      "relationship_count": 0
    },
    {
      "cwe_id": "656",
      "name": "Reliance on Security Through Obscurity",
      "type": "class",
      "score": 1.3600000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "672",
      "name": "Operation on a Resource after Expiration or Release",
      "type": "class",
      "score": 1.3600000000000003,
      "relationship_count": 0
    }
  ]
}