## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved net/tcp Disable TCP-AO static key after RCU grace period The lifetime of TCP-AO static_key is the same as the last tcp_ao_info. On the socket destruction tcp_ao_info ceases to be with RCU grace period, while tcp-ao static branch is currently deferred destructed. The static key definition is DEFINE_STATIC_KEY_DEFERRED_FALSE(tcp_ao_needed, HZ) which means that if RCU grace period is delayed by more than a second and tcp_ao_needed is in the process of disablement, other CPUs may yet see tcp_ao_info which atent dead, but soon-to-be. And that breaks the assumption of static_key_fast_inc_not_disabled(). See the comment near the definition > * The caller must make sure that the static key cant get disabled while > * in this function. It doesnt patch jump labels, only adds a user to > * an already enabled static key. Originally it was introduced in commit eb8c507296f6 (jump_label Prevent key->enabled int **overflow**), which is needed for the atomic contexts, one of which would be the creation of a full socket from a request socket. In that atomic context, its known by the presence of the key (md5/ao) that the static branch is already enabled. So, the ref counter for that static branch is just incremented instead of holding the proper mutex. static_key_fast_inc_not_disabled() is just a helper for such usage case. But it must not be used if the static branch could get disabled in parallel as its not prote

### Vulnerability Description Key Phrases
- **rootcause:** **improper use of static key**
- **weakness:** **overflow**
- **impact:** use-after-free
- **product:** Linux kernel
- **component:** net/tcp

## CVE Reference Links Content Summary
The provided content describes a fix for a race condition in the Linux kernel's TCP-AO (TCP Authentication Option) implementation. The vulnerability occurs due to incorrect handling of a static key used to track whether TCP-AO is needed.

**Root Cause:**

The root cause lies in the deferred destruction of the TCP-AO static key (`tcp_ao_needed`) combined with the usage of `static_key_fast_inc_not_disabled()`. The static key's lifetime is tied to the last `tcp_ao_info` structure. When a socket is destroyed, `tcp_ao_info` is freed after an RCU grace period, but the static key was being deferred destructed which could lead to a race. If the RCU grace period is delayed and the static key is being disabled, other CPUs might still see a soon-to-be-dead `tcp_ao_info`. This breaks the assumption of `static_key_fast_inc_not_disabled()`, which expects the key to not be disabled while it is in use.

**Weaknesses/Vulnerabilities:**

- **Race Condition:** A race condition exists between the disabling of the static key and its use in `static_key_fast_inc_not_disabled()`.
- **Incorrect Usage of `static_key_fast_inc_not_disabled()`:** This function was used in a context where the static branch could be disabled concurrently, violating its intended use.
- **Lack of Protection:** The static branch increment in `static_key_fast_inc_not_disabled()` was not protected by `jump_label_mutex`, leading to races with `jump_label_update()`.

**Impact of Exploitation:**

- **Kernel Panic/Bug:** The race condition can lead to a kernel panic due to an invalid opcode, as seen in the provided logs.
- **System Instability:** The system can become unstable due to the kernel bug and may require a reboot.

**Attack Vectors:**

- The vulnerability is triggered during socket destruction when TCP-AO is enabled.
- The specific trigger is related to timing in the RCU grace period when the static key is being disabled.
- The vulnerability was triggered in a netdev test-bot environment.

**Required Attacker Capabilities/Position:**

- The attacker would need to have the ability to establish a TCP connection with TCP-AO enabled.
- Triggering the vulnerability involves manipulating the timing of socket creation and destruction, along with the RCU grace period, which is more likely to occur under heavy load and specific timing conditions.

**Fix:**

The fix involves moving the static branch decrement inside the RCU callback after the `tcp_ao_info` is freed and also adding a call to a function to handle the freeing of socket memory associated with TCP-AO.

**Additional Details:**

- The original commit that introduced the problematic code is `67fa83f7c86a ("net/tcp: Add static_key for TCP-AO")`.
- The fix is also intended for stable kernel branches.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 190 | Integer Overflow or Wraparound | Base | Allowed | alternate_terms | 1.000 |
| 2 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | alternate_terms | 0.700 |
| 3 | 120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | Base | Allowed-with-Review | alternate_terms | 0.700 |
| 4 | 321 | Use of Hard-coded Cryptographic Key | Variant | Allowed | sparse | 1.180 |
| 5 | 1204 | Generation of Weak Initialization Vector (IV) | Base | Allowed | sparse | 1.176 |
| 6 | 1391 | Use of Weak Credentials | Class | Allowed-with-Review | sparse | 1.168 |
| 7 | 639 | Authorization Bypass Through User-Controlled Key | Base | Allowed | sparse | 1.150 |
| 8 | 327 | Use of a Broken or Risky Cryptographic Algorithm | Class | Allowed-with-Review | sparse | 1.141 |
| 9 | 911 | Improper Update of Reference Count | Base | Allowed | dense | 0.436 |
| 10 | 259 | Use of Hard-coded Password | Variant | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-190: Integer Overflow or Wraparound

CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer

CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')

CWE-321: Use of Hard-coded Cryptographic Key

CWE-1204: Generation of Weak Initialization Vector (IV)

CWE-1391: Use of Weak Credentials

CWE-639: Authorization Bypass Through User-Controlled Key

CWE-327: Use of a Broken or Risky Cryptographic Algorithm

CWE-911: Improper Update of Reference Count

CWE-259: Use of Hard-coded Password