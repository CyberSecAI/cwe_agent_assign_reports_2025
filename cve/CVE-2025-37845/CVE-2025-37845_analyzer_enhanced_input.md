## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved tracing fprobe events Fix possible **UAF** on modules Commit ac91052f0ae5 (tracing tprobe-events Fix leakage of module refcount) moved try_module_get() from __find_tracepoint_module_cb() to find_tracepoint() caller, but that introduced a possible **UAF** because the module can be unloaded before try_module_get(). In this case, the module object should be freed too. Thus, try_module_get() does not only fail but may access to the freed object. To avoid that, try_module_get() in __find_tracepoint_module_cb() again.

### Vulnerability Description Key Phrases
- **weakness:** **UAF**
- **product:** Linux kernel
- **component:** tracing fprobe events

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 416 | Use After Free | Variant | Allowed | alternate_terms | 1.000 |
| 2 | 415 | Double Free | Variant | Allowed | sparse | 0.373 |
| 3 | 1265 | Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls | Base | Allowed | sparse | 0.358 |
| 4 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.356 |
| 5 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.339 |
| 6 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.334 |
| 7 | 639 | Authorization Bypass Through User-Controlled Key | Base | Allowed | sparse | 0.327 |
| 8 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.321 |
| 9 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | dense | 0.491 |
| 10 | 123 | Write-what-where Condition | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-416: Use After Free

CWE-415: Double Free

CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-401: Missing Release of Memory after Effective Lifetime

CWE-770: Allocation of Resources Without Limits or Throttling

CWE-639: Authorization Bypass Through User-Controlled Key

CWE-667: Improper Locking

CWE-909: Missing Initialization of Resource

CWE-123: Write-what-where Condition