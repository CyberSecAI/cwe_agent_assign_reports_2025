# Vulnerability Information: CVE-2024-53053

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved scsi ufs core Fix another **deadlock** during RTC update If ufshcd_rtc_work calls ufshcd_rpm_put_sync() and the pms usage_count is 0, we will enter the runtime suspend callback. However, the runtime suspend callback will wait to flush ufshcd_rtc_work, causing a **deadlock**. Replace ufshcd_rpm_put_sync() with ufshcd_rpm_put() to avoid the **deadlock**.

### Vulnerability Description Key Phrases
- **weakness:** **deadlock**
- **impact:** runtime suspend callback
- **vector:** ufshcd_rtc_work calls ufshcd_rpm_put_sync() when the pms usage_count is 0
- **product:** Linux kernel
- **component:** scsi ufs core

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of the vulnerability:

**Root Cause:**
- A deadlock occurs in the UFS (Universal Flash Storage) subsystem when updating the Real-Time Clock (RTC).

**Vulnerabilities:**
- The function `ufshcd_update_rtc` calls `ufshcd_rpm_put_sync()`.
- If the power management (PM) usage count is 0, `ufshcd_rpm_put_sync()` will trigger the runtime suspend callback.
- The runtime suspend callback waits for `ufshcd_rtc_work` to complete (flush), but `ufshcd_rtc_work` itself is blocked on `ufshcd_rpm_put_sync()`, creating a deadlock condition.

**Impact of Exploitation:**
- The system will become unresponsive due to the deadlock.
- The UFS storage operations will be stalled.

**Attack Vectors:**
- The vulnerability is triggered by the normal operation of the UFS driver, specifically during the RTC update process. No specific attacker action is needed to trigger the bug.

**Required Attacker Capabilities/Position:**
- No specific attacker capabilities or position is required. The vulnerability can be triggered by the system itself.

**Technical Details:**
- The fix replaces `ufshcd_rpm_put_sync()` with `ufshcd_rpm_put()`. The `ufshcd_rpm_put` function does not wait for the power management operation to complete synchronously, avoiding the deadlock.

**Additional Notes:**
- The fix was backported to stable kernel versions, including 6.11.x.
- The issue was introduced by commit `6bf999e0eb41 ("scsi: ufs: core: Add UFS RTC support")`.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.324 |
| 2 | 833 | Deadlock | Base | Allowed | sparse | 0.297 |
| 3 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | Allowed | sparse | 0.236 |
| 4 | 663 | Use of a Non-reentrant Function in a Concurrent Context | Base | Allowed | sparse | 0.234 |
| 5 | 61 | UNIX Symbolic Link (Symlink) Following | Compound | Allowed | sparse | 0.229 |
| 6 | 1281 | Sequence of Processor Instructions Leads to Unexpected Behavior | Base | Allowed | sparse | 0.219 |
| 7 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.214 |
| 8 | 415 | Double Free | Variant | Allowed | sparse | 0.214 |
| 9 | 413 | Improper Resource Locking | Base | Allowed | dense | 0.488 |
| 10 | 772 | Missing Release of Resource after Effective Lifetime | Base | Allowed | graph | 0.002 |

