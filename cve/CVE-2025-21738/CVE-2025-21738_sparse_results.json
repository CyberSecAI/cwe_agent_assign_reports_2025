{
  "query": "In the Linux kernel, the following vulnerability has been resolved ata libata-sff Ensure that we cannot write outside the allocated buffer reveliofuzzing reported that a SCSI_IOCTL_SEND_COMMAND ioctl with out_len set to 0xd42, SCSI command set to ATA_16 PASS-THROUGH, ATA command set to ATA_NOP, and protocol set to ATA_PROT_PIO, can cause ata_pio_sector() to write outside the allocated buffer, overwriting random memory. While a ATA device is supposed to abort a ATA_NOP command, there does seem to be a bug either in libata-sff or QEMU, where either this status is not set, or the status is cleared before read by ata_sff_hsm_move(). Anyway, that is most likely a separate bug. Looking at __atapi_pio_bytes(), it already has a safety check to ensure that __atapi_pio_bytes() cannot write outside the allocated buffer. Add a similar check to ata_pio_sector(), such that also ata_pio_sector() cannot write outside the allocated buffer.",
  "count": 10,
  "results": [
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "abstraction": "Base",
      "score": 778.2868339671545,
      "original_score": 778.2868339671545,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "787",
      "name": "Out-of-bounds Write",
      "abstraction": "Base",
      "score": 708.651722702172,
      "original_score": 708.651722702172,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "190",
      "name": "Integer Overflow or Wraparound",
      "abstraction": "Base",
      "score": 706.6116478782621,
      "original_score": 706.6116478782621,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "125",
      "name": "Out-of-bounds Read",
      "abstraction": "Base",
      "score": 703.8039025124397,
      "original_score": 703.8039025124397,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "131",
      "name": "Incorrect Calculation of Buffer Size",
      "abstraction": "Base",
      "score": 682.7503129814586,
      "original_score": 682.7503129814586,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "122",
      "name": "Heap-based Buffer Overflow",
      "abstraction": "Variant",
      "score": 673.6094681839819,
      "original_score": 673.6094681839819,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "119",
      "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
      "abstraction": "Class",
      "score": 666.3422941809148,
      "original_score": 666.3422941809148,
      "mapping_usage": "Discouraged"
    },
    {
      "cwe_id": "22",
      "name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
      "abstraction": "Base",
      "score": 663.4476504265419,
      "original_score": 663.4476504265419,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "abstraction": "Class",
      "score": 662.0942971363146,
      "original_score": 662.0942971363146,
      "mapping_usage": "Allowed-with-Review"
    },
    {
      "cwe_id": "367",
      "name": "Time-of-check Time-of-use (TOCTOU) Race Condition",
      "abstraction": "Base",
      "score": 661.5983951716418,
      "original_score": 661.5983951716418,
      "mapping_usage": "Allowed"
    }
  ],
  "statistics": {
    "min": 661.5983951716418,
    "max": 778.2868339671545,
    "mean": 690.7196525140882,
    "median": 678.1798905827202,
    "count": 10
  }
}