{
  "retriever": "dense",
  "query": "In the Linux kernel, the following vulnerability has been resolved net phy leds fix memory leak A network restart test on a router led to an out-of-memory condition, which was traced to a memory leak in the PHY LED trigger code. The root cause is misuse of the devm API. The registration function (phy_led_triggers_register) is called from phy_attach_direct, not phy_probe, and the unregister function (phy_led_triggers_unregister) is called from phy_detach, not phy_remove. This means the register and unregister functions can be called multiple times for the same PHY device, but devm-allocated memory is not freed until the driver is unbound. This also prevents kmemleak from detecting the leak, as the devm API internally stores the allocated pointer. Fix this by replacing devm_kzalloc/devm_kcalloc with standard kzalloc/kcalloc, and add the corresponding kfree calls in the unregister path.",
  "keyphrases": {
    "rootcause": [
      "misuse of the devm API"
    ],
    "weakness": [
      "memory leak"
    ]
  },
  "timestamp": "2025-07-14 22:06:41",
  "cve_id": "CVE-2025-37989",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "401",
      "name": "Missing Release of Memory after Effective Lifetime",
      "type": "Variant",
      "score": 0.5447726130750086
    },
    {
      "cwe_id": "909",
      "name": "Missing Initialization of Resource",
      "type": "Class",
      "score": 0.5339123127934455
    },
    {
      "cwe_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "type": "Base",
      "score": 0.4779422432147433
    },
    {
      "cwe_id": "911",
      "name": "Improper Update of Reference Count",
      "type": "Base",
      "score": 0.47474801401083394
    },
    {
      "cwe_id": "1256",
      "name": "Improper Restriction of Software Interfaces to Hardware Features",
      "type": "Base",
      "score": 0.4693681252848676
    },
    {
      "cwe_id": "908",
      "name": "Use of Uninitialized Resource",
      "type": "Base",
      "score": 0.46739178988384444
    },
    {
      "cwe_id": "126",
      "name": "Buffer Over-read",
      "type": "Variant",
      "score": 0.46489129797081874
    },
    {
      "cwe_id": "226",
      "name": "Sensitive Information in Resource Not Removed Before Reuse",
      "type": "Base",
      "score": 0.463816019737348
    },
    {
      "cwe_id": "763",
      "name": "Release of Invalid Pointer or Reference",
      "type": "Base",
      "score": 0.45989841460993697
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "type": "Variant",
      "score": 0.45962818373472314
    },
    {
      "cwe_id": "1262",
      "name": "Improper Access Control for Register Interface",
      "type": "Base",
      "score": 0.4584417248074283
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "type": "Class",
      "score": 0.45328022111055083
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 0.4508225278100972
    },
    {
      "cwe_id": "119",
      "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
      "type": "Class",
      "score": 0.45032879512104446
    },
    {
      "cwe_id": "789",
      "name": "Memory Allocation with Excessive Size Value",
      "type": "Variant",
      "score": 0.447073850565074
    },
    {
      "cwe_id": "822",
      "name": "Untrusted Pointer Dereference",
      "type": "Base",
      "score": 0.4468258890511183
    },
    {
      "cwe_id": "665",
      "name": "Improper Initialization",
      "type": "Class",
      "score": 0.44429564150271994
    },
    {
      "cwe_id": "415",
      "name": "Double Free",
      "type": "Variant",
      "score": 0.4428170066954129
    },
    {
      "cwe_id": "121",
      "name": "Stack-based Buffer Overflow",
      "type": "Variant",
      "score": 0.4425978079683468
    },
    {
      "cwe_id": "1260",
      "name": "Improper Handling of Overlap Between Protected Memory Ranges",
      "type": "Base",
      "score": 0.4408740748575955
    }
  ]
}