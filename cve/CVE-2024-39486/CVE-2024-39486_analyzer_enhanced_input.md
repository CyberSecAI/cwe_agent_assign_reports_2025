## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved drm/drm_file Fix pid refcounting race , Maxime Ripard , Thomas Zimmermann filp->pid is supposed to be a refcounted pointer however, before this patch, drm_file_update_pid() only increments the refcount of a struct pid after storing a pointer to it in filp->pid and dropping the dev->filelist_mutex, making the following race possible process A process B ========= ========= begin drm_file_update_pid mutex_lock(&dev->filelist_mutex) rcu_replace_pointer(filp->pid, , 1) mutex_unlock(&dev->filelist_mutex) begin drm_file_update_pid mutex_lock(&dev->filelist_mutex) rcu_replace_pointer(filp->pid, , 1) mutex_unlock(&dev->filelist_mutex) get_pid() synchronize_rcu() put_pid() *** pid B reaches refcount 0 and is freed here *** get_pid() *** UAF *** synchronize_rcu() put_pid() As far as I know, this race can only occur with CONFIG_PREEMPT_RCU=y because it requires RCU to detect a quiescent state in code that is not explicitly calling into the scheduler. This race leads to use-after-free of a struct pid. It is probably somewhat hard to hit because process A has to pass through a synchronize_rcu() oper

### Vulnerability Description Key Phrases
- **rootcause:** **race condition in drm_file_update_pid()**
- **impact:** use-after-free of a struct pid
- **product:** Linux kernel
- **component:** drm/drm_file

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of the vulnerability:

**Root Cause:**
The vulnerability stems from a race condition in the `drm_file_update_pid` function within the Direct Rendering Manager (DRM) subsystem of the Linux kernel. This function is responsible for updating the process ID (PID) associated with a DRM file structure (`filp->pid`).

**Vulnerabilities/Weaknesses:**
- **Race Condition:** The primary issue is that the refcount of the `struct pid` was incremented *after* the pointer was stored in `filp->pid` and after the `dev->filelist_mutex` was dropped, which enables a race condition where another process can modify `filp->pid` to point to its pid, which may be then freed causing a use-after-free.
- **Incorrect Refcounting:** The `filp->pid` is supposed to be a refcounted pointer but was not correctly being handled.
- **Reliance on RCU:** The race is more likely to happen with `CONFIG_PREEMPT_RCU=y` which depends on RCU to detect a quiescent state, making the race more likely.

**Impact of Exploitation:**
- **Use-After-Free (UAF):** The vulnerability leads to a use-after-free condition of a `struct pid`. This can cause the system to crash or allow for arbitrary code execution.

**Attack Vectors:**
- **Concurrent Processes:** The attack requires two processes (A and B) to concurrently interact with the DRM subsystem.
- **Timing:** The attacker must be able to trigger the race by having process A and B call `drm_file_update_pid()` at specific times, particularly when process B is between `mutex_unlock()` and `get_pid()`, while process A needs to be passing through a `synchronize_rcu()` operation

**Required Attacker Capabilities/Position:**
- **Local Access:** The attacker would require the ability to open DRM devices, which is typically a local privilege.
- **Timing Control:** The attacker would need some ability to control the timing of when `drm_file_update_pid()` is called. It does not need precise control, but rather to increase the chance of the race condition.

**Technical Details:**
The code diffs show the fix involves taking an additional reference on the pid *before* storing the pointer to the pid in the `filp->pid`. This ensures that there will be at least one reference count of the pid if a concurrent process also updates `filp->pid`. Also, the `synchronize_rcu()` is moved outside the `if` condition.

**Patch:**
The patch moves `get_pid(pid)` before the `mutex_unlock(&dev->filelist_mutex)` which ensures that there is always an active reference when the pointer to the pid is stored in the `filp->pid`. The conditional call to `synchronize_rcu()` is also removed, simplifying the logic.

The provided content gives more detail than the basic CVE description as it provides the root cause, the race condition details, the impact, the attack vectors, and the fix.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | alternate_terms | 0.800 |
| 2 | 775 | Missing Release of File Descriptor or Handle after Effective Lifetime | Variant | Allowed | sparse | 0.805 |
| 3 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.787 |
| 4 | 911 | Improper Update of Reference Count | Base | Allowed | sparse | 0.717 |
| 5 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.699 |
| 6 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.693 |
| 7 | 364 | Signal Handler Race Condition | Base | Allowed | sparse | 0.690 |
| 8 | 415 | Double Free | Variant | Allowed | sparse | 0.689 |
| 9 | 366 | Race Condition within a Thread | Base | Allowed | dense | 0.523 |
| 10 | 609 | Double-Checked Locking | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-775: Missing Release of File Descriptor or Handle after Effective Lifetime

CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition

CWE-911: Improper Update of Reference Count

CWE-770: Allocation of Resources Without Limits or Throttling

CWE-667: Improper Locking

CWE-364: Signal Handler Race Condition

CWE-415: Double Free

CWE-366: Race Condition within a Thread

CWE-609: Double-Checked Locking