## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved usb xhci Fix isochronous Ring Underrun/Overrun event handling The TRB pointer of these events points at enqueue at the time of error occurrence on xHCI 1.1+ HCs or its NULL on older ones. By the time we are handling the event, a new TD may be queued at this ring position. I can trigger this race by rising interrupt moderation to increase IRQ handling delay. Similar delay may occur naturally due to system load. If this ever happens after a Missed Service Error, missed TDs will be skipped and the new TD processed as if it matched the event. It could be given back prematurely, risking data loss or buffer UAF by the xHC. Dont complete TDs on xrun events and dont warn if queued TDs dont match the events TRB pointer, which can be NULL or a link/no-op TRB. Dont warn if there are no queued TDs at all. Now that its safe, also handle xrun events if the skip flag is clear. This ensures completion of any TD stuck in error mid TD state right before the xrun event, which could happen if a driver submits a finite number of URBs to a buggy HC and then an error occurs on the last TD.

### Vulnerability Description Key Phrases
- **component:** usb xhci
- **rootcause:** **race condition**
- **vector:** IRQ handling delay
- **weakness:** **memory corruption, buffer UAF**
- **product:** Linux kernel
- **impact:** data loss, resource exhaustion

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | alternate_terms | 1.000 |
| 2 | 787 | Out-of-bounds Write | Base | Allowed | alternate_terms | 1.000 |
| 3 | 416 | Use After Free | Variant | Allowed | alternate_terms | 0.800 |
| 4 | 364 | Signal Handler Race Condition | Base | Allowed | sparse | 1.008 |
| 5 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.923 |
| 6 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.919 |
| 7 | 476 | NULL Pointer Dereference | Base | Allowed | sparse | 0.907 |
| 8 | 754 | Improper Check for Unusual or Exceptional Conditions | Class | Allowed-with-Review | sparse | 0.902 |
| 9 | 191 | Integer Underflow (Wrap or Wraparound) | Base | Allowed | dense | 0.509 |
| 10 | 123 | Write-what-where Condition | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-787: Out-of-bounds Write

CWE-416: Use After Free

CWE-364: Signal Handler Race Condition

CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition

CWE-401: Missing Release of Memory after Effective Lifetime

CWE-476: NULL Pointer Dereference

CWE-754: Improper Check for Unusual or Exceptional Conditions

CWE-191: Integer Underflow (Wrap or Wraparound)

CWE-123: Write-what-where Condition