{
  "cve_id": "CVE-2024-38667",
  "description": "In the Linux kernel, the following vulnerability has been resolved riscv prevent pt_regs corruption for secondary idle threads Top of the kernel thread stack should be reserved for pt_regs. However this is not the case for the idle threads of the secondary boot harts. Their stacks overlap with their pt_regs, so both may get corrupted. Similar issue has been fixed for the primary hart, see c7cdd96eca28 (riscv prevent **stack corruption** by reserving task_pt_regs(p) early). However that fix was not propagated to the secondary harts. The problem has been noticed in some CPU hotplug tests with V enabled. The function smp_callin stored several registers on stack, corrupting top of pt_regs structure including status field. As a result, kernel attempted to save or restore inexistent V context.",
  "key_phrases": {
    "rootcause": "stack corruption",
    "weakness": "",
    "impact": "pt_regs corruption",
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": ""
  },
  "reference_content": "Based on the provided content, here's an analysis of the vulnerability:\n\n**Root Cause:**\n\n- The root cause is the incorrect stack pointer initialization for secondary idle threads on RISC-V architecture. Specifically, the stack pointer was being set to the top of the thread's stack page instead of being set to the reserved `pt_regs` area. This caused the stack to overlap with the `pt_regs` structure.\n\n**Weaknesses/Vulnerabilities Present:**\n\n- **Stack Corruption:** The primary vulnerability is stack corruption. Because the stack pointer was not correctly initialized, operations such as `smp_callin` could write directly to the area reserved for `pt_regs`.\n- **`pt_regs` Corruption:**  The `pt_regs` structure, which stores register states for context switching, was being overwritten when the stack pointer was not correctly initialized. This is a critical data structure which when corrupted leads to undefined behavior.\n\n**Impact of Exploitation:**\n\n- **Undefined Behavior:** Corrupting the `pt_regs` structure resulted in the kernel attempting to save or restore the incorrect V (vector) context, leading to undefined behavior and potentially causing crashes.\n- **CPU Hotplug Issues:** The vulnerability was noticed during CPU hotplug tests, particularly when V (vector) extensions were enabled, indicating that this issue has the potential to destabilize the system during dynamic CPU management.\n\n**Attack Vectors:**\n\n- **CPU Hotplug:** The vulnerability was exposed during CPU hotplug operations, where the system attempts to bring additional CPU cores online.\n- **Secondary Hart Initialization:** The issue was specifically related to the initialization of secondary harts (hardware threads), as the primary hart's initialization had already been addressed.\n- **`smp_callin` Function:** The `smp_callin` function, which is invoked during the process of bringing secondary harts online, was identified as one of the functions writing to the stack, causing corruption of the `pt_regs`.\n\n**Required Attacker Capabilities/Position:**\n\n- **System-Level Access:** An attacker would likely require system-level access to trigger CPU hotplug operations, where they might be able to exploit the vulnerability.\n- **Knowledge of RISC-V Architecture:** The attacker would need some understanding of the RISC-V architecture and how the kernel manages threads and context switching.\n- **Ability to Trigger CPU Hotplug:** Specifically, the attacker must be able to initiate CPU hotplug events, which typically are performed by the operating system itself or privileged applications.\n\n**Additional Details:**\n\n- The fix addresses the issue by setting the `stack_ptr` or `__cpu_spinwait_stack_pointer` to `task_pt_regs(tidle)` instead of `task_stack_page(tidle) + THREAD_SIZE`. This ensures that the stack pointer is correctly positioned just before the `pt_regs` area which reserves the top of the thread's stack.\n- The issue was identified during testing of CPU hotplug with vector extensions enabled and was related to `smp_callin` function.\n\nIn summary, the vulnerability lies in the incorrect stack pointer initialization during the bring-up of secondary CPU cores in RISC-V systems. This resulted in stack corruption, overwriting the `pt_regs` structure and leading to undefined behavior. An attacker able to trigger CPU hotplug operations would be able to exploit this issue, potentially destabilizing the system.",
  "similar_info": {
    "cwe_distribution": {},
    "cwe_consensus": "",
    "similarity_stats": {
      "thresholds": [],
      "total_samples_by_threshold": {},
      "top_cwes_by_threshold": {}
    }
  },
  "similarity_summary": {
    "consensus_cwe": "",
    "top_cwes": [],
    "confidence_levels": {},
    "total_samples": 0
  },
  "analysis": "# Summary\n| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |\n|---|---|---|---|---|---|\n| CWE-121 | Stack-based Buffer Overflow | 0.9 | Base | Primary | Allowed |\n| CWE-120 | Buffer Copy without Checking Size | 0.7 | Base | Secondary Candidate | Allowed |\n| CWE-789 | Memory Allocation with Excessive Size Value | 0.6 | Variant | Secondary Candidate | Allowed |\n\n## Evidence and Confidence\n\n*   **Confidence Score:** 0.8\n*   **Evidence Strength:** MEDIUM\n\n## Relationship Analysis\nThe primary CWE is CWE-121 (Stack-based Buffer Overflow), which is a specific type of buffer overflow that occurs on the stack. CWE-121 is a child of CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer), which is a more general class of buffer overflows. CWE-120 (Buffer Copy without Checking Size) can precede CWE-121, as copying data without checking the size can lead to a buffer overflow. CWE-789 (Memory Allocation with Excessive Size Value) can also lead to stack corruption if the allocated memory exceeds the stack's capacity.\n\n```mermaid\ngraph TD\n    cwe121[\"CWE-121: Stack-based Buffer Overflow\"]\n    cwe119[\"CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\"]\n    cwe120[\"CWE-120: Buffer Copy without Checking Size\"]\n    cwe789[\"CWE-789: Memory Allocation with Excessive Size Value\"]\n\n    cwe121 -->|CHILDOF| cwe119\n    cwe120 -->|CANPRECEDE| cwe121\n    cwe789 -->|CANPRECEDE| cwe121\n\n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    classDef tertiary fill:#9e9,stroke:#333\n    class cwe121 primary\n    class cwe119,cwe120,cwe789 secondary\n```\n\n## Vulnerability Chain\nThe vulnerability chain starts with the **incorrect stack pointer initialization**, leading to **stack corruption**. The **stack corruption** overwrites the `pt_regs` structure, leading to undefined behavior. This can be summarized as: Incorrect Stack Initialization -> Stack Corruption (CWE-121) -> `pt_regs` Corruption -> Undefined Behavior.\n\n## Summary of Analysis\nThe initial analysis focused on the **stack corruption** issue described in the vulnerability description. The evidence supports the classification of CWE-121 (Stack-based Buffer Overflow) as the primary CWE, as the vulnerability involves writing beyond the intended boundaries of the stack due to incorrect initialization. The relationship analysis shows that CWE-121 is a specific type of buffer overflow, making it a more appropriate choice than the more general CWE-119. The retriever results and graph relationships further support this decision, with CWE-120 and CWE-789 as potential contributing factors. The selected CWEs are at the optimal level of specificity, providing a clear and accurate representation of the vulnerability.\n\nThe vulnerability description explicitly mentions \"**stack corruption**\" and the \"overlap with their pt_regs, so both may get corrupted\". The CVE Reference Links Content Summary confirms that \"The primary vulnerability is stack corruption. Because the stack pointer was not correctly initialized, operations such as `smp_callin` could write directly to the area reserved for `pt_regs`.\"\n\nRelevant CWE Information:\n\n*   **CWE-121: Stack-based Buffer Overflow:** This CWE is the best fit because the vulnerability involves writing beyond the intended boundaries of the stack due to an incorrect stack pointer initialization. The impact is corruption of the `pt_regs` structure, leading to undefined behavior. This aligns perfectly with the description of a stack-based buffer overflow.\n*   **CWE-120: Buffer Copy without Checking Size:** This could be a contributing factor if the `smp_callin` function copies data onto the stack without proper size checks, exacerbating the stack corruption issue. However, the root cause is the incorrect stack initialization, making CWE-121 the primary issue.\n*   **CWE-789: Memory Allocation with Excessive Size Value:** The stack corruption could be triggered by allocating a large data structure on the stack, exceeding its capacity.\n\nCWEs considered but not used:\n\n*   CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer: While this is a parent of CWE-121, it's less specific and doesn't fully capture the stack-specific nature of the vulnerability.\n*   CWE-125: Out-of-bounds Read: This is not the primary issue, as the vulnerability focuses on writing to an incorrect memory location.\n*   CWE-476: NULL Pointer Dereference: There is no mention of null pointer dereference in the vulnerability description.\n*   CWE-770: Allocation of Resources Without Limits or Throttling: This is not the primary issue, as the vulnerability focuses on incorrect stack pointer initialization.",
  "analysis_with_relationships": "# Summary\n| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |\n|---|---|---|---|---|---|\n| CWE-121 | Stack-based Buffer Overflow | 0.9 | Base | Primary | Allowed |\n| CWE-120 | Buffer Copy without Checking Size | 0.7 | Base | Secondary Candidate | Allowed |\n| CWE-789 | Memory Allocation with Excessive Size Value | 0.6 | Variant | Secondary Candidate | Allowed |\n\n## Evidence and Confidence\n\n*   **Confidence Score:** 0.8\n*   **Evidence Strength:** MEDIUM\n\n## Relationship Analysis\nThe primary CWE is CWE-121 (Stack-based Buffer Overflow), which is a specific type of buffer overflow that occurs on the stack. CWE-121 is a child of CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer), which is a more general class of buffer overflows. CWE-120 (Buffer Copy without Checking Size) can precede CWE-121, as copying data without checking the size can lead to a buffer overflow. CWE-789 (Memory Allocation with Excessive Size Value) can also lead to stack corruption if the allocated memory exceeds the stack's capacity.\n\n```mermaid\ngraph TD\n    cwe121[\"CWE-121: Stack-based Buffer Overflow\"]\n    cwe119[\"CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\"]\n    cwe120[\"CWE-120: Buffer Copy without Checking Size\"]\n    cwe789[\"CWE-789: Memory Allocation with Excessive Size Value\"]\n\n    cwe121 -->|CHILDOF| cwe119\n    cwe120 -->|CANPRECEDE| cwe121\n    cwe789 -->|CANPRECEDE| cwe121\n\n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    classDef tertiary fill:#9e9,stroke:#333\n    class cwe121 primary\n    class cwe119,cwe120,cwe789 secondary\n```\n\n## Vulnerability Chain\nThe vulnerability chain starts with the **incorrect stack pointer initialization**, leading to **stack corruption**. The **stack corruption** overwrites the `pt_regs` structure, leading to undefined behavior. This can be summarized as: Incorrect Stack Initialization -> Stack Corruption (CWE-121) -> `pt_regs` Corruption -> Undefined Behavior.\n\n## Summary of Analysis\nThe initial analysis focused on the **stack corruption** issue described in the vulnerability description. The evidence supports the classification of CWE-121 (Stack-based Buffer Overflow) as the primary CWE, as the vulnerability involves writing beyond the intended boundaries of the stack due to incorrect initialization. The relationship analysis shows that CWE-121 is a specific type of buffer overflow, making it a more appropriate choice than the more general CWE-119. The retriever results and graph relationships further support this decision, with CWE-120 and CWE-789 as potential contributing factors. The selected CWEs are at the optimal level of specificity, providing a clear and accurate representation of the vulnerability.\n\nThe vulnerability description explicitly mentions \"**stack corruption**\" and the \"overlap with their pt_regs, so both may get corrupted\". The CVE Reference Links Content Summary confirms that \"The primary vulnerability is stack corruption. Because the stack pointer was not correctly initialized, operations such as `smp_callin` could write directly to the area reserved for `pt_regs`.\"\n\nRelevant CWE Information:\n\n*   **CWE-121: Stack-based Buffer Overflow:** This CWE is the best fit because the vulnerability involves writing beyond the intended boundaries of the stack due to an incorrect stack pointer initialization. The impact is corruption of the `pt_regs` structure, leading to undefined behavior. This aligns perfectly with the description of a stack-based buffer overflow.\n*   **CWE-120: Buffer Copy without Checking Size:** This could be a contributing factor if the `smp_callin` function copies data onto the stack without proper size checks, exacerbating the stack corruption issue. However, the root cause is the incorrect stack initialization, making CWE-121 the primary issue.\n*   **CWE-789: Memory Allocation with Excessive Size Value:** The stack corruption could be triggered by allocating a large data structure on the stack, exceeding its capacity.\n\nCWEs considered but not used:\n\n*   CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer: While this is a parent of CWE-121, it's less specific and doesn't fully capture the stack-specific nature of the vulnerability.\n*   CWE-125: Out-of-bounds Read: This is not the primary issue, as the vulnerability focuses on writing to an incorrect memory location.\n*   CWE-476: NULL Pointer Dereference: There is no mention of null pointer dereference in the vulnerability description.\n*   CWE-770: Allocation of Resources Without Limits or Throttling: This is not the primary issue, as the vulnerability focuses on incorrect stack pointer initialization.\n\n\n## CWE Relationship Analysis\n\nCurrent CWEs represent these abstraction levels: .\n\n\n### Vulnerability Chain Analysis\n\n**Chain starting from CWE-121:**\n- 121 (Stack-based Buffer Overflow) - ROOT\n\n\n**Chain starting from CWE-476:**\n- 476 (NULL Pointer Dereference) - ROOT\n\n\n\n### CWE Relationship Diagram\n\n```mermaid\ngraph TD\n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    classDef tertiary fill:#9e9,stroke:#333\n```",
  "criticism": "",
  "resolution": "",
  "relevant_cwes": [
    {
      "metadata": {
        "doc_id": "674",
        "name": "Uncontrolled Recursion",
        "source": "sparse"
      },
      "similarity": 585.7850763362671
    },
    {
      "metadata": {
        "doc_id": "667",
        "name": "Improper Locking",
        "source": "sparse"
      },
      "similarity": 581.0939844086067
    },
    {
      "metadata": {
        "doc_id": "362",
        "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
        "source": "sparse"
      },
      "similarity": 556.2317480713239
    },
    {
      "metadata": {
        "doc_id": "1284",
        "name": "Improper Validation of Specified Quantity in Input",
        "source": "sparse"
      },
      "similarity": 552.0668340157998
    },
    {
      "metadata": {
        "doc_id": "457",
        "name": "Use of Uninitialized Variable",
        "source": "sparse"
      },
      "similarity": 548.9743937618517
    },
    {
      "metadata": {
        "doc_id": "125",
        "name": "Out-of-bounds Read",
        "source": "sparse"
      },
      "similarity": 539.8791583052451
    },
    {
      "metadata": {
        "doc_id": "770",
        "name": "Allocation of Resources Without Limits or Throttling",
        "source": "sparse"
      },
      "similarity": 538.2675698461196
    },
    {
      "metadata": {
        "doc_id": "190",
        "name": "Integer Overflow or Wraparound",
        "source": "sparse"
      },
      "similarity": 534.0336674301813
    },
    {
      "metadata": {
        "doc_id": "1342",
        "name": "Information Exposure through Microarchitectural State after Transient Execution",
        "type": "Base",
        "original_content": "The processor does not properly clear microarchitectural state after incorrect microcode assists or speculative execution, resulting in transient execution.",
        "keyphrase_source": "rootcause:stack corruption",
        "source": "dense",
        "mapping_notes": {
          "usage": "Allowed",
          "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
          "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
          "reasons": [
            "Acceptable-Use"
          ]
        },
        "score_info": {
          "retrievers": [
            "dense"
          ],
          "retriever_count": 1,
          "normalized_scores": {
            "dense": 0.5229330237696548
          }
        }
      },
      "similarity": 0.5229330237696548
    },
    {
      "doc_id": "476",
      "text": "CWE-476: NULL Pointer Dereference",
      "score": 2.2100000000000004,
      "metadata": {
        "doc_id": "476",
        "name": "NULL Pointer Dereference",
        "type": "base",
        "original_content": "CWE-476: NULL Pointer Dereference",
        "relationships": [
          {
            "source_id": "476",
            "target_id": "789",
            "label": "CANFOLLOW",
            "properties": {
              "view_id": "1000"
            }
          },
          {
            "source_id": "476",
            "target_id": "362",
            "label": "CANFOLLOW",
            "properties": {
              "view_id": "1000"
            }
          },
          {
            "source_id": "476",
            "target_id": "252",
            "label": "CANFOLLOW",
            "properties": {
              "view_id": "1000"
            }
          },
          {
            "source_id": "476",
            "target_id": "1325",
            "label": "CANFOLLOW",
            "properties": {
              "view_id": "1000"
            }
          },
          {
            "source_id": "476",
            "target_id": "754",
            "label": "CHILDOF",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1003"
            }
          },
          {
            "source_id": "476",
            "target_id": "754",
            "label": "CHILDOF",
            "properties": {
              "view_id": "1000"
            }
          },
          {
            "source_id": "476",
            "target_id": "710",
            "label": "CHILDOF",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          },
          {
            "source_id": "789",
            "target_id": "476",
            "label": "CANPRECEDE",
            "properties": {
              "view_id": "1000"
            }
          },
          {
            "source_id": "754",
            "target_id": "476",
            "label": "PARENTOF",
            "properties": {
              "view_id": "1000"
            }
          },
          {
            "source_id": "710",
            "target_id": "476",
            "label": "PARENTOF",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          },
          {
            "source_id": "362",
            "target_id": "476",
            "label": "CANPRECEDE",
            "properties": {
              "view_id": "1000"
            }
          },
          {
            "source_id": "252",
            "target_id": "476",
            "label": "CANPRECEDE",
            "properties": {
              "view_id": "1000"
            }
          },
          {
            "source_id": "1325",
            "target_id": "476",
            "label": "CANPRECEDE",
            "properties": {
              "view_id": "1000"
            }
          }
        ],
        "score_components": {
          "relationship_chain": 1.0,
          "sequence_path": 1.0
        },
        "abstraction_factor": 1.3,
        "graph_path_info": {
          "path_types": [
            "relationship_chain",
            "vulnerability_sequence_forward"
          ],
          "best_paths": {
            "relationship_chain": {
              "path": [
                [
                  "362",
                  "476",
                  "CANPRECEDE"
                ]
              ],
              "score": 1.0,
              "type": "relationship_chain",
              "source": "362"
            },
            "vulnerability_sequence_forward": {
              "path": [
                [
                  "362",
                  "476",
                  "CANPRECEDE"
                ]
              ],
              "score": 1.0,
              "type": "vulnerability_sequence_forward",
              "source": "362"
            }
          }
        },
        "position": "after",
        "sources": [
          "graph"
        ],
        "source": "graph",
        "mapping_notes": {
          "usage": "Allowed",
          "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
          "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
          "reasons": [
            "Acceptable-Use"
          ]
        },
        "score_info": {
          "retrievers": [
            "sparse",
            "graph"
          ],
          "retriever_count": 2,
          "normalized_scores": {
            "sparse": 172.1045020996663,
            "graph": 2.2100000000000004
          }
        }
      },
      "similarity": 2.2100000000000004
    }
  ],
  "identified_cwes": {
    "analyzer": [
      "CWE-121",
      "CWE-476",
      "CWE-770",
      "CWE-125",
      "CWE-119",
      "CWE-120",
      "CWE-789"
    ],
    "critic_additional": []
  },
  "keyphrase_cwe_mapping": {}
}