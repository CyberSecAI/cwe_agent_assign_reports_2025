{
  "retriever": "graph",
  "query": "In the Linux kernel, the following vulnerability has been resolved nvkm/gsp correctly advance the read pointer of GSP message queue A GSP event message consists three parts message header, RPC header, message body. GSP calculates the number of pages to write from the total size of a GSP message. This behavior can be observed from the movement of the write pointer. However, nvkm takes only the size of RPC header and message body as the message size when advancing the read pointer. When handling a two-page GSP message in the non rollback case, It wrongly takes the message body of the previous message as the message header of the next message. As the message length tends to be zero, in the calculation of size needs to be copied (0 - size of (message header)), the size needs to be copied will be 0xffffffxx. It also triggers a kernel panic due to a NULL pointer error. [ 547.614102] msg 00000f90 ff ff ff ff ff ff ff ff 40 d7 18 fb 8b 00 00 00 ........@....... [ 547.622533] msg 00000fa0 00 00 00 00 ff ff ff ff ff ff ff ff 00 00 00 00 ................ [ 547.630965] msg 00000fb0 ff ff ff ff ff ff ff ff 00 00 00 00 ff ff ff ff ................ [ 547.639397] msg 00000fc0 ff ff ff ff 00 00 00 00 ff ff ff ff ff ff ff ff ................ [ 547.647832] nvkm 0000c100.0 gsp peek msg rpc fn0 len0x0/0xffffffffffffffe0 [ 547.655225] nvkm 0000c100.0 gsp get msg rpc fn0 len0x0/0xffffffffffffffe0 [ 547.662532] Consider specifically these CWEs: CWE-130 CWE-823 CWE-805 CWE-770 CWE-306 CWE-1285 CWE-158 CWE-294 CWE-532 CWE-126",
  "keyphrases": {
    "original_query": "In the Linux kernel, the following vulnerability has been resolved nvkm/gsp correctly advance the read pointer of GSP message queue A GSP event message consists three parts message header, RPC header, message body. GSP calculates the number of pages to write from the total size of a GSP message. This behavior can be observed from the movement of the write pointer. However, nvkm takes only the size of RPC header and message body as the message size when advancing the read pointer. When handling a two-page GSP message in the non rollback case, It wrongly takes the message body of the previous message as the message header of the next message. As the message length tends to be zero, in the calculation of size needs to be copied (0 - size of (message header)), the size needs to be copied will be 0xffffffxx. It also triggers a kernel panic due to a NULL pointer error. [ 547.614102] msg 00000f90 ff ff ff ff ff ff ff ff 40 d7 18 fb 8b 00 00 00 ........@....... [ 547.622533] msg 00000fa0 00 00 00 00 ff ff ff ff ff ff ff ff 00 00 00 00 ................ [ 547.630965] msg 00000fb0 ff ff ff ff ff ff ff ff 00 00 00 00 ff ff ff ff ................ [ 547.639397] msg 00000fc0 ff ff ff ff 00 00 00 00 ff ff ff ff ff ff ff ff ................ [ 547.647832] nvkm 0000c100.0 gsp peek msg rpc fn0 len0x0/0xffffffffffffffe0 [ 547.655225] nvkm 0000c100.0 gsp get msg rpc fn0 len0x0/0xffffffffffffffe0 [ 547.662532]",
    "enhanced_query": "In the Linux kernel, the following vulnerability has been resolved nvkm/gsp correctly advance the read pointer of GSP message queue A GSP event message consists three parts message header, RPC header, message body. GSP calculates the number of pages to write from the total size of a GSP message. This behavior can be observed from the movement of the write pointer. However, nvkm takes only the size of RPC header and message body as the message size when advancing the read pointer. When handling a two-page GSP message in the non rollback case, It wrongly takes the message body of the previous message as the message header of the next message. As the message length tends to be zero, in the calculation of size needs to be copied (0 - size of (message header)), the size needs to be copied will be 0xffffffxx. It also triggers a kernel panic due to a NULL pointer error. [ 547.614102] msg 00000f90 ff ff ff ff ff ff ff ff 40 d7 18 fb 8b 00 00 00 ........@....... [ 547.622533] msg 00000fa0 00 00 00 00 ff ff ff ff ff ff ff ff 00 00 00 00 ................ [ 547.630965] msg 00000fb0 ff ff ff ff ff ff ff ff 00 00 00 00 ff ff ff ff ................ [ 547.639397] msg 00000fc0 ff ff ff ff 00 00 00 00 ff ff ff ff ff ff ff ff ................ [ 547.647832] nvkm 0000c100.0 gsp peek msg rpc fn0 len0x0/0xffffffffffffffe0 [ 547.655225] nvkm 0000c100.0 gsp get msg rpc fn0 len0x0/0xffffffffffffffe0 [ 547.662532] Consider specifically these CWEs: CWE-130 CWE-823 CWE-805 CWE-770 CWE-306 CWE-1285 CWE-158 CWE-294 CWE-532 CWE-126",
    "cwe_mentions": [
      "CWE-130",
      "CWE-823",
      "CWE-805",
      "CWE-770",
      "CWE-306",
      "CWE-1285",
      "CWE-158",
      "CWE-294",
      "CWE-532",
      "CWE-126"
    ],
    "search_time": 3.156161069869995
  },
  "timestamp": "2025-07-14 00:42:56",
  "cve_id": "CVE-2024-58019",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "130",
      "name": "Improper Handling of Length Parameter Inconsistency",
      "type": "Base",
      "score": 2.7997874491209744,
      "relationship_count": 0
    },
    {
      "cwe_id": "805",
      "name": "Buffer Access with Incorrect Length Value",
      "type": "Base",
      "score": 2.7985766110757915,
      "relationship_count": 0
    },
    {
      "cwe_id": "294",
      "name": "Authentication Bypass by Capture-replay",
      "type": "base",
      "score": 2.3998000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "170",
      "name": "Improper Null Termination",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "306",
      "name": "Missing Authentication for Critical Function",
      "type": "base",
      "score": 2.1189999999999998,
      "relationship_count": 0
    },
    {
      "cwe_id": "532",
      "name": "Insertion of Sensitive Information into Log File",
      "type": "base",
      "score": 2.1189999999999998,
      "relationship_count": 0
    },
    {
      "cwe_id": "770",
      "name": "Allocation of Resources Without Limits or Throttling",
      "type": "Base",
      "score": 1.8726715521124284,
      "relationship_count": 0
    },
    {
      "cwe_id": "781",
      "name": "Improper Address Validation in IOCTL with METHOD_NEITHER I/O Control Code",
      "type": "variant",
      "score": 1.83936,
      "relationship_count": 0
    },
    {
      "cwe_id": "129",
      "name": "Improper Validation of Array Index",
      "type": "Variant",
      "score": 1.7890582058559468,
      "relationship_count": 0
    },
    {
      "cwe_id": "120",
      "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "22",
      "name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "41",
      "name": "Improper Resolution of Path Equivalence",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "825",
      "name": "Expired Pointer Dereference",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "20",
      "name": "Improper Input Validation",
      "type": "class",
      "score": 1.6736000000000002,
      "relationship_count": 0
    },
    {
      "cwe_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "type": "Base",
      "score": 1.6430035225232464,
      "relationship_count": 0
    },
    {
      "cwe_id": "823",
      "name": "Use of Out-of-range Pointer Offset",
      "type": "Base",
      "score": 1.6345489010359284,
      "relationship_count": 0
    },
    {
      "cwe_id": "839",
      "name": "Numeric Range Comparison Without Minimum Check",
      "type": "base",
      "score": 1.6016000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "789",
      "name": "Memory Allocation with Excessive Size Value",
      "type": "Variant",
      "score": 1.5531837472730565,
      "relationship_count": 0
    },
    {
      "cwe_id": "1257",
      "name": "Improper Access Control Applied to Mirrored or Aliased Memory Regions",
      "type": "base",
      "score": 1.5350400000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "128",
      "name": "Wrap-around Error",
      "type": "base",
      "score": 1.5350400000000004,
      "relationship_count": 0
    }
  ]
}