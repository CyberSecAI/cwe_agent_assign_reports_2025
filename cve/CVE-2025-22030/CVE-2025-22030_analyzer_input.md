# Vulnerability Information: CVE-2025-22030

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved mm zswap fix crypto_free_acomp() **deadlock** in zswap_cpu_comp_dead() Currently, zswap_cpu_comp_dead() calls crypto_free_acomp() while holding the per-CPU acomp_ctx mutex. crypto_free_acomp() then holds scomp_lock (through crypto_exit_scomp_ops_async()). On the other hand, crypto_alloc_acomp_node() holds the scomp_lock (through crypto_scomp_init_tfm()), and then allocates memory. If the allocation results in reclaim, we may attempt to hold the per-CPU acomp_ctx mutex. The above dependencies can cause an ABBA **deadlock**. For example in the following scenario (1) Task A running on CPU #1 crypto_alloc_acomp_node() Holds scomp_lock Enters reclaim Reads per_cpu_ptr(pool->acomp_ctx, 1) (2) Task A is descheduled (3) CPU #1 goes offline zswap_cpu_comp_dead(CPU #1) Holds per_cpu_ptr(pool->acomp_ctx, 1)) Calls crypto_free_acomp() Waits for scomp_lock (4) Task A running on CPU #2 Waits for per_cpu_ptr(pool->acomp_ctx, 1) // Read on CPU #1 DEADLOCK Since there is no requirement to call crypto_free_acomp() with the per-CPU acomp_ctx mutex held in zswap_cpu_comp_dead(), move it after the mutex is unlocked. Also move the acomp_request_free() and kfree() calls for consistency and to avoid any potential sublte locking dependencies in the future. With this, only setting acomp_ctx fields to NULL occurs with the mutex held. This is similar to how zswap_cpu_comp_prepare() only initializes acomp_ctx fields with the mutex held, after performing all allocations before holding the mutex. Opportunistically, move the NULL check on acomp_ctx so that it takes place before the mutex dereference.

### Vulnerability Description Key Phrases
- **rootcause:** **lock ordering dependency**
- **weakness:** **deadlock**
- **product:** Linux kernel
- **component:** zswap

## CVE Reference Links Content Summary
UNRELATED

The provided content describes a system called Anubis designed to mitigate website scraping by AI companies. It does not relate to any vulnerability described by a CVE ID. It details a Proof-of-Work scheme and challenges related to bot detection, but doesn't present or discuss any security flaws or vulnerabilities.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 1.165 |
| 2 | 833 | Deadlock | Base | Allowed | sparse | 1.039 |
| 3 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.907 |
| 4 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | sparse | 0.894 |
| 5 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | Allowed | sparse | 0.889 |
| 6 | 400 | Uncontrolled Resource Consumption | Class | Discouraged | sparse | 0.880 |
| 7 | 407 | Inefficient Algorithmic Complexity | Class | Allowed-with-Review | sparse | 0.875 |
| 8 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.869 |
| 9 | 1252 | CPU Hardware Not Configured to Support Exclusivity of Write and Execute Operations | Base | Allowed | dense | 0.462 |
| 10 | 120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | Base | Allowed-with-Review | graph | 0.002 |

