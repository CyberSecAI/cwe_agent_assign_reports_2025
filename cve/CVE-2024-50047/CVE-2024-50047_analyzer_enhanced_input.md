## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved smb client fix UAF in async decryption Doing an async decryption (large read) crashes with a slab-use-after-free way down in the crypto API. Reproducer # mount.cifs -o ...,seal,esize=1 //srv/share /mnt # dd if=/mnt/largefile of=/dev/null ... [ 194.196391] ================================================================== [ 194.196844] BUG KASAN slab-use-after-free in gf128mul_4k_lle+0xc1/0x110 [ 194.197269] Read of size 8 at addr ffff888112bd0448 by task kworker/u772/899 [ 194.197707] [ 194.197818] CPU 12 UID 0 PID 899 Comm kworker/u772 Not tainted 6.11.0-lku-00028-gfca3ca14a17a-dirty #43 [ 194.198400] Hardware name QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.2-3-gd478f380-prebuilt.qemu.org 04/01/2014 [ 194.199046] Workqueue smb3decryptd smb2_decrypt_offload [cifs] [ 194.200032] Call Trace [ 194.200191] [ 194.200327] dump_stack_lvl+0x4e/0x70 [ 194.200558] ? gf128mul_4k_lle+0xc1/0x110 [ 194.200809] print_report+0x174/0x505 [ 194.201040] ? __pfx__raw_spin_lock_irqsave+0x10/0x10 [ 194.201352] ? srso_return_thunk+0x5/0x5f [ 194.201604] ? __virt_addr_valid+0xdf/0x1c0 [ 194.201868] ? gf128mul_4k_lle+0xc1/0x110 [ 194.202128] kasan_report+0xc8/0x150 [ 194.202361] ? gf128mul_4k_lle+0xc1/0x110 [ 194.202616] gf128mul_4k_lle+0xc1/0x110 [ 194.202863] ghash_update+0x184/0x210 [ 194.203103] shash_ahash_update+0x184/0x2a0 [ 194.203377] ? __pfx_shash_ahash_update+0x10/0x10 [ 194.203651] ? srso_return_thunk+0x5/0x5f [ 194.203877] ? crypto_gcm_init_common+0x1ba/0x340 [ 194.204142] gcm_hash_assoc_remain_continue+0x10a/0x140 [ 194.204434] crypt_message+0xec1/0x10a0 [cifs] [ 194.206489] ? __pfx_crypt_message+0x10/0x10 [cifs] [ 194.208507] ? srso_return_thunk+0x5/0x5f [ 194.209205] ? srso_return_thunk+0x5/0x5f [ 194.209925] ? srso_return_thunk+0x5/0x5f [ 194.210443] ? srso_return_thunk+0x5/0x5f [ 194.211037] decrypt_raw_data+0x15f/0x250 [cifs] [ 194.212906] ? __pfx_decrypt_raw_data+0x10/0x10 [cifs] [ 194.214670] ? srso_return_thunk+0x5/0x5f [ 194.215193] smb2_decrypt_offload+0x12a/0x6c0 [cifs] This is because TFM is being used in parallel. Fix this by allocating a new AEAD TFM for async decryption, but keep the existing one for synchronous READ cases (similar to what is done in smb3_calc_signature()). Also remove the calls to aead_request_set_callback() and crypto_wait_req() since its always going to be a synchronous operation.

### Vulnerability Description Key Phrases
- **rootcause:** **Use-after-free in async decryption due to shared TFM**
- **weakness:** **The same TFM was being used for both sync and async operations, which caused a race condition and use-after-free when using async decryption**
- **impact:** System crash due to a slab-use-after-free
- **vector:** Mounting a cifs share with encryption and performing a large read
- **attacker:** Local user with the ability to mount a cifs share
- **product:** Linux Kernel
- **version:** 6.11.0-lku-00028-gfca3ca14a17a-dirty
- **component:** SMB client (cifs)

## CVE Reference Links Content Summary
- **Root cause of vulnerability:** A use-after-free (UAF) vulnerability occurs in the Linux kernel's SMB client during asynchronous decryption of SMB messages. This happens because the same crypto transform (TFM) is used concurrently for both synchronous and asynchronous operations.
- **Weaknesses/vulnerabilities present:** The primary weakness is the concurrent use of a single TFM for both synchronous and asynchronous decryption, leading to a race condition.
- **Impact of exploitation:**  Exploitation results in a slab-use-after-free, which crashes the system. The provided kernel log shows a KASAN report indicating a read of size 8 at a freed memory location, which is a strong indication of a UAF.
- **Attack vectors:** The attack vector involves mounting a CIFS share with encryption enabled (seal option) and initiating a large read operation using a command like 'dd'. This triggers the asynchronous decryption code path where the UAF exists.
- **Required attacker capabilities/position:** An attacker needs to be able to mount an SMB share on a vulnerable client, control the server, and perform large read operations triggering the vulnerable code path.

The provided content gives detailed information about the vulnerability including the root cause, the kernel crash details, the attack vector and the fix.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 416 | Use After Free | Variant | Allowed | alternate_terms | 0.800 |
| 2 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | alternate_terms | 0.800 |
| 3 | 194 | Unexpected Sign Extension | Variant | Allowed | sparse | 1.229 |
| 4 | 197 | Numeric Truncation Error | Base | Allowed | sparse | 0.968 |
| 5 | 276 | Incorrect Default Permissions | Base | Allowed | sparse | 0.910 |
| 6 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.778 |
| 7 | 23 | Relative Path Traversal | Base | Allowed | sparse | 0.700 |
| 8 | 190 | Integer Overflow or Wraparound | Base | Allowed | sparse | 0.700 |
| 9 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | dense | 0.579 |
| 10 | 364 | Signal Handler Race Condition | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-416: Use After Free

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-194: Unexpected Sign Extension

CWE-197: Numeric Truncation Error

CWE-276: Incorrect Default Permissions

CWE-125: Out-of-bounds Read

CWE-23: Relative Path Traversal

CWE-190: Integer Overflow or Wraparound

CWE-401: Missing Release of Memory after Effective Lifetime

CWE-364: Signal Handler Race Condition