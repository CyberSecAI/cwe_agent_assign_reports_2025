{
  "retriever": "graph",
  "query": "In the Linux kernel, the following vulnerability has been resolved soc qcom pdr Fix the potential deadlock When some client process A call pdr_add_lookup() to add the look up for the service and does schedule locator work, later a process B got a new server packet indicating locator is up and call pdr_locator_new_server() which eventually sets pdr->locator_init_complete to true which process A sees and takes list lock and queries domain list but it will timeout due to deadlock as the response will queued to the same qmi->wq and it is ordered workqueue and process B is not able to complete new server request work due to deadlock on list lock. Fix it by removing the unnecessary list iteration as the list iteration is already being done inside locator work, so avoid it here and just call schedule_work() here. Process A Process B process_scheduled_works() pdr_add_lookup() qmi_data_ready_work() process_scheduled_works() pdr_locator_new_server() pdr->locator_init_complete=true pdr_locator_work() mutex_lock(&pdr->list_lock) pdr_locate_service() mutex_lock(&pdr->list_lock) pdr_get_domain_list() pr_err(PDR %s get domain list txn wait failed %d\\\\n, req->service_name, ret) Timeout error log due to deadlock PDR tms/servreg get domain list txn wait failed -110 PDR service lookup for msm/adsp/sensor_pdtms/servreg failed -110 Thanks to Bjorn and Johan for letting me know that this commit also fixes an audio regression when using the in-kernel pd-mapper as that makes it easier to hit this race. [1] Consider specifically these CWEs: CWE-863 CWE-667 CWE-833 CWE-401 CWE-201 CWE-1285 CWE-362",
  "keyphrases": {
    "original_query": "In the Linux kernel, the following vulnerability has been resolved soc qcom pdr Fix the potential deadlock When some client process A call pdr_add_lookup() to add the look up for the service and does schedule locator work, later a process B got a new server packet indicating locator is up and call pdr_locator_new_server() which eventually sets pdr->locator_init_complete to true which process A sees and takes list lock and queries domain list but it will timeout due to deadlock as the response will queued to the same qmi->wq and it is ordered workqueue and process B is not able to complete new server request work due to deadlock on list lock. Fix it by removing the unnecessary list iteration as the list iteration is already being done inside locator work, so avoid it here and just call schedule_work() here. Process A Process B process_scheduled_works() pdr_add_lookup() qmi_data_ready_work() process_scheduled_works() pdr_locator_new_server() pdr->locator_init_complete=true pdr_locator_work() mutex_lock(&pdr->list_lock) pdr_locate_service() mutex_lock(&pdr->list_lock) pdr_get_domain_list() pr_err(PDR %s get domain list txn wait failed %d\\\\n, req->service_name, ret) Timeout error log due to deadlock PDR tms/servreg get domain list txn wait failed -110 PDR service lookup for msm/adsp/sensor_pdtms/servreg failed -110 Thanks to Bjorn and Johan for letting me know that this commit also fixes an audio regression when using the in-kernel pd-mapper as that makes it easier to hit this race. [1]",
    "enhanced_query": "In the Linux kernel, the following vulnerability has been resolved soc qcom pdr Fix the potential deadlock When some client process A call pdr_add_lookup() to add the look up for the service and does schedule locator work, later a process B got a new server packet indicating locator is up and call pdr_locator_new_server() which eventually sets pdr->locator_init_complete to true which process A sees and takes list lock and queries domain list but it will timeout due to deadlock as the response will queued to the same qmi->wq and it is ordered workqueue and process B is not able to complete new server request work due to deadlock on list lock. Fix it by removing the unnecessary list iteration as the list iteration is already being done inside locator work, so avoid it here and just call schedule_work() here. Process A Process B process_scheduled_works() pdr_add_lookup() qmi_data_ready_work() process_scheduled_works() pdr_locator_new_server() pdr->locator_init_complete=true pdr_locator_work() mutex_lock(&pdr->list_lock) pdr_locate_service() mutex_lock(&pdr->list_lock) pdr_get_domain_list() pr_err(PDR %s get domain list txn wait failed %d\\\\n, req->service_name, ret) Timeout error log due to deadlock PDR tms/servreg get domain list txn wait failed -110 PDR service lookup for msm/adsp/sensor_pdtms/servreg failed -110 Thanks to Bjorn and Johan for letting me know that this commit also fixes an audio regression when using the in-kernel pd-mapper as that makes it easier to hit this race. [1] Consider specifically these CWEs: CWE-863 CWE-667 CWE-833 CWE-401 CWE-201 CWE-1285 CWE-362",
    "cwe_mentions": [
      "CWE-863",
      "CWE-667",
      "CWE-833",
      "CWE-401",
      "CWE-201",
      "CWE-1285",
      "CWE-362"
    ],
    "search_time": 3.2976043224334717
  },
  "timestamp": "2025-07-14 10:05:11",
  "cve_id": "CVE-2025-22014",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "390",
      "name": "Detection of Error Condition Without Action",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "226",
      "name": "Sensitive Information in Resource Not Removed Before Reuse",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "212",
      "name": "Improper Removal of Sensitive Information Before Storage or Transfer",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "201",
      "name": "Insertion of Sensitive Information Into Sent Data",
      "type": "base",
      "score": 2.1189999999999998,
      "relationship_count": 0
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "type": "variant",
      "score": 2.04,
      "relationship_count": 0
    },
    {
      "cwe_id": "120",
      "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "123",
      "name": "Write-what-where Condition",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "364",
      "name": "Signal Handler Race Condition",
      "type": "base",
      "score": 1.7550000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 1.7215235065069767,
      "relationship_count": 0
    },
    {
      "cwe_id": "1265",
      "name": "Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "1325",
      "name": "Improperly Controlled Sequential Memory Allocation",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "386",
      "name": "Symbolic Name not Mapping to Correct Object",
      "type": "base",
      "score": 1.6744000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "662",
      "name": "Improper Synchronization",
      "type": "class",
      "score": 1.6736000000000002,
      "relationship_count": 0
    },
    {
      "cwe_id": "61",
      "name": "UNIX Symbolic Link (Symlink) Following",
      "type": "compound",
      "score": 1.61,
      "relationship_count": 0
    },
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "type": "Base",
      "score": 1.5319892179912795,
      "relationship_count": 0
    },
    {
      "cwe_id": "202",
      "name": "Exposure of Sensitive Information Through Data Queries",
      "type": "base",
      "score": 1.521,
      "relationship_count": 0
    },
    {
      "cwe_id": "209",
      "name": "Generation of Error Message Containing Sensitive Information",
      "type": "base",
      "score": 1.521,
      "relationship_count": 0
    },
    {
      "cwe_id": "129",
      "name": "Improper Validation of Array Index",
      "type": "variant",
      "score": 1.51536,
      "relationship_count": 0
    },
    {
      "cwe_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "type": "Base",
      "score": 1.5038116049943757,
      "relationship_count": 0
    },
    {
      "cwe_id": "415",
      "name": "Double Free",
      "type": "variant",
      "score": 1.4784000000000002,
      "relationship_count": 0
    }
  ]
}