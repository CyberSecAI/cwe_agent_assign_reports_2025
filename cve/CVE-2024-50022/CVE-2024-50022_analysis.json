{
  "cve_id": "CVE-2024-50022",
  "description": "In the Linux kernel, the following vulnerability has been resolved device-dax correct pgoff align in dax_set_mapping() pgoff should be aligned using ALIGN_DOWN() instead of ALIGN(). Otherwise, vmf->address not aligned to fault_size will be aligned to the next alignment, that can result in memory failure getting the wrong address. Its a subtle situation that only can be observed in page_mapped_in_vma() after the page is page fault handled by dev_dax_huge_fault. Generally, there is little chance to perform page_mapped_in_vma in dev-daxs page unless in specific error injection to the dax device to trigger an MCE - memory-failure. In that case, page_mapped_in_vma() will be triggered to determine which task is accessing the failure address and kill that task in the end. We used self-developed dax device (which is 2M aligned mapping) , to perform error injection to random address. It turned out that error injected to non-2M-aligned address was causing endless MCE until panic. Because page_mapped_in_vma() kept resulting wrong address and the task accessing the failure address was never killed properly [ 3783.719419] Memory failure 0x200c9742 recovery action for dax page Recovered [ 3784.049006] mce Uncorrected hardware memory error in user-access at 200c9742380 [ 3784.049190] Memory failure 0x200c9742 recovery action for dax page Recovered [ 3784.448042] mce Uncorrected hardware memory error in user-access at 200c9742380 [ 3784.448186] Memory failure 0x2",
  "key_phrases": {
    "rootcause": "",
    "weakness": "wrong alignment in dax_set_mapping()",
    "impact": [
      "memory failure",
      "panic"
    ],
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": ""
  },
  "reference_content": "Based on the provided content, here's an analysis of the vulnerability:\n\n**Root Cause:**\nThe vulnerability lies in the `dax_set_mapping()` function within the Linux kernel's device-dax driver.  The function incorrectly calculates the page offset (`pgoff`) by using `ALIGN()` instead of `ALIGN_DOWN()`.\n\n**Weaknesses/Vulnerabilities:**\n- **Incorrect Address Alignment:** Using `ALIGN()` rounds the address up to the next alignment boundary, while `ALIGN_DOWN()` rounds down to the previous boundary. When the `vmf->address` is not aligned with the `fault_size`, using `ALIGN()` results in a `pgoff` value that is misaligned.\n- **Memory Corruption**: This incorrect `pgoff` calculation leads to the `page_mapped_in_vma()` function being provided with the wrong address when handling a page fault after a `dev_dax_huge_fault`.\n\n**Impact of Exploitation:**\n- **Endless MCE Loop**: When a memory error is injected into an unpinned device-dax region that is not aligned to its device-dax alignment (e.g., 2MB), the incorrect `pgoff` causes `page_mapped_in_vma()` to identify the wrong task as responsible for the memory access. This means the kernel does not correctly kill the offending task and recovery action is not taken, leading to an infinite loop of Memory Check Exception (MCE) reports and ultimately a kernel panic.\n- **System Instability:** The continuous MCE loop consumes system resources and renders the system unresponsive, potentially requiring a hard reset.\n\n**Attack Vectors:**\n- **Error Injection:** This vulnerability is triggered by injecting a memory error into an unpinned device-dax region that is not aligned to its device-dax alignment (e.g., 4K, 2M, 1G).\n- **Specific Device Setup**: The vulnerability is specific to using a device-dax device, and specifically, one with an alignment requirement (e.g. 2M aligned mapping), and triggering a memory error.\n\n**Required Attacker Capabilities/Position:**\n- **Kernel access/privileges**: The attacker would need the capability to trigger memory errors in a direct access (dax) device. This usually implies kernel-level access, or the ability to directly manipulate memory via custom hardware or error injection.\n- **Specific setup:** Requires a system with a device-dax device configured and unpinned memory regions.\n- **Knowledge of Memory Structure:** Some understanding of device-dax and memory alignment requirements is necessary.\n\n**Additional details from the provided content:**\n- The issue is difficult to reproduce in normal production environments because device-dax regions are typically pinned to their alignment boundaries, but can be triggered by using a custom device that is not aligned.\n- The developers used bpftrace to trace the page faults and MCE addresses to pinpoint the root cause of the issue.\n- The fix involves changing `ALIGN()` to `ALIGN_DOWN()` in the `dax_set_mapping()` function.\n- The issue is in the function `dax_set_mapping` of the driver `drivers/dax/device.c`.\n\nThis information is more detailed than a typical CVE description, and provides the code context, trigger conditions, and impact of the vulnerability.",
  "similar_info": {
    "cwe_distribution": {},
    "cwe_consensus": "",
    "similarity_stats": {
      "thresholds": [],
      "total_samples_by_threshold": {},
      "top_cwes_by_threshold": {}
    }
  },
  "similarity_summary": {
    "consensus_cwe": "",
    "top_cwes": [],
    "confidence_levels": {},
    "total_samples": 0
  },
  "analysis": "# Summary\n| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |\n|---|---|---|---|---|---|\n| CWE-131 | Incorrect Calculation of Buffer Size | 0.8 | Base |  Primary CWE | Allowed |\n| CWE-787 | Out-of-bounds Write | 0.7 | Base | Secondary Candidate | Allowed |\n| CWE-119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | 0.6 | Class | Secondary Candidate | Discouraged |\n\n## Evidence and Confidence\n\n*   **Confidence Score:** 0.7\n*   **Evidence Strength:** MEDIUM\n\n## Relationship Analysis\nThe primary relationship influencing the CWE selection is the chain relationship where an incorrect calculation of buffer size (CWE-131) can lead to an out-of-bounds write (CWE-787). CWE-131 is a child of CWE-682 (Incorrect Calculation) and can precede CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer). CWE-787 is a child of CWE-119.\n\n```mermaid\ngraph TD\n    cwe131[\"CWE-131: Incorrect Calculation of Buffer Size\"]\n    cwe787[\"CWE-787: Out-of-bounds Write\"]\n    cwe119[\"CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\"]\n    cwe682[\"CWE-682: Incorrect Calculation\"]\n\n    cwe131 -->|CHILDOF| cwe682\n    cwe131 -->|CANPRECEDE| cwe119\n    cwe787 -->|CHILDOF| cwe119\n\n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    classDef tertiary fill:#9e9,stroke:#333\n    class cwe131 primary\n    class cwe787,cwe119 secondary\n```\n\n## Vulnerability Chain\nThe vulnerability chain starts with an **incorrect address alignment** in `dax_set_mapping()`, caused by using `ALIGN()` instead of `ALIGN_DOWN()`. This **incorrect calculation of buffer size** (CWE-131) leads to an out-of-bounds write (CWE-787) when `page_mapped_in_vma()` is called with the **wrong address**, ultimately leading to a memory failure and system panic.\n\n## Summary of Analysis\nThe primary root cause of the vulnerability is the **incorrect calculation of the page offset** in the `dax_set_mapping()` function. The use of `ALIGN()` instead of `ALIGN_DOWN()` leads to the function using the **wrong address**, resulting in a misaligned `pgoff` value. This aligns well with CWE-131 (Incorrect Calculation of Buffer Size). The subsequent memory corruption and system panic are consequences of this initial error, making CWE-787 (Out-of-bounds Write) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer) secondary considerations.\n\nThe evidence from the CVE description includes the following key phrases:\n- **\"weakness: wrong alignment in dax_set_mapping()\"**\n- **\"pgoff should be aligned using ALIGN_DOWN() instead of ALIGN(). Otherwise, vmf->address not aligned to fault_size will be aligned to the next alignment, that can result in memory failure getting the wrong address.\"**\n\nThese phrases directly support the classification of CWE-131 as the primary weakness, as they highlight the **incorrect calculation** leading to memory errors.\n\nCWE-131 is chosen over other candidates because it specifically addresses the root cause \u2013 the **incorrect calculation** of the buffer size due to using the wrong alignment function.\n\nOther CWEs Considered:\n\n*   CWE-787 (Out-of-bounds Write): While the vulnerability ultimately leads to memory corruption, the root cause is the incorrect calculation, not the write operation itself. Therefore, CWE-787 is a secondary consequence.\n*   CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer): This is a more general CWE and less specific than CWE-131 and CWE-787. It describes the symptom (memory corruption) but not the root cause.\n*   CWE-1285 (Improper Validation of Specified Index, Position, or Offset in Input): This CWE is related to validating input but doesn't directly apply because the issue is with the calculation of the offset, not the validation of an external input.\n*   CWE-789 (Memory Allocation with Excessive Size Value): This CWE is related to allocating memory based on an untrusted, large size value, but the issue here is the incorrect calculation of the address, not an excessive size value.",
  "analysis_with_relationships": "# Summary\n| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |\n|---|---|---|---|---|---|\n| CWE-131 | Incorrect Calculation of Buffer Size | 0.8 | Base |  Primary CWE | Allowed |\n| CWE-787 | Out-of-bounds Write | 0.7 | Base | Secondary Candidate | Allowed |\n| CWE-119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | 0.6 | Class | Secondary Candidate | Discouraged |\n\n## Evidence and Confidence\n\n*   **Confidence Score:** 0.7\n*   **Evidence Strength:** MEDIUM\n\n## Relationship Analysis\nThe primary relationship influencing the CWE selection is the chain relationship where an incorrect calculation of buffer size (CWE-131) can lead to an out-of-bounds write (CWE-787). CWE-131 is a child of CWE-682 (Incorrect Calculation) and can precede CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer). CWE-787 is a child of CWE-119.\n\n```mermaid\ngraph TD\n    cwe131[\"CWE-131: Incorrect Calculation of Buffer Size\"]\n    cwe787[\"CWE-787: Out-of-bounds Write\"]\n    cwe119[\"CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\"]\n    cwe682[\"CWE-682: Incorrect Calculation\"]\n\n    cwe131 -->|CHILDOF| cwe682\n    cwe131 -->|CANPRECEDE| cwe119\n    cwe787 -->|CHILDOF| cwe119\n\n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    classDef tertiary fill:#9e9,stroke:#333\n    class cwe131 primary\n    class cwe787,cwe119 secondary\n```\n\n## Vulnerability Chain\nThe vulnerability chain starts with an **incorrect address alignment** in `dax_set_mapping()`, caused by using `ALIGN()` instead of `ALIGN_DOWN()`. This **incorrect calculation of buffer size** (CWE-131) leads to an out-of-bounds write (CWE-787) when `page_mapped_in_vma()` is called with the **wrong address**, ultimately leading to a memory failure and system panic.\n\n## Summary of Analysis\nThe primary root cause of the vulnerability is the **incorrect calculation of the page offset** in the `dax_set_mapping()` function. The use of `ALIGN()` instead of `ALIGN_DOWN()` leads to the function using the **wrong address**, resulting in a misaligned `pgoff` value. This aligns well with CWE-131 (Incorrect Calculation of Buffer Size). The subsequent memory corruption and system panic are consequences of this initial error, making CWE-787 (Out-of-bounds Write) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer) secondary considerations.\n\nThe evidence from the CVE description includes the following key phrases:\n- **\"weakness: wrong alignment in dax_set_mapping()\"**\n- **\"pgoff should be aligned using ALIGN_DOWN() instead of ALIGN(). Otherwise, vmf->address not aligned to fault_size will be aligned to the next alignment, that can result in memory failure getting the wrong address.\"**\n\nThese phrases directly support the classification of CWE-131 as the primary weakness, as they highlight the **incorrect calculation** leading to memory errors.\n\nCWE-131 is chosen over other candidates because it specifically addresses the root cause \u2013 the **incorrect calculation** of the buffer size due to using the wrong alignment function.\n\nOther CWEs Considered:\n\n*   CWE-787 (Out-of-bounds Write): While the vulnerability ultimately leads to memory corruption, the root cause is the incorrect calculation, not the write operation itself. Therefore, CWE-787 is a secondary consequence.\n*   CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer): This is a more general CWE and less specific than CWE-131 and CWE-787. It describes the symptom (memory corruption) but not the root cause.\n*   CWE-1285 (Improper Validation of Specified Index, Position, or Offset in Input): This CWE is related to validating input but doesn't directly apply because the issue is with the calculation of the offset, not the validation of an external input.\n*   CWE-789 (Memory Allocation with Excessive Size Value): This CWE is related to allocating memory based on an untrusted, large size value, but the issue here is the incorrect calculation of the address, not an excessive size value.\n\n\n## CWE Relationship Analysis\n\nCurrent CWEs represent these abstraction levels: .\n\n\n### Vulnerability Chain Analysis\n\n**Chain starting from CWE-682:**\n- 682 (Incorrect Calculation) - ROOT\n\n\n**Chain starting from CWE-131:**\n- 131 (Incorrect Calculation of Buffer Size) - ROOT\n\n\n\n### CWE Relationship Diagram\n\n```mermaid\ngraph TD\n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    classDef tertiary fill:#9e9,stroke:#333\n```",
  "criticism": "",
  "resolution": "",
  "relevant_cwes": [
    {
      "metadata": {
        "doc_id": "667",
        "name": "Improper Locking",
        "source": "sparse"
      },
      "similarity": 869.052345192915
    },
    {
      "metadata": {
        "doc_id": "770",
        "name": "Allocation of Resources Without Limits or Throttling",
        "source": "sparse"
      },
      "similarity": 856.9376274811863
    },
    {
      "metadata": {
        "doc_id": "119",
        "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
        "source": "sparse"
      },
      "similarity": 848.8426690021168
    },
    {
      "metadata": {
        "doc_id": "362",
        "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
        "source": "sparse"
      },
      "similarity": 840.4885915606678
    },
    {
      "metadata": {
        "doc_id": "1285",
        "name": "Improper Validation of Specified Index, Position, or Offset in Input",
        "source": "sparse"
      },
      "similarity": 839.7563377979674
    },
    {
      "metadata": {
        "doc_id": "1284",
        "name": "Improper Validation of Specified Quantity in Input",
        "source": "sparse"
      },
      "similarity": 831.3833729566243
    },
    {
      "metadata": {
        "doc_id": "125",
        "name": "Out-of-bounds Read",
        "source": "sparse"
      },
      "similarity": 830.5278035168589
    },
    {
      "metadata": {
        "doc_id": "789",
        "name": "Memory Allocation with Excessive Size Value",
        "source": "sparse"
      },
      "similarity": 820.3204462612491
    },
    {
      "metadata": {
        "doc_id": "1190",
        "name": "DMA Device Enabled Too Early in Boot Phase",
        "type": "Base",
        "original_content": "The product enables a Direct Memory Access (DMA) capable device before the security configuration settings are established, which allows an attacker to extract data from or gain privileges on the product.",
        "keyphrase_source": "weakness:wrong alignment in dax_set_mapping()",
        "source": "dense",
        "mapping_notes": {
          "usage": "Allowed",
          "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
          "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
          "reasons": [
            "Acceptable-Use"
          ]
        },
        "score_info": {
          "retrievers": [
            "dense"
          ],
          "retriever_count": 1,
          "normalized_scores": {
            "dense": 0.5414551101220869
          }
        }
      },
      "similarity": 0.5414551101220869
    },
    {
      "doc_id": "1260",
      "text": "The product allows address regions to overlap, which can result in the bypassing of intended memory protection.",
      "score": 0.5562594598518947,
      "metadata": {
        "doc_id": "1260",
        "name": "Improper Handling of Overlap Between Protected Memory Ranges",
        "type": "Base",
        "extended_description": "\n\nIsolated memory regions and access control (read/write) policies are used by hardware to protect privileged software. Software components are often allowed to change or remap memory region definitions in order to enable flexible and dynamically changeable memory management by system software.\n\n\nIf a software component running at lower privilege can program a memory address region to overlap with other memory regions used by software running at higher privilege, privilege escalation may be available to attackers. The memory protection unit (MPU) logic can incorrectly handle such an address overlap and allow the lower-privilege software to read or write into the protected memory region, resulting in privilege escalation attack. An address overlap weakness can also be used to launch a denial of service attack on the higher-privilege software memory regions.\n",
        "alternate_terms": [],
        "original_content": "The product allows address regions to overlap, which can result in the bypassing of intended memory protection.",
        "relationships": [
          {
            "source_id": "1260",
            "target_id": "119",
            "label": "CANPRECEDE",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          },
          {
            "source_id": "1260",
            "target_id": "284",
            "label": "CHILDOF",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          },
          {
            "source_id": "284",
            "target_id": "1260",
            "label": "PARENTOF",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          },
          {
            "source_id": "119",
            "target_id": "1260",
            "label": "CANFOLLOW",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          }
        ],
        "source": "graph",
        "sources": [
          "vector",
          "graph"
        ],
        "vector_score": 0.5562594598518947,
        "graph_score": 4.329000000000001,
        "score_components": {
          "relationship_chain": 1.0,
          "explicit_mention": 1.0,
          "abstraction_path": 0.9,
          "sequence_path": 1.0
        },
        "abstraction_factor": 1.3,
        "graph_path_info": {
          "path_types": [
            "relationship_chain",
            "vulnerability_sequence_forward",
            "vulnerability_sequence_backward"
          ],
          "best_paths": {
            "relationship_chain": {
              "path": [
                [
                  "119",
                  "1260",
                  "CANFOLLOW"
                ]
              ],
              "score": 1.0,
              "type": "relationship_chain",
              "source": "119"
            },
            "vulnerability_sequence_forward": {
              "path": [
                [
                  "119",
                  "1260",
                  "CANFOLLOW"
                ]
              ],
              "score": 0.9,
              "type": "vulnerability_sequence_forward",
              "source": "119"
            },
            "vulnerability_sequence_backward": {
              "path": [
                [
                  "1260",
                  "119",
                  "CANPRECEDE"
                ]
              ],
              "score": 1.0,
              "type": "vulnerability_sequence_backward",
              "source": "119"
            }
          }
        },
        "is_explicit": true,
        "abstraction_level": "base",
        "position": "after",
        "mapping_notes": {
          "usage": "Allowed",
          "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
          "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
          "reasons": [
            "Acceptable-Use"
          ]
        },
        "score_info": {
          "retrievers": [
            "dense",
            "graph"
          ],
          "retriever_count": 2,
          "normalized_scores": {
            "dense": 0.5336736232413968,
            "graph": 2.819903783940758
          }
        }
      },
      "similarity": 2.819903783940758
    }
  ],
  "identified_cwes": {
    "analyzer": [
      "CWE-682",
      "CWE-131",
      "CWE-787",
      "CWE-1285",
      "CWE-119",
      "CWE-789"
    ],
    "critic_additional": []
  },
  "keyphrase_cwe_mapping": {}
}