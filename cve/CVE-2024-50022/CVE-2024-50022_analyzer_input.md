# Vulnerability Information: CVE-2024-50022

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved device-dax correct pgoff align in dax_set_mapping() pgoff should be aligned using ALIGN_DOWN() instead of ALIGN(). Otherwise, vmf->address not aligned to fault_size will be aligned to the next alignment, that can result in memory failure getting the wrong address. Its a subtle situation that only can be observed in page_mapped_in_vma() after the page is page fault handled by dev_dax_huge_fault. Generally, there is little chance to perform page_mapped_in_vma in dev-daxs page unless in specific error injection to the dax device to trigger an MCE - memory-failure. In that case, page_mapped_in_vma() will be triggered to determine which task is accessing the failure address and kill that task in the end. We used self-developed dax device (which is 2M aligned mapping) , to perform error injection to random address. It turned out that error injected to non-2M-aligned address was causing endless MCE until panic. Because page_mapped_in_vma() kept resulting wrong address and the task accessing the failure address was never killed properly [ 3783.719419] Memory failure 0x200c9742 recovery action for dax page Recovered [ 3784.049006] mce Uncorrected hardware memory error in user-access at 200c9742380 [ 3784.049190] Memory failure 0x200c9742 recovery action for dax page Recovered [ 3784.448042] mce Uncorrected hardware memory error in user-access at 200c9742380 [ 3784.448186] Memory failure 0x2

### Vulnerability Description Key Phrases
- **weakness:** **wrong alignment in dax_set_mapping()**
- **impact:** memory failure and panic
- **product:** Linux kernel

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of the vulnerability:

**Root Cause:**
The vulnerability lies in the `dax_set_mapping()` function within the Linux kernel's device-dax driver.  The function incorrectly calculates the page offset (`pgoff`) by using `ALIGN()` instead of `ALIGN_DOWN()`.

**Weaknesses/Vulnerabilities:**
- **Incorrect Address Alignment:** Using `ALIGN()` rounds the address up to the next alignment boundary, while `ALIGN_DOWN()` rounds down to the previous boundary. When the `vmf->address` is not aligned with the `fault_size`, using `ALIGN()` results in a `pgoff` value that is misaligned.
- **Memory Corruption**: This incorrect `pgoff` calculation leads to the `page_mapped_in_vma()` function being provided with the wrong address when handling a page fault after a `dev_dax_huge_fault`.

**Impact of Exploitation:**
- **Endless MCE Loop**: When a memory error is injected into an unpinned device-dax region that is not aligned to its device-dax alignment (e.g., 2MB), the incorrect `pgoff` causes `page_mapped_in_vma()` to identify the wrong task as responsible for the memory access. This means the kernel does not correctly kill the offending task and recovery action is not taken, leading to an infinite loop of Memory Check Exception (MCE) reports and ultimately a kernel panic.
- **System Instability:** The continuous MCE loop consumes system resources and renders the system unresponsive, potentially requiring a hard reset.

**Attack Vectors:**
- **Error Injection:** This vulnerability is triggered by injecting a memory error into an unpinned device-dax region that is not aligned to its device-dax alignment (e.g., 4K, 2M, 1G).
- **Specific Device Setup**: The vulnerability is specific to using a device-dax device, and specifically, one with an alignment requirement (e.g. 2M aligned mapping), and triggering a memory error.

**Required Attacker Capabilities/Position:**
- **Kernel access/privileges**: The attacker would need the capability to trigger memory errors in a direct access (dax) device. This usually implies kernel-level access, or the ability to directly manipulate memory via custom hardware or error injection.
- **Specific setup:** Requires a system with a device-dax device configured and unpinned memory regions.
- **Knowledge of Memory Structure:** Some understanding of device-dax and memory alignment requirements is necessary.

**Additional details from the provided content:**
- The issue is difficult to reproduce in normal production environments because device-dax regions are typically pinned to their alignment boundaries, but can be triggered by using a custom device that is not aligned.
- The developers used bpftrace to trace the page faults and MCE addresses to pinpoint the root cause of the issue.
- The fix involves changing `ALIGN()` to `ALIGN_DOWN()` in the `dax_set_mapping()` function.
- The issue is in the function `dax_set_mapping` of the driver `drivers/dax/device.c`.

This information is more detailed than a typical CVE description, and provides the code context, trigger conditions, and impact of the vulnerability.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.869 |
| 2 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.857 |
| 3 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | sparse | 0.849 |
| 4 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.840 |
| 5 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | Allowed | sparse | 0.840 |
| 6 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.831 |
| 7 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.831 |
| 8 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | sparse | 0.820 |
| 9 | 1190 | DMA Device Enabled Too Early in Boot Phase | Base | Allowed | dense | 0.541 |
| 10 | 1260 | Improper Handling of Overlap Between Protected Memory Ranges | Base | Allowed | graph | 0.003 |

