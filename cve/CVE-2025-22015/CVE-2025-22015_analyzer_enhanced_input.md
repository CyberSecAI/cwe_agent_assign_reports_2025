## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved mm/migrate fix shmem xarray update during migration A shmem folio can be either in page cache or in swap cache, but not at the same time. Namely, once it is in swap cache, folio->mapping should be NULL, and the folio is no longer in a shmem mapping. In __folio_migrate_mapping(), to determine the number of xarray entries to update, folio_test_swapbacked() is used, but that **conflates shmem in page cache case and shmem in swap cache case**. It leads to **xarray multi-index entry corruption**, since it turns a sibling entry to a normal entry during xas_store() (see [1] for a userspace reproduction). Fix it by only using folio_test_swapcache() to determine whether xarray is storing swap cache entries or not to choose the right number of xarray entries to update. [1] https//lore.kernel.org/linux-mm/Z8idPCkaJW1IChjT@casper.infradead.org/ Note In __split_huge_page(), folio_test_anon() && folio_test_swapcache() is used to get swap_cache address space, but that ignores the shmem folio in swap cache case. It could lead to NULL pointer dereferencing when a in-swap-cache shmem folio is split at __xa_store(), since !folio_test_anon() is true and folio->mapping is NULL. But fortunately, its caller split_huge_page_to_list_to_order() bails out early with EBUSY when folio->mapping is NULL. So no need to take care of it here.

### Vulnerability Description Key Phrases
- **rootcause:** **conflates shmem in page cache case and shmem in swap cache case**
- **weakness:** **xarray multi-index entry corruption**
- **impact:** NULL pointer dereferencing
- **product:** Linux kernel
- **component:** mm/migrate fix shmem xarray update during migration

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 617 | Reachable Assertion | Base | Allowed | sparse | 1.047 |
| 2 | 404 | Improper Resource Shutdown or Release | Class | Allowed-with-Review | sparse | 1.030 |
| 3 | 476 | NULL Pointer Dereference | Base | Allowed | sparse | 1.006 |
| 4 | 1251 | Mirrored Regions with Different Values | Base | Allowed | sparse | 0.999 |
| 5 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.991 |
| 6 | 276 | Incorrect Default Permissions | Base | Allowed | sparse | 0.982 |
| 7 | 591 | Sensitive Data Storage in Improperly Locked Memory | Variant | Allowed | sparse | 0.970 |
| 8 | 79 | Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') | Base | Allowed | sparse | 0.961 |
| 9 | 667 | Improper Locking | Class | Allowed-with-Review | dense | 0.433 |
| 10 | 1260 | Improper Handling of Overlap Between Protected Memory Ranges | Base | Allowed | graph | 0.002 |



# Complete CWE Specifications

CWE-617: Reachable Assertion

CWE-404: Improper Resource Shutdown or Release

CWE-476: NULL Pointer Dereference

CWE-1251: Mirrored Regions with Different Values

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-276: Incorrect Default Permissions

CWE-591: Sensitive Data Storage in Improperly Locked Memory

CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')

CWE-667: Improper Locking

CWE-1260: Improper Handling of Overlap Between Protected Memory Ranges