# Vulnerability Information: CVE-2024-46828

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved sched sch_cake fix bulk flow accounting logic for host fairness In sch_cake, we keep track of the count of active bulk flows per host, when running in dst/src host fairness mode, which is used as the round-robin weight when iterating through flows. The count of active bulk flows is updated whenever a flow changes state. This has a peculiar interaction with the **hash collision** handling when a **hash collision** occurs (after the set-associative hashing), the state of the hash bucket is simply updated to match the new packet that collided, and if host fairness is enabled, that also means assigning new per-host state to the flow. For this reason, the bulk flow counters of the host(s) assigned to the flow are decremented, before new state is assigned (and the counters, which may not belong to the same host anymore, are incremented again). Back when this code was introduced, the host fairness mode was always enabled, so the decrement was unconditional. When the configuration flags were introduced the *increment* was made conditional, but the *decrement* was not. Which of course can lead to a **spurious decrement** (and associated wrap-around to U16_MAX). AFAICT, when host fairness is disabled, the decrement and wrap-around happens as soon as a **hash collision** occurs (which is not that common in itself, due to the set-associative hashing). However, in most cases this is harmless, as the value is only used when host f

### Vulnerability Description Key Phrases
- **rootcause:** **hash collision**
- **weakness:** **spurious decrement**
- **impact:** wrap-around to U16_MAX
- **product:** Linux kernel
- **component:** sched sch_cake

## CVE Reference Links Content Summary
Based on the provided content, here's a breakdown of the vulnerability:

**Root Cause:**
- The `sch_cake` (Cake Queueing Discipline) in the Linux kernel tracks active bulk flows per host when operating in destination/source host fairness mode. This count is used as a weight for round-robin scheduling of flows.
- When a hash collision occurs (after set-associative hashing), the state of the hash bucket is updated, which might involve reassigning per-host state to the flow.
- The code decremented the bulk flow counters for the hosts associated with the flow unconditionally, *before* assigning the new state. This decrement was not conditional, unlike the subsequent increment.

**Weakness/Vulnerability:**
- **Unconditional Decrement:** The unconditional decrement of bulk flow counters, even when host fairness is disabled, could lead to a spurious decrement and subsequent wrap-around of the counter to `U16_MAX` (maximum value for an unsigned 16-bit integer).
- **Out-of-Bounds Array Access:** When host fairness is re-enabled after a wrap-around, the wrapped-around value is used as an index to an array, causing an out-of-bounds access and a potential crash.

**Impact of Exploitation:**
- **Array Overflow/Out-of-Bounds Access:** Exploitation leads to an array out-of-bounds access, potentially causing a kernel crash and denial of service.

**Attack Vectors:**
- **Configuration:** The vulnerability is triggered by first configuring `sch_cake` with host fairness disabled, then inducing a hash collision, and finally reconfiguring the qdisc with host fairness enabled.
- **Hash Collisions:** Triggering a hash collision is necessary but not very frequent due to set-associative hashing.
- **Reconfiguration:** The qdisc needs to be reconfigured to enable host fairness after the counter wrap-around.

**Required Attacker Capabilities/Position:**
- **Kernel Control:** The attacker needs to be able to configure the `sch_cake` qdisc, requiring some level of control over the system's networking stack.
- **Traffic Generation:** The attacker needs to be able to generate traffic that results in hash collisions within the `sch_cake` queue.

**Additional Details:**
- The vulnerability was reported by syzbot, a fuzzer, which managed to trigger the specific sequence of events, including the hash collision and the qdisc reconfiguration
- The fix ensures that the bulk flow counters are only decremented if the respective source/destination host tracking is enabled, similar to the existing increment logic.

This detailed information expands on the potential impact and attack vectors beyond the general CVE description.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 190 | Integer Overflow or Wraparound | Base | Allowed | sparse | 1.280 |
| 2 | 407 | Inefficient Algorithmic Complexity | Class | Allowed-with-Review | sparse | 1.258 |
| 3 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | sparse | 1.243 |
| 4 | 295 | Improper Certificate Validation | Base | Allowed | sparse | 1.243 |
| 5 | 328 | Use of Weak Hash | Base | Allowed | sparse | 1.235 |
| 6 | 863 | Incorrect Authorization | Class | Allowed-with-Review | sparse | 1.234 |
| 7 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 1.231 |
| 8 | 916 | Use of Password Hash With Insufficient Computational Effort | Base | Allowed | sparse | 1.217 |
| 9 | 911 | Improper Update of Reference Count | Base | Allowed | dense | 0.492 |
| 10 | 364 | Signal Handler Race Condition | Base | Allowed | graph | 0.002 |

