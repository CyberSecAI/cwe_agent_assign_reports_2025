## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved bpf Fix deadlock when freeing cgroup storage The following commit bc235cdb423a (bpf Prevent deadlock from recursive bpf_task_storage_[get|delete]) first introduced deadlock prevention for fentry/fexit programs attaching on bpf_task_storage helpers. That commit also employed the logic in map free path in its v6 version. Later bpf_cgrp_storage was first introduced in c4bcfb38a95e (bpf Implement cgroup storage available to non-cgroup-attached bpf progs) which faces the same issue as bpf_task_storage, instead of its busy counter, NULL was passed to bpf_local_storage_map_free() which opened a window to cause deadlock (acquiring local_storage->lock) _raw_spin_lock_irqsave+0x3d/0x50 bpf_local_storage_update+0xd1/0x460 bpf_cgrp_storage_get+0x109/0x130 bpf_prog_a4d4a370ba857314_cgrp_ptr+0x139/0x170 ? __bpf_prog_enter_recur+0x16/0x80 bpf_trampoline_6442485186+0x43/0xa4 cgroup_storage_ptr+0x9/0x20 (holding local_storage->lock) bpf_selem_unlink_storage_nolock.constprop.0+0x135/0x160 bpf_selem_unlink_storage+0x6f/0x110 bpf_local_storage_map_free+0xa2/0x110 bpf_map_free_deferred+0x5b/0x90 process_one_work+0x17c/0x390 worker_thread+0x251/0x360 kthread+0xd2/0x100 ret_from_fork+0x34/0x50 ret_from_fork_asm+0x1a/0x30 Progs - A SEC(fentry/cgroup_storage_ptr) - cgid (BPF_MAP_TYPE_HASH) Record the id of the cgroup the current task belonging to in this hash map, using the address of the cgroup as the map key. - cgrpa (BPF_MAP_TYPE_CGRP_STORAGE) If current task is a kworker, lookup the above hash map using function parameter @owner as the key to get its corresponding cgroup id which is then used to get a trusted pointer to the cgroup through bpf_cgroup_from_id(). This trusted pointer can then be passed to bpf_cgrp_storage_get() to finally trigger the deadlock issue. - B SEC(tp_btf/sys_enter) - cgrpb (BPF_MAP_TYPE_CGRP_STORAGE) The only purpose of this prog is to fill Prog As hash map by calling bpf_cgrp_storage_get() for as many userspace tasks as possible. Steps to reproduce - Run A - while (true) { Run B Destroy B } Fix this issue by passing its busy counter to the free procedure so it can be properly incremented before storage/smap locking.

### Vulnerability Description Key Phrases
- **rootcause:** **null pointer dereference**
- **impact:** deadlock
- **product:** Linux kernel
- **component:** bpf_cgrp_storage

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 1.195 |
| 2 | 833 | Deadlock | Base | Allowed | sparse | 1.136 |
| 3 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 1.083 |
| 4 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | sparse | 1.035 |
| 5 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 1.027 |
| 6 | 639 | Authorization Bypass Through User-Controlled Key | Base | Allowed | sparse | 1.016 |
| 7 | 335 | Incorrect Usage of Seeds in Pseudo-Random Number Generator (PRNG) | Base | Allowed | sparse | 1.015 |
| 8 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | sparse | 1.012 |
| 9 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | dense | 0.466 |
| 10 | 609 | Double-Checked Locking | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-667: Improper Locking

CWE-833: Deadlock

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-674: Uncontrolled Recursion

CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition

CWE-639: Authorization Bypass Through User-Controlled Key

CWE-335: Incorrect Usage of Seeds in Pseudo-Random Number Generator (PRNG)

CWE-909: Missing Initialization of Resource

CWE-401: Missing Release of Memory after Effective Lifetime

CWE-609: Double-Checked Locking