# Raw Retriever Results for CVE-2024-42294

# Raw Retriever Results for CVE-2024-42294
## Query
In the Linux kernel, the following vulnerability has been resolvedblock fix deadlock between sd_remove & sd_releaseOur test report the following hung task[ 2538.459400] INFO task kworker/007 blocked for more than 188 seconds.[ 2538.459427] Call trace[ 2538.459430] __switch_to+0x174/0x338[ 2538.459436] __schedule+0x628/0x9c4[ 2538.459442] schedule+0x7c/0xe8[ 2538.459447] schedule_preempt_disabled+0x24/0x40[ 2538.459453] __mutex_lock+0x3ec/0xf04[ 2538.459456] __mutex_lock_slowpath+0x14/0x24[ 2538.459459] mutex_lock+0x30/0xd8[ 2538.459462] del_gendisk+0xdc/0x350[ 2538.459466] sd_remove+0x30/0x60[ 2538.459470] device_release_driver_internal+0x1c4/0x2c4[ 2538.459474] device_release_driver+0x18/0x28[ 2538.459478] bus_remove_device+0x15c/0x174[ 2538.459483] device_del+0x1d0/0x358[ 2538.459488] __scsi_remove_device+0xa8/0x198[ 2538.459493] scsi_forget_host+0x50/0x70[ 2538.459497] scsi_remove_host+0x80/0x180[ 2538.459502] usb_stor_disconnect+0x68/0xf4[ 2538.459506] usb_unbind_interface+0xd4/0x280[ 2538.459510] device_release_driver_internal+0x1c4/0x2c4[ 2538.459514] device_release_driver+0x18/0x28[ 2538.459518] bus_remove_device+0x15c/0x174[ 2538.459523] device_del+0x1d0/0x358[ 2538.459528] usb_disable_device+0x84/0x194[ 2538.459532] usb_disconnect+0xec/0x300[ 2538.459537] hub_event+0xb80/0x1870[ 2538.459541] process_scheduled_works+0x248/0x4dc[ 2538.459545] worker_thread+0x244/0x334[ 2538.459549] kthread+0x114/0x1bc[ 2538.461001] INFO task fsck.15415 blocked for more than 188 seconds.[ 2538.461014] Call trace[ 2538.461016] __switch_to+0x174/0x338[ 2538.461021] __schedule+0x628/0x9c4[ 2538.461025] schedule+0x7c/0xe8[ 2538.461030] blk_queue_enter+0xc4/0x160[ 2538.461034] blk_mq_alloc_request+0x120/0x1d4[ 2538.461037] scsi_execute_cmd+0x7c/0x23c[ 2538.461040] ioctl_internal_command+0x5c/0x164[ 2538.461046] scsi_set_medium_removal+0x5c/0xb0[ 2538.461051] sd_release+0x50/0x94[ 2538.461054] blkdev_put+0x190/0x28c[ 2538.461058] blkdev_release+0x28/0x40[ 2538.461063] __fput+0xf8/0x2a8[ 2538.461066] __fput_sync+0x28/0x5c[ 2538.461070] __arm64_sys_close+0x84/0xe8[ 2538.461073] invoke_syscall+0x58/0x114[ 2538.461078] el0_svc_common+0xac/0xe0[ 2538.461082] do_el0_svc+0x1c/0x28[ 2538.461087] el0_svc+0x38/0x68[ 2538.461090] el0t_64_sync_handler+0x68/0xbc[ 2538.461093] el0t_64_sync+0x1a8/0x1ac T1 T2 sd_remove del_gendisk __blk_mark_disk_dead blk_freeze_queue_start ++q->mq_freeze_depth bdev_release mutex_lock(&disk->open_mutex) sd_release scsi_execute_cmd blk_queue_enter wait_event(!q->mq_freeze_depth) mutex_lock(&disk->open_mutex)SCSI does not set GD_OWNS_QUEUE, so QUEUE_FLAG_DYING is not set inthis scenario. This is a classic ABBA deadlock. To fix the deadlock,make sure we dont try to acquire disk->open_mutex after freezingthe queue.

## Keyphrases
- **rootcause**: 'Deadlock between sd_remove', 'sd_release due to incorrect mutex acquisition order after queue freezing.'
- **weakness**: 'Incorrect locking order in the SCSI driver', 'specifically attempting to acquire the disk->open_mutex after the queue has been frozen.'

## Score Statistics
| Retriever | Min | Max | Mean | Median | Count |
|-----------|-----|-----|------|--------|-------|
| Dense | 0.4002 | 0.5433 | 0.4384 | 0.4318 | 20 |
| Sparse | 273.5097 | 393.6600 | 310.1166 | 302.8565 | 14 |
| Graph | 1.4074 | 2.3400 | 1.7346 | 1.6823 | 20 |

## Graph Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Mapping Usage |
|---|--------|------|-------------|-------|---------------|
| 1 | 1325 | Improperly Controlled Sequential Memory Allocation | base | 2.3400 | Allowed |
| 2 | 390 | Detection of Error Condition Without Action | base | 2.2100 | Allowed |
| 3 | 129 | Improper Validation of Array Index | variant | 2.0554 | Allowed |
| 4 | 22 | Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') | base | 1.7680 | Allowed |
| 5 | 41 | Improper Resolution of Path Equivalence | base | 1.7680 | Allowed |
| 6 | 123 | Write-what-where Condition | base | 1.7680 | Allowed |
| 7 | 364 | Signal Handler Race Condition | base | 1.7550 | Allowed |
| 8 | 833 | Deadlock | Base | 1.7128 | Allowed |
| 9 | 252 | Unchecked Return Value | base | 1.6848 | Allowed |
| 10 | 1265 | Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls | base | 1.6848 | Allowed |
| 11 | 413 | Improper Resource Locking | Base | 1.6799 | Allowed |
| 12 | 386 | Symbolic Name not Mapping to Correct Object | base | 1.6744 | Allowed |
| 13 | 20 | Improper Input Validation | class | 1.6736 | Discouraged |
| 14 | 662 | Improper Synchronization | class | 1.6736 | Discouraged |
| 15 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | 1.6323 | Allowed |

## Dense Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Original Score | Mapping Usage |
|---|--------|------|-------------|-------|----------------|---------------|
| 1 | 833 | Deadlock | Base | 0.5433 | 0.5433 | Allowed |
| 2 | 667 | Improper Locking | Class | 0.4895 | 0.4895 | Allowed-with-Review |
| 3 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | 0.4765 | 0.4765 | Allowed-with-Review |
| 4 | 413 | Improper Resource Locking | Base | 0.4617 | 0.4617 | Allowed |
| 5 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | 0.4582 | 0.4582 | Allowed |
| 6 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | 0.4558 | 0.4558 | Allowed |
| 7 | 775 | Missing Release of File Descriptor or Handle after Effective Lifetime | Variant | 0.4556 | 0.4556 | Allowed |
| 8 | 401 | Missing Release of Memory after Effective Lifetime | Variant | 0.4549 | 0.4549 | Allowed |
| 9 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | 0.4507 | 0.4507 | Discouraged |
| 10 | 909 | Missing Initialization of Resource | Class | 0.4464 | 0.4464 | Allowed-with-Review |
| 11 | 770 | Allocation of Resources Without Limits or Throttling | Base | 0.4172 | 0.4172 | Allowed |
| 12 | 416 | Use After Free | Variant | 0.4151 | 0.4151 | Allowed |
| 13 | 789 | Memory Allocation with Excessive Size Value | Variant | 0.4128 | 0.4128 | Allowed |
| 14 | 122 | Heap-based Buffer Overflow | Variant | 0.4087 | 0.4087 | Allowed |
| 15 | 126 | Buffer Over-read | Variant | 0.4076 | 0.4076 | Allowed |

## Sparse Retriever Results (14)
| # | CWE ID | Name | Score | Original Score | Mapping Usage |
|---|--------|------|-------|---------------|---------------|
| 1 | 667 | Improper Locking | 393.6600 | 393.6600 | Allowed-with-Review |
| 2 | 401 | Missing Release of Memory after Effective Lifetime | 342.1847 | 342.1847 | Allowed |
| 3 | 833 | Deadlock | 334.5370 | 334.5370 | Allowed |
| 4 | 770 | Allocation of Resources Without Limits or Throttling | 323.4031 | 323.4031 | Allowed |
| 5 | 316 | Cleartext Storage of Sensitive Information in Memory | 314.5064 | 314.5064 | Allowed |
| 6 | 226 | Sensitive Information in Resource Not Removed Before Reuse | 312.0888 | 312.0888 | Allowed |
| 7 | 328 | Use of Weak Hash | 303.8202 | 303.8202 | Allowed |
| 8 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | 301.8928 | 301.8928 | Allowed-with-Review |
| 9 | 252 | Unchecked Return Value | 300.6083 | 300.6083 | Allowed |
| 10 | 591 | Sensitive Data Storage in Improperly Locked Memory | 299.2028 | 299.2028 | Allowed |
| 11 | 772 | Missing Release of Resource after Effective Lifetime | 289.5155 | 289.5155 | Allowed |
| 12 | 406 | Insufficient Control of Network Message Volume (Network Amplification) | 278.2053 | 278.2053 | Allowed-with-Review |
| 13 | 663 | Use of a Non-reentrant Function in a Concurrent Context | 274.4980 | 274.4980 | Allowed |
| 14 | 79 | Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') | 273.5097 | 273.5097 | Allowed |
