{
  "cve_id": "CVE-2024-49946",
  "description": "In the Linux kernel, the following vulnerability has been resolved ppp do not assume bh is held in ppp_channel_bridge_input() Networking receive path is usually handled from BH handler. However, some protocols need to acquire the socket lock, and packets might be stored in the socket backlog is the socket was owned by a user process. In this case, release_sock(), __release_sock(), and sk_backlog_rcv() might call the sk->sk_backlog_rcv() handler in process context. sybot caught ppp was not considering this case in ppp_channel_bridge_input() WARNING inconsistent lock state 6.11.0-rc7-syzkaller-g5f5673607153 #0 Not tainted -------------------------------- inconsistent {SOFTIRQ-ON-W} -> {IN-SOFTIRQ-W} usage. ksoftirqd/1/24 [HC0[0]SC1[1]HE1SE0] takes ffff0000db7f11e0 (&pch->downl){+.?.}-{22}, at spin_lock include/linux/spinlock.h351 [inline] ffff0000db7f11e0 (&pch->downl){+.?.}-{22}, at ppp_channel_bridge_input drivers/net/ppp/ppp_generic.c2272 [inline] ffff0000db7f11e0 (&pch->downl){+.?.}-{22}, at ppp_input+0x16c/0x854 drivers/net/ppp/ppp_generic.c2304 {SOFTIRQ-ON-W} state was registered at lock_acquire+0x240/0x728 kernel/locking/lockdep.c5759 __raw_spin_lock include/linux/spinlock_api_smp.h133 [inline] _raw_spin_lock+0x48/0x60 kernel/locking/spinlock.c154 spin_lock include/linux/spinlock.h351 [inline] ppp_channel_bridge_input drivers/net/ppp/ppp_generic.c2272 [inline] ppp_input+0x16c/0x854 drivers/net/ppp/ppp_generic.c2304 pppoe_rcv_core+0xfc/0x314 drivers/net/ppp/pppoe.c379 sk_backlog_rcv include/net/sock.h1111 [inline] __release_sock+0x1a8/0x3d8 net/core/sock.c3004 release_sock+0x68/0x1b8 net/core/sock.c3558 pppoe_sendmsg+0xc8/0x5d8 drivers/net/ppp/pppoe.c903 sock_sendmsg_nosec net/socket.c730 [inline] __sock_sendmsg net/socket.c745 [inline] __sys_sendto+0x374/0x4f4 net/socket.c2204 __do_sys_sendto net/socket.c2216 [inline] __se_sys_sendto net/socket.c2212 [inline] __arm64_sys_sendto+0xd8/0xf8 net/socket.c2212 __invoke_syscall arch/arm64/kernel/syscall.c35 [inline] invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c49 el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c132 do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c151 el0_svc+0x54/0x168 arch/arm64/kernel/entry-common.c712 el0t_64_sync_handler+0x84/0xfc arch/arm64/kernel/entry-common.c730 el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S598 irq event stamp 282914 hardirqs last enabled at (282914) [] __raw_spin_unlock_irqrestore include/linux/spinlock_api_smp.h151 [inline] hardirqs last enabled at (282914) [] _raw_spin_unlock_irqrestore+0x38/0x98 kernel/locking/spinlock.c194 hardirqs last disabled at (282913) [] __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h108 [inline] hardirqs last disabled at (282913) [] _raw_spin_lock_irqsave+0x2c/0x7c kernel/locking/spinlock.c162 softirqs last enabled at (282904) [] softirq_handle_end kernel/softirq.c400 [inline] softirqs last enabled at (282904) [] handle_softirqs+0xa3c/0xbfc kernel/softirq.c582 softirqs last disabled at (282909) [] run_ksoftirqd+0x70/0x158 kernel/softirq.c928 other info that might help us debug this Possible unsafe locking scenario CPU0 ---- lock(&pch->downl) lock(&pch->downl) *** DEADLOCK *** 1 lock held by ksoftirqd/1/24 #0 ffff80008f74dfa0 (rcu_read_lock){....}-{12}, at rcu_lock_acquire+0x10/0x4c include/linux/rcupdate.h325 stack backtrace CPU 1 UID 0 PID 24 Comm ksoftirqd/1 Not tainted 6.11.0-rc7-syzkaller-g5f5673607153 #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024 Call trace dump_backtrace+0x1b8/0x1e4 arch/arm64/kernel/stacktrace.c319 show_stack+0x2c/0x3c arch/arm64/kernel/stacktrace.c326 __dump_sta ---truncated---",
  "key_phrases": {
    "rootcause": "The ppp_channel_bridge_input function in the Linux kernel's PPP implementation does not properly handle cases where it is called from a process context, leading to a potential lock state inconsistency and deadlock.",
    "weakness": "The ppp_channel_bridge_input function assumes it is always called from a bottom half (BH) handler, which is not always the case. This function uses a spinlock (`pch->downl`) without considering that it might be called in a process context, which leads to re-entrancy of the lock and deadlock",
    "impact": "A deadlock can occur, leading to a denial of service. The system may become unresponsive as the ksoftirqd process is stuck waiting for a lock it already holds.",
    "vector": "The vulnerability is triggered through the network stack when receiving a PPP packet, especially when the socket is owned by a user process. The vulnerability is reachable by sending a crafted PPP packet.",
    "attacker": "A remote attacker who can send crafted PPP packets or a malicious local process.",
    "product": "Linux Kernel",
    "version": "6.11.0-rc7",
    "component": "PPP implementation in drivers/net/ppp/ppp_generic.c and drivers/net/ppp/pppoe.c"
  },
  "reference_content": "```\n{\n  \"vulnerability\": {\n    \"root_cause\": \"The `ppp_channel_bridge_input()` function in the Linux kernel's PPP (Point-to-Point Protocol) implementation incorrectly assumed that it was always called from a bottom half (BH) context. However, certain network protocols might cause the function to be invoked from a process context, leading to a locking conflict.\",\n    \"weaknesses\": [\n      \"Incorrect assumption about execution context\",\n       \"Inconsistent lock state\"\n    ],\n    \"impact\": \"A deadlock could occur due to the incorrect locking, leading to a denial-of-service.\",\n    \"attack_vectors\": \"The vulnerability can be triggered via the network stack when processing PPP packets, particularly when the socket is owned by a user process and packets are stored in the socket backlog. Specifically, it involves the interaction of `release_sock()`, `__release_sock()`, and `sk_backlog_rcv()`.\",\n    \"required_capabilities\": \"An attacker would need to be able to send network traffic to a vulnerable system in a way that triggers the described call flow involving ppp and socket backlogs. This could be through regular network connections, possibly using PPPoE.\"\n  },\n  \"affected_code\": {\n    \"file\": \"drivers/net/ppp/ppp_generic.c\",\n    \"vulnerable_lines\": [\n        \"spin_lock(&pchb->downl);\",\n        \"spin_unlock(&pchb->downl);\"\n    ],\n    \"fixed_lines\":[\n      \"spin_lock_bh(&pchb->downl);\",\n      \"spin_unlock_bh(&pchb->downl);\"\n    ],\n        \"description\": \"The original code used `spin_lock` and `spin_unlock`, which are not appropriate for bottom half context where they should be using `spin_lock_bh` and `spin_unlock_bh` which disable softirqs to prevent re-entrance. This is because the function can be invoked outside of bottom half context.\"\n  },\n    \"additional_info\": \"The vulnerability was detected by syzbot, a Linux kernel fuzzer. The fix involves using bottom-half aware spinlock functions, `spin_lock_bh()` and `spin_unlock_bh()`, instead of `spin_lock()` and `spin_unlock()`. This ensures that softirqs are disabled when acquiring the spinlock, preventing a deadlock if the code is called from both process and softirq context.\"\n}\n```",
  "similar_info": {
    "cwe_distribution": {},
    "cwe_consensus": "",
    "similarity_stats": {
      "thresholds": [],
      "total_samples_by_threshold": {},
      "top_cwes_by_threshold": {}
    }
  },
  "similarity_summary": {
    "consensus_cwe": "",
    "top_cwes": [],
    "confidence_levels": {},
    "total_samples": 0
  },
  "analysis": "# Summary\n| CWE ID  | CWE Name                                                                                                 | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |\n| :------- | :------------------------------------------------------------------------------------------------------- | :--------- | :---------------------- | :------------------------------ | :------------------------------ |\n| CWE-833 | Deadlock                                                                                                 | 0.95       | Base                    | Primary                         | Allowed                         |\n| CWE-667 | Improper Locking                                                                                         | 0.80       | Class                   | Secondary                       | Allowed-with-Review           |\n\n## Evidence and Confidence\n\n*   **Confidence Score:** 0.90\n*   **Evidence Strength:** HIGH\n\n## Relationship Analysis\n\nThe primary weakness is **CWE-833 Deadlock**, which is caused by **improper locking** as described in **CWE-667**. **CWE-667** is a Class, and **CWE-833** is a Base, making **CWE-833** the more specific choice. The relationship is that **CWE-833** is a child of **CWE-667**.\n\n```mermaid\ngraph TD\n    cwe833[\"CWE-833: Deadlock\"]\n    cwe667[\"CWE-667: Improper Locking\"]\n    \n    cwe833 -->|CHILDOF| cwe667\n    \n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    class cwe833 primary\n    class cwe667 secondary\n```\n\n## Vulnerability Chain\n\nThe vulnerability chain starts with the **improper locking** (**CWE-667**) in `ppp_channel_bridge_input()`, which leads to a **deadlock** (**CWE-833**) when the function is called from both process and softirq context.\n  - **Root Cause:** **Improper locking** (**CWE-667**) due to an incorrect assumption about the execution context.\n  - **Weakness:** **Deadlock** (**CWE-833**) caused by re-entrancy of the lock.\n  - **Impact:** Denial of service due to system unresponsiveness.\n\n## Summary of Analysis\n\nThe primary cause of the vulnerability is the potential for deadlock in `ppp_channel_bridge_input()` because it **incorrectly assumes** it's always called from a bottom half (BH) context. The code attempts to acquire a spinlock (`pch->downl`) without properly accounting for the possibility of being called in a process context. This leads to a re-entrancy issue and ultimately a deadlock.\n\nThe **Vulnerability Description** states that:\n\"ppp do not assume bh is held in ppp_channel_bridge_input()\" and \"ppp was not considering this case in ppp_channel_bridge_input() WARNING inconsistent lock state\" which supports the deadlock condition.\n\nThe **CVE Reference Links Content Summary** states that:\n\"The `ppp_channel_bridge_input()` function in the Linux kernel's PPP (Point-to-Point Protocol) implementation **incorrectly assumed** that it was always called from a bottom half (BH) context. However, certain network protocols might cause the function to be invoked from a process context, leading to a locking conflict.\" and \"A **deadlock** could occur due to the incorrect locking, leading to a denial-of-service.\"\n\n**CWE-833 Deadlock** is the most appropriate primary CWE because the vulnerability's root cause directly leads to a deadlock scenario. The function's incorrect assumption about the execution context and subsequent improper locking creates a situation where the system can become unresponsive due to threads waiting for each other indefinitely. **CWE-667 Improper Locking** is a secondary CWE that describes the underlying cause of the deadlock.\n\nOther CWEs considered:\n\n*   **CWE-362 Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')**: While a race condition might be present, the ultimate outcome is a deadlock, making **CWE-833** a more precise classification.\n*   **CWE-476 NULL Pointer Dereference**: There is no mention of NULL pointer dereference in the description.\n*   **CWE-770 Allocation of Resources Without Limits or Throttling**: There is no mention of resource allocation limits.\n*   **CWE-911 Improper Update of Reference Count**: There is no mention of reference counts.\n\nThe selected CWEs are at the optimal level of specificity. **CWE-833** is a Base level CWE that directly describes the deadlock condition, while **CWE-667** is a Class level CWE that describes the general category of improper locking.",
  "analysis_with_relationships": "# Summary\n| CWE ID  | CWE Name                                                                                                 | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |\n| :------- | :------------------------------------------------------------------------------------------------------- | :--------- | :---------------------- | :------------------------------ | :------------------------------ |\n| CWE-833 | Deadlock                                                                                                 | 0.95       | Base                    | Primary                         | Allowed                         |\n| CWE-667 | Improper Locking                                                                                         | 0.80       | Class                   | Secondary                       | Allowed-with-Review           |\n\n## Evidence and Confidence\n\n*   **Confidence Score:** 0.90\n*   **Evidence Strength:** HIGH\n\n## Relationship Analysis\n\nThe primary weakness is **CWE-833 Deadlock**, which is caused by **improper locking** as described in **CWE-667**. **CWE-667** is a Class, and **CWE-833** is a Base, making **CWE-833** the more specific choice. The relationship is that **CWE-833** is a child of **CWE-667**.\n\n```mermaid\ngraph TD\n    cwe833[\"CWE-833: Deadlock\"]\n    cwe667[\"CWE-667: Improper Locking\"]\n    \n    cwe833 -->|CHILDOF| cwe667\n    \n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    class cwe833 primary\n    class cwe667 secondary\n```\n\n## Vulnerability Chain\n\nThe vulnerability chain starts with the **improper locking** (**CWE-667**) in `ppp_channel_bridge_input()`, which leads to a **deadlock** (**CWE-833**) when the function is called from both process and softirq context.\n  - **Root Cause:** **Improper locking** (**CWE-667**) due to an incorrect assumption about the execution context.\n  - **Weakness:** **Deadlock** (**CWE-833**) caused by re-entrancy of the lock.\n  - **Impact:** Denial of service due to system unresponsiveness.\n\n## Summary of Analysis\n\nThe primary cause of the vulnerability is the potential for deadlock in `ppp_channel_bridge_input()` because it **incorrectly assumes** it's always called from a bottom half (BH) context. The code attempts to acquire a spinlock (`pch->downl`) without properly accounting for the possibility of being called in a process context. This leads to a re-entrancy issue and ultimately a deadlock.\n\nThe **Vulnerability Description** states that:\n\"ppp do not assume bh is held in ppp_channel_bridge_input()\" and \"ppp was not considering this case in ppp_channel_bridge_input() WARNING inconsistent lock state\" which supports the deadlock condition.\n\nThe **CVE Reference Links Content Summary** states that:\n\"The `ppp_channel_bridge_input()` function in the Linux kernel's PPP (Point-to-Point Protocol) implementation **incorrectly assumed** that it was always called from a bottom half (BH) context. However, certain network protocols might cause the function to be invoked from a process context, leading to a locking conflict.\" and \"A **deadlock** could occur due to the incorrect locking, leading to a denial-of-service.\"\n\n**CWE-833 Deadlock** is the most appropriate primary CWE because the vulnerability's root cause directly leads to a deadlock scenario. The function's incorrect assumption about the execution context and subsequent improper locking creates a situation where the system can become unresponsive due to threads waiting for each other indefinitely. **CWE-667 Improper Locking** is a secondary CWE that describes the underlying cause of the deadlock.\n\nOther CWEs considered:\n\n*   **CWE-362 Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')**: While a race condition might be present, the ultimate outcome is a deadlock, making **CWE-833** a more precise classification.\n*   **CWE-476 NULL Pointer Dereference**: There is no mention of NULL pointer dereference in the description.\n*   **CWE-770 Allocation of Resources Without Limits or Throttling**: There is no mention of resource allocation limits.\n*   **CWE-911 Improper Update of Reference Count**: There is no mention of reference counts.\n\nThe selected CWEs are at the optimal level of specificity. **CWE-833** is a Base level CWE that directly describes the deadlock condition, while **CWE-667** is a Class level CWE that describes the general category of improper locking.\n\n\n## CWE Relationship Analysis\n\nCurrent CWEs represent these abstraction levels: .\n\n\n### Vulnerability Chain Analysis\n\n**Chain starting from CWE-476:**\n- 476 (NULL Pointer Dereference) - ROOT\n\n\n**Chain starting from CWE-911:**\n- 911 (Improper Update of Reference Count) - ROOT\n\n\n\n### CWE Relationship Diagram\n\n```mermaid\ngraph TD\n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    classDef tertiary fill:#9e9,stroke:#333\n```",
  "criticism": "",
  "resolution": "",
  "relevant_cwes": [
    {
      "metadata": {
        "doc_id": "667",
        "name": "Improper Locking",
        "source": "sparse"
      },
      "similarity": 1332.3816313848338
    },
    {
      "metadata": {
        "doc_id": "362",
        "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
        "source": "sparse"
      },
      "similarity": 1219.0805802007694
    },
    {
      "metadata": {
        "doc_id": "476",
        "name": "NULL Pointer Dereference",
        "source": "sparse"
      },
      "similarity": 1137.9814240211176
    },
    {
      "metadata": {
        "doc_id": "401",
        "name": "Missing Release of Memory after Effective Lifetime",
        "source": "sparse"
      },
      "similarity": 1132.1962860000642
    },
    {
      "metadata": {
        "doc_id": "909",
        "name": "Missing Initialization of Resource",
        "source": "sparse"
      },
      "similarity": 1131.0879922766749
    },
    {
      "metadata": {
        "doc_id": "911",
        "name": "Improper Update of Reference Count",
        "source": "sparse"
      },
      "similarity": 1127.9603071157144
    },
    {
      "metadata": {
        "doc_id": "770",
        "name": "Allocation of Resources Without Limits or Throttling",
        "source": "sparse"
      },
      "similarity": 1103.3448266821515
    },
    {
      "metadata": {
        "doc_id": "833",
        "name": "Deadlock",
        "source": "sparse"
      },
      "similarity": 1098.0626340091926
    },
    {
      "metadata": {
        "doc_id": "1285",
        "name": "Improper Validation of Specified Index, Position, or Offset in Input",
        "type": "Base",
        "original_content": "The product receives input that is expected to specify an index, position, or offset into an indexable resource such as a buffer or file, but it does not validate or incorrectly validates that the specified index/position/offset has the required properties.",
        "keyphrase_source": "weakness:The ppp_channel_bridge_input function assumes it is always called from a bottom half (BH) handler",
        "source": "dense",
        "mapping_notes": {
          "usage": "Allowed",
          "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
          "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
          "reasons": [
            "Acceptable-Use"
          ]
        },
        "score_info": {
          "retrievers": [
            "dense",
            "graph"
          ],
          "retriever_count": 2,
          "normalized_scores": {
            "dense": 0.5479001847172275,
            "graph": 1.6316077628983676
          }
        }
      },
      "similarity": 0.5479001847172275
    },
    {
      "doc_id": "129",
      "text": "CWE-129: Improper Validation of Array Index",
      "score": 2.2704,
      "metadata": {
        "doc_id": "129",
        "name": "Improper Validation of Array Index",
        "type": "variant",
        "original_content": "CWE-129: Improper Validation of Array Index",
        "relationships": [
          {
            "source_id": "129",
            "target_id": "789",
            "label": "CANPRECEDE",
            "properties": {
              "view_id": "1000"
            }
          },
          {
            "source_id": "129",
            "target_id": "823",
            "label": "CANPRECEDE",
            "properties": {
              "view_id": "1000"
            }
          },
          {
            "source_id": "129",
            "target_id": "119",
            "label": "CANPRECEDE",
            "properties": {
              "view_id": "1000"
            }
          },
          {
            "source_id": "129",
            "target_id": "20",
            "label": "CHILDOF",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1003"
            }
          },
          {
            "source_id": "129",
            "target_id": "1285",
            "label": "CHILDOF",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          },
          {
            "source_id": "823",
            "target_id": "129",
            "label": "CANFOLLOW",
            "properties": {
              "view_id": "1000"
            }
          },
          {
            "source_id": "789",
            "target_id": "129",
            "label": "CANFOLLOW",
            "properties": {
              "view_id": "1000"
            }
          },
          {
            "source_id": "20",
            "target_id": "129",
            "label": "PARENTOF",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1003"
            }
          },
          {
            "source_id": "1285",
            "target_id": "129",
            "label": "PARENTOF",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          },
          {
            "source_id": "119",
            "target_id": "129",
            "label": "CANFOLLOW",
            "properties": {
              "view_id": "1000"
            }
          }
        ],
        "score_components": {
          "relationship_chain": 0.8,
          "abstraction_path": 0.76,
          "sequence_path": 0.8
        },
        "abstraction_factor": 1.2,
        "graph_path_info": {
          "path_types": [
            "relationship_chain",
            "abstraction_path_down",
            "vulnerability_sequence_forward",
            "vulnerability_sequence_backward"
          ],
          "best_paths": {
            "relationship_chain": {
              "path": [
                [
                  "476",
                  "789",
                  "CANFOLLOW"
                ],
                [
                  "789",
                  "129",
                  "CANFOLLOW"
                ]
              ],
              "score": 0.8,
              "type": "relationship_chain",
              "source": "476"
            },
            "abstraction_path_down": {
              "path": [
                [
                  "1285",
                  "129",
                  "PARENTOF"
                ]
              ],
              "score": 0.76,
              "type": "abstraction_path_down",
              "source": "1285"
            },
            "vulnerability_sequence_forward": {
              "path": [
                [
                  "476",
                  "789",
                  "CANFOLLOW"
                ],
                [
                  "789",
                  "129",
                  "CANFOLLOW"
                ]
              ],
              "score": 0.7200000000000001,
              "type": "vulnerability_sequence_forward",
              "source": "476"
            },
            "vulnerability_sequence_backward": {
              "path": [
                [
                  "789",
                  "476",
                  "CANPRECEDE"
                ],
                [
                  "129",
                  "789",
                  "CANPRECEDE"
                ]
              ],
              "score": 0.8,
              "type": "vulnerability_sequence_backward",
              "source": "476"
            }
          }
        },
        "abstraction_level": "variant",
        "position": "after",
        "sources": [
          "graph"
        ],
        "source": "graph",
        "mapping_notes": {
          "usage": "Allowed",
          "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
          "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
          "reasons": [
            "Acceptable-Use"
          ]
        },
        "score_info": {
          "retrievers": [
            "graph"
          ],
          "retriever_count": 1,
          "normalized_scores": {
            "graph": 2.2704
          }
        }
      },
      "similarity": 2.2704
    }
  ],
  "identified_cwes": {
    "analyzer": [
      "CWE-476",
      "CWE-911",
      "CWE-770",
      "CWE-667",
      "CWE-833",
      "CWE-362"
    ],
    "critic_additional": []
  },
  "keyphrase_cwe_mapping": {}
}