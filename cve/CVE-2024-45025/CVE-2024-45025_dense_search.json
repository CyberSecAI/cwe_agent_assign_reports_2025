{
  "retriever": "dense",
  "query": "In the Linux kernel, the following vulnerability has been resolved fix bitmap corruption on close_range() with CLOSE_RANGE_UNSHARE copy_fd_bitmaps(new, old, count) is expected to copy the first count/BITS_PER_LONG bits from old->full_fds_bits[] and fill the rest with zeroes. What it does is copying enough words (BITS_TO_LONGS(count/BITS_PER_LONG)), then memsets the rest. That works fine, *if* all bits past the cutoff point are clear. Otherwise we are risking garbage from the last word wed copied. For most of the callers that is true - expand_fdtable() has count equal to old->max_fds, so theres no open descriptors past count, let alone fully occupied words in ->open_fds[], which is what bits in ->full_fds_bits[] correspond to. The other caller (dup_fd()) passes sane_fdtable_size(old_fdt, max_fds), which is the smallest multiple of BITS_PER_LONG that covers all opened descriptors below max_fds. In the common case (copying on fork()) max_fds is ~0U, so all opened descriptors will be below it and we are fine, by the same reasons why the call in expand_fdtable() is safe. Unfortunately, there is a case where max_fds is less than that and where we might, indeed, end up with junk in ->full_fds_bits[] - close_range(from, to, CLOSE_RANGE_UNSHARE) with * descriptor table being currently shared * to being above the current capacity of descriptor table * from being just under some chunk of opened descriptors. In that case we end up with observably wrong behaviour - e.g. spa",
  "keyphrases": {
    "weakness": [
      "bitmap corruption"
    ]
  },
  "timestamp": "2025-07-13 15:54:53",
  "cve_id": "CVE-2024-45025",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "403",
      "name": "Exposure of File Descriptor to Unintended Control Sphere ('File Descriptor Leak')",
      "type": "Base",
      "score": 0.505160129765744
    },
    {
      "cwe_id": "911",
      "name": "Improper Update of Reference Count",
      "type": "Base",
      "score": 0.48491171359701435
    },
    {
      "cwe_id": "1260",
      "name": "Improper Handling of Overlap Between Protected Memory Ranges",
      "type": "Base",
      "score": 0.481167860618986
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 0.48069899375192815
    },
    {
      "cwe_id": "1316",
      "name": "Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges",
      "type": "Base",
      "score": 0.4762283397986746
    },
    {
      "cwe_id": "191",
      "name": "Integer Underflow (Wrap or Wraparound)",
      "type": "Base",
      "score": 0.4738707090331512
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "type": "Class",
      "score": 0.4714940810848903
    },
    {
      "cwe_id": "823",
      "name": "Use of Out-of-range Pointer Offset",
      "type": "Base",
      "score": 0.4703573217052842
    },
    {
      "cwe_id": "190",
      "name": "Integer Overflow or Wraparound",
      "type": "Base",
      "score": 0.4674689007583165
    },
    {
      "cwe_id": "689",
      "name": "Permission Race Condition During Resource Copy",
      "type": "Compound",
      "score": 0.4672734414448571
    },
    {
      "cwe_id": "805",
      "name": "Buffer Access with Incorrect Length Value",
      "type": "Base",
      "score": 0.454435985214401
    },
    {
      "cwe_id": "126",
      "name": "Buffer Over-read",
      "type": "Variant",
      "score": 0.452078174586789
    },
    {
      "cwe_id": "1335",
      "name": "Incorrect Bitwise Shift of Integer",
      "type": "Base",
      "score": 0.4504363523359343
    },
    {
      "cwe_id": "127",
      "name": "Buffer Under-read",
      "type": "Variant",
      "score": 0.4497243293692853
    },
    {
      "cwe_id": "789",
      "name": "Memory Allocation with Excessive Size Value",
      "type": "Variant",
      "score": 0.4489264601956293
    },
    {
      "cwe_id": "131",
      "name": "Incorrect Calculation of Buffer Size",
      "type": "Base",
      "score": 0.44851396812577266
    },
    {
      "cwe_id": "366",
      "name": "Race Condition within a Thread",
      "type": "Base",
      "score": 0.44724321301698194
    },
    {
      "cwe_id": "775",
      "name": "Missing Release of File Descriptor or Handle after Effective Lifetime",
      "type": "Variant",
      "score": 0.4472151404084247
    },
    {
      "cwe_id": "124",
      "name": "Buffer Underwrite ('Buffer Underflow')",
      "type": "Base",
      "score": 0.44689182838399644
    },
    {
      "cwe_id": "125",
      "name": "Out-of-bounds Read",
      "type": "Base",
      "score": 0.4465390298790307
    }
  ]
}