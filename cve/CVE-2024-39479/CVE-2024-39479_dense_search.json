{
  "retriever": "dense",
  "query": "In the Linux kernel, the following vulnerability has been resolved drm/i915/hwmon Get rid of devm When both hwmon and hwmon drvdata (on which hwmon depends) are device managed resources, the expectation, on device unbind, is that hwmon will be released before drvdata. However, in i915 there are two separate code paths, which both release either drvdata or hwmon and either can be released before the other. These code paths (for device unbind) are as follows (see also the bug referenced below) Call Trace release_nodes+0x11/0x70 devres_release_group+0xb2/0x110 component_unbind_all+0x8d/0xa0 component_del+0xa5/0x140 intel_pxp_tee_component_fini+0x29/0x40 [i915] intel_pxp_fini+0x33/0x80 [i915] i915_driver_remove+0x4c/0x120 [i915] i915_pci_remove+0x19/0x30 [i915] pci_device_remove+0x32/0xa0 device_release_driver_internal+0x19c/0x200 unbind_store+0x9c/0xb0 and Call Trace release_nodes+0x11/0x70 devres_release_all+0x8a/0xc0 device_unbind_cleanup+0x9/0x70 device_release_driver_internal+0x1c1/0x200 unbind_store+0x9c/0xb0 This means that in i915, if use devm, we cannot gurantee that hwmon will always be released before drvdata. Which means that we have a uaf if hwmon sysfs is accessed when drvdata has been released but hwmon hasnt. The only way out of this seems to be do get rid of devm_ and release/free everything explicitly during device unbind. v2 Change commit message and other minor code changes v3 Cleanup from i915_hwmon_register on error (Armin Wolf) v4 Eliminate",
  "keyphrases": {
    "weakness": [
      "Use-After-Free"
    ]
  },
  "timestamp": "2025-07-13 11:27:30",
  "cve_id": "CVE-2024-39479",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "909",
      "name": "Missing Initialization of Resource",
      "type": "Class",
      "score": 0.4775449774291993
    },
    {
      "cwe_id": "908",
      "name": "Use of Uninitialized Resource",
      "type": "Base",
      "score": 0.471492095318032
    },
    {
      "cwe_id": "1256",
      "name": "Improper Restriction of Software Interfaces to Hardware Features",
      "type": "Base",
      "score": 0.45753123533710904
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "type": "Class",
      "score": 0.4562260115744071
    },
    {
      "cwe_id": "775",
      "name": "Missing Release of File Descriptor or Handle after Effective Lifetime",
      "type": "Variant",
      "score": 0.4512651910960156
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 0.45123519127946615
    },
    {
      "cwe_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "type": "Base",
      "score": 0.4470296040680699
    },
    {
      "cwe_id": "1264",
      "name": "Hardware Logic with Insecure De-Synchronization between Control and Data Channels",
      "type": "Base",
      "score": 0.4469151546655913
    },
    {
      "cwe_id": "1190",
      "name": "DMA Device Enabled Too Early in Boot Phase",
      "type": "Base",
      "score": 0.4443592463063244
    },
    {
      "cwe_id": "413",
      "name": "Improper Resource Locking",
      "type": "Base",
      "score": 0.44302472529064263
    },
    {
      "cwe_id": "401",
      "name": "Missing Release of Memory after Effective Lifetime",
      "type": "Variant",
      "score": 0.41703255440838094
    },
    {
      "cwe_id": "782",
      "name": "Exposed IOCTL with Insufficient Access Control",
      "type": "Variant",
      "score": 0.41664532330993675
    },
    {
      "cwe_id": "119",
      "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
      "type": "Class",
      "score": 0.41663608978319416
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 0.4127045782806822
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "type": "Variant",
      "score": 0.409930477622095
    },
    {
      "cwe_id": "911",
      "name": "Improper Update of Reference Count",
      "type": "Base",
      "score": 0.4071795383279287
    },
    {
      "cwe_id": "126",
      "name": "Buffer Over-read",
      "type": "Variant",
      "score": 0.40717307660013713
    },
    {
      "cwe_id": "1301",
      "name": "Insufficient or Incomplete Data Removal within Hardware Component",
      "type": "Base",
      "score": 0.4030116338236691
    },
    {
      "cwe_id": "122",
      "name": "Heap-based Buffer Overflow",
      "type": "Variant",
      "score": 0.4020781273147854
    },
    {
      "cwe_id": "787",
      "name": "Out-of-bounds Write",
      "type": "Base",
      "score": 0.4017687347734624
    }
  ]
}