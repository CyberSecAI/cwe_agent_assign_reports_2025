## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved netpoll Fix **race condition in netpoll_owner_active** KCSAN detected a race condition in netpoll BUG KCSAN data-race in net_rx_action / netpoll_send_skb write (marked) to 0xffff8881164168b0 of 4 bytes by interrupt on cpu 10 net_rx_action (./include/linux/netpoll.h90 net/core/dev.c6712 net/core/dev.c6822) read to 0xffff8881164168b0 of 4 bytes by task 1 on cpu 2 netpoll_send_skb (net/core/netpoll.c319 net/core/netpoll.c345 net/core/netpoll.c393) netpoll_send_udp (net/core/netpoll.c?) value changed 0x0000000a -> 0xffffffff This happens because netpoll_owner_active() needs to check if the current CPU is the owner of the lock, touching napi->poll_owner non atomically. The ->poll_owner field contains the current CPU holding the lock. Use an atomic read to check if the poll owner is the current CPU.

### Vulnerability Description Key Phrases
- **rootcause:** **race condition in netpoll_owner_active**
- **impact:** data-race in net_rx_action/netpoll_send_skb
- **product:** Linux kernel

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of the vulnerability:

**Root Cause:**
- The `netpoll_owner_active()` function in the Linux kernel's netpoll module checks if the current CPU is the owner of the lock.
- It accesses the `napi->poll_owner` field non-atomically. This field holds the ID of the CPU currently holding the lock.
- Because the access is non-atomic, a race condition can occur when an interrupt modifies the `napi->poll_owner` field at the same time that another task is reading from it, leading to data corruption.

**Weaknesses/Vulnerabilities:**
- **Data Race:** A classic race condition vulnerability exists where multiple threads/processes can access shared data (`napi->poll_owner`) concurrently, with at least one of the accesses being a write without proper synchronization.
- **Non-atomic Access:** The `napi->poll_owner` field was being accessed without using atomic operations.

**Impact of Exploitation:**
- **Kernel Panic/Crash:** The KCSAN (Kernel Concurrency Sanitizer) detected a data race causing a change in the `poll_owner` value (0x0000000a -> 0xffffffff). This indicates a severe data corruption issue that can lead to a kernel crash or undefined behavior, causing a denial of service.

**Attack Vectors:**
- This isn't an easily exploitable vulnerability for a malicious actor but rather a bug in the code that can trigger under certain conditions.
- The vulnerability arises within the kernel itself due to concurrent access to a shared memory location.
- Exploitation would involve triggering the race condition, which involves having the `net_rx_action` interrupt handler write to `napi->poll_owner` at the same time that another task, like `netpoll_send_skb`, attempts to read it.

**Required Attacker Capabilities/Position:**
- The vulnerability is within the kernel code and not something that can be triggered by a remote user, or an application, making the vulnerability primarily a stability issue rather than an attack vector.
- It's triggered by specific network activities that use netpoll and involve multiple CPUs.

**Additional Notes:**
- The fix replaces the direct read of `napi->poll_owner` with `READ_ONCE(napi->poll_owner)`. `READ_ONCE` is a macro that performs an atomic read, thus preventing the race condition.
- The provided logs include KCSAN output showing the specific read/write race condition with code locations.
- Multiple commits (c2e6a872bde9912f1a7579639c5ca3adf1003916, 43c0ca793a18578a0f5b305dd77fcf7ed99f1265, 96826b16ef9c6568d31a1f6ceaa266411a46e46c, efd29cd9c7b8369dfc7bcb34637e6bf1a188aa8e, 3f1a155950a1685ffd0fd7175b3f671da8771f3d, a130e7da73ae93afdb4659842267eec734ffbd57) show the same fix being applied across different kernel versions, which strongly suggests that they all address the same underlying issue.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | alternate_terms | 0.800 |
| 2 | 833 | Deadlock | Base | Allowed | sparse | 0.769 |
| 3 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.637 |
| 4 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.603 |
| 5 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | sparse | 0.599 |
| 6 | 787 | Out-of-bounds Write | Base | Allowed | sparse | 0.580 |
| 7 | 502 | Deserialization of Untrusted Data | Base | Allowed | sparse | 0.568 |
| 8 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | sparse | 0.561 |
| 9 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | Allowed | dense | 0.513 |
| 10 | 609 | Double-Checked Locking | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-833: Deadlock

CWE-667: Improper Locking

CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition

CWE-674: Uncontrolled Recursion

CWE-787: Out-of-bounds Write

CWE-502: Deserialization of Untrusted Data

CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer

CWE-1285: Improper Validation of Specified Index, Position, or Offset in Input

CWE-609: Double-Checked Locking