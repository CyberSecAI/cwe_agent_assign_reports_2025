# Vulnerability Information: CVE-2024-38557

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved net/mlx5 Reload only IB representors upon lag disable/enable On lag disable, the bond IB device along with all of its representors are destroyed, and then the slaves representors get reloaded. In case the slave IB representor load fails, the eswitch error flow unloads all representors, including ethernet representors, where the netdevs get detached and removed from lag bond. Such flow is inaccurate as the lag driver is not responsible for loading/unloading ethernet representors. Furthermore, the flow described above begins by holding lag lock to prevent bond changes during disable flow. However, when reaching the ethernet representors detachment from lag, the lag lock is required again, triggering the following **deadlock** Call trace __switch_to+0xf4/0x148 __schedule+0x2c8/0x7d0 schedule+0x50/0xe0 schedule_preempt_disabled+0x18/0x28 __mutex_lock.isra.13+0x2b8/0x570 __mutex_lock_slowpath+0x1c/0x28 mutex_lock+0x4c/0x68 mlx5_lag_remove_netdev+0x3c/0x1a0 [mlx5_core] mlx5e_uplink_rep_disable+0x70/0xa0 [mlx5_core] mlx5e_detach_netdev+0x6c/0xb0 [mlx5_core] mlx5e_netdev_change_profile+0x44/0x138 [mlx5_core] mlx5e_netdev_attach_nic_profile+0x28/0x38 [mlx5_core] mlx5e_vport_rep_unload+0x184/0x1b8 [mlx5_core] mlx5_esw_offloads_rep_load+0xd8/0xe0 [mlx5_core] mlx5_eswitch_reload_reps+0x74/0xd0 [mlx5_core] mlx5_disable_lag+0x130/0x138 [mlx5_core] mlx5_lag_disable_change+0x6c/0x70 [mlx5_core] // hold ldev->lock mlx5_de

### Vulnerability Description Key Phrases
- **weakness:** **deadlock**
- **product:** Linux kernel
- **component:** net/mlx5

## CVE Reference Links Content Summary
Based on the provided content, here's a breakdown of the vulnerability:

**Root Cause:**

- The vulnerability stems from an incorrect flow in the mlx5 driver when a LAG (Link Aggregation Group) is disabled. The driver attempts to unload all representors, including Ethernet representors, which are not its responsibility to manage. This leads to a deadlock.

**Weaknesses/Vulnerabilities:**

-   **Deadlock:** The core issue is a deadlock caused by acquiring the lag lock twice in the disable flow. The first lock is held at the start of the disable operation and then the code attempts to acquire the lock again when detaching Ethernet representors, leading to a deadlock.
-   **Incorrect Representor Management:** The mlx5 driver incorrectly attempts to unload Ethernet representors when disabling a LAG. This is outside the scope of the LAG driver's responsibilities and contributes to the deadlock.
-   **Error Handling:** When a slave IB representor fails to load, the eswitch error flow inaccurately unloads all representors, including ethernet representors.

**Impact of Exploitation:**

-   **System Hang/Denial of Service:** The deadlock results in a system hang, causing a denial of service. The system becomes unresponsive and requires a reboot.

**Attack Vectors:**

- The attack is triggered by disabling a LAG interface. This could be done through various system administration tools, potentially remotely if the attacker has sufficient privileges on the system.
- The specific sequence of operations leading to the deadlock occurs during the eswitch representor reload when a LAG is disabled or enabled.

**Required Attacker Capabilities/Position:**

-   **Privileged Access:** The attacker needs to have sufficient privileges to trigger a LAG disable/enable operation, which usually requires root or administrator access to the system.
-   **Network Configuration Knowledge:** The attacker needs a basic understanding of network configurations and the LAG setup on the system.
-   **Interaction with Netlink:** The call trace shows the issue is triggered through the netlink interface via the `devlink_nl_cmd_eswitch_set_doit` function, so the attacker needs a method to send a netlink message to trigger the vulnerable code path

**Additional Details:**

- The provided code diff shows the fix involves modifying the `mlx5_eswitch_reload_reps` function to only reload the IB (InfiniBand) representors and to skip the Ethernet representors. A static helper `__esw_offloads_load_rep` was also created for symmetry to the unload operation.
-   The commit messages and the call trace provide a clear understanding of the issue.
-   The fix ensures that the LAG driver only manages IB representors, thus preventing the deadlock and incorrect representor management.

The provided content offers more detail than a basic CVE description, detailing the specific functions involved, the locking issues leading to the deadlock, and the exact code modifications used as a fix.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.488 |
| 2 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.482 |
| 3 | 833 | Deadlock | Base | Allowed | sparse | 0.476 |
| 4 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | Allowed | sparse | 0.471 |
| 5 | 400 | Uncontrolled Resource Consumption | Class | Discouraged | sparse | 0.453 |
| 6 | 201 | Insertion of Sensitive Information Into Sent Data | Base | Allowed | sparse | 0.452 |
| 7 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.430 |
| 8 | 212 | Improper Removal of Sensitive Information Before Storage or Transfer | Base | Allowed | sparse | 0.429 |
| 9 | 775 | Missing Release of File Descriptor or Handle after Effective Lifetime | Variant | Allowed | dense | 0.466 |
| 10 | 390 | Detection of Error Condition Without Action | Base | Allowed | graph | 0.002 |

