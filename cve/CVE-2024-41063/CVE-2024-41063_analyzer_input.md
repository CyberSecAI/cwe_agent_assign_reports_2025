# Vulnerability Information: CVE-2024-41063

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved Bluetooth hci_core cancel all works upon hci_unregister_dev() syzbot is reporting that calling hci_release_dev() from hci_error_reset() due to hci_dev_put() from hci_error_reset() can cause **deadlock** at destroy_workqueue(), for hci_error_reset() is called from hdev->req_workqueue which destroy_workqueue() needs to flush. We need to make sure that hdev->{rx_work,cmd_work,tx_work} which are queued into hdev->workqueue and hdev->{power_on,error_reset} which are queued into hdev->req_workqueue are no longer running by the moment destroy_workqueue(hdev->workqueue) destroy_workqueue(hdev->req_workqueue) are called from hci_release_dev(). Call cancel_work_sync() on these work items from hci_unregister_dev() as soon as hdev->list is removed from hci_dev_list.

### Vulnerability Description Key Phrases
- **weakness:** **deadlock**
- **product:** Linux kernel
- **component:** Bluetooth hci_core

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of the vulnerability:

**Root Cause:**

The root cause is a potential deadlock in the Bluetooth HCI core driver during device unregistration. The `hci_error_reset()` function can call `hci_release_dev()` due to `hci_dev_put()`. However, `hci_error_reset()` is executed from a workqueue (`hdev->req_workqueue`) that needs to be flushed before it is destroyed by `destroy_workqueue()` in `hci_release_dev()`, leading to a deadlock.

**Weaknesses/Vulnerabilities Present:**

The core weakness lies in the race condition between work items queued to different workqueues associated with the Bluetooth device (`hdev`). Specifically:
   - `hdev->rx_work`, `hdev->cmd_work`, and `hdev->tx_work` are queued into `hdev->workqueue`.
   - `hdev->power_on` and `hdev->error_reset` are queued into `hdev->req_workqueue`.
   - The `hci_release_dev()` function, which is called during unregistration, attempts to destroy these workqueues which requires the work items to be flushed/cancelled. However, `hci_error_reset()` can be running as a work item in the `hdev->req_workqueue` when `hci_release_dev` tries to destroy it causing a deadlock.
   - The core issue is that the work items are not cancelled/stopped before `destroy_workqueue` is called.

**Impact of Exploitation:**

The impact is a denial-of-service (DoS) condition due to a deadlock. The system would become unresponsive while waiting for the workqueues to be flushed and destroyed, making the Bluetooth functionality unusable.

**Attack Vectors:**

The attack vector involves triggering a specific sequence of events that leads to the execution of `hci_error_reset()` while a Bluetooth device is being unregistered, forcing the problematic code path in `hci_release_dev()` leading to the deadlock. This can be done through normal Bluetooth operations which leads to device error/reset.

**Required Attacker Capabilities/Position:**

An attacker would need to have the ability to interact with Bluetooth devices on the system and cause an error that results in the device being reset and unregistered. This would likely require a local or adjacent network position that allows interaction with the Bluetooth hardware.

**Mitigation:**
The fix introduces calls to `cancel_work_sync()` for all relevant work items (`hdev->rx_work`, `hdev->cmd_work`, `hdev->tx_work`, `hdev->power_on`, and `hdev->error_reset`) within `hci_unregister_dev()` immediately after removing `hdev->list` from the `hci_dev_list` . This ensures that the work items are no longer running before the workqueues are destroyed.

**Additional notes:**
- All the provided content comes from patches addressing the same underlying issue, which indicates that the vulnerability was present in multiple versions of the Linux kernel, requiring backports of the fix.
- The patches were reported by syzbot, a Linux kernel fuzzer which identified the deadlock scenario.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 212 | Improper Removal of Sensitive Information Before Storage or Transfer | Base | Allowed | sparse | 0.372 |
| 2 | 833 | Deadlock | Base | Allowed | sparse | 0.370 |
| 3 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.367 |
| 4 | 1333 | Inefficient Regular Expression Complexity | Base | Allowed | sparse | 0.363 |
| 5 | 863 | Incorrect Authorization | Class | Allowed-with-Review | sparse | 0.363 |
| 6 | 138 | Improper Neutralization of Special Elements | Class | Discouraged | sparse | 0.359 |
| 7 | 61 | UNIX Symbolic Link (Symlink) Following | Compound | Allowed | sparse | 0.357 |
| 8 | 364 | Signal Handler Race Condition | Base | Allowed | sparse | 0.355 |
| 9 | 820 | Missing Synchronization | Base | Allowed | dense | 0.436 |
| 10 | 201 | Insertion of Sensitive Information Into Sent Data | Base | Allowed | graph | 0.002 |

