{
  "cve_id": "CVE-2025-21938",
  "description": "In the Linux kernel, the following vulnerability has been resolved mptcp fix scheduling while atomic in mptcp_pm_nl_append_new_local_addr If multiple connection requests attempt to create an implicit mptcp endpoint in parallel, more than one caller may end up in mptcp_pm_nl_append_new_local_addr because none found the address in local_addr_list during their call to mptcp_pm_nl_get_local_id. In this case, the concurrent new_local_addr calls may delete the address entry created by the previous caller. These deletes use synchronize_rcu, but this is not permitted in some of the contexts where this function may be called. During packet recv, the caller may be in a rcu read critical section and have preemption disabled. An example stack BUG scheduling while atomic swapper/2/0/0x00000302 Call Trace dump_stack_lvl (lib/dump_stack.c117 (discriminator 1)) dump_stack (lib/dump_stack.c124) __schedule_bug (kernel/sched/core.c5943) schedule_debug.constprop.0 (arch/x86/include/asm/preempt.h33 kernel/sched/core.c5970) __schedule (arch/x86/include/asm/jump_label.h27 include/linux/jump_label.h207 kernel/sched/features.h29 kernel/sched/core.c6621) schedule (arch/x86/include/asm/preempt.h84 kernel/sched/core.c6804 kernel/sched/core.c6818) schedule_timeout (kernel/time/timer.c2160) wait_for_completion (kernel/sched/completion.c96 kernel/sched/completion.c116 kernel/sched/completion.c127 kernel/sched/completion.c148) __wait_rcu_gp (include/linux/rcupdate.h311 kernel/rcu/update.c444) synchronize_rcu (kernel/rcu/tree.c3609) mptcp_pm_nl_append_new_local_addr (net/mptcp/pm_netlink.c966 net/mptcp/pm_netlink.c1061) mptcp_pm_nl_get_local_id (net/mptcp/pm_netlink.c1164) mptcp_pm_get_local_id (net/mptcp/pm.c420) subflow_check_req (net/mptcp/subflow.c98 net/mptcp/subflow.c213) subflow_v4_route_req (net/mptcp/subflow.c305) tcp_conn_request (net/ipv4/tcp_input.c7216) subflow_v4_conn_request (net/mptcp/subflow.c651) tcp_rcv_state_process (net/ipv4/tcp_input.c6709) tcp_v4_do_rcv (net/ipv4/tcp_ipv4.c1934) tcp_v4_rcv (net/ipv4/tcp_ipv4.c2334) ip_protocol_deliver_rcu (net/ipv4/ip_input.c205 (discriminator 1)) ip_local_deliver_finish (include/linux/rcupdate.h813 net/ipv4/ip_input.c234) ip_local_deliver (include/linux/netfilter.h314 include/linux/netfilter.h308 net/ipv4/ip_input.c254) ip_sublist_rcv_finish (include/net/dst.h461 net/ipv4/ip_input.c580) ip_sublist_rcv (net/ipv4/ip_input.c640) ip_list_rcv (net/ipv4/ip_input.c675) __netif_receive_skb_list_core (net/core/dev.c5583 net/core/dev.c5631) netif_receive_skb_list_internal (net/core/dev.c5685 net/core/dev.c5774) napi_complete_done (include/linux/list.h37 include/net/gro.h449 include/net/gro.h444 net/core/dev.c6114) igb_poll (drivers/net/ethernet/intel/igb/igb_main.c8244) igb __napi_poll (net/core/dev.c6582) net_rx_action (net/core/dev.c6653 net/core/dev.c6787) handle_softirqs (kernel/softirq.c553) __irq_exit_rcu (kernel/softirq.c588 kernel/softirq.c427 kernel/softirq.c636) irq_exit_rcu (kernel/softirq.c651) common_interrupt (arch/x86/kernel/irq.c247 (discriminator 14)) This problem seems particularly prevalent if the user advertises an endpoint that has a different external vs internal address. In the case where the external address is advertised and multiple connections already exist, multiple subflow SYNs arrive in parallel which tends to trigger the race during creation of the first local_addr_list entries which have the internal address instead. Fix by skipping the replacement of an existing implicit local address if called via mptcp_pm_nl_get_local_id.",
  "key_phrases": {
    "rootcause": "race condition in mptcp_pm_nl_append_new_local_addr function",
    "weakness": "synchronize_rcu in a non-permissible context",
    "impact": "",
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "mptcp_pm_nl_append_new_local_addr function"
  },
  "reference_content": null,
  "similar_info": {
    "cwe_distribution": {},
    "cwe_consensus": "",
    "similarity_stats": {
      "thresholds": [],
      "total_samples_by_threshold": {},
      "top_cwes_by_threshold": {}
    }
  },
  "similarity_summary": {
    "consensus_cwe": "",
    "top_cwes": [],
    "confidence_levels": {},
    "total_samples": 0
  },
  "analysis": "# Summary\n| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |\n|---|---|---|---|---|---|\n| CWE-362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | 0.9 | Class | Allowed-with-Review | Primary CWE. The vulnerability occurs due to multiple connection requests attempting to create an implicit mptcp endpoint in parallel leading to a race condition.|\n| CWE-404 | Improper Resource Shutdown or Release | 0.7 | Class | Allowed-with-Review | Secondary CWE. The concurrent new_local_addr calls may delete the address entry created by the previous caller.|\n\n## Evidence and Confidence\n\n*   **Confidence Score:** 0.8\n*   **Evidence Strength:** HIGH\n\n## Relationship Analysis\nThe primary CWE is CWE-362, a class-level weakness describing a race condition. CWE-404 is a Class-level weakness, which is a potential consequence of the race condition where resources are improperly released.\n\n```mermaid\ngraph TD\n    cwe362[\"CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\"]\n    cwe404[\"CWE-404: Improper Resource Shutdown or Release\"]\n    \n    cwe404 -->|CANFOLLOW| cwe362\n\n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    class cwe362 primary\n    class cwe404 secondary\n```\n\n## Vulnerability Chain\nThe vulnerability chain starts with a **race condition** (CWE-362) due to concurrent connection requests. This leads to the potential improper release of resources (CWE-404).\n\n## Summary of Analysis\nThe primary weakness is a **race condition** (CWE-362) in the `mptcp_pm_nl_append_new_local_addr` function. Multiple connection requests, processed concurrently, can lead to one caller deleting an address entry created by another, resulting in an improper resource shutdown or release (CWE-404).\n\nThe evidence from the vulnerability description includes: \"If multiple connection requests attempt to create an implicit mptcp endpoint in parallel, more than one caller may end up in mptcp_pm_nl_append_new_local_addr because none found the address in local_addr_list during their call to mptcp_pm_nl_get_local_id. In this case, the concurrent new_local_addr calls may delete the address entry created by the previous caller.\"\n\nThe graph relationship shows that CWE-404 can follow CWE-362.\n\nCWE-362 is chosen as the primary CWE because the **race condition** is the root cause of the issue. The deletion of the address entry (CWE-404) is a consequence of the **race condition**.\n\nI considered other CWEs from the Retriever Results, but they were not as relevant.\n- CWE-911: Improper Update of Reference Count - While reference counting might be involved, the core issue is the **race condition** itself.\n- CWE-909: Missing Initialization of Resource - This doesn't fit the scenario described.\n- CWE-667: Improper Locking - While locking might help prevent the **race condition**, the description doesn't explicitly mention improper locking.\n- CWE-415: Double Free - This is a specific type of memory error, and the description doesn't explicitly state that memory is being freed twice.\n\nRelevant CWE Information:\n*   CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\n*   CWE-404: Improper Resource Shutdown or Release",
  "analysis_with_relationships": "# Summary\n| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |\n|---|---|---|---|---|---|\n| CWE-362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | 0.9 | Class | Allowed-with-Review | Primary CWE. The vulnerability occurs due to multiple connection requests attempting to create an implicit mptcp endpoint in parallel leading to a race condition.|\n| CWE-404 | Improper Resource Shutdown or Release | 0.7 | Class | Allowed-with-Review | Secondary CWE. The concurrent new_local_addr calls may delete the address entry created by the previous caller.|\n\n## Evidence and Confidence\n\n*   **Confidence Score:** 0.8\n*   **Evidence Strength:** HIGH\n\n## Relationship Analysis\nThe primary CWE is CWE-362, a class-level weakness describing a race condition. CWE-404 is a Class-level weakness, which is a potential consequence of the race condition where resources are improperly released.\n\n```mermaid\ngraph TD\n    cwe362[\"CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\"]\n    cwe404[\"CWE-404: Improper Resource Shutdown or Release\"]\n    \n    cwe404 -->|CANFOLLOW| cwe362\n\n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    class cwe362 primary\n    class cwe404 secondary\n```\n\n## Vulnerability Chain\nThe vulnerability chain starts with a **race condition** (CWE-362) due to concurrent connection requests. This leads to the potential improper release of resources (CWE-404).\n\n## Summary of Analysis\nThe primary weakness is a **race condition** (CWE-362) in the `mptcp_pm_nl_append_new_local_addr` function. Multiple connection requests, processed concurrently, can lead to one caller deleting an address entry created by another, resulting in an improper resource shutdown or release (CWE-404).\n\nThe evidence from the vulnerability description includes: \"If multiple connection requests attempt to create an implicit mptcp endpoint in parallel, more than one caller may end up in mptcp_pm_nl_append_new_local_addr because none found the address in local_addr_list during their call to mptcp_pm_nl_get_local_id. In this case, the concurrent new_local_addr calls may delete the address entry created by the previous caller.\"\n\nThe graph relationship shows that CWE-404 can follow CWE-362.\n\nCWE-362 is chosen as the primary CWE because the **race condition** is the root cause of the issue. The deletion of the address entry (CWE-404) is a consequence of the **race condition**.\n\nI considered other CWEs from the Retriever Results, but they were not as relevant.\n- CWE-911: Improper Update of Reference Count - While reference counting might be involved, the core issue is the **race condition** itself.\n- CWE-909: Missing Initialization of Resource - This doesn't fit the scenario described.\n- CWE-667: Improper Locking - While locking might help prevent the **race condition**, the description doesn't explicitly mention improper locking.\n- CWE-415: Double Free - This is a specific type of memory error, and the description doesn't explicitly state that memory is being freed twice.\n\nRelevant CWE Information:\n*   CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\n*   CWE-404: Improper Resource Shutdown or Release\n\n\n## CWE Relationship Analysis\n\nCurrent CWEs represent these abstraction levels: .\n\n\n### Vulnerability Chain Analysis\n\n**Chain starting from CWE-911:**\n- 911 (Improper Update of Reference Count) - ROOT\n\n\n**Chain starting from CWE-404:**\n- 404 (Improper Resource Shutdown or Release) - ROOT\n\n\n\n### CWE Relationship Diagram\n\n```mermaid\ngraph TD\n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    classDef tertiary fill:#9e9,stroke:#333\n```",
  "criticism": "",
  "resolution": "",
  "relevant_cwes": [
    {
      "metadata": {
        "doc_id": "362",
        "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
        "source": "alternate_terms",
        "original_matched_text": "AlternateTerms: Race Condition",
        "match_reason": "term_in_phrase_whole_phrase"
      },
      "similarity": 800.0,
      "alternate_term_match": true
    },
    {
      "metadata": {
        "doc_id": "911",
        "name": "Improper Update of Reference Count",
        "source": "sparse"
      },
      "similarity": 1616.1877889669645
    },
    {
      "metadata": {
        "doc_id": "909",
        "name": "Missing Initialization of Resource",
        "source": "sparse"
      },
      "similarity": 1591.5592236239117
    },
    {
      "metadata": {
        "doc_id": "667",
        "name": "Improper Locking",
        "source": "sparse"
      },
      "similarity": 1586.2559000552883
    },
    {
      "metadata": {
        "doc_id": "674",
        "name": "Uncontrolled Recursion",
        "source": "sparse"
      },
      "similarity": 1494.4894171245755
    },
    {
      "metadata": {
        "doc_id": "415",
        "name": "Double Free",
        "source": "sparse"
      },
      "similarity": 1424.2167608489137
    },
    {
      "metadata": {
        "doc_id": "401",
        "name": "Missing Release of Memory after Effective Lifetime",
        "source": "sparse"
      },
      "similarity": 1423.0569150818155
    },
    {
      "metadata": {
        "doc_id": "197",
        "name": "Numeric Truncation Error",
        "source": "sparse"
      },
      "similarity": 1337.5914859223556
    },
    {
      "metadata": {
        "doc_id": "366",
        "name": "Race Condition within a Thread",
        "type": "Base",
        "original_content": "If two threads of execution use a resource simultaneously, there exists the possibility that resources may be used while invalid, in turn making the state of execution undefined.",
        "keyphrase_source": "weakness:synchronize_rcu in a non-permissible context",
        "source": "dense",
        "mapping_notes": {
          "usage": "Allowed",
          "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
          "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
          "reasons": [
            "Acceptable-Use"
          ]
        },
        "score_info": {
          "retrievers": [
            "dense",
            "graph"
          ],
          "retriever_count": 2,
          "normalized_scores": {
            "dense": 0.5548282281751635,
            "graph": 1.7103315213182526
          }
        }
      },
      "similarity": 0.5548282281751635
    },
    {
      "doc_id": "364",
      "text": "CWE-364: Signal Handler Race Condition",
      "score": 2.3400000000000003,
      "metadata": {
        "doc_id": "364",
        "name": "Signal Handler Race Condition",
        "type": "base",
        "original_content": "CWE-364: Signal Handler Race Condition",
        "relationships": [
          {
            "source_id": "364",
            "target_id": "831",
            "label": "PARENTOF",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          },
          {
            "source_id": "364",
            "target_id": "828",
            "label": "PARENTOF",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          },
          {
            "source_id": "364",
            "target_id": "432",
            "label": "PARENTOF",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          },
          {
            "source_id": "364",
            "target_id": "123",
            "label": "CANPRECEDE",
            "properties": {
              "view_id": "1000"
            }
          },
          {
            "source_id": "364",
            "target_id": "416",
            "label": "CANPRECEDE",
            "properties": {
              "view_id": "1000"
            }
          },
          {
            "source_id": "364",
            "target_id": "415",
            "label": "CANPRECEDE",
            "properties": {
              "view_id": "1000"
            }
          },
          {
            "source_id": "364",
            "target_id": "362",
            "label": "CHILDOF",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          },
          {
            "source_id": "831",
            "target_id": "364",
            "label": "CHILDOF",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          },
          {
            "source_id": "828",
            "target_id": "364",
            "label": "CHILDOF",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          },
          {
            "source_id": "432",
            "target_id": "364",
            "label": "CHILDOF",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          },
          {
            "source_id": "416",
            "target_id": "364",
            "label": "CANFOLLOW",
            "properties": {
              "view_id": "1000"
            }
          },
          {
            "source_id": "415",
            "target_id": "364",
            "label": "CANFOLLOW",
            "properties": {
              "view_id": "1000"
            }
          },
          {
            "source_id": "368",
            "target_id": "364",
            "label": "CANALSOBE",
            "properties": {
              "view_id": "1000"
            }
          },
          {
            "source_id": "362",
            "target_id": "364",
            "label": "PARENTOF",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          },
          {
            "source_id": "123",
            "target_id": "364",
            "label": "CANFOLLOW",
            "properties": {
              "view_id": "1000"
            }
          }
        ],
        "score_components": {
          "relationship_chain": 0.8,
          "abstraction_path": 0.7200000000000001,
          "sequence_path": 0.7200000000000001
        },
        "abstraction_factor": 1.3,
        "graph_path_info": {
          "path_types": [
            "relationship_chain",
            "abstraction_path_down",
            "vulnerability_sequence_forward"
          ],
          "best_paths": {
            "relationship_chain": {
              "path": [
                [
                  "362",
                  "416",
                  "CANPRECEDE"
                ],
                [
                  "416",
                  "364",
                  "CANFOLLOW"
                ]
              ],
              "score": 0.8,
              "type": "relationship_chain",
              "source": "362"
            },
            "abstraction_path_down": {
              "path": [
                [
                  "362",
                  "364",
                  "PARENTOF"
                ]
              ],
              "score": 0.7200000000000001,
              "type": "abstraction_path_down",
              "source": "362"
            },
            "vulnerability_sequence_forward": {
              "path": [
                [
                  "362",
                  "416",
                  "CANPRECEDE"
                ],
                [
                  "416",
                  "364",
                  "CANFOLLOW"
                ]
              ],
              "score": 0.7200000000000001,
              "type": "vulnerability_sequence_forward",
              "source": "362"
            }
          }
        },
        "abstraction_level": "base",
        "position": "after",
        "sources": [
          "graph"
        ],
        "source": "graph",
        "mapping_notes": {
          "usage": "Allowed",
          "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
          "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
          "reasons": [
            "Acceptable-Use"
          ]
        },
        "score_info": {
          "retrievers": [
            "graph"
          ],
          "retriever_count": 1,
          "normalized_scores": {
            "graph": 2.3400000000000003
          }
        }
      },
      "similarity": 2.3400000000000003
    }
  ],
  "identified_cwes": {
    "analyzer": [
      "CWE-911",
      "CWE-404",
      "CWE-667",
      "CWE-909",
      "CWE-362",
      "CWE-415"
    ],
    "critic_additional": []
  },
  "keyphrase_cwe_mapping": {}
}