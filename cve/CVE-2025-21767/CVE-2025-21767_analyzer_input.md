# Vulnerability Information: CVE-2025-21767

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved clocksource Use migrate_disable() to avoid calling get_random_u32() in atomic context The following bug report happened with a PREEMPT_RT kernel BUG **sleeping function called from invalid context** at kernel/locking/spinlock_rt.c48 in_atomic() 1, irqs_disabled() 0, non_block 0, pid 2012, name kwatchdog preempt_count 1, expected 0 RCU nest depth 0, expected 0 get_random_u32+0x4f/0x110 clocksource_verify_choose_cpus+0xab/0x1a0 clocksource_verify_percpu.part.0+0x6b/0x330 clocksource_watchdog_kthread+0x193/0x1a0 It is due to the fact that clocksource_verify_choose_cpus() is invoked with preemption disabled. This function invokes get_random_u32() to obtain random numbers for choosing CPUs. The batched_entropy_32 local lock and/or the base_crng.lock spinlock in driver/char/random.c will be acquired during the call. In PREEMPT_RT kernel, they are both sleeping locks and so **cannot be acquired in atomic context**. Fix this problem by using migrate_disable() to allow smp_processor_id() to be reliably used without introducing atomic context. preempt_disable() is then called after clocksource_verify_choose_cpus() but before the clocksource measurement is being run to avoid introducing unexpected latency.

### Vulnerability Description Key Phrases
- **rootcause:** **sleeping function called from invalid context**
- **weakness:** **cannot be acquired in atomic context**
- **impact:** kernel BUG
- **product:** Linux kernel
- **component:** clocksource

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.701 |
| 2 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.683 |
| 3 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.647 |
| 4 | 415 | Double Free | Variant | Allowed | sparse | 0.638 |
| 5 | 457 | Use of Uninitialized Variable | Variant | Allowed | sparse | 0.637 |
| 6 | 787 | Out-of-bounds Write | Base | Allowed | sparse | 0.635 |
| 7 | 828 | Signal Handler with Functionality that is not Asynchronous-Safe | Variant | Allowed | sparse | 0.635 |
| 8 | 190 | Integer Overflow or Wraparound | Base | Allowed | sparse | 0.624 |
| 9 | 413 | Improper Resource Locking | Base | Allowed | dense | 0.565 |
| 10 | 609 | Double-Checked Locking | Base | Allowed | graph | 0.003 |

