# Vulnerability Information: CVE-2024-50354

## Vulnerability Description
gnark is a fast zk-SNARK library that offers a high-level API to design circuits. In gnark 0.11.0 and earlier, **deserialization of Groth16 verification keys allocate excessive memory**, consuming a lot of resources and triggering a crash with the error fatal error runtime out of memory.

### Vulnerability Description Key Phrases
- **weakness:** **deserialization of Groth16 verification keys allocate excessive memory**
- **impact:** crash
- **product:** gnark
- **version:** 0.11.0 and earlier

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of the vulnerability described in the content, which relates to CVE-2024-50354:

**Root Cause of Vulnerability:**

- The vulnerability stems from how the `VerifyingKey` (and potentially `ProvingKey`) is deserialized in the `gnark` library, specifically within the `ReadFrom` function in `backend/groth16/<curve>/marshal.go`.
- During deserialization, the code reads a value `nbCommitments` from the input file, which specifies the number of expected Pedersen verification keys. This value is then directly used to allocate a slice in memory.
- A malicious actor can craft an input file with an extremely large `nbCommitments` value, leading to an attempt to allocate an excessive amount of memory.

**Weaknesses/Vulnerabilities Present:**

- **Unvalidated Input:** The `nbCommitments` value is read from the input file without any validation or bounds checking.
- **Unbounded Memory Allocation:** The code attempts to allocate a slice of size `nbCommitments` without any checks on the size, leading to a potential out-of-memory condition.
- **Lack of Input Sanitization:** The vulnerability lies in the lack of sanitization of the input data, specifically the number of commitments.

**Impact of Exploitation:**

- **Denial of Service (DoS):** A successful exploit leads to an out-of-memory error, causing the program to crash or become unresponsive, effectively resulting in a denial of service for the prover and verifier.
- **Resource Exhaustion:** Exploiting the vulnerability can consume excessive memory resources, impacting system stability.

**Attack Vectors:**

- **Malicious Input Files:** An attacker can craft malicious input files (such as a `VerifyingKey` file) containing a large `nbCommitments` value.
- **Deserialization:** The vulnerability is triggered during the deserialization process of these crafted files.

**Required Attacker Capabilities/Position:**

- **Ability to Provide Input Files:** The attacker needs to be able to provide a maliciously crafted `VerifyingKey` or `ProvingKey` file to the vulnerable component.
- **No Special Privileges Needed:** The vulnerability can be triggered without requiring any special privileges, however, the attack vector is local.

**Additional Details:**

- The vulnerability was found via fuzzing.
- The issue affects multiple elliptic curve implementations within the `gnark` library including `bn254`, `bls12-377`, and others.
- The fix involves reading the commitment keys from the input file to check how many there actually are, instead of relying on the number of expected commitments and allocating a slice beforehand. This bounds the in-memory key size to the serialized size.

The provided content includes a detailed description of the vulnerability, its root cause, impact, and the fix that was implemented. It also includes the CVSS v3 base metrics which reflects that the attack vector is local with low complexity and privileges, no user interaction, and results in a high availability impact.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | sparse | 0.314 |
| 2 | 502 | Deserialization of Untrusted Data | Base | Allowed | sparse | 0.265 |
| 3 | 755 | Improper Handling of Exceptional Conditions | Class | Discouraged | sparse | 0.257 |
| 4 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.257 |
| 5 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.255 |
| 6 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.253 |
| 7 | 400 | Uncontrolled Resource Consumption | Class | Discouraged | sparse | 0.252 |
| 8 | 834 | Excessive Iteration | Class | Discouraged | sparse | 0.249 |
| 9 | 194 | Unexpected Sign Extension | Variant | Allowed | dense | 0.356 |
| 10 | 1325 | Improperly Controlled Sequential Memory Allocation | Base | Allowed | graph | 0.003 |

