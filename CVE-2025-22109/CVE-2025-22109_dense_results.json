{
  "query": "In the Linux kernel, the following vulnerability has been resolved ax25 Remove broken autobind Binding AX25 socket by using the autobind feature leads to memory leaks in ax25_connect() and also refcount leaks in ax25_release(). Memory leak was detected with kmemleak ================================================================ unreferenced object 0xffff8880253cd680 (size 96) backtrace __kmalloc_node_track_caller_noprof (./include/linux/kmemleak.h43) kmemdup_noprof (mm/util.c136) ax25_rt_autobind (net/ax25/ax25_route.c428) ax25_connect (net/ax25/af_ax25.c1282) __sys_connect_file (net/socket.c2045) __sys_connect (net/socket.c2064) __x64_sys_connect (net/socket.c2067) do_syscall_64 (arch/x86/entry/common.c52 arch/x86/entry/common.c83) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S130) ================================================================ When socket is bound, refcounts must be incremented the way it is done in ax25_bind() and ax25_setsockopt() (SO_BINDTODEVICE). In case of autobind, the refcounts are not incremented. This bug leads to the following issue reported by Syzkaller ================================================================ ax25_connect() syz-executor318 uses autobind, please contact jreuter@yaina.de ------------[ cut here ]------------ refcount_t decrement hit 0 leaking memory. WARNING CPU 0 PID 5317 at lib/refcount.c31 refcount_warn_saturate+0xfa/0x1d0 lib/refcount.c31 Modules linked in CPU 0 UID 0 PID 5317 Comm syz-executor318 Not tainted 6.14.0-rc4-syzkaller-00278-gece144f151ac #0 Hardware name QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014 RIP 0010refcount_warn_saturate+0xfa/0x1d0 lib/refcount.c31 ... Call Trace __refcount_dec include/linux/refcount.h336 [inline] refcount_dec include/linux/refcount.h351 [inline] ref_tracker_free+0x6af/0x7e0 lib/ref_tracker.c236 netdev_tracker_free include/linux/netdevice.h4302 [inline] netdev_put include/linux/netdevice.h4319 [inline] ax25_release+0x368/0x960 net/ax25/af_ax25.c1080 __sock_release net/socket.c647 [inline] sock_close+0xbc/0x240 net/socket.c1398 __fput+0x3e9/0x9f0 fs/file_table.c464 __do_sys_close fs/open.c1580 [inline] __se_sys_close fs/open.c1565 [inline] __x64_sys_close+0x7f/0x110 fs/open.c1565 do_syscall_x64 arch/x86/entry/common.c52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c83 entry_SYSCALL_64_after_hwframe+0x77/0x7f ... ================================================================ Considering the issues above and the comments left in the code that say check if we can remove this feature. It is broken. autobinding in this may or may not work - it is better to completely remove this feature than to fix it because it is broken and leads to various kinds of memory bugs. Now calling connect() without first binding socket will result in an error (-EINVAL). Userspace software that relies on the autobind feature might get broken. However, this feature does not seem widely used with this specific driver as it was not reliable at any point of time, and it is already broken anyway. E.g. ax25-tools and ax25-apps packages for popular distributions do not use the autobind feature for AF_AX25. Found by Linux Verification Center (linuxtesting.org) with Syzkaller.",
  "count": 20,
  "results": [
    {
      "cwe_id": "401",
      "name": "Missing Release of Memory after Effective Lifetime",
      "abstraction": "Variant",
      "score": 0.5704953629777378,
      "original_score": 0.5704953629777378,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "909",
      "name": "Missing Initialization of Resource",
      "abstraction": "Class",
      "score": 0.5345533967289737,
      "original_score": 0.5345533967289737,
      "mapping_usage": "Allowed-with-Review"
    },
    {
      "cwe_id": "126",
      "name": "Buffer Over-read",
      "abstraction": "Variant",
      "score": 0.5218158491909202,
      "original_score": 0.5218158491909202,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "abstraction": "Base",
      "score": 0.5191165106206049,
      "original_score": 0.5191165106206049,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "605",
      "name": "Multiple Binds to the Same Port",
      "abstraction": "Variant",
      "score": 0.5190071416416255,
      "original_score": 0.5190071416416255,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "abstraction": "Class",
      "score": 0.515298860206985,
      "original_score": 0.515298860206985,
      "mapping_usage": "Allowed-with-Review"
    },
    {
      "cwe_id": "911",
      "name": "Improper Update of Reference Count",
      "abstraction": "Base",
      "score": 0.5128955475251913,
      "original_score": 0.5128955475251913,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "abstraction": "Base",
      "score": 0.5120449190642292,
      "original_score": 0.5120449190642292,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "252",
      "name": "Unchecked Return Value",
      "abstraction": "Base",
      "score": 0.5105671524268043,
      "original_score": 0.5105671524268043,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "121",
      "name": "Stack-based Buffer Overflow",
      "abstraction": "Variant",
      "score": 0.5093293554201334,
      "original_score": 0.5093293554201334,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "191",
      "name": "Integer Underflow (Wrap or Wraparound)",
      "abstraction": "Base",
      "score": 0.49586248686427076,
      "original_score": 0.49586248686427076,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "835",
      "name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
      "abstraction": "Base",
      "score": 0.49483437212961123,
      "original_score": 0.49483437212961123,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "908",
      "name": "Use of Uninitialized Resource",
      "abstraction": "Base",
      "score": 0.4923619124680497,
      "original_score": 0.4923619124680497,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "abstraction": "Base",
      "score": 0.4888739758287756,
      "original_score": 0.4888739758287756,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "131",
      "name": "Incorrect Calculation of Buffer Size",
      "abstraction": "Base",
      "score": 0.48855899637679767,
      "original_score": 0.48855899637679767,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "abstraction": "Class",
      "score": 0.4876994425559518,
      "original_score": 0.4876994425559518,
      "mapping_usage": "Allowed-with-Review"
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "abstraction": "Variant",
      "score": 0.48756837887498494,
      "original_score": 0.48756837887498494,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "770",
      "name": "Allocation of Resources Without Limits or Throttling",
      "abstraction": "Base",
      "score": 0.48749172313211575,
      "original_score": 0.48749172313211575,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "abstraction": "Base",
      "score": 0.486888463289738,
      "original_score": 0.486888463289738,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "789",
      "name": "Memory Allocation with Excessive Size Value",
      "abstraction": "Variant",
      "score": 0.48659588942768667,
      "original_score": 0.48659588942768667,
      "mapping_usage": "Allowed"
    }
  ],
  "statistics": {
    "min": 0.48659588942768667,
    "max": 0.5704953629777378,
    "mean": 0.5060929868375593,
    "median": 0.5025959211422021,
    "count": 20
  }
}