{
  "query": "In the Linux kernel, the following vulnerability has been resolved ax25 Remove broken autobind Binding AX25 socket by using the autobind feature leads to memory leaks in ax25_connect() and also refcount leaks in ax25_release(). Memory leak was detected with kmemleak ================================================================ unreferenced object 0xffff8880253cd680 (size 96) backtrace __kmalloc_node_track_caller_noprof (./include/linux/kmemleak.h43) kmemdup_noprof (mm/util.c136) ax25_rt_autobind (net/ax25/ax25_route.c428) ax25_connect (net/ax25/af_ax25.c1282) __sys_connect_file (net/socket.c2045) __sys_connect (net/socket.c2064) __x64_sys_connect (net/socket.c2067) do_syscall_64 (arch/x86/entry/common.c52 arch/x86/entry/common.c83) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S130) ================================================================ When socket is bound, refcounts must be incremented the way it is done in ax25_bind() and ax25_setsockopt() (SO_BINDTODEVICE). In case of autobind, the refcounts are not incremented. This bug leads to the following issue reported by Syzkaller ================================================================ ax25_connect() syz-executor318 uses autobind, please contact jreuter@yaina.de ------------[ cut here ]------------ refcount_t decrement hit 0 leaking memory. WARNING CPU 0 PID 5317 at lib/refcount.c31 refcount_warn_saturate+0xfa/0x1d0 lib/refcount.c31 Modules linked in CPU 0 UID 0 PID 5317 Comm syz-executor318 Not tainted 6.14.0-rc4-syzkaller-00278-gece144f151ac #0 Hardware name QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014 RIP 0010refcount_warn_saturate+0xfa/0x1d0 lib/refcount.c31 ... Call Trace __refcount_dec include/linux/refcount.h336 [inline] refcount_dec include/linux/refcount.h351 [inline] ref_tracker_free+0x6af/0x7e0 lib/ref_tracker.c236 netdev_tracker_free include/linux/netdevice.h4302 [inline] netdev_put include/linux/netdevice.h4319 [inline] ax25_release+0x368/0x960 net/ax25/af_ax25.c1080 __sock_release net/socket.c647 [inline] sock_close+0xbc/0x240 net/socket.c1398 __fput+0x3e9/0x9f0 fs/file_table.c464 __do_sys_close fs/open.c1580 [inline] __se_sys_close fs/open.c1565 [inline] __x64_sys_close+0x7f/0x110 fs/open.c1565 do_syscall_x64 arch/x86/entry/common.c52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c83 entry_SYSCALL_64_after_hwframe+0x77/0x7f ... ================================================================ Considering the issues above and the comments left in the code that say check if we can remove this feature. It is broken. autobinding in this may or may not work - it is better to completely remove this feature than to fix it because it is broken and leads to various kinds of memory bugs. Now calling connect() without first binding socket will result in an error (-EINVAL). Userspace software that relies on the autobind feature might get broken. However, this feature does not seem widely used with this specific driver as it was not reliable at any point of time, and it is already broken anyway. E.g. ax25-tools and ax25-apps packages for popular distributions do not use the autobind feature for AF_AX25. Found by Linux Verification Center (linuxtesting.org) with Syzkaller.",
  "count": 20,
  "results": [
    {
      "cwe_id": "364",
      "name": "Signal Handler Race Condition",
      "abstraction": "base",
      "score": 2.8651999999999997,
      "original_score": 2.8651999999999997,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "123",
      "name": "Write-what-where Condition",
      "abstraction": "base",
      "score": 2.4700000000000006,
      "original_score": 2.4700000000000006,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "1325",
      "name": "Improperly Controlled Sequential Memory Allocation",
      "abstraction": "base",
      "score": 2.3400000000000003,
      "original_score": 2.3400000000000003,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "825",
      "name": "Expired Pointer Dereference",
      "abstraction": "base",
      "score": 2.2100000000000004,
      "original_score": 2.2100000000000004,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "170",
      "name": "Improper Null Termination",
      "abstraction": "base",
      "score": 2.2100000000000004,
      "original_score": 2.2100000000000004,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "823",
      "name": "Use of Out-of-range Pointer Offset",
      "abstraction": "base",
      "score": 2.2100000000000004,
      "original_score": 2.2100000000000004,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "772",
      "name": "Missing Release of Resource after Effective Lifetime",
      "abstraction": "base",
      "score": 2.2100000000000004,
      "original_score": 2.2100000000000004,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "390",
      "name": "Detection of Error Condition Without Action",
      "abstraction": "base",
      "score": 2.2100000000000004,
      "original_score": 2.2100000000000004,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "911",
      "name": "Improper Update of Reference Count",
      "abstraction": "Base",
      "score": 2.049186083079437,
      "original_score": 2.049186083079437,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "125",
      "name": "Out-of-bounds Read",
      "abstraction": "Base",
      "score": 2.0365139558368575,
      "original_score": 2.0365139558368575,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "770",
      "name": "Allocation of Resources Without Limits or Throttling",
      "abstraction": "Base",
      "score": 1.9017177038497435,
      "original_score": 1.9017177038497435,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "456",
      "name": "Missing Initialization of a Variable",
      "abstraction": "variant",
      "score": 1.83936,
      "original_score": 1.83936,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "abstraction": "Variant",
      "score": 1.820850643752318,
      "original_score": 1.820850643752318,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "120",
      "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
      "abstraction": "base",
      "score": 1.7680000000000005,
      "original_score": 1.7680000000000005,
      "mapping_usage": "Allowed-with-Review"
    },
    {
      "cwe_id": "787",
      "name": "Out-of-bounds Write",
      "abstraction": "base",
      "score": 1.7680000000000005,
      "original_score": 1.7680000000000005,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "562",
      "name": "Return of Stack Variable Address",
      "abstraction": "base",
      "score": 1.7680000000000005,
      "original_score": 1.7680000000000005,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "22",
      "name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
      "abstraction": "base",
      "score": 1.7680000000000005,
      "original_score": 1.7680000000000005,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "41",
      "name": "Improper Resolution of Path Equivalence",
      "abstraction": "base",
      "score": 1.7680000000000005,
      "original_score": 1.7680000000000005,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "1341",
      "name": "Multiple Releases of Same Resource or Handle",
      "abstraction": "base",
      "score": 1.6848000000000003,
      "original_score": 1.6848000000000003,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "1265",
      "name": "Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
      "abstraction": "base",
      "score": 1.6848000000000003,
      "original_score": 1.6848000000000003,
      "mapping_usage": "Allowed"
    }
  ],
  "statistics": {
    "min": 1.6848000000000003,
    "max": 2.8651999999999997,
    "mean": 2.0291214193259184,
    "median": 1.9691158298433005,
    "count": 20
  }
}