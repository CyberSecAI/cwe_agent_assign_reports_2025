## Vulnerability Description
The Jupyter Server provides the backend for Jupyter web applications. Jupyter Server on Windows has a vulnerability that lets unauthenticated attackers leak the NTLMv2 password hash of the Windows user running the Jupyter server. An attacker can crack this password to gain access to the Windows machine hosting the Jupyter server, or access other network-accessible machines or 3rd party services using that credential. Or an attacker perform an NTLM relay attack without cracking the credential to gain access to other network-accessible machines. This vulnerability is fixed in 2.14.1.

### Vulnerability Description Key Phrases
- **impact:** leak NTLMv2 password hash
- **attacker:** unauthenticated attackers
- **product:** Jupyter Server
- **version:** on Windows prior to 2.14.1

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of CVE-2024-35178:

**Root cause of vulnerability:**

The vulnerability lies in the `filefind` function of the `jupyter_server` package on Windows. Prior to the fix, the function did not properly validate if a resolved file path was within the allowed directory. Specifically, it would attempt to resolve absolute paths and if the file existed, return the path. This allowed a user to craft a malicious file path, which when resolved, would trigger the Windows NTLM authentication mechanism.

**Weaknesses/vulnerabilities present:**

- **NTLM Hash Leak:** When a file path including a UNC path to a malicious server (e.g., `\\attacker\share\file.txt`) was passed to the vulnerable `filefind` function, the Windows system would attempt NTLM authentication to the attacker's server, thereby disclosing the user's NTLMv2 password hash.
- **Lack of proper path validation:** The `filefind` function did not properly validate that the file path was within the allowed directories, especially when dealing with absolute and UNC paths. This allowed a malicious actor to specify a network location in the path.
- **Reliance on os.path.isfile:** Checking for file existence without first ensuring the path was within expected bounds enabled the vulnerability.
- **Acceptance of absolute paths:** The `filefind` function was accepting absolute paths, which are not expected in its design. This can lead to path traversal and leakage of sensitive information, since resolving the path will cause the system to access the remote location.

**Impact of exploitation:**

- **NTLMv2 Password Hash Leakage:** An attacker can obtain the NTLMv2 password hash of the Windows user running the Jupyter server.
- **Credential cracking:** The leaked NTLMv2 password hash can be cracked, potentially granting the attacker access to the Windows machine hosting the Jupyter server.
- **Network access:** An attacker can use the stolen credentials to access other network-accessible machines or 3rd party services.
- **NTLM relay attacks:** An attacker can perform an NTLM relay attack without cracking the credential to gain access to other network-accessible machines.

**Attack vectors:**

- **Network:** An unauthenticated attacker can send a crafted request to the Jupyter server containing a malicious file path with a UNC path to the attackerâ€™s server.

**Required attacker capabilities/position:**

- The attacker needs to be able to send requests to a vulnerable Jupyter server instance running on Windows.
- The attacker does not need to authenticate to the Jupyter server.

**Additional details from the commit:**

- The fix implemented in commit `79fbf80` restricts `filefind` to only accept relative paths, and explicitly checks to ensure that resolved paths remain within the specified search directories.
- The fix includes a check using `is_relative_to` (or a fallback for Python < 3.9) to ensure that the resolved path remains within the specified directory.
- The commit removes support for absolute paths from the `filefind` function.
- Added a test case to verify the vulnerability is fixed in `test_utils.py`.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 200 | Exposure of Sensitive Information to an Unauthorized Actor | Class | Discouraged | sparse | 0.185 |
| 2 | 427 | Uncontrolled Search Path Element | Base | Allowed | sparse | 0.177 |
| 3 | 522 | Insufficiently Protected Credentials | Class | Allowed-with-Review | sparse | 0.172 |
| 4 | 306 | Missing Authentication for Critical Function | Base | Allowed | sparse | 0.169 |
| 5 | 923 | Improper Restriction of Communication Channel to Intended Endpoints | Class | Allowed-with-Review | sparse | 0.169 |
| 6 | 916 | Use of Password Hash With Insufficient Computational Effort | Base | Allowed | sparse | 0.165 |
| 7 | 287 | Improper Authentication | Class | Discouraged | sparse | 0.165 |
| 8 | 269 | Improper Privilege Management | Class | Discouraged | sparse | 0.164 |
| 9 | 256 | Plaintext Storage of a Password | Base | Allowed | dense | 0.447 |
| 10 | 322 | Key Exchange without Entity Authentication | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-200: Exposure of Sensitive Information to an Unauthorized Actor

CWE-427: Uncontrolled Search Path Element

CWE-522: Insufficiently Protected Credentials

CWE-306: Missing Authentication for Critical Function

CWE-923: Improper Restriction of Communication Channel to Intended Endpoints

CWE-916: Use of Password Hash With Insufficient Computational Effort

CWE-287: Improper Authentication

CWE-269: Improper Privilege Management

CWE-256: Plaintext Storage of a Password

CWE-322: Key Exchange without Entity Authentication