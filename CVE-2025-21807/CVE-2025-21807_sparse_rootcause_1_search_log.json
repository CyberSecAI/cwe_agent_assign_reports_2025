{
  "method": "sparse_rootcause_1",
  "query": "In the Linux kernel, the following vulnerability has been resolved block fix queue freeze vs limits lock order in sysfs store methods queue_attr_store() always freezes a device queue before calling the attribute store operation. For attributes that control queue limits, the store operation will also lock the queue limits with a call to queue_limits_start_update(). However, some drivers (e.g. SCSI sd) may need to issue commands to a device to obtain limit values from the hardware with the queue limits locked. This creates a potential ABBA deadlock situation if a user attempts to modify a limit (thus freezing the device queue) while the device driver starts a revalidation of the device queue limits. Avoid such deadlock by not freezing the queue before calling the ->store_limit() method in struct queue_sysfs_entry and instead use the queue_limits_commit_update_frozen helper to freeze the queue after taking the limits lock. This also removes taking the sysfs lock for the store_limit method as it doesnt protect anything here, but creates even more nesting. Hopefully it will go away from the actual sysfs methods entirely soon. (commit log adapted from a similar patch from Damien Le Moal)",
  "keyphrases": {
    "rootcause": "lock order"
  },
  "timestamp": "2025-07-12T09:55:10.634252",
  "results_count": 10,
  "results_summary": [
    {
      "doc_id": "770",
      "name": "Allocation of Resources Without Limits or Throttling",
      "score": 887.5219322494709
    },
    {
      "doc_id": "667",
      "name": "Improper Locking",
      "score": 883.715813778434
    },
    {
      "doc_id": "606",
      "name": "Unchecked Input for Loop Condition",
      "score": 850.9289508144284
    },
    {
      "doc_id": "789",
      "name": "Memory Allocation with Excessive Size Value",
      "score": 846.9982943236168
    },
    {
      "doc_id": "833",
      "name": "Deadlock",
      "score": 835.8672151564176
    }
  ]
}