{
  "method": "sparse_base",
  "query": "In the Linux kernel, the following vulnerability has been resolved block fix queue freeze vs limits lock order in sysfs store methods queue_attr_store() always freezes a device queue before calling the attribute store operation. For attributes that control queue limits, the store operation will also lock the queue limits with a call to queue_limits_start_update(). However, some drivers (e.g. SCSI sd) may need to issue commands to a device to obtain limit values from the hardware with the queue limits locked. This creates a potential ABBA deadlock situation if a user attempts to modify a limit (thus freezing the device queue) while the device driver starts a revalidation of the device queue limits. Avoid such deadlock by not freezing the queue before calling the ->store_limit() method in struct queue_sysfs_entry and instead use the queue_limits_commit_update_frozen helper to freeze the queue after taking the limits lock. This also removes taking the sysfs lock for the store_limit method as it doesnt protect anything here, but creates even more nesting. Hopefully it will go away from the actual sysfs methods entirely soon. (commit log adapted from a similar patch from Damien Le Moal)",
  "keyphrases": {
    "base_query": "In the Linux kernel, the following vulnerability has been resolved block fix queue freeze vs limits lock order in sysfs store methods queue_attr_store() always freezes a device queue before calling the attribute store operation. For attributes that control queue limits, the store operation will also lock the queue limits with a call to queue_limits_start_update(). However, some drivers (e.g. SCSI sd) may need to issue commands to a device to obtain limit values from the hardware with the queue limits locked. This creates a potential ABBA deadlock situation if a user attempts to modify a limit (thus freezing the device queue) while the device driver starts a revalidation of the device queue limits. Avoid such deadlock by not freezing the queue before calling the ->store_limit() method in struct queue_sysfs_entry and instead use the queue_limits_commit_update_frozen helper to freeze the queue after taking the limits lock. This also removes taking the sysfs lock for the store_limit method as it doesnt protect anything here, but creates even more nesting. Hopefully it will go away from the actual sysfs methods entirely soon. (commit log adapted from a similar patch from Damien Le Moal)"
  },
  "timestamp": "2025-07-12T09:55:10.463333",
  "results_count": 10,
  "results_summary": [
    {
      "doc_id": "770",
      "name": "Allocation of Resources Without Limits or Throttling",
      "score": 294.9223670348443
    },
    {
      "doc_id": "667",
      "name": "Improper Locking",
      "score": 287.74033121526577
    },
    {
      "doc_id": "606",
      "name": "Unchecked Input for Loop Condition",
      "score": 283.64298360480944
    },
    {
      "doc_id": "789",
      "name": "Memory Allocation with Excessive Size Value",
      "score": 282.33276477453893
    },
    {
      "doc_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "score": 272.646182363418
    }
  ]
}