{
  "retriever": "sparse",
  "query": "In the Linux kernel, the following vulnerability has been resolved block fix queue freeze vs limits lock order in sysfs store methods queue_attr_store() always freezes a device queue before calling the attribute store operation. For attributes that control queue limits, the store operation will also lock the queue limits with a call to queue_limits_start_update(). However, some drivers (e.g. SCSI sd) may need to issue commands to a device to obtain limit values from the hardware with the queue limits locked. This creates a potential ABBA deadlock situation if a user attempts to modify a limit (thus freezing the device queue) while the device driver starts a revalidation of the device queue limits. Avoid such deadlock by not freezing the queue before calling the ->store_limit() method in struct queue_sysfs_entry and instead use the queue_limits_commit_update_frozen helper to freeze the queue after taking the limits lock. This also removes taking the sysfs lock for the store_limit method as it doesnt protect anything here, but creates even more nesting. Hopefully it will go away from the actual sysfs methods entirely soon. (commit log adapted from a similar patch from Damien Le Moal)",
  "keyphrases": {
    "rootcause": [
      "lock order"
    ],
    "weakness": [
      "ABBA deadlock"
    ]
  },
  "timestamp": "2025-07-12 09:55:10",
  "cve_id": "CVE-2025-21807",
  "result_count": 11,
  "results": [
    {
      "cwe_id": "770",
      "name": "Allocation of Resources Without Limits or Throttling",
      "score": 887.5219322494709,
      "search_source": "rootcause:lock order"
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "score": 883.715813778434,
      "search_source": "rootcause:lock order"
    },
    {
      "cwe_id": "606",
      "name": "Unchecked Input for Loop Condition",
      "score": 850.9289508144284,
      "search_source": "rootcause:lock order"
    },
    {
      "cwe_id": "789",
      "name": "Memory Allocation with Excessive Size Value",
      "score": 846.9982943236168,
      "search_source": "rootcause:lock order"
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "score": 835.8672151564176,
      "search_source": "rootcause:lock order"
    },
    {
      "cwe_id": "319",
      "name": "Cleartext Transmission of Sensitive Information",
      "score": 822.5417985096565,
      "search_source": "rootcause:lock order"
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "score": 821.0745407951838,
      "search_source": "rootcause:lock order"
    },
    {
      "cwe_id": "774",
      "name": "Allocation of File Descriptors or Handles Without Limits or Throttling",
      "score": 809.1890763085332,
      "search_source": "rootcause:lock order"
    },
    {
      "cwe_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "score": 803.1138904946868,
      "search_source": "rootcause:lock order"
    },
    {
      "cwe_id": "266",
      "name": "Incorrect Privilege Assignment",
      "score": 793.6633180283116,
      "search_source": "rootcause:lock order"
    },
    {
      "cwe_id": "835",
      "name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
      "score": 739.0092563979064,
      "search_source": "weakness:ABBA deadlock"
    }
  ]
}