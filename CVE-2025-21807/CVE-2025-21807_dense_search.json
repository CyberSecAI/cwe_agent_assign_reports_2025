{
  "retriever": "dense",
  "query": "In the Linux kernel, the following vulnerability has been resolved block fix queue freeze vs limits lock order in sysfs store methods queue_attr_store() always freezes a device queue before calling the attribute store operation. For attributes that control queue limits, the store operation will also lock the queue limits with a call to queue_limits_start_update(). However, some drivers (e.g. SCSI sd) may need to issue commands to a device to obtain limit values from the hardware with the queue limits locked. This creates a potential ABBA deadlock situation if a user attempts to modify a limit (thus freezing the device queue) while the device driver starts a revalidation of the device queue limits. Avoid such deadlock by not freezing the queue before calling the ->store_limit() method in struct queue_sysfs_entry and instead use the queue_limits_commit_update_frozen helper to freeze the queue after taking the limits lock. This also removes taking the sysfs lock for the store_limit method as it doesnt protect anything here, but creates even more nesting. Hopefully it will go away from the actual sysfs methods entirely soon. (commit log adapted from a similar patch from Damien Le Moal)",
  "keyphrases": {
    "rootcause": [
      "lock order"
    ],
    "weakness": [
      "ABBA deadlock"
    ]
  },
  "timestamp": "2025-07-14 09:50:09",
  "cve_id": "CVE-2025-21807",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 0.48725892085349176
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "type": "Class",
      "score": 0.46816816712034354
    },
    {
      "cwe_id": "413",
      "name": "Improper Resource Locking",
      "type": "Base",
      "score": 0.4631076750680818
    },
    {
      "cwe_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "type": "Base",
      "score": 0.45222419165261996
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 0.4471032295667153
    },
    {
      "cwe_id": "1256",
      "name": "Improper Restriction of Software Interfaces to Hardware Features",
      "type": "Base",
      "score": 0.44165642642310654
    },
    {
      "cwe_id": "1233",
      "name": "Security-Sensitive Hardware Controls with Missing Lock Bit Protection",
      "type": "Base",
      "score": 0.4347867244472122
    },
    {
      "cwe_id": "119",
      "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
      "type": "Class",
      "score": 0.4333585443934611
    },
    {
      "cwe_id": "591",
      "name": "Sensitive Data Storage in Improperly Locked Memory",
      "type": "Variant",
      "score": 0.4330223092911913
    },
    {
      "cwe_id": "606",
      "name": "Unchecked Input for Loop Condition",
      "type": "Base",
      "score": 0.42802134535050196
    },
    {
      "cwe_id": "764",
      "name": "Multiple Locks of a Critical Resource",
      "type": "Base",
      "score": 0.41520028919554886
    },
    {
      "cwe_id": "832",
      "name": "Unlock of a Resource that is not Locked",
      "type": "Base",
      "score": 0.4145917420219408
    },
    {
      "cwe_id": "835",
      "name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
      "type": "Base",
      "score": 0.4079912782926104
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "type": "Base",
      "score": 0.4070701183290229
    },
    {
      "cwe_id": "774",
      "name": "Allocation of File Descriptors or Handles Without Limits or Throttling",
      "type": "Variant",
      "score": 0.40558623726484244
    },
    {
      "cwe_id": "401",
      "name": "Missing Release of Memory after Effective Lifetime",
      "type": "Variant",
      "score": 0.40199399211994535
    },
    {
      "cwe_id": "1231",
      "name": "Improper Prevention of Lock Bit Modification",
      "type": "Base",
      "score": 0.4008817287158315
    },
    {
      "cwe_id": "909",
      "name": "Missing Initialization of Resource",
      "type": "Class",
      "score": 0.3989975931687269
    },
    {
      "cwe_id": "770",
      "name": "Allocation of Resources Without Limits or Throttling",
      "type": "Base",
      "score": 0.397601157364864
    },
    {
      "cwe_id": "765",
      "name": "Multiple Unlocks of a Critical Resource",
      "type": "Base",
      "score": 0.395317253984966
    }
  ]
}