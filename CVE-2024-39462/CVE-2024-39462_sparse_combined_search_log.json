{
  "method": "sparse_combined",
  "query": "In the Linux kernel, the following vulnerability has been resolved clk bcm dvp Assign ->num before accessing ->hws Commit f316cdff8d67 (clk Annotate struct clk_hw_onecell_data with __counted_by) annotated the hws member of struct clk_hw_onecell_data with __counted_by, which informs the bounds sanitizer about the number of elements in hws, so that it can warn when hws is accessed out of bounds. As noted in that change, the __counted_by member must be initialized with the number of elements before the first array access happens, otherwise there will be a warning from each access prior to the initialization because the number of elements is zero. This occurs in clk_dvp_probe() due to ->num being assigned after ->hws has been accessed UBSAN array-index-out-of-bounds in drivers/clk/bcm/clk-bcm2711-dvp.c592 index 0 is out of range for type struct clk_hw *[] __counted_by(num) (aka struct clk_hw *[]) Move the ->num initialization to before the first access of ->hws, which clears up the warning.",
  "keyphrases": {
    "rootcause": [
      "uninitialized __counted_by member"
    ],
    "weakness": [
      "array-index-out-of-bounds"
    ]
  },
  "timestamp": "2025-07-13T11:26:05.092848",
  "results_count": 12,
  "results_summary": [
    {
      "doc_id": "125",
      "name": "Out-of-bounds Read",
      "score": 773.7034688720851
    },
    {
      "doc_id": "191",
      "name": "Integer Underflow (Wrap or Wraparound)",
      "score": 765.2433353577214
    },
    {
      "doc_id": "824",
      "name": "Access of Uninitialized Pointer",
      "score": 763.3304170112448
    },
    {
      "doc_id": "476",
      "name": "NULL Pointer Dereference",
      "score": 760.3310342454872
    },
    {
      "doc_id": "908",
      "name": "Use of Uninitialized Resource",
      "score": 757.6363009935216
    }
  ]
}