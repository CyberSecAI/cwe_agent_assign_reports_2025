# Raw Retriever Results for CVE-2024-42239

# Raw Retriever Results for CVE-2024-42239
## Query
In the Linux kernel, the following vulnerability has been resolved bpf Fail bpf_timer_cancel when callback is being cancelled Given a schedule timer1 cbtimer2 cb bpf_timer_cancel(timer2)bpf_timer_cancel(timer1) Both bpf_timer_cancel calls would wait for the other callback to finish executing, introducing a lockup. Add an atomic_t count named cancelling in bpf_hrtimer. This keeps track of all in-flight cancellation requests for a given BPF timer. Whenever cancelling a BPF timer, we must check if we have outstanding cancellation requests, and if so, we must fail the operation with an error (-EDEADLK) since cancellation is synchronous and waits for the callback to finish executing. This implies that we can enter a deadlock situation involving two or more timer callbacks executing in parallel and attempting to cancel one another. Note that we avoid incrementing the cancelling counter for the target timer (the one being cancelled) if bpf_timer_cancel is not invoked from a callback, to avoid spurious errors. The whole point of detecting cur->cancelling and returning -EDEADLK is to not enter a busy wait loop (which may or may not lead to a lockup). This does not apply in case the caller is in a non-callback context, the other side can continue to cancel as it sees fit without running into errors. Background on prior attempts Earlier versions of this patch used a bool cancelling bit and used the following pattern under timer->lock to publish cancellation status. l

## Keyphrases
- **weakness**: 'deadlock'

## Score Statistics
| Retriever | Min | Max | Mean | Median | Count |
|-----------|-----|-----|------|--------|-------|
| Dense | 0.3473 | 0.4269 | 0.3684 | 0.3652 | 20 |
| Sparse | 956.6364 | 994.2325 | 972.9076 | 971.1338 | 10 |
| Graph | 1.4921 | 2.2100 | 1.7847 | 1.6848 | 20 |

## Graph Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Mapping Usage |
|---|--------|------|-------------|-------|---------------|
| 1 | 123 | Write-what-where Condition | base | 2.2100 | Allowed |
| 2 | 368 | Context Switching Race Condition | base | 2.1762 | Allowed |
| 3 | 364 | Signal Handler Race Condition | Base | 2.0979 | Allowed |
| 4 | 416 | Use After Free | variant | 2.0400 | Allowed |
| 5 | 415 | Double Free | variant | 2.0400 | Allowed |
| 6 | 606 | Unchecked Input for Loop Condition | Base | 1.9974 | Allowed |
| 7 | 1284 | Improper Validation of Specified Quantity in Input | base | 1.8106 | Allowed |
| 8 | 120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | base | 1.7680 | Allowed-with-Review |
| 9 | 1265 | Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls | base | 1.6848 | Allowed |
| 10 | 134 | Use of Externally-Controlled Format String | base | 1.6848 | Allowed |
| 11 | 1339 | Insufficient Precision or Accuracy of a Real Number | base | 1.6848 | Allowed |
| 12 | 252 | Unchecked Return Value | base | 1.6848 | Allowed |
| 13 | 1325 | Improperly Controlled Sequential Memory Allocation | base | 1.6848 | Allowed |
| 14 | 386 | Symbolic Name not Mapping to Correct Object | base | 1.6744 | Allowed |
| 15 | 833 | Deadlock | Base | 1.6557 | Allowed |

## Dense Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Original Score | Mapping Usage |
|---|--------|------|-------------|-------|----------------|---------------|
| 1 | 833 | Deadlock | Base | 0.4269 | 0.4269 | Allowed |
| 2 | 667 | Improper Locking | Class | 0.3962 | 0.3962 | Allowed-with-Review |
| 3 | 364 | Signal Handler Race Condition | Base | 0.3900 | 0.3900 | Allowed |
| 4 | 828 | Signal Handler with Functionality that is not Asynchronous-Safe | Variant | 0.3878 | 0.3878 | Allowed |
| 5 | 606 | Unchecked Input for Loop Condition | Base | 0.3847 | 0.3847 | Allowed |
| 6 | 765 | Multiple Unlocks of a Critical Resource | Base | 0.3761 | 0.3761 | Allowed |
| 7 | 1322 | Use of Blocking Code in Single-threaded, Non-blocking Context | Base | 0.3753 | 0.3753 | Allowed |
| 8 | 413 | Improper Resource Locking | Base | 0.3745 | 0.3745 | Allowed |
| 9 | 663 | Use of a Non-reentrant Function in a Concurrent Context | Base | 0.3707 | 0.3707 | Allowed |
| 10 | 1264 | Hardware Logic with Insecure De-Synchronization between Control and Data Channels | Base | 0.3700 | 0.3700 | Allowed |
| 11 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | 0.3603 | 0.3603 | Allowed-with-Review |
| 12 | 385 | Covert Timing Channel | Base | 0.3575 | 0.3575 | Allowed |
| 13 | 479 | Signal Handler Use of a Non-reentrant Function | Variant | 0.3539 | 0.3539 | Allowed |
| 14 | 775 | Missing Release of File Descriptor or Handle after Effective Lifetime | Variant | 0.3508 | 0.3508 | Allowed |
| 15 | 820 | Missing Synchronization | Base | 0.3508 | 0.3508 | Allowed |

## Sparse Retriever Results (10)
| # | CWE ID | Name | Score | Original Score | Mapping Usage |
|---|--------|------|-------|---------------|---------------|
| 1 | 667 | Improper Locking | 994.2325 | 994.2325 | Allowed-with-Review |
| 2 | 833 | Deadlock | 990.3962 | 990.3962 | Allowed |
| 3 | 364 | Signal Handler Race Condition | 980.9113 | 980.9113 | Allowed |
| 4 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | 978.7526 | 978.7526 | Allowed |
| 5 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | 977.7089 | 977.7089 | Allowed-with-Review |
| 6 | 863 | Incorrect Authorization | 964.5587 | 964.5587 | Allowed-with-Review |
| 7 | 287 | Improper Authentication | 964.3987 | 964.3987 | Discouraged |
| 8 | 617 | Reachable Assertion | 963.6867 | 963.6867 | Allowed |
| 9 | 125 | Out-of-bounds Read | 957.7939 | 957.7939 | Allowed |
| 10 | 754 | Improper Check for Unusual or Exceptional Conditions | 956.6364 | 956.6364 | Allowed-with-Review |
