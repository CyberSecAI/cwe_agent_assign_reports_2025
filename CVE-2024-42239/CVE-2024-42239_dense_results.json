{
  "query": "In the Linux kernel, the following vulnerability has been resolved bpf Fail bpf_timer_cancel when callback is being cancelled Given a schedule timer1 cbtimer2 cb bpf_timer_cancel(timer2)bpf_timer_cancel(timer1) Both bpf_timer_cancel calls would wait for the other callback to finish executing, introducing a lockup. Add an atomic_t count named cancelling in bpf_hrtimer. This keeps track of all in-flight cancellation requests for a given BPF timer. Whenever cancelling a BPF timer, we must check if we have outstanding cancellation requests, and if so, we must fail the operation with an error (-EDEADLK) since cancellation is synchronous and waits for the callback to finish executing. This implies that we can enter a deadlock situation involving two or more timer callbacks executing in parallel and attempting to cancel one another. Note that we avoid incrementing the cancelling counter for the target timer (the one being cancelled) if bpf_timer_cancel is not invoked from a callback, to avoid spurious errors. The whole point of detecting cur->cancelling and returning -EDEADLK is to not enter a busy wait loop (which may or may not lead to a lockup). This does not apply in case the caller is in a non-callback context, the other side can continue to cancel as it sees fit without running into errors. Background on prior attempts Earlier versions of this patch used a bool cancelling bit and used the following pattern under timer->lock to publish cancellation status. l",
  "count": 20,
  "results": [
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "abstraction": "Base",
      "score": 0.4268775837822191,
      "original_score": 0.4268775837822191,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "abstraction": "Class",
      "score": 0.39623838737263717,
      "original_score": 0.39623838737263717,
      "mapping_usage": "Allowed-with-Review"
    },
    {
      "cwe_id": "364",
      "name": "Signal Handler Race Condition",
      "abstraction": "Base",
      "score": 0.39000294825262927,
      "original_score": 0.39000294825262927,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "828",
      "name": "Signal Handler with Functionality that is not Asynchronous-Safe",
      "abstraction": "Variant",
      "score": 0.3878474556517979,
      "original_score": 0.3878474556517979,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "606",
      "name": "Unchecked Input for Loop Condition",
      "abstraction": "Base",
      "score": 0.38465834466541027,
      "original_score": 0.38465834466541027,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "765",
      "name": "Multiple Unlocks of a Critical Resource",
      "abstraction": "Base",
      "score": 0.376106956106128,
      "original_score": 0.376106956106128,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "1322",
      "name": "Use of Blocking Code in Single-threaded, Non-blocking Context",
      "abstraction": "Base",
      "score": 0.3752632159895601,
      "original_score": 0.3752632159895601,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "413",
      "name": "Improper Resource Locking",
      "abstraction": "Base",
      "score": 0.3745270544484647,
      "original_score": 0.3745270544484647,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "663",
      "name": "Use of a Non-reentrant Function in a Concurrent Context",
      "abstraction": "Base",
      "score": 0.37073208456293355,
      "original_score": 0.37073208456293355,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "1264",
      "name": "Hardware Logic with Insecure De-Synchronization between Control and Data Channels",
      "abstraction": "Base",
      "score": 0.3700487729678174,
      "original_score": 0.3700487729678174,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "abstraction": "Class",
      "score": 0.3601823031979746,
      "original_score": 0.3601823031979746,
      "mapping_usage": "Allowed-with-Review"
    },
    {
      "cwe_id": "385",
      "name": "Covert Timing Channel",
      "abstraction": "Base",
      "score": 0.35700271797442806,
      "original_score": 0.35700271797442806,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "479",
      "name": "Signal Handler Use of a Non-reentrant Function",
      "abstraction": "Variant",
      "score": 0.35398849299190205,
      "original_score": 0.35398849299190205,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "775",
      "name": "Missing Release of File Descriptor or Handle after Effective Lifetime",
      "abstraction": "Variant",
      "score": 0.3507655670129058,
      "original_score": 0.3507655670129058,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "820",
      "name": "Missing Synchronization",
      "abstraction": "Base",
      "score": 0.3505390962983679,
      "original_score": 0.3505390962983679,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "834",
      "name": "Excessive Iteration",
      "abstraction": "Class",
      "score": 0.3490156877409719,
      "original_score": 0.3490156877409719,
      "mapping_usage": "Discouraged"
    },
    {
      "cwe_id": "764",
      "name": "Multiple Locks of a Critical Resource",
      "abstraction": "Base",
      "score": 0.3489039409678616,
      "original_score": 0.3489039409678616,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "911",
      "name": "Improper Update of Reference Count",
      "abstraction": "Base",
      "score": 0.3488717417803031,
      "original_score": 0.3488717417803031,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "1341",
      "name": "Multiple Releases of Same Resource or Handle",
      "abstraction": "Base",
      "score": 0.3477099562685322,
      "original_score": 0.3477099562685322,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "1281",
      "name": "Sequence of Processor Instructions Leads to Unexpected Behavior",
      "abstraction": "Base",
      "score": 0.34693450372895884,
      "original_score": 0.34693450372895884,
      "mapping_usage": "Allowed"
    }
  ],
  "statistics": {
    "min": 0.34693450372895884,
    "max": 0.4268775837822191,
    "mean": 0.36831084058809016,
    "median": 0.365115538082896,
    "count": 20
  }
}