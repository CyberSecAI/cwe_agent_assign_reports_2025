{
  "method": "sparse_base",
  "query": "In the Linux kernel, the following vulnerability has been resolved bpf Fail bpf_timer_cancel when callback is being cancelled Given a schedule timer1 cbtimer2 cb bpf_timer_cancel(timer2)bpf_timer_cancel(timer1) Both bpf_timer_cancel calls would wait for the other callback to finish executing, introducing a lockup. Add an atomic_t count named cancelling in bpf_hrtimer. This keeps track of all in-flight cancellation requests for a given BPF timer. Whenever cancelling a BPF timer, we must check if we have outstanding cancellation requests, and if so, we must fail the operation with an error (-EDEADLK) since cancellation is synchronous and waits for the callback to finish executing. This implies that we can enter a deadlock situation involving two or more timer callbacks executing in parallel and attempting to cancel one another. Note that we avoid incrementing the cancelling counter for the target timer (the one being cancelled) if bpf_timer_cancel is not invoked from a callback, to avoid spurious errors. The whole point of detecting cur->cancelling and returning -EDEADLK is to not enter a busy wait loop (which may or may not lead to a lockup). This does not apply in case the caller is in a non-callback context, the other side can continue to cancel as it sees fit without running into errors. Background on prior attempts Earlier versions of this patch used a bool cancelling bit and used the following pattern under timer->lock to publish cancellation status. l",
  "keyphrases": {
    "base_query": "In the Linux kernel, the following vulnerability has been resolved bpf Fail bpf_timer_cancel when callback is being cancelled Given a schedule timer1 cbtimer2 cb bpf_timer_cancel(timer2)bpf_timer_cancel(timer1) Both bpf_timer_cancel calls would wait for the other callback to finish executing, introducing a lockup. Add an atomic_t count named cancelling in bpf_hrtimer. This keeps track of all in-flight cancellation requests for a given BPF timer. Whenever cancelling a BPF timer, we must check if we have outstanding cancellation requests, and if so, we must fail the operation with an error (-EDEADLK) since cancellation is synchronous and waits for the callback to finish executing. This implies that we can enter a deadlock situation involving two or more timer callbacks executing in parallel and attempting to cancel one another. Note that we avoid incrementing the cancelling counter for the target timer (the one being cancelled) if bpf_timer_cancel is not invoked from a callback, to avoid spurious errors. The whole point of detecting cur->cancelling and returning -EDEADLK is to not enter a busy wait loop (which may or may not lead to a lockup). This does not apply in case the caller is in a non-callback context, the other side can continue to cancel as it sees fit without running into errors. Background on prior attempts Earlier versions of this patch used a bool cancelling bit and used the following pattern under timer->lock to publish cancellation status. l"
  },
  "timestamp": "2025-07-12T03:41:06.648382",
  "results_count": 10,
  "results_summary": [
    {
      "doc_id": "364",
      "name": "Signal Handler Race Condition",
      "score": 350.3254593171666
    },
    {
      "doc_id": "835",
      "name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
      "score": 349.5545052990197
    },
    {
      "doc_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "score": 349.18176504828153
    },
    {
      "doc_id": "667",
      "name": "Improper Locking",
      "score": 345.7886351636787
    },
    {
      "doc_id": "863",
      "name": "Incorrect Authorization",
      "score": 344.48526257825364
    }
  ]
}