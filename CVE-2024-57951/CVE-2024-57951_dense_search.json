{
  "retriever": "dense",
  "query": "In the Linux kernel, the following vulnerability has been resolved hrtimers Handle CPU state correctly on hotplug Consider a scenario where a CPU transitions from CPUHP_ONLINE to halfway through a CPU hotunplug down to CPUHP_HRTIMERS_PREPARE, and then back to CPUHP_ONLINE Since hrtimers_prepare_cpu() does not run, cpu_base.hres_active remains set to 1 throughout. However, during a CPU unplug operation, the tick and the clockevents are shut down at CPUHP_AP_TICK_DYING. On return to the online state, for instance CFS incorrectly assumes that the hrtick is already active, and the chance of the clockevent device to transition to oneshot mode is also lost forever for the CPU, unless it goes back to a lower state than CPUHP_HRTIMERS_PREPARE once. This round-trip reveals another issue cpu_base.online is not set to 1 after the transition, which appears as a WARN_ON_ONCE in enqueue_hrtimer(). Aside of that, the bulk of the per CPU state is not reset either, which means there are dangling pointers in the worst case. Address this by adding a corresponding startup() callback, which resets the stale per CPU state and sets the online flag. [ tglx Make the new callback unconditionally available, remove the online modification in the prepare() callback and clear the remaining state in the starting callback instead of the prepare callback ]",
  "keyphrases": {
    "weakness": [
      "dangling pointers",
      "hres_active remains set to 1"
    ]
  },
  "timestamp": "2025-07-14 00:37:32",
  "cve_id": "CVE-2024-57951",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "1256",
      "name": "Improper Restriction of Software Interfaces to Hardware Features",
      "type": "Base",
      "score": 0.4996642046654281
    },
    {
      "cwe_id": "909",
      "name": "Missing Initialization of Resource",
      "type": "Class",
      "score": 0.4825406297272126
    },
    {
      "cwe_id": "1342",
      "name": "Information Exposure through Microarchitectural State after Transient Execution",
      "type": "Base",
      "score": 0.4800198531276658
    },
    {
      "cwe_id": "1233",
      "name": "Security-Sensitive Hardware Controls with Missing Lock Bit Protection",
      "type": "Base",
      "score": 0.471577392041215
    },
    {
      "cwe_id": "413",
      "name": "Improper Resource Locking",
      "type": "Base",
      "score": 0.47055318332592105
    },
    {
      "cwe_id": "1247",
      "name": "Improper Protection Against Voltage and Clock Glitches",
      "type": "Base",
      "score": 0.470385437385863
    },
    {
      "cwe_id": "1272",
      "name": "Sensitive Information Uncleared Before Debug/Power State Transition",
      "type": "Base",
      "score": 0.4680442584914926
    },
    {
      "cwe_id": "1264",
      "name": "Hardware Logic with Insecure De-Synchronization between Control and Data Channels",
      "type": "Base",
      "score": 0.4679444784579826
    },
    {
      "cwe_id": "1421",
      "name": "Exposure of Sensitive Information in Shared Microarchitectural Structures during Transient Execution",
      "type": "Base",
      "score": 0.46718207028374686
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 0.46707128467702963
    },
    {
      "cwe_id": "1281",
      "name": "Sequence of Processor Instructions Leads to Unexpected Behavior",
      "type": "Base",
      "score": 0.4504889854554165
    },
    {
      "cwe_id": "1423",
      "name": "Exposure of Sensitive Information caused by Shared Microarchitectural Predictor State that Influences Transient Execution",
      "type": "Base",
      "score": 0.44335053205782793
    },
    {
      "cwe_id": "1260",
      "name": "Improper Handling of Overlap Between Protected Memory Ranges",
      "type": "Base",
      "score": 0.4431532522540134
    },
    {
      "cwe_id": "1252",
      "name": "CPU Hardware Not Configured to Support Exclusivity of Write and Execute Operations",
      "type": "Base",
      "score": 0.44267755124479136
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "type": "Class",
      "score": 0.4415174129226298
    },
    {
      "cwe_id": "908",
      "name": "Use of Uninitialized Resource",
      "type": "Base",
      "score": 0.44120681426576147
    },
    {
      "cwe_id": "1313",
      "name": "Hardware Allows Activation of Test or Debug Logic at Runtime",
      "type": "Base",
      "score": 0.4410391199432618
    },
    {
      "cwe_id": "1232",
      "name": "Improper Lock Behavior After Power State Transition",
      "type": "Base",
      "score": 0.4408456452774019
    },
    {
      "cwe_id": "911",
      "name": "Improper Update of Reference Count",
      "type": "Base",
      "score": 0.43863548680415143
    },
    {
      "cwe_id": "366",
      "name": "Race Condition within a Thread",
      "type": "Base",
      "score": 0.43393377235358477
    }
  ]
}