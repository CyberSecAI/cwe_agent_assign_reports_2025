{
  "retriever": "graph",
  "query": "In the Linux kernel, the following vulnerability has been resolved hrtimers Handle CPU state correctly on hotplug Consider a scenario where a CPU transitions from CPUHP_ONLINE to halfway through a CPU hotunplug down to CPUHP_HRTIMERS_PREPARE, and then back to CPUHP_ONLINE Since hrtimers_prepare_cpu() does not run, cpu_base.hres_active remains set to 1 throughout. However, during a CPU unplug operation, the tick and the clockevents are shut down at CPUHP_AP_TICK_DYING. On return to the online state, for instance CFS incorrectly assumes that the hrtick is already active, and the chance of the clockevent device to transition to oneshot mode is also lost forever for the CPU, unless it goes back to a lower state than CPUHP_HRTIMERS_PREPARE once. This round-trip reveals another issue cpu_base.online is not set to 1 after the transition, which appears as a WARN_ON_ONCE in enqueue_hrtimer(). Aside of that, the bulk of the per CPU state is not reset either, which means there are dangling pointers in the worst case. Address this by adding a corresponding startup() callback, which resets the stale per CPU state and sets the online flag. [ tglx Make the new callback unconditionally available, remove the online modification in the prepare() callback and clear the remaining state in the starting callback instead of the prepare callback ] Consider specifically these CWEs: CWE-400 CWE-407 CWE-226 CWE-639 CWE-413 CWE-909 CWE-1256 CWE-1342 CWE-1269 CWE-1233",
  "keyphrases": {
    "original_query": "In the Linux kernel, the following vulnerability has been resolved hrtimers Handle CPU state correctly on hotplug Consider a scenario where a CPU transitions from CPUHP_ONLINE to halfway through a CPU hotunplug down to CPUHP_HRTIMERS_PREPARE, and then back to CPUHP_ONLINE Since hrtimers_prepare_cpu() does not run, cpu_base.hres_active remains set to 1 throughout. However, during a CPU unplug operation, the tick and the clockevents are shut down at CPUHP_AP_TICK_DYING. On return to the online state, for instance CFS incorrectly assumes that the hrtick is already active, and the chance of the clockevent device to transition to oneshot mode is also lost forever for the CPU, unless it goes back to a lower state than CPUHP_HRTIMERS_PREPARE once. This round-trip reveals another issue cpu_base.online is not set to 1 after the transition, which appears as a WARN_ON_ONCE in enqueue_hrtimer(). Aside of that, the bulk of the per CPU state is not reset either, which means there are dangling pointers in the worst case. Address this by adding a corresponding startup() callback, which resets the stale per CPU state and sets the online flag. [ tglx Make the new callback unconditionally available, remove the online modification in the prepare() callback and clear the remaining state in the starting callback instead of the prepare callback ]",
    "enhanced_query": "In the Linux kernel, the following vulnerability has been resolved hrtimers Handle CPU state correctly on hotplug Consider a scenario where a CPU transitions from CPUHP_ONLINE to halfway through a CPU hotunplug down to CPUHP_HRTIMERS_PREPARE, and then back to CPUHP_ONLINE Since hrtimers_prepare_cpu() does not run, cpu_base.hres_active remains set to 1 throughout. However, during a CPU unplug operation, the tick and the clockevents are shut down at CPUHP_AP_TICK_DYING. On return to the online state, for instance CFS incorrectly assumes that the hrtick is already active, and the chance of the clockevent device to transition to oneshot mode is also lost forever for the CPU, unless it goes back to a lower state than CPUHP_HRTIMERS_PREPARE once. This round-trip reveals another issue cpu_base.online is not set to 1 after the transition, which appears as a WARN_ON_ONCE in enqueue_hrtimer(). Aside of that, the bulk of the per CPU state is not reset either, which means there are dangling pointers in the worst case. Address this by adding a corresponding startup() callback, which resets the stale per CPU state and sets the online flag. [ tglx Make the new callback unconditionally available, remove the online modification in the prepare() callback and clear the remaining state in the starting callback instead of the prepare callback ] Consider specifically these CWEs: CWE-400 CWE-407 CWE-226 CWE-639 CWE-413 CWE-909 CWE-1256 CWE-1342 CWE-1269 CWE-1233",
    "cwe_mentions": [
      "CWE-400",
      "CWE-407",
      "CWE-226",
      "CWE-639",
      "CWE-413",
      "CWE-909",
      "CWE-1256",
      "CWE-1342",
      "CWE-1269",
      "CWE-1233"
    ],
    "search_time": 2.555777072906494
  },
  "timestamp": "2025-07-14 00:37:35",
  "cve_id": "CVE-2024-57951",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "226",
      "name": "Sensitive Information in Resource Not Removed Before Reuse",
      "type": "base",
      "score": 2.4699999999999998,
      "relationship_count": 0
    },
    {
      "cwe_id": "410",
      "name": "Insufficient Resource Pool",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "201",
      "name": "Insertion of Sensitive Information Into Sent Data",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "639",
      "name": "Authorization Bypass Through User-Controlled Key",
      "type": "base",
      "score": 2.1189999999999998,
      "relationship_count": 0
    },
    {
      "cwe_id": "1269",
      "name": "Product Released in Non-Release Configuration",
      "type": "base",
      "score": 2.1189999999999998,
      "relationship_count": 0
    },
    {
      "cwe_id": "1342",
      "name": "Information Exposure through Microarchitectural State after Transient Execution",
      "type": "Base",
      "score": 1.6836426261170727,
      "relationship_count": 0
    },
    {
      "cwe_id": "1233",
      "name": "Security-Sensitive Hardware Controls with Missing Lock Bit Protection",
      "type": "Base",
      "score": 1.6404622964026543,
      "relationship_count": 0
    },
    {
      "cwe_id": "212",
      "name": "Improper Removal of Sensitive Information Before Storage or Transfer",
      "type": "base",
      "score": 1.6094,
      "relationship_count": 0
    },
    {
      "cwe_id": "1256",
      "name": "Improper Restriction of Software Interfaces to Hardware Features",
      "type": "Base",
      "score": 1.607528561174219,
      "relationship_count": 0
    },
    {
      "cwe_id": "908",
      "name": "Use of Uninitialized Resource",
      "type": "Base",
      "score": 1.5249545176795363,
      "relationship_count": 0
    },
    {
      "cwe_id": "413",
      "name": "Improper Resource Locking",
      "type": "Base",
      "score": 1.4741557136306027,
      "relationship_count": 0
    },
    {
      "cwe_id": "407",
      "name": "Inefficient Algorithmic Complexity",
      "type": "class",
      "score": 1.3648,
      "relationship_count": 0
    },
    {
      "cwe_id": "244",
      "name": "Improper Clearing of Heap Memory Before Release ('Heap Inspection')",
      "type": "variant",
      "score": 1.2864,
      "relationship_count": 0
    },
    {
      "cwe_id": "400",
      "name": "Uncontrolled Resource Consumption",
      "type": "class",
      "score": 1.192,
      "relationship_count": 0
    },
    {
      "cwe_id": "1271",
      "name": "Uninitialized Value on Reset for Registers Holding Security Settings",
      "type": "base",
      "score": 1.1466,
      "relationship_count": 0
    },
    {
      "cwe_id": "920",
      "name": "Improper Restriction of Power Consumption",
      "type": "base",
      "score": 1.0062,
      "relationship_count": 0
    },
    {
      "cwe_id": "779",
      "name": "Logging of Excessive Data",
      "type": "base",
      "score": 1.0062,
      "relationship_count": 0
    },
    {
      "cwe_id": "771",
      "name": "Missing Reference to Active Allocated Resource",
      "type": "base",
      "score": 1.0062,
      "relationship_count": 0
    },
    {
      "cwe_id": "770",
      "name": "Allocation of Resources Without Limits or Throttling",
      "type": "base",
      "score": 1.0062,
      "relationship_count": 0
    },
    {
      "cwe_id": "1246",
      "name": "Improper Write Handling in Limited-write Non-Volatile Memories",
      "type": "base",
      "score": 1.0062,
      "relationship_count": 0
    }
  ]
}