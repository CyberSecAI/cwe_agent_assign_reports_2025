# Vulnerability Information: CVE-2024-57951

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved hrtimers Handle CPU state correctly on hotplug Consider a scenario where a CPU transitions from CPUHP_ONLINE to halfway through a CPU hotunplug down to CPUHP_HRTIMERS_PREPARE, and then back to CPUHP_ONLINE Since hrtimers_prepare_cpu() does not run, cpu_base.hres_active remains set to 1 throughout. However, during a CPU unplug operation, the tick and the clockevents are shut down at CPUHP_AP_TICK_DYING. On return to the online state, for instance CFS incorrectly assumes that the hrtick is already active, and the chance of the clockevent device to transition to oneshot mode is also lost forever for the CPU, unless it goes back to a lower state than CPUHP_HRTIMERS_PREPARE once. This round-trip reveals another issue cpu_base.online is not set to 1 after the transition, which appears as a WARN_ON_ONCE in enqueue_hrtimer(). Aside of that, the bulk of the per CPU state is not reset either, which means there are dangling pointers in the worst case. Address this by adding a corresponding startup() callback, which resets the stale per CPU state and sets the online flag. [ tglx Make the new callback unconditionally available, remove the online modification in the prepare() callback and clear the remaining state in the starting callback instead of the prepare callback ]

### Vulnerability Description Key Phrases
- **vector:** hotplug
- **weakness:** **dangling pointers, hres_active remains set to 1**
- **product:** Linux kernel
- **impact:** kernel panic

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 416 | Use After Free | Variant | Allowed | alternate_terms | 0.800 |
| 2 | 825 | Expired Pointer Dereference | Base | Allowed | alternate_terms | 0.800 |
| 3 | 226 | Sensitive Information in Resource Not Removed Before Reuse | Base | Allowed | sparse | 0.985 |
| 4 | 407 | Inefficient Algorithmic Complexity | Class | Allowed-with-Review | sparse | 0.974 |
| 5 | 639 | Authorization Bypass Through User-Controlled Key | Base | Allowed | sparse | 0.963 |
| 6 | 1269 | Product Released in Non-Release Configuration | Base | Allowed | sparse | 0.960 |
| 7 | 400 | Uncontrolled Resource Consumption | Class | Discouraged | sparse | 0.960 |
| 8 | 863 | Incorrect Authorization | Class | Allowed-with-Review | sparse | 0.945 |
| 9 | 1256 | Improper Restriction of Software Interfaces to Hardware Features | Base | Allowed | dense | 0.500 |
| 10 | 410 | Insufficient Resource Pool | Base | Allowed | graph | 0.002 |

