{
  "retriever": "sparse",
  "query": "In the Linux kernel, the following vulnerability has been resolved hrtimers Handle CPU state correctly on hotplug Consider a scenario where a CPU transitions from CPUHP_ONLINE to halfway through a CPU hotunplug down to CPUHP_HRTIMERS_PREPARE, and then back to CPUHP_ONLINE Since hrtimers_prepare_cpu() does not run, cpu_base.hres_active remains set to 1 throughout. However, during a CPU unplug operation, the tick and the clockevents are shut down at CPUHP_AP_TICK_DYING. On return to the online state, for instance CFS incorrectly assumes that the hrtick is already active, and the chance of the clockevent device to transition to oneshot mode is also lost forever for the CPU, unless it goes back to a lower state than CPUHP_HRTIMERS_PREPARE once. This round-trip reveals another issue cpu_base.online is not set to 1 after the transition, which appears as a WARN_ON_ONCE in enqueue_hrtimer(). Aside of that, the bulk of the per CPU state is not reset either, which means there are dangling pointers in the worst case. Address this by adding a corresponding startup() callback, which resets the stale per CPU state and sets the online flag. [ tglx Make the new callback unconditionally available, remove the online modification in the prepare() callback and clear the remaining state in the starting callback instead of the prepare callback ]",
  "keyphrases": {
    "weakness": [
      "dangling pointers",
      "hres_active remains set to 1"
    ]
  },
  "timestamp": "2025-07-12 06:57:19",
  "cve_id": "CVE-2024-57951",
  "result_count": 12,
  "results": [
    {
      "cwe_id": "226",
      "name": "Sensitive Information in Resource Not Removed Before Reuse",
      "score": 984.7761695098604,
      "search_source": "weakness:hres_active remains set to 1"
    },
    {
      "cwe_id": "407",
      "name": "Inefficient Algorithmic Complexity",
      "score": 974.1679792085752,
      "search_source": "weakness:hres_active remains set to 1"
    },
    {
      "cwe_id": "639",
      "name": "Authorization Bypass Through User-Controlled Key",
      "score": 963.3896502252004,
      "search_source": "weakness:hres_active remains set to 1"
    },
    {
      "cwe_id": "1269",
      "name": "Product Released in Non-Release Configuration",
      "score": 959.8589476015599,
      "search_source": "weakness:hres_active remains set to 1"
    },
    {
      "cwe_id": "400",
      "name": "Uncontrolled Resource Consumption",
      "score": 959.7393298257282,
      "search_source": "weakness:hres_active remains set to 1"
    },
    {
      "cwe_id": "863",
      "name": "Incorrect Authorization",
      "score": 945.4115862133235,
      "search_source": "weakness:hres_active remains set to 1"
    },
    {
      "cwe_id": "345",
      "name": "Insufficient Verification of Data Authenticity",
      "score": 936.4803911867608,
      "search_source": "weakness:hres_active remains set to 1"
    },
    {
      "cwe_id": "201",
      "name": "Insertion of Sensitive Information Into Sent Data",
      "score": 930.5658761676506,
      "search_source": "weakness:hres_active remains set to 1"
    },
    {
      "cwe_id": "835",
      "name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
      "score": 930.5599522301917,
      "search_source": "weakness:hres_active remains set to 1"
    },
    {
      "cwe_id": "79",
      "name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
      "score": 928.5681273550458,
      "search_source": "weakness:hres_active remains set to 1"
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "score": 800.0,
      "search_source": "alternate_term_match"
    },
    {
      "cwe_id": "825",
      "name": "Expired Pointer Dereference",
      "score": 800.0,
      "search_source": "alternate_term_match"
    }
  ]
}