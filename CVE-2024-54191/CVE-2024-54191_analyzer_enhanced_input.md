## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved Bluetooth iso Fix circular lock in iso_conn_big_sync This fixes the **circular locking dependency** warning below, by reworking iso_sock_recvmsg, to ensure that the socket lock is always released before calling a function that locks hdev. [ 561.670344] ====================================================== [ 561.670346] WARNING possible **circular locking dependency** detected [ 561.670349] 6.12.0-rc6+ #26 Not tainted [ 561.670351] ------------------------------------------------------ [ 561.670353] iso-tester/3289 is trying to acquire lock [ 561.670355] ffff88811f600078 (&hdev->lock){+.+.}-{33}, at iso_conn_big_sync+0x73/0x260 [bluetooth] [ 561.670405] but task is already holding lock [ 561.670407] ffff88815af58258 (sk_lock-AF_BLUETOOTH){+.+.}-{00}, at iso_sock_recvmsg+0xbf/0x500 [bluetooth] [ 561.670450] which lock already depends on the new lock. [ 561.670452] the existing dependency chain (in reverse order) is [ 561.670453] -> #2 (sk_lock-AF_BLUETOOTH){+.+.}-{00} [ 561.670458] lock_acquire+0x7c/0xc0 [ 561.670463] lock_sock_nested+0x3b/0xf0 [ 561.670467] bt_accept_dequeue+0x1a5/0x4d0 [bluetooth] [ 561.670510] iso_sock_accept+0x271/0x830 [bluetooth] [ 561.670547] do_accept+0x3dd/0x610 [ 561.670550] __sys_accept4+0xd8/0x170 [ 561.670553] __x64_sys_accept+0x74/0xc0 [ 561.670556] x64_sys_call+0x17d6/0x25f0 [ 561.670559] do_syscall_64+0x87/0x150 [ 561.670563] entry_SYSCALL_64_after_hwframe+0x76/0x7e [ 561.670567] -> #1 (sk_lock-AF_BLUETOOTH-BTPROTO_ISO){+.+.}-{00} [ 561.670571] lock_acquire+0x7c/0xc0 [ 561.670574] lock_sock_nested+0x3b/0xf0 [ 561.670577] iso_sock_listen+0x2de/0xf30 [bluetooth] [ 561.670617] __sys_listen_socket+0xef/0x130 [ 561.670620] __x64_sys_listen+0xe1/0x190 [ 561.670623] x64_sys_call+0x2517/0x25f0 [ 561.670626] do_syscall_64+0x87/0x150 [ 561.670629] entry_SYSCALL_64_after_hwframe+0x76/0x7e [ 561.670632] -> #0 (&hdev->lock){+.+.}-{33} [ 561.670636] __lock_acquire+0x32ad/0x6ab0 [ 561.670639] lock_acquire.part.0+0x118/0x360 [ 561.670642] lock_acquire+0x7c/0xc0 [ 561.670644] __mutex_lock+0x18d/0x12f0 [ 561.670647] mutex_lock_nested+0x1b/0x30 [ 561.670651] iso_conn_big_sync+0x73/0x260 [bluetooth] [ 561.670687] iso_sock_recvmsg+0x3e9/0x500 [bluetooth] [ 561.670722] sock_recvmsg+0x1d5/0x240 [ 561.670725] sock_read_iter+0x27d/0x470 [ 561.670727] vfs_read+0x9a0/0xd30 [ 561.670731] ksys_read+0x1a8/0x250 [ 561.670733] __x64_sys_read+0x72/0xc0 [ 561.670736] x64_sys_call+0x1b12/0x25f0 [ 561.670738] do_syscall_64+0x87/0x150 [ 561.670741] entry_SYSCALL_64_after_hwframe+0x76/0x7e [ 561.670744] other info that might help us debug this [ 561.670745] Chain exists of &hdev->lock --> sk_lock-AF_BLUETOOTH-BTPROTO_ISO --> sk_lock-AF_BLUETOOTH [ 561.670751] Possible unsafe locking scenario [ 561.670753] CPU0 CPU1 [ 561.670754] ---- ---- [ 561.670756] lock(sk_lock-AF_BLUETOOTH) [ 561.670758] lock(sk_lock AF_BLUETOOTH-BTPROTO_ISO) [ 561.670761] lock(sk_lock-AF_BLUETOOTH) [ 561.670764] lock(&hdev->lock) [ 561.670767] *** DEADLOCK ***

### Vulnerability Description Key Phrases
- **rootcause:** **circular locking dependency**
- **product:** Linux kernel
- **version:** 6.12.0-rc6+
- **component:** Bluetooth iso

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 561 | Dead Code | Base | Allowed | sparse | 1.684 |
| 2 | 570 | Expression is Always False | Base | Allowed | sparse | 1.454 |
| 3 | 571 | Expression is Always True | Base | Allowed | sparse | 1.454 |
| 4 | 1164 | Irrelevant Code | Class | Allowed-with-Review | sparse | 1.422 |
| 5 | 705 | Incorrect Control Flow Scoping | Class | Allowed-with-Review | sparse | 1.408 |
| 6 | 393 | Return of Wrong Status Code | Base | Allowed | sparse | 1.372 |
| 7 | 300 | Channel Accessible by Non-Endpoint | Class | Discouraged | sparse | 1.245 |
| 8 | 691 | Insufficient Control Flow Management | Pillar | Discouraged | sparse | 1.121 |
| 9 | 833 | Deadlock | Base | Allowed | dense | 0.552 |
| 10 | 120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | Base | Allowed-with-Review | graph | 0.002 |



# Complete CWE Specifications

CWE-561: Dead Code

CWE-570: Expression is Always False

CWE-571: Expression is Always True

CWE-1164: Irrelevant Code

CWE-705: Incorrect Control Flow Scoping

CWE-393: Return of Wrong Status Code

CWE-300: Channel Accessible by Non-Endpoint

CWE-691: Insufficient Control Flow Management

CWE-833: Deadlock

CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')