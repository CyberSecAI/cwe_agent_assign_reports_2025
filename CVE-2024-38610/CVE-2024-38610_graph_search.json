{
  "retriever": "graph",
  "query": "In the Linux kernel, the following vulnerability has been resolved drivers/virt/acrn fix PFNMAP PTE checks in acrn_vm_ram_map() Patch series mm follow_pte() improvements and acrn follow_pte() fixes. Patch #1 fixes a bunch of issues I spotted in the acrn driver. It compiles, thats all I know. Ill appreciate some review and testing from acrn folks. Patch #2+#3 improve follow_pte(), passing a VMA instead of the MM, adding more sanity checks, and improving the documentation. Gave it a quick test on x86-64 using VM_PAT that ends up using follow_pte(). This patch (of 3) We currently miss handling various cases, resulting in a dangerous follow_pte() (previously follow_pfn()) usage. (1) Were not checking PTE write permissions. Maybe we should simply always require pte_write() like we do for pin_user_pages_fast(FOLL_WRITE)? Hard to tell, so lets check for ACRN_MEM_ACCESS_WRITE for now. (2) Were not rejecting refcounted pages. As we are not using MMU notifiers, messing with refcounted pages is dangerous and can result in use-after-free. Lets make sure to reject them. (3) We are only looking at the first PTE of a bigger range. We only lookup a single PTE, but memmap->len may span a larger area. Lets loop over all involved PTEs and make sure the PFN range is actually contiguous. Reject everything else it couldnt have worked either way, and rather made use access PFNs we shouldnt be accessing. Consider specifically these CWEs: CWE-863 CWE-1284 CWE-404 CWE-667 CWE-909 CWE-362 CWE-367 CWE-1260 CWE-212",
  "keyphrases": {
    "original_query": "In the Linux kernel, the following vulnerability has been resolved drivers/virt/acrn fix PFNMAP PTE checks in acrn_vm_ram_map() Patch series mm follow_pte() improvements and acrn follow_pte() fixes. Patch #1 fixes a bunch of issues I spotted in the acrn driver. It compiles, thats all I know. Ill appreciate some review and testing from acrn folks. Patch #2+#3 improve follow_pte(), passing a VMA instead of the MM, adding more sanity checks, and improving the documentation. Gave it a quick test on x86-64 using VM_PAT that ends up using follow_pte(). This patch (of 3) We currently miss handling various cases, resulting in a dangerous follow_pte() (previously follow_pfn()) usage. (1) Were not checking PTE write permissions. Maybe we should simply always require pte_write() like we do for pin_user_pages_fast(FOLL_WRITE)? Hard to tell, so lets check for ACRN_MEM_ACCESS_WRITE for now. (2) Were not rejecting refcounted pages. As we are not using MMU notifiers, messing with refcounted pages is dangerous and can result in use-after-free. Lets make sure to reject them. (3) We are only looking at the first PTE of a bigger range. We only lookup a single PTE, but memmap->len may span a larger area. Lets loop over all involved PTEs and make sure the PFN range is actually contiguous. Reject everything else it couldnt have worked either way, and rather made use access PFNs we shouldnt be accessing.",
    "enhanced_query": "In the Linux kernel, the following vulnerability has been resolved drivers/virt/acrn fix PFNMAP PTE checks in acrn_vm_ram_map() Patch series mm follow_pte() improvements and acrn follow_pte() fixes. Patch #1 fixes a bunch of issues I spotted in the acrn driver. It compiles, thats all I know. Ill appreciate some review and testing from acrn folks. Patch #2+#3 improve follow_pte(), passing a VMA instead of the MM, adding more sanity checks, and improving the documentation. Gave it a quick test on x86-64 using VM_PAT that ends up using follow_pte(). This patch (of 3) We currently miss handling various cases, resulting in a dangerous follow_pte() (previously follow_pfn()) usage. (1) Were not checking PTE write permissions. Maybe we should simply always require pte_write() like we do for pin_user_pages_fast(FOLL_WRITE)? Hard to tell, so lets check for ACRN_MEM_ACCESS_WRITE for now. (2) Were not rejecting refcounted pages. As we are not using MMU notifiers, messing with refcounted pages is dangerous and can result in use-after-free. Lets make sure to reject them. (3) We are only looking at the first PTE of a bigger range. We only lookup a single PTE, but memmap->len may span a larger area. Lets loop over all involved PTEs and make sure the PFN range is actually contiguous. Reject everything else it couldnt have worked either way, and rather made use access PFNs we shouldnt be accessing. Consider specifically these CWEs: CWE-863 CWE-1284 CWE-404 CWE-667 CWE-909 CWE-362 CWE-367 CWE-1260 CWE-212",
    "cwe_mentions": [
      "CWE-863",
      "CWE-1284",
      "CWE-404",
      "CWE-667",
      "CWE-909",
      "CWE-362",
      "CWE-367",
      "CWE-1260",
      "CWE-212"
    ],
    "search_time": 3.038351535797119
  },
  "timestamp": "2025-07-13 10:46:58",
  "cve_id": "CVE-2024-38610",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "609",
      "name": "Double-Checked Locking",
      "type": "base",
      "score": 2.8651999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "386",
      "name": "Symbolic Name not Mapping to Correct Object",
      "type": "base",
      "score": 2.3764000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "212",
      "name": "Improper Removal of Sensitive Information Before Storage or Transfer",
      "type": "base",
      "score": 2.3295999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "619",
      "name": "Dangling Database Cursor ('Cursor Injection')",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "201",
      "name": "Insertion of Sensitive Information Into Sent Data",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "367",
      "name": "Time-of-check Time-of-use (TOCTOU) Race Condition",
      "type": "Base",
      "score": 2.027988358159881,
      "relationship_count": 0
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "type": "Base",
      "score": 1.951399496405102,
      "relationship_count": 0
    },
    {
      "cwe_id": "1260",
      "name": "Improper Handling of Overlap Between Protected Memory Ranges",
      "type": "Base",
      "score": 1.9008077072591,
      "relationship_count": 0
    },
    {
      "cwe_id": "456",
      "name": "Missing Initialization of a Variable",
      "type": "variant",
      "score": 1.83936,
      "relationship_count": 0
    },
    {
      "cwe_id": "120",
      "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "123",
      "name": "Write-what-where Condition",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "226",
      "name": "Sensitive Information in Resource Not Removed Before Reuse",
      "type": "base",
      "score": 1.7550000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "364",
      "name": "Signal Handler Race Condition",
      "type": "base",
      "score": 1.7550000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "590",
      "name": "Free of Memory not on the Heap",
      "type": "variant",
      "score": 1.71168,
      "relationship_count": 0
    },
    {
      "cwe_id": "1257",
      "name": "Improper Access Control Applied to Mirrored or Aliased Memory Regions",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "1325",
      "name": "Improperly Controlled Sequential Memory Allocation",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "1339",
      "name": "Insufficient Precision or Accuracy of a Real Number",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "128",
      "name": "Wrap-around Error",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "193",
      "name": "Off-by-one Error",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "839",
      "name": "Numeric Range Comparison Without Minimum Check",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    }
  ]
}