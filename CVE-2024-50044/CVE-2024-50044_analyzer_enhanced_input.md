## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved Bluetooth RFCOMM FIX possible deadlock in rfcomm_sk_state_change rfcomm_sk_state_change attempts to use sock_lock so it must never be called with it locked but rfcomm_sock_ioctl always attempt to lock it causing the following trace ====================================================== WARNING possible **circular locking dependency** detected 6.8.0-syzkaller-08951-gfe46a7dd189e #0 Not tainted ------------------------------------------------------ syz-executor386/5093 is trying to acquire lock ffff88807c396258 (sk_lock-AF_BLUETOOTH-BTPROTO_RFCOMM){+.+.}-{00}, at lock_sock include/net/sock.h1671 [inline] ffff88807c396258 (sk_lock-AF_BLUETOOTH-BTPROTO_RFCOMM){+.+.}-{00}, at rfcomm_sk_state_change+0x5b/0x310 net/bluetooth/rfcomm/sock.c73 but task is already holding lock ffff88807badfd28 (&d->lock){+.+.}-{33}, at __rfcomm_dlc_close+0x226/0x6a0 net/bluetooth/rfcomm/core.c491

### Vulnerability Description Key Phrases
- **rootcause:** **circular locking dependency**
- **product:** Linux kernel
- **version:** 6.8.0-syzkaller-08951-gfe46a7dd189e
- **component:** Bluetooth RFCOMM

## CVE Reference Links Content Summary
- **Root cause of vulnerability:** A locking issue in the Linux kernel's Bluetooth RFCOMM implementation. The `rfcomm_sk_state_change` function attempts to acquire the `sock_lock` while it might already be held by the calling task, leading to a deadlock. This occurs because `rfcomm_sock_ioctl` always attempts to lock the socket, creating a potential circular locking dependency when `rfcomm_sk_state_change` is called.
- **Weaknesses/vulnerabilities present:** Circular locking dependency in the Bluetooth RFCOMM socket handling. Specifically, the `rfcomm_sk_state_change` function and `rfcomm_sock_ioctl` can attempt to acquire the same lock in a nested manner, causing a deadlock if not properly managed.
- **Impact of exploitation:** A deadlock can occur, leading to denial of service. The system may become unresponsive, requiring a reboot or manual intervention to recover.
- **Attack vectors:** Triggering a specific sequence of operations involving RFCOMM sockets, particularly relating to state changes and IOCTL calls which can be done through a local attacker by creating and manipulating RFCOMM sockets.
- **Required attacker capabilities/position:** The attacker needs to be able to create and manipulate Bluetooth RFCOMM sockets in a way that triggers both `rfcomm_sock_ioctl` and `rfcomm_sk_state_change` simultaneously or nested leading to the deadlock. This could be a local user on the system, or a process capable of using the bluetooth subsystem.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.428 |
| 2 | 833 | Deadlock | Base | Allowed | sparse | 0.404 |
| 3 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.337 |
| 4 | 764 | Multiple Locks of a Critical Resource | Base | Allowed | sparse | 0.324 |
| 5 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.320 |
| 6 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.307 |
| 7 | 287 | Improper Authentication | Class | Discouraged | sparse | 0.304 |
| 8 | 413 | Improper Resource Locking | Base | Allowed | sparse | 0.304 |
| 9 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | Allowed | dense | 0.498 |
| 10 | 390 | Detection of Error Condition Without Action | Base | Allowed | graph | 0.002 |



# Complete CWE Specifications

CWE-667: Improper Locking

CWE-833: Deadlock

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-764: Multiple Locks of a Critical Resource

CWE-401: Missing Release of Memory after Effective Lifetime

CWE-770: Allocation of Resources Without Limits or Throttling

CWE-287: Improper Authentication

CWE-413: Improper Resource Locking

CWE-1285: Improper Validation of Specified Index, Position, or Offset in Input

CWE-390: Detection of Error Condition Without Action