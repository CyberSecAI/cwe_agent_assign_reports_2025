{
  "retriever": "graph",
  "query": "In the Linux kernel, the following vulnerability has been resolved Bluetooth btusb mediatek Add locks for usb_driver_claim_interface() The documentation for usb_driver_claim_interface() says that the device lock is needed when the function is called from places other than probe(). This appears to be the lock for the USB interface device. The Mediatek btusb code gets called via this path Workqueue hci0 hci_power_on [bluetooth] Call trace usb_driver_claim_interface btusb_mtk_claim_iso_intf btusb_mtk_setup hci_dev_open_sync hci_power_on process_scheduled_works worker_thread kthread With the above call trace the device lock hasnt been claimed. Claim it. Without this fix, wed sometimes see the error Failed to claim iso interface. Sometimes wed even see worse errors, like a NULL pointer dereference (where `intf->dev.driver` was NULL) with a trace like Call trace usb_suspend_both usb_runtime_suspend __rpm_callback rpm_suspend pm_runtime_work process_scheduled_works Both errors appear to be fixed with the proper locking. Consider specifically these CWEs: CWE-476 CWE-1234 CWE-667 CWE-833 CWE-413 CWE-909 CWE-1256 CWE-1231 CWE-362 CWE-1233",
  "keyphrases": {
    "original_query": "In the Linux kernel, the following vulnerability has been resolved Bluetooth btusb mediatek Add locks for usb_driver_claim_interface() The documentation for usb_driver_claim_interface() says that the device lock is needed when the function is called from places other than probe(). This appears to be the lock for the USB interface device. The Mediatek btusb code gets called via this path Workqueue hci0 hci_power_on [bluetooth] Call trace usb_driver_claim_interface btusb_mtk_claim_iso_intf btusb_mtk_setup hci_dev_open_sync hci_power_on process_scheduled_works worker_thread kthread With the above call trace the device lock hasnt been claimed. Claim it. Without this fix, wed sometimes see the error Failed to claim iso interface. Sometimes wed even see worse errors, like a NULL pointer dereference (where `intf->dev.driver` was NULL) with a trace like Call trace usb_suspend_both usb_runtime_suspend __rpm_callback rpm_suspend pm_runtime_work process_scheduled_works Both errors appear to be fixed with the proper locking.",
    "enhanced_query": "In the Linux kernel, the following vulnerability has been resolved Bluetooth btusb mediatek Add locks for usb_driver_claim_interface() The documentation for usb_driver_claim_interface() says that the device lock is needed when the function is called from places other than probe(). This appears to be the lock for the USB interface device. The Mediatek btusb code gets called via this path Workqueue hci0 hci_power_on [bluetooth] Call trace usb_driver_claim_interface btusb_mtk_claim_iso_intf btusb_mtk_setup hci_dev_open_sync hci_power_on process_scheduled_works worker_thread kthread With the above call trace the device lock hasnt been claimed. Claim it. Without this fix, wed sometimes see the error Failed to claim iso interface. Sometimes wed even see worse errors, like a NULL pointer dereference (where `intf->dev.driver` was NULL) with a trace like Call trace usb_suspend_both usb_runtime_suspend __rpm_callback rpm_suspend pm_runtime_work process_scheduled_works Both errors appear to be fixed with the proper locking. Consider specifically these CWEs: CWE-476 CWE-1234 CWE-667 CWE-833 CWE-413 CWE-909 CWE-1256 CWE-1231 CWE-362 CWE-1233",
    "cwe_mentions": [
      "CWE-476",
      "CWE-1234",
      "CWE-667",
      "CWE-833",
      "CWE-413",
      "CWE-909",
      "CWE-1256",
      "CWE-1231",
      "CWE-362",
      "CWE-1233"
    ],
    "search_time": 2.773353338241577
  },
  "timestamp": "2025-07-14 09:52:17",
  "cve_id": "CVE-2025-21827",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "252",
      "name": "Unchecked Return Value",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "1325",
      "name": "Improperly Controlled Sequential Memory Allocation",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "908",
      "name": "Use of Uninitialized Resource",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "789",
      "name": "Memory Allocation with Excessive Size Value",
      "type": "variant",
      "score": 2.04,
      "relationship_count": 0
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "123",
      "name": "Write-what-where Condition",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "120",
      "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "364",
      "name": "Signal Handler Race Condition",
      "type": "base",
      "score": 1.7550000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 1.7098031164721816,
      "relationship_count": 0
    },
    {
      "cwe_id": "413",
      "name": "Improper Resource Locking",
      "type": "Base",
      "score": 1.6870556839145263,
      "relationship_count": 0
    },
    {
      "cwe_id": "1265",
      "name": "Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "386",
      "name": "Symbolic Name not Mapping to Correct Object",
      "type": "base",
      "score": 1.6744000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "1233",
      "name": "Security-Sensitive Hardware Controls with Missing Lock Bit Protection",
      "type": "Base",
      "score": 1.6739873341361171,
      "relationship_count": 0
    },
    {
      "cwe_id": "662",
      "name": "Improper Synchronization",
      "type": "class",
      "score": 1.6736000000000002,
      "relationship_count": 0
    },
    {
      "cwe_id": "1234",
      "name": "Hardware Internal or Debug Modes Allow Override of Locks",
      "type": "Base",
      "score": 1.664836257318903,
      "relationship_count": 0
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 1.6606382668372934,
      "relationship_count": 0
    },
    {
      "cwe_id": "129",
      "name": "Improper Validation of Array Index",
      "type": "variant",
      "score": 1.6320000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "61",
      "name": "UNIX Symbolic Link (Symlink) Following",
      "type": "compound",
      "score": 1.61,
      "relationship_count": 0
    },
    {
      "cwe_id": "609",
      "name": "Double-Checked Locking",
      "type": "base",
      "score": 1.5912000000000004,
      "relationship_count": 0
    }
  ]
}