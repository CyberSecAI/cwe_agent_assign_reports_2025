{
  "method": "sparse_rootcause_1",
  "query": "In the Linux kernel, the following vulnerability has been resolved filemap replace pte_offset_map() with pte_offset_map_nolock() The vmf->ptl in filemap_fault_recheck_pte_none() is still set from handle_pte_fault(). But at the same time, we did a pte_unmap(vmf->pte). After a pte_unmap(vmf->pte) unmap and rcu_read_unlock(), the page table may be racily changed and vmf->ptl maybe fails to protect the actual page table. Fix this by replacing pte_offset_map() with pte_offset_map_nolock(). As David said, the PTL pointer might be stale so if we continue to use it infilemap_fault_recheck_pte_none(), it might trigger UAF. Also, if the PTL fails, the issue fixed by commit 58f327f2ce80 (filemap avoid unnecessary major faults in filemap_fault()) might reappear.",
  "keyphrases": {
    "rootcause": "use of stale PTL pointer"
  },
  "timestamp": "2025-07-12T03:40:52.702504",
  "results_count": 10,
  "results_summary": [
    {
      "doc_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "score": 504.5663265407094
    },
    {
      "doc_id": "415",
      "name": "Double Free",
      "score": 502.6868348008361
    },
    {
      "doc_id": "125",
      "name": "Out-of-bounds Read",
      "score": 479.19523234049296
    },
    {
      "doc_id": "476",
      "name": "NULL Pointer Dereference",
      "score": 471.5764637514444
    },
    {
      "doc_id": "911",
      "name": "Improper Update of Reference Count",
      "score": 467.86312188486437
    }
  ]
}