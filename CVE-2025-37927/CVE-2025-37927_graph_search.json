{
  "retriever": "graph",
  "query": "In the Linux kernel, the following vulnerability has been resolved iommu/amd Fix potential buffer overflow in parse_ivrs_acpihid There is a string parsing logic error which can lead to an overflow of hid or uid buffers. Comparing ACPIID_LEN against a total string length doesnt take into account the lengths of individual hid and uid buffers so the check is insufficient in some cases. For example if the length of hid string is 4 and the length of the uid string is 260, the length of str will be equal to ACPIID_LEN + 1 but uid string will overflow uid buffer which size is 256. The same applies to the hid string with length 13 and uid string with length 250. Check the length of hid and uid strings separately to prevent buffer overflow. Found by Linux Verification Center (linuxtesting.org) with SVACE. Consider specifically these CWEs: CWE-1284 CWE-191 CWE-119 CWE-126 CWE-805 CWE-190 CWE-125 CWE-130 CWE-193 CWE-131",
  "keyphrases": {
    "original_query": "In the Linux kernel, the following vulnerability has been resolved iommu/amd Fix potential buffer overflow in parse_ivrs_acpihid There is a string parsing logic error which can lead to an overflow of hid or uid buffers. Comparing ACPIID_LEN against a total string length doesnt take into account the lengths of individual hid and uid buffers so the check is insufficient in some cases. For example if the length of hid string is 4 and the length of the uid string is 260, the length of str will be equal to ACPIID_LEN + 1 but uid string will overflow uid buffer which size is 256. The same applies to the hid string with length 13 and uid string with length 250. Check the length of hid and uid strings separately to prevent buffer overflow. Found by Linux Verification Center (linuxtesting.org) with SVACE.",
    "enhanced_query": "In the Linux kernel, the following vulnerability has been resolved iommu/amd Fix potential buffer overflow in parse_ivrs_acpihid There is a string parsing logic error which can lead to an overflow of hid or uid buffers. Comparing ACPIID_LEN against a total string length doesnt take into account the lengths of individual hid and uid buffers so the check is insufficient in some cases. For example if the length of hid string is 4 and the length of the uid string is 260, the length of str will be equal to ACPIID_LEN + 1 but uid string will overflow uid buffer which size is 256. The same applies to the hid string with length 13 and uid string with length 250. Check the length of hid and uid strings separately to prevent buffer overflow. Found by Linux Verification Center (linuxtesting.org) with SVACE. Consider specifically these CWEs: CWE-1284 CWE-191 CWE-119 CWE-126 CWE-805 CWE-190 CWE-125 CWE-130 CWE-193 CWE-131",
    "cwe_mentions": [
      "CWE-1284",
      "CWE-191",
      "CWE-119",
      "CWE-126",
      "CWE-805",
      "CWE-190",
      "CWE-125",
      "CWE-130",
      "CWE-193",
      "CWE-131"
    ],
    "search_time": 3.226710796356201
  },
  "timestamp": "2025-07-12 13:30:13",
  "cve_id": "CVE-2025-37927",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "1339",
      "name": "Insufficient Precision or Accuracy of a Real Number",
      "type": "base",
      "score": 2.9120000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "128",
      "name": "Wrap-around Error",
      "type": "base",
      "score": 2.9120000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "822",
      "name": "Untrusted Pointer Dereference",
      "type": "base",
      "score": 2.8651999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "824",
      "name": "Access of Uninitialized Pointer",
      "type": "base",
      "score": 2.8651999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "825",
      "name": "Expired Pointer Dereference",
      "type": "base",
      "score": 2.8651999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "805",
      "name": "Buffer Access with Incorrect Length Value",
      "type": "Base",
      "score": 2.8346479522898482,
      "relationship_count": 0
    },
    {
      "cwe_id": "131",
      "name": "Incorrect Calculation of Buffer Size",
      "type": "Base",
      "score": 2.823580163658937,
      "relationship_count": 0
    },
    {
      "cwe_id": "190",
      "name": "Integer Overflow or Wraparound",
      "type": "Base",
      "score": 2.8212863095793956,
      "relationship_count": 0
    },
    {
      "cwe_id": "130",
      "name": "Improper Handling of Length Parameter Inconsistency",
      "type": "Base",
      "score": 2.8186212187488837,
      "relationship_count": 0
    },
    {
      "cwe_id": "193",
      "name": "Off-by-one Error",
      "type": "Base",
      "score": 2.8093828750567065,
      "relationship_count": 0
    },
    {
      "cwe_id": "120",
      "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
      "type": "base",
      "score": 2.4232000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "170",
      "name": "Improper Null Termination",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "1257",
      "name": "Improper Access Control Applied to Mirrored or Aliased Memory Regions",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "839",
      "name": "Numeric Range Comparison Without Minimum Check",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "843",
      "name": "Access of Resource Using Incompatible Type ('Type Confusion')",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "617",
      "name": "Reachable Assertion",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "126",
      "name": "Buffer Over-read",
      "type": "Variant",
      "score": 2.173364781957103,
      "relationship_count": 0
    },
    {
      "cwe_id": "125",
      "name": "Out-of-bounds Read",
      "type": "Base",
      "score": 2.0794652624980454,
      "relationship_count": 0
    },
    {
      "cwe_id": "789",
      "name": "Memory Allocation with Excessive Size Value",
      "type": "variant",
      "score": 2.04,
      "relationship_count": 0
    },
    {
      "cwe_id": "129",
      "name": "Improper Validation of Array Index",
      "type": "variant",
      "score": 2.04,
      "relationship_count": 0
    }
  ]
}