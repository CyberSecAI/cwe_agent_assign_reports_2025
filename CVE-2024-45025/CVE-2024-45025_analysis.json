{
  "cve_id": "CVE-2024-45025",
  "description": "In the Linux kernel, the following vulnerability has been resolved fix **bitmap corruption** on close_range() with CLOSE_RANGE_UNSHARE copy_fd_bitmaps(new, old, count) is expected to copy the first count/BITS_PER_LONG bits from old->full_fds_bits[] and fill the rest with zeroes. What it does is copying enough words (BITS_TO_LONGS(count/BITS_PER_LONG)), then memsets the rest. That works fine, *if* all bits past the cutoff point are clear. Otherwise we are risking garbage from the last word wed copied. For most of the callers that is true - expand_fdtable() has count equal to old->max_fds, so theres no open descriptors past count, let alone fully occupied words in ->open_fds[], which is what bits in ->full_fds_bits[] correspond to. The other caller (dup_fd()) passes sane_fdtable_size(old_fdt, max_fds), which is the smallest multiple of BITS_PER_LONG that covers all opened descriptors below max_fds. In the common case (copying on fork()) max_fds is ~0U, so all opened descriptors will be below it and we are fine, by the same reasons why the call in expand_fdtable() is safe. Unfortunately, there is a case where max_fds is less than that and where we might, indeed, end up with junk in ->full_fds_bits[] - close_range(from, to, CLOSE_RANGE_UNSHARE) with * descriptor table being currently shared * to being above the current capacity of descriptor table * from being just under some chunk of opened descriptors. In that case we end up with observably wrong behaviour - e.g. spa",
  "key_phrases": {
    "rootcause": "",
    "weakness": "bitmap corruption",
    "impact": "",
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "close_range()"
  },
  "reference_content": "```\n{\n  \"CVE-2024-45025\": {\n    \"Metadata\": {\n      \"ID\": \"CVE-2024-45025\",\n      \"Description\": \"PLACEHOLDER - Implement CVE description retrieval\"\n    },\n    \"Content\": [\n      {\n        \"Type\": \"Commit\",\n        \"Data\": {\n          \"commit_id\": \"dd72ae8b0fce9c0bbe9582b9b50820f0407f8d8a\",\n          \"commit_message\": \"fix bitmap corruption on close_range() with CLOSE_RANGE_UNSHARE\\n\\ncopy_fd_bitmaps(new, old, count) is expected to copy the first\\ncount/BITS_PER_LONG bits from old->full_fds_bits[] and fill\\nthe rest with zeroes. What it does is copying enough words\\n(BITS_TO_LONGS(count/BITS_PER_LONG)), then memsets the rest.\\nThat works fine, *if* all bits past the cutoff point are\\nclear. Otherwise we are risking garbage from the last word\\nwe'd copied.\\n\\nFor most of the callers that is true - expand_fdtable() has\\ncount equal to old->max_fds, so there's no open descriptors\\npast count, let alone fully occupied words in ->open_fds[],\\nwhich is what bits in ->full_fds_bits[] correspond to.\\nThe other caller (dup_fd()) passes sane_fdtable_size(old_fdt, max_fds),\\nwhich is the smallest multiple of BITS_PER_LONG that covers all\\nopened descriptors below max_fds. In the common case (copying on\\nfork()) max_fds is ~0U, so all opened descriptors will be below\\nit and we are fine, by the same reasons why the call in expand_fdtable()\\nis safe.\\n\\nUnfortunately, there is a case where max_fds is less than that\\nand where we might, indeed, end up with junk in ->full_fds_bits[] -\\nclose_range(from, to, CLOSE_RANGE_UNSHARE) with\\n* descriptor table being currently shared\\n* 'to' being above the current capacity of descriptor table\\n* 'from' being just under some chunk of opened descriptors.\\nIn that case we end up with observably wrong behaviour - e.g. spawn\\na child with CLONE_FILES, get all descriptors in range 0..127 open,\\nthen close_range(64, ~0U, CLOSE_RANGE_UNSHARE) and watch dup(0) ending\\nup with descriptor #128, despite #64 being observably not open.\\n\\nThe minimally invasive fix would be to deal with that in dup_fd().\\nIf this proves to add measurable overhead, we can go that way, but\\nlet's try to fix copy_fd_bitmaps() first.\\n\\n* new helper: bitmap_copy_and_expand(to, from, bits_to_copy, size).\\n* make copy_fd_bitmaps() take the bitmap size in words, rather than\\nbits; it's 'count' argument is always a multiple of BITS_PER_LONG,\\nso we are not losing any information, and that way we can use the\\nsame helper for all three bitmaps - compiler will see that count\\nis a multiple of BITS_PER_LONG for the large ones, so it'll generate\\nplain memcpy()+memset().\\n\\nReproducer added to tools/testing/selftests/core/close_range_test.c\\n\\nCc: stable@vger.kernel.org\\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\",\n          \"vulnerability_details\": {\n            \"root_cause\": \"The `copy_fd_bitmaps` function did not correctly handle cases where the file descriptor table was being truncated via `close_range` with `CLOSE_RANGE_UNSHARE` when the descriptor table was shared, potentially leading to bitmap corruption.\",\n            \"weaknesses\": [\n              \"Incorrect bitmap handling during file descriptor table operations.\",\n              \"Insufficient consideration of shared descriptor table scenarios when truncating descriptor ranges.\"\n            ],\n            \"impact\": \"Incorrect file descriptor bitmap can lead to unexpected behavior, where a file descriptor can be reported as open when it's not, potentially causing a process to use the wrong file descriptor, such as reusing a recently closed descriptor. In the provided example, `dup(0)` may return 128 instead of 64.\",\n            \"attack_vectors\": [\n              \"`close_range` syscall with `CLOSE_RANGE_UNSHARE` flag.\",\n               \"A process with CLONE_FILES\",\n               \"A shared descriptor table.\"\n            ],\n            \"required_capabilities\": \"An attacker needs to be able to call the `close_range` syscall with `CLOSE_RANGE_UNSHARE` after having a shared file descriptor table with opened file descriptors. The attacker needs the ability to fork a process with `CLONE_FILES` and make system calls.\"\n          },\n          \"affected_files\": [\n            \"fs/file.c\",\n            \"include/linux/bitmap.h\",\n            \"tools/testing/selftests/core/close_range_test.c\"\n          ]\n        }\n      },\n      {\n        \"Type\": \"Commit\",\n        \"Data\": {\n          \"commit_id\": \"8cad3b2b3ab81ca55f37405ffd1315bcc2948058\",\n          \"commit_message\": \"fix bitmap corruption on close_range() with CLOSE_RANGE_UNSHARE\\n\\ncopy_fd_bitmaps(new, old, count) is expected to copy the first\\ncount/BITS_PER_LONG bits from old->full_fds_bits[] and fill\\nthe rest with zeroes. What it does is copying enough words\\n(BITS_TO_LONGS(count/BITS_PER_LONG)), then memsets the rest.\\nThat works fine, *if* all bits past the cutoff point are\\nclear. Otherwise we are risking garbage from the last word\\nwe'd copied.\\n\\nFor most of the callers that is true - expand_fdtable() has\\ncount equal to old->max_fds, so there's no open descriptors\\npast count, let alone fully occupied words in ->open_fds[],\\nwhich is what bits in ->full_fds_bits[] correspond to.\\nThe other caller (dup_fd()) passes sane_fdtable_size(old_fdt, max_fds),\\nwhich is the smallest multiple of BITS_PER_LONG that covers all\\nopened descriptors below max_fds. In the common case (copying on\\nfork()) max_fds is ~0U, so all opened descriptors will be below\\nit and we are fine, by the same reasons why the call in expand_fdtable()\\nis safe.\\n\\nUnfortunately, there is a case where max_fds is less than that\\nand where we might, indeed, end up with junk in ->full_fds_bits[] -\\nclose_range(from, to, CLOSE_RANGE_UNSHARE) with\\n* descriptor table being currently shared\\n* 'to' being above the current capacity of descriptor table\\n* 'from' being just under some chunk of opened descriptors.\\nIn that case we end up with observably wrong behaviour - e.g. spawn\\na child with CLONE_FILES, get all descriptors in range 0..127 open,\\nthen close_range(64, ~0U, CLOSE_RANGE_UNSHARE) and watch dup(0) ending\\nup with descriptor #128, despite #64 being observably not open.\\n\\nThe minimally invasive fix would be to deal with that in dup_fd().\\nIf this proves to add measurable overhead, we can go that way, but\\nlet's try to fix copy_fd_bitmaps() first.\\n\\n* new helper: bitmap_copy_and_expand(to, from, bits_to_copy, size).\\n* make copy_fd_bitmaps() take the bitmap size in words, rather than\\nbits; it's 'count' argument is always a multiple of BITS_PER_LONG,\\nso we are not losing any information, and that way we can use the\\nsame helper for all three bitmaps - compiler will see that count\\nis a multiple of BITS_PER_LONG for the large ones, so it'll generate\\nplain memcpy()+memset().\\n\\nReproducer added to tools/testing/selftests/core/close_range_test.c\\n\\nCc: stable@vger.kernel.org\\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\",\n          \"vulnerability_details\": {\n             \"root_cause\": \"The `copy_fd_bitmaps` function was not correctly handling descriptor table truncation via `close_range` with `CLOSE_RANGE_UNSHARE` when the descriptor table was shared, leading to potential garbage data in the bitmap.\",\n            \"weaknesses\": [\n              \"Incorrect bitmap copying logic.\",\n               \"Lack of proper handling of shared file descriptor tables during truncation.\"\n            ],\n            \"impact\": \"A process can have its file descriptor bitmap corrupted which can lead to file descriptors being reported as open when they are not. In the example case a `dup(0)` call returns `128` even though fd `64` is closed and should be the first available file descriptor.\",\n            \"attack_vectors\": [\n                \"`close_range` syscall with `CLOSE_RANGE_UNSHARE`.\",\n                \"A shared descriptor table via fork and CLONE_FILES.\",\n                \"Truncated descriptor range.\"\n            ],\n            \"required_capabilities\": \"The attacker needs to be able to call `close_range` with the `CLOSE_RANGE_UNSHARE` flag. Also, the attacker needs to be able to fork a process that shares file descriptors with `CLONE_FILES`\"\n          },\n           \"affected_files\": [\n            \"fs/file.c\",\n            \"include/linux/bitmap.h\",\n            \"tools/testing/selftests/core/close_range_test.c\"\n          ]\n        }\n      },\n      {\n        \"Type\": \"Commit\",\n        \"Data\": {\n          \"commit_id\": \"9a2fa1472083580b6c66bdaf291f591e1170123a\",\n          \"commit_message\": \"fix bitmap corruption on close_range() with CLOSE_RANGE_UNSHAREcopy_fd_bitmaps(new, old, count) is expected to copy the first\\ncount/BITS_PER_LONG bits from old->full_fds_bits[] and fill\\nthe rest with zeroes. What it does is copying enough words\\n(BITS_TO_LONGS(count/BITS_PER_LONG)), then memsets the rest.\\nThat works fine, *if* all bits past the cutoff point are\\nclear. Otherwise we are risking garbage from the last word\\nwe'd copied.\\n\\nFor most of the callers that is true - expand_fdtable() has\\ncount equal to old->max_fds, so there's no open descriptors\\npast count, let alone fully occupied words in ->open_fds[],\\nwhich is what bits in ->full_fds_bits[] correspond to.\\nThe other caller (dup_fd()) passes sane_fdtable_size(old_fdt, max_fds),\\nwhich is the smallest multiple of BITS_PER_LONG that covers all\\nopened descriptors below max_fds. In the common case (copying on\\nfork()) max_fds is ~0U, so all opened descriptors will be below\\nit and we are fine, by the same reasons why the call in expand_fdtable()\\nis safe.\\n\\nUnfortunately, there is a case where max_fds is less than that\\nand where we might, indeed, end up with junk in ->full_fds_bits[] -\\nclose_range(from, to, CLOSE_RANGE_UNSHARE) with\\n* descriptor table being currently shared\\n* 'to' being above the current capacity of descriptor table\\n* 'from' being just under some chunk of opened descriptors.\\nIn that case we end up with observably wrong behaviour - e.g. spawn\\na child with CLONE_FILES, get all descriptors in range 0..127 open,\\nthen close_range(64, ~0U, CLOSE_RANGE_UNSHARE) and watch dup(0) ending\\nup with descriptor #128, despite #64 being observably not open.\\n\\nThe minimally invasive fix would be to deal with that in dup_fd().\\nIf this proves to add measurable overhead, we can go that way, but\\nlet's try to fix copy_fd_bitmaps() first.\\n\\n* new helper: bitmap_copy_and_expand(to, from, bits_to_copy, size).\\n* make copy_fd_bitmaps() take the bitmap size in words, rather than\\nbits; it's 'count' argument is always a multiple of BITS_PER_LONG,\\nso we are not losing any information, and that way we can use the\\nsame helper for all three bitmaps - compiler will see that count\\nis a multiple of BITS_PER_LONG for the large ones, so it'll generate\\nplain memcpy()+memset().\\nReproducer added to tools/testing/selftests/core/close_range_test.c\\nCc: stable@vger.kernel.org\\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\",\n           \"vulnerability_details\": {\n             \"root_cause\": \"The `copy_fd_bitmaps` function does not correctly handle cases where the descriptor table is truncated via `close_range` with the `CLOSE_RANGE_UNSHARE` flag when a shared table is involved, leading to a risk of garbage data within the file descriptor bitmap.\",\n              \"weaknesses\": [\n               \"The logic for copying and expanding file descriptor bitmaps is flawed, particularly when dealing with truncation and shared tables.\",\n               \"The function fails to correctly clear the tail bits in the bitmaps, leading to potential corruption.\",\n               \"Insufficient checks are in place for handling descriptor table resizing during the `close_range` operation.\"\n              ],\n              \"impact\": \"When the descriptor table is truncated via `close_range` with `CLOSE_RANGE_UNSHARE`, it can lead to a corrupted bitmap where a file descriptor might be incorrectly reported as open. In the provided example scenario, `dup(0)` may return descriptor #128 instead of #64 despite #64 being closed.\",\n              \"attack_vectors\": [\n                \"close_range syscall with the CLOSE_RANGE_UNSHARE flag.\",\n                \"Shared descriptor table.\",\n                \"Truncating a descriptor range smaller than the current table size.\"\n              ],\n              \"required_capabilities\": \"The attacker must be able to invoke the `close_range` system call with `CLOSE_RANGE_UNSHARE`, and establish a shared descriptor table, which can be done through `CLONE_FILES`. Additionally, the attacker must have control of 'from' and 'to' parameters to invoke the described vulnerability.\"\n            },\n            \"affected_files\": [\n            \"fs/file.c\",\n            \"include/linux/bitmap.h\",\n            \"tools/testing/selftests/core/close_range_test.c\"\n          ]\n        }\n      },\n      {\n        \"Type\": \"Commit\",\n        \"Data\": {\n          \"commit_id\": \"ee501f827f3db02d4e599afbbc1a7f8b792d05d7\",\n          \"commit_message\": \"fix bitmap corruption on close_range() with CLOSE_RANGE_UNSHAREcommit 9a2fa1472083580b6c66bdaf291f591e1170123a upstream.\\ncopy_fd_bitmaps(new, old, count) is expected to copy the first\\ncount/BITS_PER_LONG bits from old->full_fds_bits[] and fill\\nthe rest with zeroes. What it does is copying enough words\\n(BITS_TO_LONGS(count/BITS_PER_LONG)), then memsets the rest.\\nThat works fine, *if* all bits past the cutoff point are\\nclear. Otherwise we are risking garbage from the last word\\nwe'd copied.\\n\\nFor most of the callers that is true - expand_fdtable() has\\ncount equal to old->max_fds, so there's no open descriptors\\npast count, let alone fully occupied words in ->open_fds[],\\nwhich is what bits in ->full_fds_bits[] correspond to.\\nThe other caller (dup_fd()) passes sane_fdtable_size(old_fdt, max_fds),\\nwhich is the smallest multiple of BITS_PER_LONG that covers all\\nopened descriptors below max_fds. In the common case (copying on\\nfork()) max_fds is ~0U, so all opened descriptors will be below\\nit and we are fine, by the same reasons why the call in expand_fdtable()\\nis safe.\\n\\nUnfortunately, there is a case where max_fds is less than that\\nand where we might, indeed, end up with junk in ->full_fds_bits[] -\\nclose_range(from, to, CLOSE_RANGE_UNSHARE) with\\n* descriptor table being currently shared\\n* 'to' being above the current capacity of descriptor table\\n* 'from' being just under some chunk of opened descriptors.\\nIn that case we end up with observably wrong behaviour - e.g. spawn\\na child with CLONE_FILES, get all descriptors in range 0..127 open,\\nthen close_range(64, ~0U, CLOSE_RANGE_UNSHARE) and watch dup(0) ending\\nup with descriptor #128, despite #64 being observably not open.\\n\\nThe minimally invasive fix would be to deal with that in dup_fd().\\nIf this proves to add measurable overhead, we can go that way, but\\nlet's try to fix copy_fd_bitmaps() first.\\n\\n* new helper: bitmap_copy_and_expand(to, from, bits_to_copy, size).\\n* make copy_fd_bitmaps() take the bitmap size in words, rather than\\nbits; it's 'count' argument is always a multiple of BITS_PER_LONG,\\nso we are not losing any information, and that way we can use the\\nsame helper for all three bitmaps - compiler will see that count\\nis a multiple of BITS_PER_LONG for the large ones, so it'll generate\\nplain memcpy()+memset().\\nReproducer added to tools/testing/selftests/core/close_range_test.c\\nCc: stable@vger.kernel.org\\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\",\n            \"vulnerability_details\": {\n             \"root_cause\": \"The `copy_fd_bitmaps` function doesn't handle the scenario correctly when the file descriptor table is truncated via `close_range` with `CLOSE_RANGE_UNSHARE`, when the table is shared, leading to the possibility of garbage data within the bitmap.\",\n              \"weaknesses\": [\n                \"Incorrect handling of shared file descriptor tables during truncation.\",\n                \"The `copy_fd_bitmaps` function was not zeroing out the extra bits correctly which could lead to information leakage between the process and the parent.\"\n              ],\n              \"impact\": \"A corrupted bitmap can lead to a file descriptor being reported as open when it is closed. In the example scenario a call to `dup(0)` will return 128 instead of 64 when it should be the next available file descriptor.\",\n              \"attack_vectors\": [\n               \"`close_range` syscall with `CLOSE_RANGE_UNSHARE` flag.\",\n                \"Shared file descriptor table between processes.\",\n                \"Truncated file descriptor range via `close_range`.\"\n              ],\n              \"required_capabilities\": \"Attacker needs to be able to call `close_range` with `CLOSE_RANGE_UNSHARE`.  Also needs the ability to create a shared file descriptor table via CLONE_FILES and the ability to make system calls.\"\n            },\n             \"affected_files\": [\n            \"fs/file.c\",\n            \"include/linux/bitmap.h\"\n          ]\n        }\n      },\n      {\n        \"Type\": \"Commit\",\n        \"Data\": {\n          \"commit_id\": \"c69d18f0ac7060de724511537810f10f29a27958\",\n          \"commit_message\": \"fix bitmap corruption on close_range() with CLOSE_RANGE_UNSHAREcommit 9a2fa1472083580b6c66bdaf291f591e1170123a upstream.\\ncopy_fd_bitmaps(new, old, count) is expected to copy the first\\ncount/BITS_PER_LONG bits from old->full_fds_bits[] and fill\\nthe rest with zeroes. What it does is copying enough words\\n(BITS_TO_LONGS(count/BITS_PER_LONG)), then memsets the rest.\\nThat works fine, *if* all bits past the cutoff point are\\nclear. Otherwise we are risking garbage from the last word\\nwe'd copied.\\n\\nFor most of the callers that is true - expand_fdtable() has\\ncount equal to old->max_fds, so there's no open descriptors\\npast count, let alone fully occupied words in ->open_fds[],\\nwhich is what bits in ->full_fds_bits[] correspond to.\\nThe other caller (dup_fd()) passes sane_fdtable_size(old_fdt, max_fds),\\nwhich is the smallest multiple of BITS_PER_LONG that covers all\\nopened descriptors below max_fds. In the common case (copying on\\nfork()) max_fds is ~0U, so all opened descriptors will be below\\nit and we are fine, by the same reasons why the call in expand_fdtable()\\nis safe.\\n\\nUnfortunately, there is a case where max_fds is less than that\\nand where we might, indeed, end up with junk in ->full_fds_bits[] -\\nclose_range(from, to, CLOSE_RANGE_UNSHARE) with\\n* descriptor table being currently shared\\n* 'to' being above the current capacity of descriptor table\\n* 'from' being just under some chunk of opened descriptors.\\nIn that case we end up with observably wrong behaviour - e.g. spawn\\na child with CLONE_FILES, get all descriptors in range 0..127 open,\\nthen close_range(64, ~0U, CLOSE_RANGE_UNSHARE) and watch dup(0) ending\\nup with descriptor #128, despite #64 being observably not open.\\n\\nThe minimally invasive fix would be to deal with that in dup_fd().\\nIf this proves to add measurable overhead, we can go that way, but\\nlet's try to fix copy_fd_bitmaps() first.\\n\\n* new helper: bitmap_copy_and_expand(to, from, bits_to_copy, size).\\n* make copy_fd_bitmaps() take the bitmap size in words, rather than\\nbits; it's 'count' argument is always a multiple of BITS_PER_LONG,\\nso we are not losing any information, and that way we can use the\\nsame helper for all three bitmaps - compiler will see that count\\nis a multiple of BITS_PER_LONG for the large ones, so it'll generate\\nplain memcpy()+memset().\\nReproducer added to tools/testing/selftests/core/close_range_test.c\\nCc: stable@vger.kernel.org\\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\",\n           \"vulnerability_details\": {\n             \"root_cause\": \"The `copy_fd_bitmaps` function is not handling file descriptor table truncations correctly when `close_range` with `CLOSE_RANGE_UNSHARE` is used on a shared descriptor table. This leads to potential corruption of the file descriptor bitmaps.\",\n              \"weaknesses\": [\n                \"Incorrect logic in `copy_fd_bitmaps` for copying and clearing bits.\",\n                 \"Lack of proper consideration for shared file descriptor tables during `close_range` operations.\"\n              ],\n              \"impact\": \"Bitmap corruption can lead to incorrect reporting of file descriptor status, which in turn could lead to a process using a file descriptor that it does not own. In the provided example scenario calling `dup(0)` returns 128 instead of the next available descriptor 64.\",\n              \"attack_vectors\": [\n                \"The vulnerable condition is triggered by a `close_range` call with the `CLOSE_RANGE_UNSHARE` flag when the descriptor table is shared.\",\n                 \" The descriptor table needs to be shared between parent and child via `CLONE_FILES` flag.\",\n                \"The file descriptor table must be truncated via close_range so that the max_fds is less than the number of descriptors open.\"\n              ],\n              \"required_capabilities\": \"The attacker needs to be able to make the `close_range` system call with the `CLOSE_RANGE_UNSHARE` flag. Additionally, the attacker needs the capability to create a shared file descriptor table via `CLONE_FILES` flag. A way to create a shared descriptor table.\"\n            },\n            \"affected_files\": [\n            \"fs/file.c\",\n            \"include/linux/bitmap.h\",\n            \"tools/testing/selftests/core/close_range_test.c\"\n          ]\n        }\n      },\n      {\n        \"Type\": \"Commit\",\n        \"Data\": {\n          \"commit_id\": \"5053581fe5dfb09b58c65dd8462bf5dea71f41ff\",\n          \"commit_message\": \"fix bitmap corruption on close_range() with CLOSE_RANGE_UNSHAREcommit 9a2fa1472083580b6c66bdaf291f591e1170123a upstream.\\ncopy_fd_bitmaps(new, old, count) is expected to copy the first\\ncount/BITS_PER_LONG bits from old->full_fds_bits[] and fill\\nthe rest with zeroes. What it does is copying enough words\\n(BITS_TO_LONGS(count/BITS_PER_LONG)), then memsets the rest.\\nThat works fine, *if* all bits past the cutoff point are\\nclear. Otherwise we are risking garbage from the last word\\nwe'd copied.\\n\\nFor most of the callers that is true - expand_fdtable() has\\ncount equal to old->max_fds, so there's no open descriptors\\npast count, let alone fully occupied words in ->open_fds[],\\nwhich is what bits in ->full_fds_bits[] correspond to.\\nThe other caller (dup_fd()) passes sane_fdtable_size(old_fdt, max_fds),\\nwhich is the smallest multiple of BITS_PER_LONG that covers all\\nopened descriptors below max_fds. In the common case (copying on\\nfork()) max_fds is ~0U, so all opened descriptors will be below\\nit and we are fine, by the same reasons why the call in expand_fdtable()\\nis safe.\\n\\nUnfortunately, there is a case where max_fds is less than that\\nand where we might, indeed, end up with junk in ->full_fds_bits[] -\\nclose_range(from, to, CLOSE_RANGE_UNSHARE) with\\n* descriptor table being currently shared\\n* 'to' being above the current capacity of descriptor table\\n* 'from' being just under some chunk of opened descriptors.\\nIn that case we end up with observably wrong behaviour - e.g. spawn\\na child with CLONE_FILES, get all descriptors in range 0..127 open,\\nthen close_range(64, ~0U, CLOSE_RANGE_UNSHARE) and watch dup(0) ending\\nup with descriptor #128, despite #64 being observably not open.\\n\\nThe minimally invasive fix would be to deal with that in dup_fd().\\nIf this proves to add measurable overhead, we can go that way, but\\nlet's try to fix copy_fd_bitmaps() first.\\n\\n* new helper: bitmap_copy_and_expand(to, from, bits_to_copy, size).\\n* make copy_fd_bitmaps() take the bitmap size in words, rather than\\nbits; it's 'count' argument is always a multiple of BITS_PER_LONG,\\nso we are not losing any information, and that way we can use the\\nsame helper for all three bitmaps - compiler will see that count\\nis a multiple of BITS_PER_LONG for the large ones, so it'll generate\\nplain memcpy()+memset().\\nReproducer added to tools/testing/selftests/core/close_range_test.c\\nCc: stable@vger.kernel.org\\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\",\n            \"vulnerability_details\": {\n              \"root_cause\": \"The function `copy_fd_bitmaps` doesn't correctly copy the file descriptor bitmap when used with `close_range` with the `CLOSE_RANGE_UNSHARE` flag when the descriptor table is shared, leading to potential information leakage and incorrect bitmap state.\",\n              \"weaknesses\": [\n                \"The `copy_fd_bitmaps` function fails to correctly handle bitmap tail bits when copying and expanding descriptor bitmaps\",\n                \"The function does not properly handle shared file descriptor tables during the `close_range` operation.\"\n              ],\n              \"impact\": \"An incorrect bitmap can result in a file descriptor being reported as open when it is actually closed. In the provided example, `dup(0)` returns 128 instead of the expected 64, causing an issue in file descriptor handling.\",\n              \"attack_vectors\": [\n                \"`close_range` syscall with `CLOSE_RANGE_UNSHARE` flag.\",\n                \"Shared file descriptor table between processes created with CLONE_FILES.\",\n                \"File descriptor range truncation.\"\n              ],\n              \"required_capabilities\": \"The attacker needs to be able to invoke the `close_range` system call with `CLOSE_RANGE_UNSHARE` flag, create a shared file descriptor table by forking a process with `CLONE_FILES`, and have some level of control over opened file descriptors.\"\n            },\n             \"affected_files\": [\n            \"fs/file.c\",\n            \"include/linux/bitmap.h\",\n            \"tools/testing/selftests/core/close_range_test.c\"\n          ]\n        }\n      },\n      {\n        \"Type\": \"Commit\",\n        \"Data\": {\n          \"commit_id\": \"e807487a1d5fd5d941f26578ae826ca815dbfcd6\",\n          \"commit_message\": \"fix bitmap corruption on close_range() with CLOSE_RANGE_UNSHAREcommit 9a2fa1472083580b6c66bdaf291f591e1170123a upstream.\\ncopy_fd_bitmaps(new, old, count) is expected to copy the first\\ncount/BITS_PER_LONG bits from old->full_fds_bits[] and fill\\nthe rest with zeroes. What it does is copying enough words\\n(BITS_TO_LONGS(count/BITS_PER_LONG)), then memsets the rest.\\nThat works fine, *if* all bits past the cutoff point are\\nclear. Otherwise we are risking garbage from the last word\\nwe'd copied.\\n\\nFor most of the callers that is true - expand_fdtable() has\\ncount equal to old->max_fds, so there's no open descriptors\\npast count, let alone fully occupied words in ->open_fds[],\\nwhich is what bits in ->full_fds_bits[] correspond to.\\nThe other caller (dup_fd()) passes sane_fdtable_size(old_fdt, max_fds),\\nwhich is the smallest multiple of BITS_PER_LONG that covers all\\nopened descriptors below max_fds. In the common case (copying on\\nfork()) max_fds is ~0U, so all opened descriptors will be below\\nit and we are fine, by the same reasons why the call in expand_fdtable()\\nis safe.\\n\\nUnfortunately, there is a case where max_fds is less than that\\nand where we might, indeed, end up with junk in ->full_fds_bits[] -\\nclose_range(from, to, CLOSE_RANGE_UNSHARE) with\\n* descriptor table being currently shared\\n* 'to' being above the current capacity of descriptor table\\n* 'from' being just under some chunk of opened descriptors.\\nIn that case we end up with observably wrong behaviour - e.g. spawn\\na child with CLONE_FILES, get all descriptors in range 0..127 open,\\nthen close_range(64, ~0U, CLOSE_RANGE_UNSHARE) and watch dup(0) ending\\nup with descriptor #128, despite #64 being observably not open.\\n\\nThe minimally invasive fix would be to deal with that in dup_fd().\\nIf this proves to add measurable overhead, we can go that way, but\\nlet's try to fix copy_fd_bitmaps() first.\\n\\n* new helper: bitmap_copy_and_expand(to, from, bits_to_copy, size).\\n* make copy_fd_bitmaps() take the bitmap size in words, rather than\\nbits; it's 'count' argument is always a multiple of BITS_PER_LONG,\\nso we are not losing any information, and that way we can use the\\nsame helper for all three bitmaps - compiler will see that count\\nis a multiple of BITS_PER_LONG for the large ones, so it'll generate\\nplain memcpy()+memset().\\nReproducer added to tools/testing/selftests/core/close_range_test.c\\nCc: stable@vger.kernel.org\\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\",\n           \"vulnerability_details\": {\n              \"root_cause\": \"The `copy_fd_bitmaps` function has incorrect handling of shared file descriptor tables when `close_range` with the `CLOSE_RANGE_UNSHARE` flag is used, which can lead to corrupted bitmaps.\",\n              \"weaknesses\": [\n                \"Inadequate bitmap handling during `close_range` operation with `CLOSE_RANGE_UNSHARE`.\",\n                \"Improper clearing of bits in the file descriptor bitmap.\"\n              ],",
  "similar_info": {
    "cwe_distribution": {},
    "cwe_consensus": "",
    "similarity_stats": {
      "thresholds": [],
      "total_samples_by_threshold": {},
      "top_cwes_by_threshold": {}
    }
  },
  "similarity_summary": {
    "consensus_cwe": "",
    "top_cwes": [],
    "confidence_levels": {},
    "total_samples": 0
  },
  "analysis": "# Summary\n| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |\n|---|---|---|---|---|---|\n| CWE-787 | Out-of-bounds Write | 0.95 | Base | Primary | Allowed |\n| CWE-119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | 0.75 | Class | Secondary | Allowed-with-Review |\n| CWE-125 | Out-of-bounds Read | 0.65 | Base | Secondary | Allowed |\n\n## Evidence and Confidence\n\n*   **Confidence Score:** 0.85\n*   **Evidence Strength:** HIGH\n\n## Relationship Analysis\n\nThe primary weakness is CWE-787 Out-of-bounds Write, as the **bitmap corruption** is caused by writing data outside the intended buffer. CWE-119 Improper Restriction of Operations within the Bounds of a Memory Buffer is a broader category that encompasses out-of-bounds write, indicating a parent-child relationship. CWE-125 Out-of-bounds Read is also considered as the **bitmap corruption** may also be due to reading data from outside the intended buffer.\n\n```mermaid\ngraph TD\n    cwe787[\"CWE-787: Out-of-bounds Write\"]\n    cwe119[\"CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\"]\n    cwe125[\"CWE-125: Out-of-bounds Read\"]\n\n    cwe787 -->|CHILDOF| cwe119\n    cwe125 -->|CHILDOF| cwe119\n    \n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    classDef tertiary fill:#9e9,stroke:#333\n    class cwe787 primary\n    class cwe119,cwe125 secondary\n```\n\n## Vulnerability Chain\n\nThe vulnerability chain involves the following sequence:\n1.  The `copy_fd_bitmaps` function in the Linux kernel **incorrectly copies the bitmap** when `close_range` with `CLOSE_RANGE_UNSHARE` is used with a shared descriptor table.\n2.  This leads to **bitmap corruption**, where file descriptors might be incorrectly reported as open or closed.\n3.  The impact is that a process might use an incorrect file descriptor, such as `dup(0)` returning 128 instead of 64.\n\nThe root cause is the incorrect bitmap copying logic in `copy_fd_bitmaps`. The impact is the **bitmap corruption** and subsequent incorrect file descriptor handling.\n\n## Summary of Analysis\n\nThe primary CWE is CWE-787 Out-of-bounds Write, as the core issue is writing outside the bounds of the bitmap buffer. The vulnerability description clearly states that \"Otherwise we are risking garbage from the last word we'd copied.\" This indicates that the copy operation can write beyond the intended boundaries. The commit messages in the CVE Reference Links Content Summary also confirm this.\n\nCWE-119 Improper Restriction of Operations within the Bounds of a Memory Buffer is considered a secondary CWE because it's a broader category encompassing out-of-bounds write.\n\nCWE-125 Out-of-bounds Read is considered as the **bitmap corruption** may also be due to reading data from outside the intended buffer.\n\nThe retriever results also list CWE-787 with a reasonable similarity score.\n\nRelevant CWE Information:\n*   **CWE-787: Out-of-bounds Write**\n    *   **Technical Explanation:** The `copy_fd_bitmaps` function in the Linux kernel does not properly handle the case where the file descriptor table is truncated using `close_range` with `CLOSE_RANGE_UNSHARE` when the descriptor table is shared. This results in writing data beyond the intended boundaries of the bitmap.\n    *   **Security Implications:** This leads to **bitmap corruption**, which can cause file descriptors to be incorrectly reported as open or closed.\n    *   **Relationship:** Child of CWE-119.\n    *   **Mapping Guidance:** Usage: Allowed.\n*   **CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer**\n    *   **Technical Explanation:** This is a more general class of vulnerability where operations are not properly restricted within the bounds of a memory buffer, leading to potential read or write errors.\n    *   **Security Implications:** Can lead to various issues, including information disclosure, denial of service, or arbitrary code execution.\n    *   **Relationship:** Parent of CWE-787.\n    *   **Mapping Guidance:** Usage: Allowed-with-Review.\n*   **CWE-125: Out-of-bounds Read**\n    *   **Technical Explanation:** The product reads data past the end, or before the beginning, of the intended buffer.\n    *   **Security Implications:** This can lead to information disclosure or denial of service.\n    *   **Relationship:** Child of CWE-119.\n    *   **Mapping Guidance:** Usage: Allowed.\n\nOther CWEs Considered:\n\n*   CWE-775: Missing Release of File Descriptor or Handle after Effective Lifetime - While file descriptors are involved, the core issue is the **bitmap corruption** due to improper copying, not the failure to release the descriptor.\n*   CWE-911: Improper Update of Reference Count - This is not directly related to reference counting issues.\n*   CWE-190: Integer Overflow or Wraparound - There is no indication of integer overflow in the provided description.\n*   CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') - While the descriptor table is shared, the core issue is not a race condition, but rather incorrect bitmap handling.\n*   CWE-1284: Improper Validation of Specified Quantity in Input - There is no mention of improper validation of input quantity.\n*   CWE-201: Insertion of Sensitive Information Into Sent Data - This is not related to the insertion of sensitive information.\n\nI am confident that CWE-787 is the most appropriate primary CWE, as it directly addresses the root cause of the vulnerability.",
  "analysis_with_relationships": "# Summary\n| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |\n|---|---|---|---|---|---|\n| CWE-787 | Out-of-bounds Write | 0.95 | Base | Primary | Allowed |\n| CWE-119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | 0.75 | Class | Secondary | Allowed-with-Review |\n| CWE-125 | Out-of-bounds Read | 0.65 | Base | Secondary | Allowed |\n\n## Evidence and Confidence\n\n*   **Confidence Score:** 0.85\n*   **Evidence Strength:** HIGH\n\n## Relationship Analysis\n\nThe primary weakness is CWE-787 Out-of-bounds Write, as the **bitmap corruption** is caused by writing data outside the intended buffer. CWE-119 Improper Restriction of Operations within the Bounds of a Memory Buffer is a broader category that encompasses out-of-bounds write, indicating a parent-child relationship. CWE-125 Out-of-bounds Read is also considered as the **bitmap corruption** may also be due to reading data from outside the intended buffer.\n\n```mermaid\ngraph TD\n    cwe787[\"CWE-787: Out-of-bounds Write\"]\n    cwe119[\"CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\"]\n    cwe125[\"CWE-125: Out-of-bounds Read\"]\n\n    cwe787 -->|CHILDOF| cwe119\n    cwe125 -->|CHILDOF| cwe119\n    \n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    classDef tertiary fill:#9e9,stroke:#333\n    class cwe787 primary\n    class cwe119,cwe125 secondary\n```\n\n## Vulnerability Chain\n\nThe vulnerability chain involves the following sequence:\n1.  The `copy_fd_bitmaps` function in the Linux kernel **incorrectly copies the bitmap** when `close_range` with `CLOSE_RANGE_UNSHARE` is used with a shared descriptor table.\n2.  This leads to **bitmap corruption**, where file descriptors might be incorrectly reported as open or closed.\n3.  The impact is that a process might use an incorrect file descriptor, such as `dup(0)` returning 128 instead of 64.\n\nThe root cause is the incorrect bitmap copying logic in `copy_fd_bitmaps`. The impact is the **bitmap corruption** and subsequent incorrect file descriptor handling.\n\n## Summary of Analysis\n\nThe primary CWE is CWE-787 Out-of-bounds Write, as the core issue is writing outside the bounds of the bitmap buffer. The vulnerability description clearly states that \"Otherwise we are risking garbage from the last word we'd copied.\" This indicates that the copy operation can write beyond the intended boundaries. The commit messages in the CVE Reference Links Content Summary also confirm this.\n\nCWE-119 Improper Restriction of Operations within the Bounds of a Memory Buffer is considered a secondary CWE because it's a broader category encompassing out-of-bounds write.\n\nCWE-125 Out-of-bounds Read is considered as the **bitmap corruption** may also be due to reading data from outside the intended buffer.\n\nThe retriever results also list CWE-787 with a reasonable similarity score.\n\nRelevant CWE Information:\n*   **CWE-787: Out-of-bounds Write**\n    *   **Technical Explanation:** The `copy_fd_bitmaps` function in the Linux kernel does not properly handle the case where the file descriptor table is truncated using `close_range` with `CLOSE_RANGE_UNSHARE` when the descriptor table is shared. This results in writing data beyond the intended boundaries of the bitmap.\n    *   **Security Implications:** This leads to **bitmap corruption**, which can cause file descriptors to be incorrectly reported as open or closed.\n    *   **Relationship:** Child of CWE-119.\n    *   **Mapping Guidance:** Usage: Allowed.\n*   **CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer**\n    *   **Technical Explanation:** This is a more general class of vulnerability where operations are not properly restricted within the bounds of a memory buffer, leading to potential read or write errors.\n    *   **Security Implications:** Can lead to various issues, including information disclosure, denial of service, or arbitrary code execution.\n    *   **Relationship:** Parent of CWE-787.\n    *   **Mapping Guidance:** Usage: Allowed-with-Review.\n*   **CWE-125: Out-of-bounds Read**\n    *   **Technical Explanation:** The product reads data past the end, or before the beginning, of the intended buffer.\n    *   **Security Implications:** This can lead to information disclosure or denial of service.\n    *   **Relationship:** Child of CWE-119.\n    *   **Mapping Guidance:** Usage: Allowed.\n\nOther CWEs Considered:\n\n*   CWE-775: Missing Release of File Descriptor or Handle after Effective Lifetime - While file descriptors are involved, the core issue is the **bitmap corruption** due to improper copying, not the failure to release the descriptor.\n*   CWE-911: Improper Update of Reference Count - This is not directly related to reference counting issues.\n*   CWE-190: Integer Overflow or Wraparound - There is no indication of integer overflow in the provided description.\n*   CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') - While the descriptor table is shared, the core issue is not a race condition, but rather incorrect bitmap handling.\n*   CWE-1284: Improper Validation of Specified Quantity in Input - There is no mention of improper validation of input quantity.\n*   CWE-201: Insertion of Sensitive Information Into Sent Data - This is not related to the insertion of sensitive information.\n\nI am confident that CWE-787 is the most appropriate primary CWE, as it directly addresses the root cause of the vulnerability.\n\n\n## CWE Relationship Analysis\n\nCurrent CWEs represent these abstraction levels: .\n\n\n### Vulnerability Chain Analysis\n\n**Chain starting from CWE-1284:**\n- 1284 (Improper Validation of Specified Quantity in Input) - ROOT\n\n\n**Chain starting from CWE-911:**\n- 911 (Improper Update of Reference Count) - ROOT\n\n\n\n### CWE Relationship Diagram\n\n```mermaid\ngraph TD\n    classDef primary fill:#f96,stroke:#333,stroke-width:2px\n    classDef secondary fill:#69f,stroke:#333\n    classDef tertiary fill:#9e9,stroke:#333\n```",
  "criticism": "",
  "resolution": "",
  "relevant_cwes": [
    {
      "metadata": {
        "doc_id": "775",
        "name": "Missing Release of File Descriptor or Handle after Effective Lifetime",
        "source": "sparse"
      },
      "similarity": 936.5006069302204
    },
    {
      "metadata": {
        "doc_id": "911",
        "name": "Improper Update of Reference Count",
        "source": "sparse"
      },
      "similarity": 923.6586703786655
    },
    {
      "metadata": {
        "doc_id": "190",
        "name": "Integer Overflow or Wraparound",
        "source": "sparse"
      },
      "similarity": 912.291577545523
    },
    {
      "metadata": {
        "doc_id": "362",
        "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
        "source": "sparse"
      },
      "similarity": 908.0405066471162
    },
    {
      "metadata": {
        "doc_id": "1284",
        "name": "Improper Validation of Specified Quantity in Input",
        "source": "sparse"
      },
      "similarity": 894.8994170277828
    },
    {
      "metadata": {
        "doc_id": "787",
        "name": "Out-of-bounds Write",
        "source": "sparse"
      },
      "similarity": 876.7831365347236
    },
    {
      "metadata": {
        "doc_id": "201",
        "name": "Insertion of Sensitive Information Into Sent Data",
        "source": "sparse"
      },
      "similarity": 874.2368185440218
    },
    {
      "metadata": {
        "doc_id": "639",
        "name": "Authorization Bypass Through User-Controlled Key",
        "source": "sparse"
      },
      "similarity": 873.9165099144669
    },
    {
      "metadata": {
        "doc_id": "403",
        "name": "Exposure of File Descriptor to Unintended Control Sphere ('File Descriptor Leak')",
        "type": "Base",
        "original_content": "A process does not close sensitive file descriptors before invoking a child process, which allows the child to perform unauthorized I/O operations using those descriptors.",
        "keyphrase_source": "weakness:bitmap corruption",
        "source": "dense",
        "mapping_notes": {
          "usage": "Allowed",
          "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
          "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
          "reasons": [
            "Acceptable-Use"
          ]
        },
        "score_info": {
          "retrievers": [
            "dense"
          ],
          "retriever_count": 1,
          "normalized_scores": {
            "dense": 0.505160129765744
          }
        }
      },
      "similarity": 0.505160129765744
    },
    {
      "doc_id": "1260",
      "text": "The product allows address regions to overlap, which can result in the bypassing of intended memory protection.",
      "score": 0.5368289949533293,
      "metadata": {
        "doc_id": "1260",
        "name": "Improper Handling of Overlap Between Protected Memory Ranges",
        "type": "Base",
        "extended_description": "\n\nIsolated memory regions and access control (read/write) policies are used by hardware to protect privileged software. Software components are often allowed to change or remap memory region definitions in order to enable flexible and dynamically changeable memory management by system software.\n\n\nIf a software component running at lower privilege can program a memory address region to overlap with other memory regions used by software running at higher privilege, privilege escalation may be available to attackers. The memory protection unit (MPU) logic can incorrectly handle such an address overlap and allow the lower-privilege software to read or write into the protected memory region, resulting in privilege escalation attack. An address overlap weakness can also be used to launch a denial of service attack on the higher-privilege software memory regions.\n",
        "alternate_terms": [],
        "original_content": "The product allows address regions to overlap, which can result in the bypassing of intended memory protection.",
        "relationships": [
          {
            "source_id": "1260",
            "target_id": "119",
            "label": "CANPRECEDE",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          },
          {
            "source_id": "1260",
            "target_id": "284",
            "label": "CHILDOF",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          },
          {
            "source_id": "284",
            "target_id": "1260",
            "label": "PARENTOF",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          },
          {
            "source_id": "119",
            "target_id": "1260",
            "label": "CANFOLLOW",
            "properties": {
              "ordinal": "Primary",
              "view_id": "1000"
            }
          }
        ],
        "source": "graph",
        "sources": [
          "vector",
          "graph"
        ],
        "vector_score": 0.5368289949533293,
        "graph_score": 3.8038000000000003,
        "score_components": {
          "relationship_chain": 0.8,
          "explicit_mention": 1.0,
          "abstraction_path": 0.9,
          "sequence_path": 0.7200000000000001
        },
        "abstraction_factor": 1.3,
        "graph_path_info": {
          "path_types": [
            "relationship_chain",
            "vulnerability_sequence_forward"
          ],
          "best_paths": {
            "relationship_chain": {
              "path": [
                [
                  "190",
                  "119",
                  "CANPRECEDE"
                ],
                [
                  "119",
                  "1260",
                  "CANFOLLOW"
                ]
              ],
              "score": 0.8,
              "type": "relationship_chain",
              "source": "190"
            },
            "vulnerability_sequence_forward": {
              "path": [
                [
                  "190",
                  "119",
                  "CANPRECEDE"
                ],
                [
                  "119",
                  "1260",
                  "CANFOLLOW"
                ]
              ],
              "score": 0.7200000000000001,
              "type": "vulnerability_sequence_forward",
              "source": "190"
            }
          }
        },
        "is_explicit": true,
        "abstraction_level": "base",
        "position": "after",
        "mapping_notes": {
          "usage": "Allowed",
          "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
          "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
          "reasons": [
            "Acceptable-Use"
          ]
        },
        "score_info": {
          "retrievers": [
            "dense",
            "graph"
          ],
          "retriever_count": 2,
          "normalized_scores": {
            "dense": 0.481167860618986,
            "graph": 2.4970115979813317
          }
        }
      },
      "similarity": 2.4970115979813317
    }
  ],
  "identified_cwes": {
    "analyzer": [
      "CWE-1284",
      "CWE-911",
      "CWE-775",
      "CWE-125",
      "CWE-787",
      "CWE-201",
      "CWE-190",
      "CWE-362",
      "CWE-119"
    ],
    "critic_additional": []
  },
  "keyphrase_cwe_mapping": {}
}