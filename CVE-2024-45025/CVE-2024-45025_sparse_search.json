{
  "retriever": "sparse",
  "query": "In the Linux kernel, the following vulnerability has been resolved fix bitmap corruption on close_range() with CLOSE_RANGE_UNSHARE copy_fd_bitmaps(new, old, count) is expected to copy the first count/BITS_PER_LONG bits from old->full_fds_bits[] and fill the rest with zeroes. What it does is copying enough words (BITS_TO_LONGS(count/BITS_PER_LONG)), then memsets the rest. That works fine, *if* all bits past the cutoff point are clear. Otherwise we are risking garbage from the last word wed copied. For most of the callers that is true - expand_fdtable() has count equal to old->max_fds, so theres no open descriptors past count, let alone fully occupied words in ->open_fds[], which is what bits in ->full_fds_bits[] correspond to. The other caller (dup_fd()) passes sane_fdtable_size(old_fdt, max_fds), which is the smallest multiple of BITS_PER_LONG that covers all opened descriptors below max_fds. In the common case (copying on fork()) max_fds is ~0U, so all opened descriptors will be below it and we are fine, by the same reasons why the call in expand_fdtable() is safe. Unfortunately, there is a case where max_fds is less than that and where we might, indeed, end up with junk in ->full_fds_bits[] - close_range(from, to, CLOSE_RANGE_UNSHARE) with * descriptor table being currently shared * to being above the current capacity of descriptor table * from being just under some chunk of opened descriptors. In that case we end up with observably wrong behaviour - e.g. spa",
  "keyphrases": {
    "weakness": [
      "bitmap corruption"
    ]
  },
  "timestamp": "2025-07-12 04:19:23",
  "cve_id": "CVE-2024-45025",
  "result_count": 10,
  "results": [
    {
      "cwe_id": "775",
      "name": "Missing Release of File Descriptor or Handle after Effective Lifetime",
      "score": 936.5006069302204,
      "search_source": "weakness:bitmap corruption"
    },
    {
      "cwe_id": "911",
      "name": "Improper Update of Reference Count",
      "score": 923.6586703786655,
      "search_source": "weakness:bitmap corruption"
    },
    {
      "cwe_id": "190",
      "name": "Integer Overflow or Wraparound",
      "score": 912.291577545523,
      "search_source": "weakness:bitmap corruption"
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "score": 908.0405066471162,
      "search_source": "weakness:bitmap corruption"
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "score": 894.8994170277828,
      "search_source": "weakness:bitmap corruption"
    },
    {
      "cwe_id": "787",
      "name": "Out-of-bounds Write",
      "score": 876.7831365347236,
      "search_source": "weakness:bitmap corruption"
    },
    {
      "cwe_id": "201",
      "name": "Insertion of Sensitive Information Into Sent Data",
      "score": 874.2368185440218,
      "search_source": "weakness:bitmap corruption"
    },
    {
      "cwe_id": "639",
      "name": "Authorization Bypass Through User-Controlled Key",
      "score": 873.9165099144669,
      "search_source": "weakness:bitmap corruption"
    },
    {
      "cwe_id": "367",
      "name": "Time-of-check Time-of-use (TOCTOU) Race Condition",
      "score": 869.3474214670832,
      "search_source": "weakness:bitmap corruption"
    },
    {
      "cwe_id": "212",
      "name": "Improper Removal of Sensitive Information Before Storage or Transfer",
      "score": 866.7659394980535,
      "search_source": "weakness:bitmap corruption"
    }
  ]
}