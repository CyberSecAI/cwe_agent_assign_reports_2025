# Vulnerability Information: CVE-2024-45025

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved fix **bitmap corruption** on close_range() with CLOSE_RANGE_UNSHARE copy_fd_bitmaps(new, old, count) is expected to copy the first count/BITS_PER_LONG bits from old->full_fds_bits[] and fill the rest with zeroes. What it does is copying enough words (BITS_TO_LONGS(count/BITS_PER_LONG)), then memsets the rest. That works fine, *if* all bits past the cutoff point are clear. Otherwise we are risking garbage from the last word wed copied. For most of the callers that is true - expand_fdtable() has count equal to old->max_fds, so theres no open descriptors past count, let alone fully occupied words in ->open_fds[], which is what bits in ->full_fds_bits[] correspond to. The other caller (dup_fd()) passes sane_fdtable_size(old_fdt, max_fds), which is the smallest multiple of BITS_PER_LONG that covers all opened descriptors below max_fds. In the common case (copying on fork()) max_fds is ~0U, so all opened descriptors will be below it and we are fine, by the same reasons why the call in expand_fdtable() is safe. Unfortunately, there is a case where max_fds is less than that and where we might, indeed, end up with junk in ->full_fds_bits[] - close_range(from, to, CLOSE_RANGE_UNSHARE) with * descriptor table being currently shared * to being above the current capacity of descriptor table * from being just under some chunk of opened descriptors. In that case we end up with observably wrong behaviour - e.g. spa

### Vulnerability Description Key Phrases
- **weakness:** **bitmap corruption**
- **product:** Linux kernel
- **component:** close_range()

## CVE Reference Links Content Summary
```
{
  "CVE-2024-45025": {
    "Metadata": {
      "ID": "CVE-2024-45025",
      "Description": "PLACEHOLDER - Implement CVE description retrieval"
    },
    "Content": [
      {
        "Type": "Commit",
        "Data": {
          "commit_id": "dd72ae8b0fce9c0bbe9582b9b50820f0407f8d8a",
          "commit_message": "fix bitmap corruption on close_range() with CLOSE_RANGE_UNSHARE\n\ncopy_fd_bitmaps(new, old, count) is expected to copy the first\ncount/BITS_PER_LONG bits from old->full_fds_bits[] and fill\nthe rest with zeroes. What it does is copying enough words\n(BITS_TO_LONGS(count/BITS_PER_LONG)), then memsets the rest.\nThat works fine, *if* all bits past the cutoff point are\nclear. Otherwise we are risking garbage from the last word\nwe'd copied.\n\nFor most of the callers that is true - expand_fdtable() has\ncount equal to old->max_fds, so there's no open descriptors\npast count, let alone fully occupied words in ->open_fds[],\nwhich is what bits in ->full_fds_bits[] correspond to.\nThe other caller (dup_fd()) passes sane_fdtable_size(old_fdt, max_fds),\nwhich is the smallest multiple of BITS_PER_LONG that covers all\nopened descriptors below max_fds. In the common case (copying on\nfork()) max_fds is ~0U, so all opened descriptors will be below\nit and we are fine, by the same reasons why the call in expand_fdtable()\nis safe.\n\nUnfortunately, there is a case where max_fds is less than that\nand where we might, indeed, end up with junk in ->full_fds_bits[] -\nclose_range(from, to, CLOSE_RANGE_UNSHARE) with\n* descriptor table being currently shared\n* 'to' being above the current capacity of descriptor table\n* 'from' being just under some chunk of opened descriptors.\nIn that case we end up with observably wrong behaviour - e.g. spawn\na child with CLONE_FILES, get all descriptors in range 0..127 open,\nthen close_range(64, ~0U, CLOSE_RANGE_UNSHARE) and watch dup(0) ending\nup with descriptor #128, despite #64 being observably not open.\n\nThe minimally invasive fix would be to deal with that in dup_fd().\nIf this proves to add measurable overhead, we can go that way, but\nlet's try to fix copy_fd_bitmaps() first.\n\n* new helper: bitmap_copy_and_expand(to, from, bits_to_copy, size).\n* make copy_fd_bitmaps() take the bitmap size in words, rather than\nbits; it's 'count' argument is always a multiple of BITS_PER_LONG,\nso we are not losing any information, and that way we can use the\nsame helper for all three bitmaps - compiler will see that count\nis a multiple of BITS_PER_LONG for the large ones, so it'll generate\nplain memcpy()+memset().\n\nReproducer added to tools/testing/selftests/core/close_range_test.c\n\nCc: stable@vger.kernel.org\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
          "vulnerability_details": {
            "root_cause": "The `copy_fd_bitmaps` function did not correctly handle cases where the file descriptor table was being truncated via `close_range` with `CLOSE_RANGE_UNSHARE` when the descriptor table was shared, potentially leading to bitmap corruption.",
            "weaknesses": [
              "Incorrect bitmap handling during file descriptor table operations.",
              "Insufficient consideration of shared descriptor table scenarios when truncating descriptor ranges."
            ],
            "impact": "Incorrect file descriptor bitmap can lead to unexpected behavior, where a file descriptor can be reported as open when it's not, potentially causing a process to use the wrong file descriptor, such as reusing a recently closed descriptor. In the provided example, `dup(0)` may return 128 instead of 64.",
            "attack_vectors": [
              "`close_range` syscall with `CLOSE_RANGE_UNSHARE` flag.",
               "A process with CLONE_FILES",
               "A shared descriptor table."
            ],
            "required_capabilities": "An attacker needs to be able to call the `close_range` syscall with `CLOSE_RANGE_UNSHARE` after having a shared file descriptor table with opened file descriptors. The attacker needs the ability to fork a process with `CLONE_FILES` and make system calls."
          },
          "affected_files": [
            "fs/file.c",
            "include/linux/bitmap.h",
            "tools/testing/selftests/core/close_range_test.c"
          ]
        }
      },
      {
        "Type": "Commit",
        "Data": {
          "commit_id": "8cad3b2b3ab81ca55f37405ffd1315bcc2948058",
          "commit_message": "fix bitmap corruption on close_range() with CLOSE_RANGE_UNSHARE\n\ncopy_fd_bitmaps(new, old, count) is expected to copy the first\ncount/BITS_PER_LONG bits from old->full_fds_bits[] and fill\nthe rest with zeroes. What it does is copying enough words\n(BITS_TO_LONGS(count/BITS_PER_LONG)), then memsets the rest.\nThat works fine, *if* all bits past the cutoff point are\nclear. Otherwise we are risking garbage from the last word\nwe'd copied.\n\nFor most of the callers that is true - expand_fdtable() has\ncount equal to old->max_fds, so there's no open descriptors\npast count, let alone fully occupied words in ->open_fds[],\nwhich is what bits in ->full_fds_bits[] correspond to.\nThe other caller (dup_fd()) passes sane_fdtable_size(old_fdt, max_fds),\nwhich is the smallest multiple of BITS_PER_LONG that covers all\nopened descriptors below max_fds. In the common case (copying on\nfork()) max_fds is ~0U, so all opened descriptors will be below\nit and we are fine, by the same reasons why the call in expand_fdtable()\nis safe.\n\nUnfortunately, there is a case where max_fds is less than that\nand where we might, indeed, end up with junk in ->full_fds_bits[] -\nclose_range(from, to, CLOSE_RANGE_UNSHARE) with\n* descriptor table being currently shared\n* 'to' being above the current capacity of descriptor table\n* 'from' being just under some chunk of opened descriptors.\nIn that case we end up with observably wrong behaviour - e.g. spawn\na child with CLONE_FILES, get all descriptors in range 0..127 open,\nthen close_range(64, ~0U, CLOSE_RANGE_UNSHARE) and watch dup(0) ending\nup with descriptor #128, despite #64 being observably not open.\n\nThe minimally invasive fix would be to deal with that in dup_fd().\nIf this proves to add measurable overhead, we can go that way, but\nlet's try to fix copy_fd_bitmaps() first.\n\n* new helper: bitmap_copy_and_expand(to, from, bits_to_copy, size).\n* make copy_fd_bitmaps() take the bitmap size in words, rather than\nbits; it's 'count' argument is always a multiple of BITS_PER_LONG,\nso we are not losing any information, and that way we can use the\nsame helper for all three bitmaps - compiler will see that count\nis a multiple of BITS_PER_LONG for the large ones, so it'll generate\nplain memcpy()+memset().\n\nReproducer added to tools/testing/selftests/core/close_range_test.c\n\nCc: stable@vger.kernel.org\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
          "vulnerability_details": {
             "root_cause": "The `copy_fd_bitmaps` function was not correctly handling descriptor table truncation via `close_range` with `CLOSE_RANGE_UNSHARE` when the descriptor table was shared, leading to potential garbage data in the bitmap.",
            "weaknesses": [
              "Incorrect bitmap copying logic.",
               "Lack of proper handling of shared file descriptor tables during truncation."
            ],
            "impact": "A process can have its file descriptor bitmap corrupted which can lead to file descriptors being reported as open when they are not. In the example case a `dup(0)` call returns `128` even though fd `64` is closed and should be the first available file descriptor.",
            "attack_vectors": [
                "`close_range` syscall with `CLOSE_RANGE_UNSHARE`.",
                "A shared descriptor table via fork and CLONE_FILES.",
                "Truncated descriptor range."
            ],
            "required_capabilities": "The attacker needs to be able to call `close_range` with the `CLOSE_RANGE_UNSHARE` flag. Also, the attacker needs to be able to fork a process that shares file descriptors with `CLONE_FILES`"
          },
           "affected_files": [
            "fs/file.c",
            "include/linux/bitmap.h",
            "tools/testing/selftests/core/close_range_test.c"
          ]
        }
      },
      {
        "Type": "Commit",
        "Data": {
          "commit_id": "9a2fa1472083580b6c66bdaf291f591e1170123a",
          "commit_message": "fix bitmap corruption on close_range() with CLOSE_RANGE_UNSHAREcopy_fd_bitmaps(new, old, count) is expected to copy the first\ncount/BITS_PER_LONG bits from old->full_fds_bits[] and fill\nthe rest with zeroes. What it does is copying enough words\n(BITS_TO_LONGS(count/BITS_PER_LONG)), then memsets the rest.\nThat works fine, *if* all bits past the cutoff point are\nclear. Otherwise we are risking garbage from the last word\nwe'd copied.\n\nFor most of the callers that is true - expand_fdtable() has\ncount equal to old->max_fds, so there's no open descriptors\npast count, let alone fully occupied words in ->open_fds[],\nwhich is what bits in ->full_fds_bits[] correspond to.\nThe other caller (dup_fd()) passes sane_fdtable_size(old_fdt, max_fds),\nwhich is the smallest multiple of BITS_PER_LONG that covers all\nopened descriptors below max_fds. In the common case (copying on\nfork()) max_fds is ~0U, so all opened descriptors will be below\nit and we are fine, by the same reasons why the call in expand_fdtable()\nis safe.\n\nUnfortunately, there is a case where max_fds is less than that\nand where we might, indeed, end up with junk in ->full_fds_bits[] -\nclose_range(from, to, CLOSE_RANGE_UNSHARE) with\n* descriptor table being currently shared\n* 'to' being above the current capacity of descriptor table\n* 'from' being just under some chunk of opened descriptors.\nIn that case we end up with observably wrong behaviour - e.g. spawn\na child with CLONE_FILES, get all descriptors in range 0..127 open,\nthen close_range(64, ~0U, CLOSE_RANGE_UNSHARE) and watch dup(0) ending\nup with descriptor #128, despite #64 being observably not open.\n\nThe minimally invasive fix would be to deal with that in dup_fd().\nIf this proves to add measurable overhead, we can go that way, but\nlet's try to fix copy_fd_bitmaps() first.\n\n* new helper: bitmap_copy_and_expand(to, from, bits_to_copy, size).\n* make copy_fd_bitmaps() take the bitmap size in words, rather than\nbits; it's 'count' argument is always a multiple of BITS_PER_LONG,\nso we are not losing any information, and that way we can use the\nsame helper for all three bitmaps - compiler will see that count\nis a multiple of BITS_PER_LONG for the large ones, so it'll generate\nplain memcpy()+memset().\nReproducer added to tools/testing/selftests/core/close_range_test.c\nCc: stable@vger.kernel.org\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
           "vulnerability_details": {
             "root_cause": "The `copy_fd_bitmaps` function does not correctly handle cases where the descriptor table is truncated via `close_range` with the `CLOSE_RANGE_UNSHARE` flag when a shared table is involved, leading to a risk of garbage data within the file descriptor bitmap.",
              "weaknesses": [
               "The logic for copying and expanding file descriptor bitmaps is flawed, particularly when dealing with truncation and shared tables.",
               "The function fails to correctly clear the tail bits in the bitmaps, leading to potential corruption.",
               "Insufficient checks are in place for handling descriptor table resizing during the `close_range` operation."
              ],
              "impact": "When the descriptor table is truncated via `close_range` with `CLOSE_RANGE_UNSHARE`, it can lead to a corrupted bitmap where a file descriptor might be incorrectly reported as open. In the provided example scenario, `dup(0)` may return descriptor #128 instead of #64 despite #64 being closed.",
              "attack_vectors": [
                "close_range syscall with the CLOSE_RANGE_UNSHARE flag.",
                "Shared descriptor table.",
                "Truncating a descriptor range smaller than the current table size."
              ],
              "required_capabilities": "The attacker must be able to invoke the `close_range` system call with `CLOSE_RANGE_UNSHARE`, and establish a shared descriptor table, which can be done through `CLONE_FILES`. Additionally, the attacker must have control of 'from' and 'to' parameters to invoke the described vulnerability."
            },
            "affected_files": [
            "fs/file.c",
            "include/linux/bitmap.h",
            "tools/testing/selftests/core/close_range_test.c"
          ]
        }
      },
      {
        "Type": "Commit",
        "Data": {
          "commit_id": "ee501f827f3db02d4e599afbbc1a7f8b792d05d7",
          "commit_message": "fix bitmap corruption on close_range() with CLOSE_RANGE_UNSHAREcommit 9a2fa1472083580b6c66bdaf291f591e1170123a upstream.\ncopy_fd_bitmaps(new, old, count) is expected to copy the first\ncount/BITS_PER_LONG bits from old->full_fds_bits[] and fill\nthe rest with zeroes. What it does is copying enough words\n(BITS_TO_LONGS(count/BITS_PER_LONG)), then memsets the rest.\nThat works fine, *if* all bits past the cutoff point are\nclear. Otherwise we are risking garbage from the last word\nwe'd copied.\n\nFor most of the callers that is true - expand_fdtable() has\ncount equal to old->max_fds, so there's no open descriptors\npast count, let alone fully occupied words in ->open_fds[],\nwhich is what bits in ->full_fds_bits[] correspond to.\nThe other caller (dup_fd()) passes sane_fdtable_size(old_fdt, max_fds),\nwhich is the smallest multiple of BITS_PER_LONG that covers all\nopened descriptors below max_fds. In the common case (copying on\nfork()) max_fds is ~0U, so all opened descriptors will be below\nit and we are fine, by the same reasons why the call in expand_fdtable()\nis safe.\n\nUnfortunately, there is a case where max_fds is less than that\nand where we might, indeed, end up with junk in ->full_fds_bits[] -\nclose_range(from, to, CLOSE_RANGE_UNSHARE) with\n* descriptor table being currently shared\n* 'to' being above the current capacity of descriptor table\n* 'from' being just under some chunk of opened descriptors.\nIn that case we end up with observably wrong behaviour - e.g. spawn\na child with CLONE_FILES, get all descriptors in range 0..127 open,\nthen close_range(64, ~0U, CLOSE_RANGE_UNSHARE) and watch dup(0) ending\nup with descriptor #128, despite #64 being observably not open.\n\nThe minimally invasive fix would be to deal with that in dup_fd().\nIf this proves to add measurable overhead, we can go that way, but\nlet's try to fix copy_fd_bitmaps() first.\n\n* new helper: bitmap_copy_and_expand(to, from, bits_to_copy, size).\n* make copy_fd_bitmaps() take the bitmap size in words, rather than\nbits; it's 'count' argument is always a multiple of BITS_PER_LONG,\nso we are not losing any information, and that way we can use the\nsame helper for all three bitmaps - compiler will see that count\nis a multiple of BITS_PER_LONG for the large ones, so it'll generate\nplain memcpy()+memset().\nReproducer added to tools/testing/selftests/core/close_range_test.c\nCc: stable@vger.kernel.org\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
            "vulnerability_details": {
             "root_cause": "The `copy_fd_bitmaps` function doesn't handle the scenario correctly when the file descriptor table is truncated via `close_range` with `CLOSE_RANGE_UNSHARE`, when the table is shared, leading to the possibility of garbage data within the bitmap.",
              "weaknesses": [
                "Incorrect handling of shared file descriptor tables during truncation.",
                "The `copy_fd_bitmaps` function was not zeroing out the extra bits correctly which could lead to information leakage between the process and the parent."
              ],
              "impact": "A corrupted bitmap can lead to a file descriptor being reported as open when it is closed. In the example scenario a call to `dup(0)` will return 128 instead of 64 when it should be the next available file descriptor.",
              "attack_vectors": [
               "`close_range` syscall with `CLOSE_RANGE_UNSHARE` flag.",
                "Shared file descriptor table between processes.",
                "Truncated file descriptor range via `close_range`."
              ],
              "required_capabilities": "Attacker needs to be able to call `close_range` with `CLOSE_RANGE_UNSHARE`.  Also needs the ability to create a shared file descriptor table via CLONE_FILES and the ability to make system calls."
            },
             "affected_files": [
            "fs/file.c",
            "include/linux/bitmap.h"
          ]
        }
      },
      {
        "Type": "Commit",
        "Data": {
          "commit_id": "c69d18f0ac7060de724511537810f10f29a27958",
          "commit_message": "fix bitmap corruption on close_range() with CLOSE_RANGE_UNSHAREcommit 9a2fa1472083580b6c66bdaf291f591e1170123a upstream.\ncopy_fd_bitmaps(new, old, count) is expected to copy the first\ncount/BITS_PER_LONG bits from old->full_fds_bits[] and fill\nthe rest with zeroes. What it does is copying enough words\n(BITS_TO_LONGS(count/BITS_PER_LONG)), then memsets the rest.\nThat works fine, *if* all bits past the cutoff point are\nclear. Otherwise we are risking garbage from the last word\nwe'd copied.\n\nFor most of the callers that is true - expand_fdtable() has\ncount equal to old->max_fds, so there's no open descriptors\npast count, let alone fully occupied words in ->open_fds[],\nwhich is what bits in ->full_fds_bits[] correspond to.\nThe other caller (dup_fd()) passes sane_fdtable_size(old_fdt, max_fds),\nwhich is the smallest multiple of BITS_PER_LONG that covers all\nopened descriptors below max_fds. In the common case (copying on\nfork()) max_fds is ~0U, so all opened descriptors will be below\nit and we are fine, by the same reasons why the call in expand_fdtable()\nis safe.\n\nUnfortunately, there is a case where max_fds is less than that\nand where we might, indeed, end up with junk in ->full_fds_bits[] -\nclose_range(from, to, CLOSE_RANGE_UNSHARE) with\n* descriptor table being currently shared\n* 'to' being above the current capacity of descriptor table\n* 'from' being just under some chunk of opened descriptors.\nIn that case we end up with observably wrong behaviour - e.g. spawn\na child with CLONE_FILES, get all descriptors in range 0..127 open,\nthen close_range(64, ~0U, CLOSE_RANGE_UNSHARE) and watch dup(0) ending\nup with descriptor #128, despite #64 being observably not open.\n\nThe minimally invasive fix would be to deal with that in dup_fd().\nIf this proves to add measurable overhead, we can go that way, but\nlet's try to fix copy_fd_bitmaps() first.\n\n* new helper: bitmap_copy_and_expand(to, from, bits_to_copy, size).\n* make copy_fd_bitmaps() take the bitmap size in words, rather than\nbits; it's 'count' argument is always a multiple of BITS_PER_LONG,\nso we are not losing any information, and that way we can use the\nsame helper for all three bitmaps - compiler will see that count\nis a multiple of BITS_PER_LONG for the large ones, so it'll generate\nplain memcpy()+memset().\nReproducer added to tools/testing/selftests/core/close_range_test.c\nCc: stable@vger.kernel.org\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
           "vulnerability_details": {
             "root_cause": "The `copy_fd_bitmaps` function is not handling file descriptor table truncations correctly when `close_range` with `CLOSE_RANGE_UNSHARE` is used on a shared descriptor table. This leads to potential corruption of the file descriptor bitmaps.",
              "weaknesses": [
                "Incorrect logic in `copy_fd_bitmaps` for copying and clearing bits.",
                 "Lack of proper consideration for shared file descriptor tables during `close_range` operations."
              ],
              "impact": "Bitmap corruption can lead to incorrect reporting of file descriptor status, which in turn could lead to a process using a file descriptor that it does not own. In the provided example scenario calling `dup(0)` returns 128 instead of the next available descriptor 64.",
              "attack_vectors": [
                "The vulnerable condition is triggered by a `close_range` call with the `CLOSE_RANGE_UNSHARE` flag when the descriptor table is shared.",
                 " The descriptor table needs to be shared between parent and child via `CLONE_FILES` flag.",
                "The file descriptor table must be truncated via close_range so that the max_fds is less than the number of descriptors open."
              ],
              "required_capabilities": "The attacker needs to be able to make the `close_range` system call with the `CLOSE_RANGE_UNSHARE` flag. Additionally, the attacker needs the capability to create a shared file descriptor table via `CLONE_FILES` flag. A way to create a shared descriptor table."
            },
            "affected_files": [
            "fs/file.c",
            "include/linux/bitmap.h",
            "tools/testing/selftests/core/close_range_test.c"
          ]
        }
      },
      {
        "Type": "Commit",
        "Data": {
          "commit_id": "5053581fe5dfb09b58c65dd8462bf5dea71f41ff",
          "commit_message": "fix bitmap corruption on close_range() with CLOSE_RANGE_UNSHAREcommit 9a2fa1472083580b6c66bdaf291f591e1170123a upstream.\ncopy_fd_bitmaps(new, old, count) is expected to copy the first\ncount/BITS_PER_LONG bits from old->full_fds_bits[] and fill\nthe rest with zeroes. What it does is copying enough words\n(BITS_TO_LONGS(count/BITS_PER_LONG)), then memsets the rest.\nThat works fine, *if* all bits past the cutoff point are\nclear. Otherwise we are risking garbage from the last word\nwe'd copied.\n\nFor most of the callers that is true - expand_fdtable() has\ncount equal to old->max_fds, so there's no open descriptors\npast count, let alone fully occupied words in ->open_fds[],\nwhich is what bits in ->full_fds_bits[] correspond to.\nThe other caller (dup_fd()) passes sane_fdtable_size(old_fdt, max_fds),\nwhich is the smallest multiple of BITS_PER_LONG that covers all\nopened descriptors below max_fds. In the common case (copying on\nfork()) max_fds is ~0U, so all opened descriptors will be below\nit and we are fine, by the same reasons why the call in expand_fdtable()\nis safe.\n\nUnfortunately, there is a case where max_fds is less than that\nand where we might, indeed, end up with junk in ->full_fds_bits[] -\nclose_range(from, to, CLOSE_RANGE_UNSHARE) with\n* descriptor table being currently shared\n* 'to' being above the current capacity of descriptor table\n* 'from' being just under some chunk of opened descriptors.\nIn that case we end up with observably wrong behaviour - e.g. spawn\na child with CLONE_FILES, get all descriptors in range 0..127 open,\nthen close_range(64, ~0U, CLOSE_RANGE_UNSHARE) and watch dup(0) ending\nup with descriptor #128, despite #64 being observably not open.\n\nThe minimally invasive fix would be to deal with that in dup_fd().\nIf this proves to add measurable overhead, we can go that way, but\nlet's try to fix copy_fd_bitmaps() first.\n\n* new helper: bitmap_copy_and_expand(to, from, bits_to_copy, size).\n* make copy_fd_bitmaps() take the bitmap size in words, rather than\nbits; it's 'count' argument is always a multiple of BITS_PER_LONG,\nso we are not losing any information, and that way we can use the\nsame helper for all three bitmaps - compiler will see that count\nis a multiple of BITS_PER_LONG for the large ones, so it'll generate\nplain memcpy()+memset().\nReproducer added to tools/testing/selftests/core/close_range_test.c\nCc: stable@vger.kernel.org\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
            "vulnerability_details": {
              "root_cause": "The function `copy_fd_bitmaps` doesn't correctly copy the file descriptor bitmap when used with `close_range` with the `CLOSE_RANGE_UNSHARE` flag when the descriptor table is shared, leading to potential information leakage and incorrect bitmap state.",
              "weaknesses": [
                "The `copy_fd_bitmaps` function fails to correctly handle bitmap tail bits when copying and expanding descriptor bitmaps",
                "The function does not properly handle shared file descriptor tables during the `close_range` operation."
              ],
              "impact": "An incorrect bitmap can result in a file descriptor being reported as open when it is actually closed. In the provided example, `dup(0)` returns 128 instead of the expected 64, causing an issue in file descriptor handling.",
              "attack_vectors": [
                "`close_range` syscall with `CLOSE_RANGE_UNSHARE` flag.",
                "Shared file descriptor table between processes created with CLONE_FILES.",
                "File descriptor range truncation."
              ],
              "required_capabilities": "The attacker needs to be able to invoke the `close_range` system call with `CLOSE_RANGE_UNSHARE` flag, create a shared file descriptor table by forking a process with `CLONE_FILES`, and have some level of control over opened file descriptors."
            },
             "affected_files": [
            "fs/file.c",
            "include/linux/bitmap.h",
            "tools/testing/selftests/core/close_range_test.c"
          ]
        }
      },
      {
        "Type": "Commit",
        "Data": {
          "commit_id": "e807487a1d5fd5d941f26578ae826ca815dbfcd6",
          "commit_message": "fix bitmap corruption on close_range() with CLOSE_RANGE_UNSHAREcommit 9a2fa1472083580b6c66bdaf291f591e1170123a upstream.\ncopy_fd_bitmaps(new, old, count) is expected to copy the first\ncount/BITS_PER_LONG bits from old->full_fds_bits[] and fill\nthe rest with zeroes. What it does is copying enough words\n(BITS_TO_LONGS(count/BITS_PER_LONG)), then memsets the rest.\nThat works fine, *if* all bits past the cutoff point are\nclear. Otherwise we are risking garbage from the last word\nwe'd copied.\n\nFor most of the callers that is true - expand_fdtable() has\ncount equal to old->max_fds, so there's no open descriptors\npast count, let alone fully occupied words in ->open_fds[],\nwhich is what bits in ->full_fds_bits[] correspond to.\nThe other caller (dup_fd()) passes sane_fdtable_size(old_fdt, max_fds),\nwhich is the smallest multiple of BITS_PER_LONG that covers all\nopened descriptors below max_fds. In the common case (copying on\nfork()) max_fds is ~0U, so all opened descriptors will be below\nit and we are fine, by the same reasons why the call in expand_fdtable()\nis safe.\n\nUnfortunately, there is a case where max_fds is less than that\nand where we might, indeed, end up with junk in ->full_fds_bits[] -\nclose_range(from, to, CLOSE_RANGE_UNSHARE) with\n* descriptor table being currently shared\n* 'to' being above the current capacity of descriptor table\n* 'from' being just under some chunk of opened descriptors.\nIn that case we end up with observably wrong behaviour - e.g. spawn\na child with CLONE_FILES, get all descriptors in range 0..127 open,\nthen close_range(64, ~0U, CLOSE_RANGE_UNSHARE) and watch dup(0) ending\nup with descriptor #128, despite #64 being observably not open.\n\nThe minimally invasive fix would be to deal with that in dup_fd().\nIf this proves to add measurable overhead, we can go that way, but\nlet's try to fix copy_fd_bitmaps() first.\n\n* new helper: bitmap_copy_and_expand(to, from, bits_to_copy, size).\n* make copy_fd_bitmaps() take the bitmap size in words, rather than\nbits; it's 'count' argument is always a multiple of BITS_PER_LONG,\nso we are not losing any information, and that way we can use the\nsame helper for all three bitmaps - compiler will see that count\nis a multiple of BITS_PER_LONG for the large ones, so it'll generate\nplain memcpy()+memset().\nReproducer added to tools/testing/selftests/core/close_range_test.c\nCc: stable@vger.kernel.org\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
           "vulnerability_details": {
              "root_cause": "The `copy_fd_bitmaps` function has incorrect handling of shared file descriptor tables when `close_range` with the `CLOSE_RANGE_UNSHARE` flag is used, which can lead to corrupted bitmaps.",
              "weaknesses": [
                "Inadequate bitmap handling during `close_range` operation with `CLOSE_RANGE_UNSHARE`.",
                "Improper clearing of bits in the file descriptor bitmap."
              ],

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 775 | Missing Release of File Descriptor or Handle after Effective Lifetime | Variant | Allowed | sparse | 0.937 |
| 2 | 911 | Improper Update of Reference Count | Base | Allowed | sparse | 0.924 |
| 3 | 190 | Integer Overflow or Wraparound | Base | Allowed | sparse | 0.912 |
| 4 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.908 |
| 5 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.895 |
| 6 | 787 | Out-of-bounds Write | Base | Allowed | sparse | 0.877 |
| 7 | 201 | Insertion of Sensitive Information Into Sent Data | Base | Allowed | sparse | 0.874 |
| 8 | 639 | Authorization Bypass Through User-Controlled Key | Base | Allowed | sparse | 0.874 |
| 9 | 403 | Exposure of File Descriptor to Unintended Control Sphere ('File Descriptor Leak') | Base | Allowed | dense | 0.505 |
| 10 | 1260 | Improper Handling of Overlap Between Protected Memory Ranges | Base | Allowed | graph | 0.002 |

