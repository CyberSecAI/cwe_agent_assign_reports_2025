## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved mptcp error out earlier on disconnect Eric reported a **division by zero** splat in the MPTCP protocol Oops divide error 0000

### Vulnerability Description Key Phrases
- **weakness:** **division by zero**
- **impact:** Oops
- **product:** Linux kernel
- **component:** MPTCP protocol

## CVE Reference Links Content Summary
Based on the provided information, all the content relates to the same vulnerability, a division-by-zero error in the MPTCP protocol of the Linux kernel. The vulnerability occurs due to a race condition during socket disconnection.

Here's a breakdown:

**Root Cause:**
- The root cause is a race condition that can occur when a socket is disconnected while a thread is waiting for data on it via `sk_wait_data()`. Specifically, `sk_wait_data()` can return with an error and the underlying socket disconnected, leading to a zero `rcv_mss`. The code does not handle this scenario correctly, leading to a division by zero.

**Weaknesses/Vulnerabilities:**
- **Division by Zero:** The primary vulnerability is a division-by-zero error in the `__tcp_select_window` function due to incorrect handling of a zero `rcv_mss`.

**Impact of Exploitation:**
- **Kernel Panic:** The division-by-zero error results in a kernel panic, causing a denial of service. The system becomes unusable.

**Attack Vectors:**
- **Network:** This vulnerability is triggered during the handling of MPTCP network traffic.
- **Race Condition:** The vulnerability is triggered by a race condition that occurs during socket disconnection and data reception.

**Required Attacker Capabilities/Position:**
- The attacker needs the ability to trigger a socket disconnect while the socket is in use. This is possible if the attacker has control over one of the MPTCP peers.
- The provided reproducer suggests that a user with network access could trigger this vulnerability.

**Technical Details from the provided diffs:**

The patch addresses the vulnerability by adding an error check to the `mptcp_recvmsg` function after calling `sk_wait_data()`. If `sk_wait_data()` returns with an error, the function now exits early, preventing the division-by-zero. Specifically:
```diff
--- a/net/mptcp/protocol.c
+++ b/net/mptcp/protocol.c
@@ -2267,9 +2267,16 @@
 	}
 
 	pr_debug("block timeout %ld\n", timeo);
-	sk_wait_data(sk, &timeo, NULL);
+	mptcp_rcv_space_adjust(msk, copied);
+	err = sk_wait_data(sk, &timeo, NULL);
+	if (err < 0) {
+		err = copied ? : err;
+		goto out_err;
+	}
 }
 
+	mptcp_rcv_space_adjust(msk, copied);
+out_err:
 	if (cmsg_flags && copied >= 0) {
 		if (cmsg_flags & MPTCP_CMSG_TS)
 			mptcp_fill_timestamp(msg, &tss);
```
The key changes:
- A new `err` variable to hold the return value of `sk_wait_data()`.
- An error check `if (err < 0)`.
- If there's an error, the code jumps to the `out_err` label, where the function exits.
- If data has been copied, `copied` is returned, otherwise the error code from `sk_wait_data()` is returned.

The patch ensures that the division by zero does not occur by exiting early in case of an error returned from `sk_wait_data()`, thus handling the race condition of a disconnected socket.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 1335 | Incorrect Bitwise Shift of Integer | Base | Allowed | sparse | 0.165 |
| 2 | 369 | Divide By Zero | Base | Allowed | sparse | 0.151 |
| 3 | 1389 | Incorrect Parsing of Numbers with Different Radices | Base | Allowed | sparse | 0.146 |
| 4 | 787 | Out-of-bounds Write | Base | Allowed | sparse | 0.145 |
| 5 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | sparse | 0.144 |
| 6 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.143 |
| 7 | 193 | Off-by-one Error | Base | Allowed | sparse | 0.140 |
| 8 | 194 | Unexpected Sign Extension | Variant | Allowed | sparse | 0.139 |
| 9 | 191 | Integer Underflow (Wrap or Wraparound) | Base | Allowed | dense | 0.526 |
| 10 | 190 | Integer Overflow or Wraparound | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-1335: Incorrect Bitwise Shift of Integer

CWE-369: Divide By Zero

CWE-1389: Incorrect Parsing of Numbers with Different Radices

CWE-787: Out-of-bounds Write

CWE-909: Missing Initialization of Resource

CWE-401: Missing Release of Memory after Effective Lifetime

CWE-193: Off-by-one Error

CWE-194: Unexpected Sign Extension

CWE-191: Integer Underflow (Wrap or Wraparound)

CWE-190: Integer Overflow or Wraparound