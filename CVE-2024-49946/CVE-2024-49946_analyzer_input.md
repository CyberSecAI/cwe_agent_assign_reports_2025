# Vulnerability Information: CVE-2024-49946

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved ppp do not assume bh is held in ppp_channel_bridge_input() Networking receive path is usually handled from BH handler. However, some protocols need to acquire the socket lock, and packets might be stored in the socket backlog is the socket was owned by a user process. In this case, release_sock(), __release_sock(), and sk_backlog_rcv() might call the sk->sk_backlog_rcv() handler in process context. sybot caught ppp was not considering this case in ppp_channel_bridge_input() WARNING inconsistent lock state 6.11.0-rc7-syzkaller-g5f5673607153 #0 Not tainted -------------------------------- inconsistent {SOFTIRQ-ON-W} -> {IN-SOFTIRQ-W} usage. ksoftirqd/1/24 [HC0[0]SC1[1]HE1SE0] takes ffff0000db7f11e0 (&pch->downl){+.?.}-{22}, at spin_lock include/linux/spinlock.h351 [inline] ffff0000db7f11e0 (&pch->downl){+.?.}-{22}, at ppp_channel_bridge_input drivers/net/ppp/ppp_generic.c2272 [inline] ffff0000db7f11e0 (&pch->downl){+.?.}-{22}, at ppp_input+0x16c/0x854 drivers/net/ppp/ppp_generic.c2304 {SOFTIRQ-ON-W} state was registered at lock_acquire+0x240/0x728 kernel/locking/lockdep.c5759 __raw_spin_lock include/linux/spinlock_api_smp.h133 [inline] _raw_spin_lock+0x48/0x60 kernel/locking/spinlock.c154 spin_lock include/linux/spinlock.h351 [inline] ppp_channel_bridge_input drivers/net/ppp/ppp_generic.c2272 [inline] ppp_input+0x16c/0x854 drivers/net/ppp/ppp_generic.c2304 pppoe_rcv_core+0xfc/0x314 drivers/net/ppp/pppoe.c379 sk_backlog_rcv include/net/sock.h1111 [inline] __release_sock+0x1a8/0x3d8 net/core/sock.c3004 release_sock+0x68/0x1b8 net/core/sock.c3558 pppoe_sendmsg+0xc8/0x5d8 drivers/net/ppp/pppoe.c903 sock_sendmsg_nosec net/socket.c730 [inline] __sock_sendmsg net/socket.c745 [inline] __sys_sendto+0x374/0x4f4 net/socket.c2204 __do_sys_sendto net/socket.c2216 [inline] __se_sys_sendto net/socket.c2212 [inline] __arm64_sys_sendto+0xd8/0xf8 net/socket.c2212 __invoke_syscall arch/arm64/kernel/syscall.c35 [inline] invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c49 el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c132 do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c151 el0_svc+0x54/0x168 arch/arm64/kernel/entry-common.c712 el0t_64_sync_handler+0x84/0xfc arch/arm64/kernel/entry-common.c730 el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S598 irq event stamp 282914 hardirqs last enabled at (282914) [] __raw_spin_unlock_irqrestore include/linux/spinlock_api_smp.h151 [inline] hardirqs last enabled at (282914) [] _raw_spin_unlock_irqrestore+0x38/0x98 kernel/locking/spinlock.c194 hardirqs last disabled at (282913) [] __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h108 [inline] hardirqs last disabled at (282913) [] _raw_spin_lock_irqsave+0x2c/0x7c kernel/locking/spinlock.c162 softirqs last enabled at (282904) [] softirq_handle_end kernel/softirq.c400 [inline] softirqs last enabled at (282904) [] handle_softirqs+0xa3c/0xbfc kernel/softirq.c582 softirqs last disabled at (282909) [] run_ksoftirqd+0x70/0x158 kernel/softirq.c928 other info that might help us debug this Possible unsafe locking scenario CPU0 ---- lock(&pch->downl) lock(&pch->downl) *** DEADLOCK *** 1 lock held by ksoftirqd/1/24 #0 ffff80008f74dfa0 (rcu_read_lock){....}-{12}, at rcu_lock_acquire+0x10/0x4c include/linux/rcupdate.h325 stack backtrace CPU 1 UID 0 PID 24 Comm ksoftirqd/1 Not tainted 6.11.0-rc7-syzkaller-g5f5673607153 #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024 Call trace dump_backtrace+0x1b8/0x1e4 arch/arm64/kernel/stacktrace.c319 show_stack+0x2c/0x3c arch/arm64/kernel/stacktrace.c326 __dump_sta ---truncated---

### Vulnerability Description Key Phrases
- **rootcause:** **The ppp_channel_bridge_input function in the Linux kernel's PPP implementation does not properly handle cases where it is called from a process context, leading to a potential lock state inconsistency and deadlock.**
- **weakness:** **The ppp_channel_bridge_input function assumes it is always called from a bottom half (BH) handler, which is not always the case. This function uses a spinlock (`pch->downl`) without considering that it might be called in a process context, which leads to re-entrancy of the lock and deadlock**
- **impact:** A deadlock can occur, leading to a denial of service. The system may become unresponsive as the ksoftirqd process is stuck waiting for a lock it already holds.
- **vector:** The vulnerability is triggered through the network stack when receiving a PPP packet, especially when the socket is owned by a user process. The vulnerability is reachable by sending a crafted PPP packet.
- **attacker:** A remote attacker who can send crafted PPP packets or a malicious local process.
- **product:** Linux Kernel
- **version:** 6.11.0-rc7
- **component:** PPP implementation in drivers/net/ppp/ppp_generic.c and drivers/net/ppp/pppoe.c

## CVE Reference Links Content Summary
```
{
  "vulnerability": {
    "root_cause": "The `ppp_channel_bridge_input()` function in the Linux kernel's PPP (Point-to-Point Protocol) implementation incorrectly assumed that it was always called from a bottom half (BH) context. However, certain network protocols might cause the function to be invoked from a process context, leading to a locking conflict.",
    "weaknesses": [
      "Incorrect assumption about execution context",
       "Inconsistent lock state"
    ],
    "impact": "A deadlock could occur due to the incorrect locking, leading to a denial-of-service.",
    "attack_vectors": "The vulnerability can be triggered via the network stack when processing PPP packets, particularly when the socket is owned by a user process and packets are stored in the socket backlog. Specifically, it involves the interaction of `release_sock()`, `__release_sock()`, and `sk_backlog_rcv()`.",
    "required_capabilities": "An attacker would need to be able to send network traffic to a vulnerable system in a way that triggers the described call flow involving ppp and socket backlogs. This could be through regular network connections, possibly using PPPoE."
  },
  "affected_code": {
    "file": "drivers/net/ppp/ppp_generic.c",
    "vulnerable_lines": [
        "spin_lock(&pchb->downl);",
        "spin_unlock(&pchb->downl);"
    ],
    "fixed_lines":[
      "spin_lock_bh(&pchb->downl);",
      "spin_unlock_bh(&pchb->downl);"
    ],
        "description": "The original code used `spin_lock` and `spin_unlock`, which are not appropriate for bottom half context where they should be using `spin_lock_bh` and `spin_unlock_bh` which disable softirqs to prevent re-entrance. This is because the function can be invoked outside of bottom half context."
  },
    "additional_info": "The vulnerability was detected by syzbot, a Linux kernel fuzzer. The fix involves using bottom-half aware spinlock functions, `spin_lock_bh()` and `spin_unlock_bh()`, instead of `spin_lock()` and `spin_unlock()`. This ensures that softirqs are disabled when acquiring the spinlock, preventing a deadlock if the code is called from both process and softirq context."
}
```

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 1.332 |
| 2 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 1.219 |
| 3 | 476 | NULL Pointer Dereference | Base | Allowed | sparse | 1.138 |
| 4 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 1.132 |
| 5 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | sparse | 1.131 |
| 6 | 911 | Improper Update of Reference Count | Base | Allowed | sparse | 1.128 |
| 7 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 1.103 |
| 8 | 833 | Deadlock | Base | Allowed | sparse | 1.098 |
| 9 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | Allowed | dense | 0.548 |
| 10 | 129 | Improper Validation of Array Index | Variant | Allowed | graph | 0.002 |

