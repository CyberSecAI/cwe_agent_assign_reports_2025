{
  "retriever": "graph",
  "query": "In the Linux kernel, the following vulnerability has been resolved ppp do not assume bh is held in ppp_channel_bridge_input() Networking receive path is usually handled from BH handler. However, some protocols need to acquire the socket lock, and packets might be stored in the socket backlog is the socket was owned by a user process. In this case, release_sock(), __release_sock(), and sk_backlog_rcv() might call the sk->sk_backlog_rcv() handler in process context. sybot caught ppp was not considering this case in ppp_channel_bridge_input() WARNING inconsistent lock state 6.11.0-rc7-syzkaller-g5f5673607153 #0 Not tainted -------------------------------- inconsistent {SOFTIRQ-ON-W} -> {IN-SOFTIRQ-W} usage. ksoftirqd/1/24 [HC0[0]SC1[1]HE1SE0] takes ffff0000db7f11e0 (&pch->downl){+.?.}-{22}, at spin_lock include/linux/spinlock.h351 [inline] ffff0000db7f11e0 (&pch->downl){+.?.}-{22}, at ppp_channel_bridge_input drivers/net/ppp/ppp_generic.c2272 [inline] ffff0000db7f11e0 (&pch->downl){+.?.}-{22}, at ppp_input+0x16c/0x854 drivers/net/ppp/ppp_generic.c2304 {SOFTIRQ-ON-W} state was registered at lock_acquire+0x240/0x728 kernel/locking/lockdep.c5759 __raw_spin_lock include/linux/spinlock_api_smp.h133 [inline] _raw_spin_lock+0x48/0x60 kernel/locking/spinlock.c154 spin_lock include/linux/spinlock.h351 [inline] ppp_channel_bridge_input drivers/net/ppp/ppp_generic.c2272 [inline] ppp_input+0x16c/0x854 drivers/net/ppp/ppp_generic.c2304 pppoe_rcv_core+0xfc/0x314 drivers/net/ppp/pppoe.c379 sk_backlog_rcv include/net/sock.h1111 [inline] __release_sock+0x1a8/0x3d8 net/core/sock.c3004 release_sock+0x68/0x1b8 net/core/sock.c3558 pppoe_sendmsg+0xc8/0x5d8 drivers/net/ppp/pppoe.c903 sock_sendmsg_nosec net/socket.c730 [inline] __sock_sendmsg net/socket.c745 [inline] __sys_sendto+0x374/0x4f4 net/socket.c2204 __do_sys_sendto net/socket.c2216 [inline] __se_sys_sendto net/socket.c2212 [inline] __arm64_sys_sendto+0xd8/0xf8 net/socket.c2212 __invoke_syscall arch/arm64/kernel/syscall.c35 [inline] invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c49 el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c132 do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c151 el0_svc+0x54/0x168 arch/arm64/kernel/entry-common.c712 el0t_64_sync_handler+0x84/0xfc arch/arm64/kernel/entry-common.c730 el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S598 irq event stamp 282914 hardirqs last enabled at (282914) [] __raw_spin_unlock_irqrestore include/linux/spinlock_api_smp.h151 [inline] hardirqs last enabled at (282914) [] _raw_spin_unlock_irqrestore+0x38/0x98 kernel/locking/spinlock.c194 hardirqs last disabled at (282913) [] __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h108 [inline] hardirqs last disabled at (282913) [] _raw_spin_lock_irqsave+0x2c/0x7c kernel/locking/spinlock.c162 softirqs last enabled at (282904) [] softirq_handle_end kernel/softirq.c400 [inline] softirqs last enabled at (282904) [] handle_softirqs+0xa3c/0xbfc kernel/softirq.c582 softirqs last disabled at (282909) [] run_ksoftirqd+0x70/0x158 kernel/softirq.c928 other info that might help us debug this Possible unsafe locking scenario CPU0 ---- lock(&pch->downl) lock(&pch->downl) *** DEADLOCK *** 1 lock held by ksoftirqd/1/24 #0 ffff80008f74dfa0 (rcu_read_lock){....}-{12}, at rcu_lock_acquire+0x10/0x4c include/linux/rcupdate.h325 stack backtrace CPU 1 UID 0 PID 24 Comm ksoftirqd/1 Not tainted 6.11.0-rc7-syzkaller-g5f5673607153 #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024 Call trace dump_backtrace+0x1b8/0x1e4 arch/arm64/kernel/stacktrace.c319 show_stack+0x2c/0x3c arch/arm64/kernel/stacktrace.c326 __dump_sta ---truncated--- Consider specifically these CWEs: CWE-476 CWE-667 CWE-833 CWE-401 CWE-909 CWE-1285 CWE-362",
  "keyphrases": {
    "original_query": "In the Linux kernel, the following vulnerability has been resolved ppp do not assume bh is held in ppp_channel_bridge_input() Networking receive path is usually handled from BH handler. However, some protocols need to acquire the socket lock, and packets might be stored in the socket backlog is the socket was owned by a user process. In this case, release_sock(), __release_sock(), and sk_backlog_rcv() might call the sk->sk_backlog_rcv() handler in process context. sybot caught ppp was not considering this case in ppp_channel_bridge_input() WARNING inconsistent lock state 6.11.0-rc7-syzkaller-g5f5673607153 #0 Not tainted -------------------------------- inconsistent {SOFTIRQ-ON-W} -> {IN-SOFTIRQ-W} usage. ksoftirqd/1/24 [HC0[0]SC1[1]HE1SE0] takes ffff0000db7f11e0 (&pch->downl){+.?.}-{22}, at spin_lock include/linux/spinlock.h351 [inline] ffff0000db7f11e0 (&pch->downl){+.?.}-{22}, at ppp_channel_bridge_input drivers/net/ppp/ppp_generic.c2272 [inline] ffff0000db7f11e0 (&pch->downl){+.?.}-{22}, at ppp_input+0x16c/0x854 drivers/net/ppp/ppp_generic.c2304 {SOFTIRQ-ON-W} state was registered at lock_acquire+0x240/0x728 kernel/locking/lockdep.c5759 __raw_spin_lock include/linux/spinlock_api_smp.h133 [inline] _raw_spin_lock+0x48/0x60 kernel/locking/spinlock.c154 spin_lock include/linux/spinlock.h351 [inline] ppp_channel_bridge_input drivers/net/ppp/ppp_generic.c2272 [inline] ppp_input+0x16c/0x854 drivers/net/ppp/ppp_generic.c2304 pppoe_rcv_core+0xfc/0x314 drivers/net/ppp/pppoe.c379 sk_backlog_rcv include/net/sock.h1111 [inline] __release_sock+0x1a8/0x3d8 net/core/sock.c3004 release_sock+0x68/0x1b8 net/core/sock.c3558 pppoe_sendmsg+0xc8/0x5d8 drivers/net/ppp/pppoe.c903 sock_sendmsg_nosec net/socket.c730 [inline] __sock_sendmsg net/socket.c745 [inline] __sys_sendto+0x374/0x4f4 net/socket.c2204 __do_sys_sendto net/socket.c2216 [inline] __se_sys_sendto net/socket.c2212 [inline] __arm64_sys_sendto+0xd8/0xf8 net/socket.c2212 __invoke_syscall arch/arm64/kernel/syscall.c35 [inline] invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c49 el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c132 do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c151 el0_svc+0x54/0x168 arch/arm64/kernel/entry-common.c712 el0t_64_sync_handler+0x84/0xfc arch/arm64/kernel/entry-common.c730 el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S598 irq event stamp 282914 hardirqs last enabled at (282914) [] __raw_spin_unlock_irqrestore include/linux/spinlock_api_smp.h151 [inline] hardirqs last enabled at (282914) [] _raw_spin_unlock_irqrestore+0x38/0x98 kernel/locking/spinlock.c194 hardirqs last disabled at (282913) [] __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h108 [inline] hardirqs last disabled at (282913) [] _raw_spin_lock_irqsave+0x2c/0x7c kernel/locking/spinlock.c162 softirqs last enabled at (282904) [] softirq_handle_end kernel/softirq.c400 [inline] softirqs last enabled at (282904) [] handle_softirqs+0xa3c/0xbfc kernel/softirq.c582 softirqs last disabled at (282909) [] run_ksoftirqd+0x70/0x158 kernel/softirq.c928 other info that might help us debug this Possible unsafe locking scenario CPU0 ---- lock(&pch->downl) lock(&pch->downl) *** DEADLOCK *** 1 lock held by ksoftirqd/1/24 #0 ffff80008f74dfa0 (rcu_read_lock){....}-{12}, at rcu_lock_acquire+0x10/0x4c include/linux/rcupdate.h325 stack backtrace CPU 1 UID 0 PID 24 Comm ksoftirqd/1 Not tainted 6.11.0-rc7-syzkaller-g5f5673607153 #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024 Call trace dump_backtrace+0x1b8/0x1e4 arch/arm64/kernel/stacktrace.c319 show_stack+0x2c/0x3c arch/arm64/kernel/stacktrace.c326 __dump_sta ---truncated---",
    "enhanced_query": "In the Linux kernel, the following vulnerability has been resolved ppp do not assume bh is held in ppp_channel_bridge_input() Networking receive path is usually handled from BH handler. However, some protocols need to acquire the socket lock, and packets might be stored in the socket backlog is the socket was owned by a user process. In this case, release_sock(), __release_sock(), and sk_backlog_rcv() might call the sk->sk_backlog_rcv() handler in process context. sybot caught ppp was not considering this case in ppp_channel_bridge_input() WARNING inconsistent lock state 6.11.0-rc7-syzkaller-g5f5673607153 #0 Not tainted -------------------------------- inconsistent {SOFTIRQ-ON-W} -> {IN-SOFTIRQ-W} usage. ksoftirqd/1/24 [HC0[0]SC1[1]HE1SE0] takes ffff0000db7f11e0 (&pch->downl){+.?.}-{22}, at spin_lock include/linux/spinlock.h351 [inline] ffff0000db7f11e0 (&pch->downl){+.?.}-{22}, at ppp_channel_bridge_input drivers/net/ppp/ppp_generic.c2272 [inline] ffff0000db7f11e0 (&pch->downl){+.?.}-{22}, at ppp_input+0x16c/0x854 drivers/net/ppp/ppp_generic.c2304 {SOFTIRQ-ON-W} state was registered at lock_acquire+0x240/0x728 kernel/locking/lockdep.c5759 __raw_spin_lock include/linux/spinlock_api_smp.h133 [inline] _raw_spin_lock+0x48/0x60 kernel/locking/spinlock.c154 spin_lock include/linux/spinlock.h351 [inline] ppp_channel_bridge_input drivers/net/ppp/ppp_generic.c2272 [inline] ppp_input+0x16c/0x854 drivers/net/ppp/ppp_generic.c2304 pppoe_rcv_core+0xfc/0x314 drivers/net/ppp/pppoe.c379 sk_backlog_rcv include/net/sock.h1111 [inline] __release_sock+0x1a8/0x3d8 net/core/sock.c3004 release_sock+0x68/0x1b8 net/core/sock.c3558 pppoe_sendmsg+0xc8/0x5d8 drivers/net/ppp/pppoe.c903 sock_sendmsg_nosec net/socket.c730 [inline] __sock_sendmsg net/socket.c745 [inline] __sys_sendto+0x374/0x4f4 net/socket.c2204 __do_sys_sendto net/socket.c2216 [inline] __se_sys_sendto net/socket.c2212 [inline] __arm64_sys_sendto+0xd8/0xf8 net/socket.c2212 __invoke_syscall arch/arm64/kernel/syscall.c35 [inline] invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c49 el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c132 do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c151 el0_svc+0x54/0x168 arch/arm64/kernel/entry-common.c712 el0t_64_sync_handler+0x84/0xfc arch/arm64/kernel/entry-common.c730 el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S598 irq event stamp 282914 hardirqs last enabled at (282914) [] __raw_spin_unlock_irqrestore include/linux/spinlock_api_smp.h151 [inline] hardirqs last enabled at (282914) [] _raw_spin_unlock_irqrestore+0x38/0x98 kernel/locking/spinlock.c194 hardirqs last disabled at (282913) [] __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h108 [inline] hardirqs last disabled at (282913) [] _raw_spin_lock_irqsave+0x2c/0x7c kernel/locking/spinlock.c162 softirqs last enabled at (282904) [] softirq_handle_end kernel/softirq.c400 [inline] softirqs last enabled at (282904) [] handle_softirqs+0xa3c/0xbfc kernel/softirq.c582 softirqs last disabled at (282909) [] run_ksoftirqd+0x70/0x158 kernel/softirq.c928 other info that might help us debug this Possible unsafe locking scenario CPU0 ---- lock(&pch->downl) lock(&pch->downl) *** DEADLOCK *** 1 lock held by ksoftirqd/1/24 #0 ffff80008f74dfa0 (rcu_read_lock){....}-{12}, at rcu_lock_acquire+0x10/0x4c include/linux/rcupdate.h325 stack backtrace CPU 1 UID 0 PID 24 Comm ksoftirqd/1 Not tainted 6.11.0-rc7-syzkaller-g5f5673607153 #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024 Call trace dump_backtrace+0x1b8/0x1e4 arch/arm64/kernel/stacktrace.c319 show_stack+0x2c/0x3c arch/arm64/kernel/stacktrace.c326 __dump_sta ---truncated--- Consider specifically these CWEs: CWE-476 CWE-667 CWE-833 CWE-401 CWE-909 CWE-1285 CWE-362",
    "cwe_mentions": [
      "CWE-476",
      "CWE-667",
      "CWE-833",
      "CWE-401",
      "CWE-909",
      "CWE-1285",
      "CWE-362"
    ],
    "search_time": 2.7489516735076904
  },
  "timestamp": "2025-07-13 19:41:30",
  "cve_id": "CVE-2024-49946",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "type": "Base",
      "score": 2.8158460731405603,
      "relationship_count": 0
    },
    {
      "cwe_id": "129",
      "name": "Improper Validation of Array Index",
      "type": "variant",
      "score": 2.2704,
      "relationship_count": 0
    },
    {
      "cwe_id": "1325",
      "name": "Improperly Controlled Sequential Memory Allocation",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "390",
      "name": "Detection of Error Condition Without Action",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "789",
      "name": "Memory Allocation with Excessive Size Value",
      "type": "variant",
      "score": 2.04,
      "relationship_count": 0
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 1.7689672913427588,
      "relationship_count": 0
    },
    {
      "cwe_id": "123",
      "name": "Write-what-where Condition",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "120",
      "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "364",
      "name": "Signal Handler Race Condition",
      "type": "base",
      "score": 1.7550000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 1.7020021490122168,
      "relationship_count": 0
    },
    {
      "cwe_id": "1265",
      "name": "Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "386",
      "name": "Symbolic Name not Mapping to Correct Object",
      "type": "base",
      "score": 1.6744000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "662",
      "name": "Improper Synchronization",
      "type": "class",
      "score": 1.6736000000000002,
      "relationship_count": 0
    },
    {
      "cwe_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "type": "Base",
      "score": 1.6316077628983676,
      "relationship_count": 0
    },
    {
      "cwe_id": "61",
      "name": "UNIX Symbolic Link (Symlink) Following",
      "type": "compound",
      "score": 1.61,
      "relationship_count": 0
    },
    {
      "cwe_id": "609",
      "name": "Double-Checked Locking",
      "type": "base",
      "score": 1.5912000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "908",
      "name": "Use of Uninitialized Resource",
      "type": "Base",
      "score": 1.5423808258109148,
      "relationship_count": 0
    },
    {
      "cwe_id": "252",
      "name": "Unchecked Return Value",
      "type": "Base",
      "score": 1.5352187731183602,
      "relationship_count": 0
    },
    {
      "cwe_id": "456",
      "name": "Missing Initialization of a Variable",
      "type": "variant",
      "score": 1.51536,
      "relationship_count": 0
    },
    {
      "cwe_id": "415",
      "name": "Double Free",
      "type": "variant",
      "score": 1.4784000000000002,
      "relationship_count": 0
    }
  ]
}