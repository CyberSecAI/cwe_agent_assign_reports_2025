## Vulnerability Description
Evmos is the Ethereum Virtual Machine (EVM) Hub on the Cosmos Network. There is an issue with how to liquid stake using Safe which itself is a contract. The bug only appears when there is a local state change together with an ICS20 transfer in the same function and uses the contracts balance, that is using the contract address as the sender parameter in an ICS20 transfer using the ICS20 precompile. This is in essence the **infinite money glitch** allowing contracts to double the supply of Evmos after each transaction.The issue has been patched in versions >=V18.1.0.

### Vulnerability Description Key Phrases
- **rootcause:** **infinite money glitch**
- **weakness:** **improper local state change handling**
- **impact:** double Evmos supply
- **product:** Evmos
- **version:** <V18.1.0

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of CVE-2024-37153:

**Root Cause of Vulnerability:**
The vulnerability stems from an incorrect balance update when a smart contract makes an Inter-Blockchain Communication (IBC) transfer via the ICS20 precompile. Specifically, when a contract initiates an ICS20 transfer using its own address as the sender, combined with a local state change within the same function, the contract's balance is not correctly reduced in the EVM state. This leads to a discrepancy between the actual funds held by the contract and its tracked balance, due to the changes not being mirrored to the EVM stateDB.

**Weaknesses/Vulnerabilities Present:**
- Incorrect balance handling in the EVM state when a contract uses the ICS20 precompile for transfers while also making local state changes.
- The contract's balance in the EVM state isn't correctly reduced, which does not reflect the actual funds being transferred out via the ICS20 precompile.
- Lack of proper synchronization between the bank keeper and EVM stateDB when transferring tokens from a contract's balance using the ICS20 precompile.

**Impact of Exploitation:**
- **"Infinite money glitch":** By exploiting this vulnerability, contracts could effectively duplicate the supply of tokens (EVMOS in this case) each time a transfer is made, as the contract balance is not being reduced.
- **Direct loss of funds' value:** The ability to generate new supply of tokens can lead to a loss in the value of existing tokens.
- **Potential for arbitrary inflation:** Repeated exploitation could lead to uncontrolled inflation of the EVMOS token.

**Attack Vectors:**
- Smart contracts utilizing the ICS20 precompile and transferring tokens from their own balance.
- Requires a function that both updates local state and performs an ICS20 transfer using the contract's address as the sender.

**Required Attacker Capabilities/Position:**
- The attacker needs to deploy and control a smart contract on the Evmos blockchain.
- The smart contract must interact with the ICS20 precompile.
- The attacker has to trigger the vulnerable function, causing an ICS20 transfer and a local state change.
- The attacker does not need any special privileges beyond the ability to deploy and call a smart contract on the blockchain.

**Additional Notes:**
- The vulnerability was identified when interacting with a contract through Safe, which is itself a contract.
- The issue is triggered when there's a local state change alongside an ICS20 transfer where the contract is the sender.
- The vulnerability has been patched in versions >=V18.1.0.
- The provided code includes a detailed proof-of-concept and test case for the vulnerability using a custom smart contract.
- The patch includes a fix where the `StateDB.SubBalance` is correctly called to update the balance in the stateDB when the contract is the caller and the token being transferred is the native bond denom. Also, the commit fixes the sender address to be the origin address.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | sparse | 0.510 |
| 2 | 212 | Improper Removal of Sensitive Information Before Storage or Transfer | Base | Allowed | sparse | 0.507 |
| 3 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.504 |
| 4 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.498 |
| 5 | 345 | Insufficient Verification of Data Authenticity | Class | Discouraged | sparse | 0.496 |
| 6 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | sparse | 0.494 |
| 7 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | Allowed | sparse | 0.493 |
| 8 | 200 | Exposure of Sensitive Information to an Unauthorized Actor | Class | Discouraged | sparse | 0.487 |
| 9 | 1245 | Improper Finite State Machines (FSMs) in Hardware Logic | Base | Allowed | dense | 0.419 |
| 10 | 201 | Insertion of Sensitive Information Into Sent Data | Base | Allowed | graph | 0.002 |



# Complete CWE Specifications

CWE-674: Uncontrolled Recursion

CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer

CWE-1284: Improper Validation of Specified Quantity in Input

CWE-770: Allocation of Resources Without Limits or Throttling

CWE-345: Insufficient Verification of Data Authenticity

CWE-789: Memory Allocation with Excessive Size Value

CWE-835: Loop with Unreachable Exit Condition ('Infinite Loop')

CWE-200: Exposure of Sensitive Information to an Unauthorized Actor

CWE-1245: Improper Finite State Machines (FSMs) in Hardware Logic

CWE-201: Insertion of Sensitive Information Into Sent Data