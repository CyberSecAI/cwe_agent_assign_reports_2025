{
  "retriever": "graph",
  "query": "In the Linux kernel, the following vulnerability has been resolved net Fix null-ptr-deref by sock_lock_init_class_and_name() and rmmod. When I ran the repro [0] and waited a few seconds, I observed two LOCKDEP splats a warning immediately followed by a null-ptr-deref. [1] Reproduction Steps 1) Mount CIFS 2) Add an iptables rule to drop incoming FIN packets for CIFS 3) Unmount CIFS 4) Unload the CIFS module 5) Remove the iptables rule At step 3), the CIFS module calls sock_release() for the underlying TCP socket, and it returns quickly. However, the socket remains in FIN_WAIT_1 because incoming FIN packets are dropped. At this point, the modules refcnt is 0 while the socket is still alive, so the following rmmod command succeeds. # ss -tan State Recv-Q Send-Q Local AddressPort Peer AddressPort FIN-WAIT-1 0 477 10.0.2.1551062 10.0.0.137445 # lsmod | grep cifs cifs 1159168 0 This highlights a discrepancy between the lifetime of the CIFS module and the underlying TCP socket. Even after CIFS calls sock_release() and it returns, the TCP socket does not die immediately in order to close the connection gracefully. While this is generally fine, it causes an issue with LOCKDEP because CIFS assigns a different lock class to the TCP sockets sk->sk_lock using sock_lock_init_class_and_name(). Once an incoming packet is processed for the socket or a timer fires, sk->sk_lock is acquired. Then, LOCKDEP checks the lock context in check_wait_context(), where hlock_class() is called to retrieve the lock class. However, since the module has already been unloaded, hlock_class() logs a warning and returns NULL, triggering the null-ptr-deref. If LOCKDEP is enabled, we must ensure that a module calling sock_lock_init_class_and_name() (CIFS, NFS, etc) cannot be unloaded while such a socket is still alive to prevent this issue. Lets hold the module reference in sock_lock_init_class_and_name() and release it when the socket is freed in sk_prot_free(). Note that sock_lock_init() clears sk->sk_owner for svc_create_socket() that calls sock_lock_init_class_and_name() for a listening socket, which clones a socket by sk_clone_lock() without GFP_ZERO. [0] CIFS_SERVER=10.0.0.137 CIFS_PATH=//${CIFS_SERVER}/Users/Administrator/Desktop/CIFS_TEST DEV=enp0s3 CRED=/root/WindowsCredential.txt MNT=$(mktemp -d /tmp/XXXXXX) mount -t cifs ${CIFS_PATH} ${MNT} -o vers=3.0,credentials=${CRED},cache=none,echo_interval=1 iptables -A INPUT -s ${CIFS_SERVER} -j DROP for i in $(seq 10) do umount ${MNT} rmmod cifs sleep 1 done rm -r ${MNT} iptables -D INPUT -s ${CIFS_SERVER} -j DROP [1] DEBUG_LOCKS_WARN_ON(1) WARNING CPU 10 PID 0 at kernel/locking/lockdep.c234 hlock_class (kernel/locking/lockdep.c234 kernel/locking/lockdep.c223) Modules linked in cifs_arc4 nls_ucs2_utils cifs_md4 [last unloaded cifs] CPU 10 UID 0 PID 0 Comm swapper/10 Not tainted 6.14.0 #36 Hardware name QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014 RIP 0010hlock_class (kernel/locking/lockdep.c234 kernel/locking/lockdep.c223) ... Call Trace __lock_acquire (kernel/locking/lockdep.c4853 kernel/locking/lockdep.c5178) lock_acquire (kernel/locking/lockdep.c469 kernel/locking/lockdep.c5853 kernel/locking/lockdep.c5816) _raw_spin_lock_nested (kernel/locking/spinlock.c379) tcp_v4_rcv (./include/linux/skbuff.h1678 ./include/net/tcp.h2547 net/ipv4/tcp_ipv4.c2350) ... Consider specifically these CWEs: CWE-476 CWE-400 CWE-667 CWE-833 CWE-401 CWE-362",
  "keyphrases": {
    "original_query": "In the Linux kernel, the following vulnerability has been resolved net Fix null-ptr-deref by sock_lock_init_class_and_name() and rmmod. When I ran the repro [0] and waited a few seconds, I observed two LOCKDEP splats a warning immediately followed by a null-ptr-deref. [1] Reproduction Steps 1) Mount CIFS 2) Add an iptables rule to drop incoming FIN packets for CIFS 3) Unmount CIFS 4) Unload the CIFS module 5) Remove the iptables rule At step 3), the CIFS module calls sock_release() for the underlying TCP socket, and it returns quickly. However, the socket remains in FIN_WAIT_1 because incoming FIN packets are dropped. At this point, the modules refcnt is 0 while the socket is still alive, so the following rmmod command succeeds. # ss -tan State Recv-Q Send-Q Local AddressPort Peer AddressPort FIN-WAIT-1 0 477 10.0.2.1551062 10.0.0.137445 # lsmod | grep cifs cifs 1159168 0 This highlights a discrepancy between the lifetime of the CIFS module and the underlying TCP socket. Even after CIFS calls sock_release() and it returns, the TCP socket does not die immediately in order to close the connection gracefully. While this is generally fine, it causes an issue with LOCKDEP because CIFS assigns a different lock class to the TCP sockets sk->sk_lock using sock_lock_init_class_and_name(). Once an incoming packet is processed for the socket or a timer fires, sk->sk_lock is acquired. Then, LOCKDEP checks the lock context in check_wait_context(), where hlock_class() is called to retrieve the lock class. However, since the module has already been unloaded, hlock_class() logs a warning and returns NULL, triggering the null-ptr-deref. If LOCKDEP is enabled, we must ensure that a module calling sock_lock_init_class_and_name() (CIFS, NFS, etc) cannot be unloaded while such a socket is still alive to prevent this issue. Lets hold the module reference in sock_lock_init_class_and_name() and release it when the socket is freed in sk_prot_free(). Note that sock_lock_init() clears sk->sk_owner for svc_create_socket() that calls sock_lock_init_class_and_name() for a listening socket, which clones a socket by sk_clone_lock() without GFP_ZERO. [0] CIFS_SERVER=10.0.0.137 CIFS_PATH=//${CIFS_SERVER}/Users/Administrator/Desktop/CIFS_TEST DEV=enp0s3 CRED=/root/WindowsCredential.txt MNT=$(mktemp -d /tmp/XXXXXX) mount -t cifs ${CIFS_PATH} ${MNT} -o vers=3.0,credentials=${CRED},cache=none,echo_interval=1 iptables -A INPUT -s ${CIFS_SERVER} -j DROP for i in $(seq 10) do umount ${MNT} rmmod cifs sleep 1 done rm -r ${MNT} iptables -D INPUT -s ${CIFS_SERVER} -j DROP [1] DEBUG_LOCKS_WARN_ON(1) WARNING CPU 10 PID 0 at kernel/locking/lockdep.c234 hlock_class (kernel/locking/lockdep.c234 kernel/locking/lockdep.c223) Modules linked in cifs_arc4 nls_ucs2_utils cifs_md4 [last unloaded cifs] CPU 10 UID 0 PID 0 Comm swapper/10 Not tainted 6.14.0 #36 Hardware name QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014 RIP 0010hlock_class (kernel/locking/lockdep.c234 kernel/locking/lockdep.c223) ... Call Trace __lock_acquire (kernel/locking/lockdep.c4853 kernel/locking/lockdep.c5178) lock_acquire (kernel/locking/lockdep.c469 kernel/locking/lockdep.c5853 kernel/locking/lockdep.c5816) _raw_spin_lock_nested (kernel/locking/spinlock.c379) tcp_v4_rcv (./include/linux/skbuff.h1678 ./include/net/tcp.h2547 net/ipv4/tcp_ipv4.c2350) ...",
    "enhanced_query": "In the Linux kernel, the following vulnerability has been resolved net Fix null-ptr-deref by sock_lock_init_class_and_name() and rmmod. When I ran the repro [0] and waited a few seconds, I observed two LOCKDEP splats a warning immediately followed by a null-ptr-deref. [1] Reproduction Steps 1) Mount CIFS 2) Add an iptables rule to drop incoming FIN packets for CIFS 3) Unmount CIFS 4) Unload the CIFS module 5) Remove the iptables rule At step 3), the CIFS module calls sock_release() for the underlying TCP socket, and it returns quickly. However, the socket remains in FIN_WAIT_1 because incoming FIN packets are dropped. At this point, the modules refcnt is 0 while the socket is still alive, so the following rmmod command succeeds. # ss -tan State Recv-Q Send-Q Local AddressPort Peer AddressPort FIN-WAIT-1 0 477 10.0.2.1551062 10.0.0.137445 # lsmod | grep cifs cifs 1159168 0 This highlights a discrepancy between the lifetime of the CIFS module and the underlying TCP socket. Even after CIFS calls sock_release() and it returns, the TCP socket does not die immediately in order to close the connection gracefully. While this is generally fine, it causes an issue with LOCKDEP because CIFS assigns a different lock class to the TCP sockets sk->sk_lock using sock_lock_init_class_and_name(). Once an incoming packet is processed for the socket or a timer fires, sk->sk_lock is acquired. Then, LOCKDEP checks the lock context in check_wait_context(), where hlock_class() is called to retrieve the lock class. However, since the module has already been unloaded, hlock_class() logs a warning and returns NULL, triggering the null-ptr-deref. If LOCKDEP is enabled, we must ensure that a module calling sock_lock_init_class_and_name() (CIFS, NFS, etc) cannot be unloaded while such a socket is still alive to prevent this issue. Lets hold the module reference in sock_lock_init_class_and_name() and release it when the socket is freed in sk_prot_free(). Note that sock_lock_init() clears sk->sk_owner for svc_create_socket() that calls sock_lock_init_class_and_name() for a listening socket, which clones a socket by sk_clone_lock() without GFP_ZERO. [0] CIFS_SERVER=10.0.0.137 CIFS_PATH=//${CIFS_SERVER}/Users/Administrator/Desktop/CIFS_TEST DEV=enp0s3 CRED=/root/WindowsCredential.txt MNT=$(mktemp -d /tmp/XXXXXX) mount -t cifs ${CIFS_PATH} ${MNT} -o vers=3.0,credentials=${CRED},cache=none,echo_interval=1 iptables -A INPUT -s ${CIFS_SERVER} -j DROP for i in $(seq 10) do umount ${MNT} rmmod cifs sleep 1 done rm -r ${MNT} iptables -D INPUT -s ${CIFS_SERVER} -j DROP [1] DEBUG_LOCKS_WARN_ON(1) WARNING CPU 10 PID 0 at kernel/locking/lockdep.c234 hlock_class (kernel/locking/lockdep.c234 kernel/locking/lockdep.c223) Modules linked in cifs_arc4 nls_ucs2_utils cifs_md4 [last unloaded cifs] CPU 10 UID 0 PID 0 Comm swapper/10 Not tainted 6.14.0 #36 Hardware name QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014 RIP 0010hlock_class (kernel/locking/lockdep.c234 kernel/locking/lockdep.c223) ... Call Trace __lock_acquire (kernel/locking/lockdep.c4853 kernel/locking/lockdep.c5178) lock_acquire (kernel/locking/lockdep.c469 kernel/locking/lockdep.c5853 kernel/locking/lockdep.c5816) _raw_spin_lock_nested (kernel/locking/spinlock.c379) tcp_v4_rcv (./include/linux/skbuff.h1678 ./include/net/tcp.h2547 net/ipv4/tcp_ipv4.c2350) ... Consider specifically these CWEs: CWE-476 CWE-400 CWE-667 CWE-833 CWE-401 CWE-362",
    "cwe_mentions": [
      "CWE-476",
      "CWE-400",
      "CWE-667",
      "CWE-833",
      "CWE-401",
      "CWE-362"
    ],
    "search_time": 7.09702205657959
  },
  "timestamp": "2025-07-14 11:00:26",
  "cve_id": "CVE-2025-23143",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "type": "Base",
      "score": 2.8375620800033112,
      "relationship_count": 0
    },
    {
      "cwe_id": "1325",
      "name": "Improperly Controlled Sequential Memory Allocation",
      "type": "base",
      "score": 2.73416,
      "relationship_count": 0
    },
    {
      "cwe_id": "410",
      "name": "Insufficient Resource Pool",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "390",
      "name": "Detection of Error Condition Without Action",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "123",
      "name": "Write-what-where Condition",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "120",
      "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 1.7659350340493196,
      "relationship_count": 0
    },
    {
      "cwe_id": "364",
      "name": "Signal Handler Race Condition",
      "type": "base",
      "score": 1.7550000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "789",
      "name": "Memory Allocation with Excessive Size Value",
      "type": "Variant",
      "score": 1.750105948841143,
      "relationship_count": 0
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 1.7219934550730531,
      "relationship_count": 0
    },
    {
      "cwe_id": "1265",
      "name": "Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "386",
      "name": "Symbolic Name not Mapping to Correct Object",
      "type": "base",
      "score": 1.6744000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "662",
      "name": "Improper Synchronization",
      "type": "class",
      "score": 1.6736000000000002,
      "relationship_count": 0
    },
    {
      "cwe_id": "129",
      "name": "Improper Validation of Array Index",
      "type": "variant",
      "score": 1.6320000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "609",
      "name": "Double-Checked Locking",
      "type": "base",
      "score": 1.5912000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "252",
      "name": "Unchecked Return Value",
      "type": "Base",
      "score": 1.5488391461346314,
      "relationship_count": 0
    },
    {
      "cwe_id": "415",
      "name": "Double Free",
      "type": "variant",
      "score": 1.4784000000000002,
      "relationship_count": 0
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "type": "Variant",
      "score": 1.4426578865616997,
      "relationship_count": 0
    },
    {
      "cwe_id": "823",
      "name": "Use of Out-of-range Pointer Offset",
      "type": "base",
      "score": 1.3676000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "412",
      "name": "Unrestricted Externally Accessible Lock",
      "type": "base",
      "score": 1.3104,
      "relationship_count": 0
    }
  ]
}