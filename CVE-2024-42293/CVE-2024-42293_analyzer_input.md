# Vulnerability Information: CVE-2024-42293

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved arm64 mm Fix **lockless walks with static and dynamic page-table folding** Lina reports random oopsen originating from the fast GUP code when 16K pages are used with 4-level page-tables, the fourth level being folded at runtime due to lack of LPA2. In this configuration, the generic implementation of p4d_offset_lockless() will return a p4d_t * corresponding to the pgd_t allocated on the stack of the caller, gup_fast_pgd_range(). This is normally fine, but when the fourth level of page-table is folded at runtime, pud_offset_lockless() will offset from the address of the p4d_t to calculate the address of the PUD in the same page-table page. This results in a stray stack read when the p4d_t has been allocated on the stack and can send the walker into the weeds. Fix the problem by providing our own definition of p4d_offset_lockless() when CONFIG_PGTABLE_LEVELS <= 4 which returns the real page-table pointer rather than the address of the local stack variable.

### Vulnerability Description Key Phrases
- **rootcause:** **lockless walks with static and dynamic page-table folding**
- **weakness:** **stack corruption**
- **impact:** random oopsen
- **product:** Linux kernel
- **component:** arm64 mm

## CVE Reference Links Content Summary
The provided content relates to a vulnerability in the Linux kernel's arm64 architecture, specifically when using 16K pages with 4-level page tables and dynamic folding of the fourth level due to lack of LPA2.

**Root cause of vulnerability:**
- The generic implementation of `p4d_offset_lockless()` returns a `p4d_t *` corresponding to the `pgd_t` allocated on the stack of the caller (in `gup_fast_pgd_range()`).
- When the fourth level of the page table is folded at runtime, `pud_offset_lockless()` calculates the address of the PUD by offsetting from the address of this stack-allocated `p4d_t`. This results in an out-of-bounds stack read when accessing the PUD, potentially causing a crash or other undefined behavior.

**Weaknesses/vulnerabilities present:**
- **Incorrect pointer calculation:** The `pud_offset_lockless()` function assumes that the provided `p4d_t *` points to a valid page table entry, but in this specific scenario, it's pointing to a stack variable, leading to a stack out-of-bounds read.
- **Lack of awareness of dynamic page-table folding:** The generic `p4d_offset_lockless()` function doesn't account for the scenario where the fourth level page table is folded at runtime, leading to incorrect pointer arithmetic.

**Impact of exploitation:**
- **System crash:** The out-of-bounds stack read can cause a kernel oops, leading to a system crash or instability.
- **Potential for further exploitation:** Although not explicitly stated, out-of-bounds reads can potentially be leveraged for other forms of exploitation, but this is not detailed in the provided information.

**Attack vectors:**
- The vulnerability is triggered during page table walks. Specifically, it manifests when 16K pages are used with 4-level page tables where the fourth level is dynamically folded due to the lack of LPA2.
- The vulnerability occurs during operations that use the fast GUP (Get User Pages) path, which is used to efficiently map user-space memory into the kernel.

**Required attacker capabilities/position:**
- The attacker needs to be able to trigger the fast GUP code path with memory mappings that involve the specific page table configurations (16k pages, 4-level page tables with dynamic folding of 4th level) to exploit this issue.
- The attacker would need to execute code that leads to the faulting page table walk, probably through triggering a specific memory access pattern or system call.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.890 |
| 2 | 472 | External Control of Assumed-Immutable Web Parameter | Base | Allowed | sparse | 0.853 |
| 3 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.846 |
| 4 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.843 |
| 5 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.841 |
| 6 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.841 |
| 7 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | sparse | 0.837 |
| 8 | 79 | Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') | Base | Allowed | sparse | 0.832 |
| 9 | 667 | Improper Locking | Class | Allowed-with-Review | dense | 0.537 |
| 10 | 823 | Use of Out-of-range Pointer Offset | Base | Allowed | graph | 0.003 |

