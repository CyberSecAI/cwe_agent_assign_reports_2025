{
  "retriever": "graph",
  "query": "In the Linux kernel, the following vulnerability has been resolved sctp detect and prevent references to a freed transport in sendmsg sctp_sendmsg() re-uses associations and transports when possible by doing a lookup based on the socket endpoint and the message destination address, and then sctp_sendmsg_to_asoc() sets the selected transport in all the message chunks to be sent. Theres a possible race condition if another thread triggers the removal of that selected transport, for instance, by explicitly unbinding an address with setsockopt(SCTP_SOCKOPT_BINDX_REM), after the chunks have been set up and before the message is sent. This can happen if the send buffer is full, during the period when the sender thread temporarily releases the socket lock in sctp_wait_for_sndbuf(). This causes the access to the transport data in sctp_outq_select_transport(), when the association outqueue is flushed, to result in a use-after-free read. This change avoids this scenario by having sctp_transport_free() signal the freeing of the transport, tagging it as dead. In order to do this, the patch restores the dead bit in struct sctp_transport, which was removed in commit 47faa1e4c50e (sctp remove the dead field of sctp_transport). Then, in the scenario where the sender thread has released the socket lock in sctp_wait_for_sndbuf(), the bit is checked again after re-acquiring the socket lock to detect the deletion. This is done while holding a reference to the transport to prevent it from being freed in the process. If the transport was deleted while the socket lock was relinquished, sctp_sendmsg_to_asoc() will return -EAGAIN to let userspace retry the send. The bug was found by a private syzbot instance (see the error report [1] and the C reproducer that triggers it [2]). Consider specifically these CWEs: CWE-366 CWE-367 CWE-401 CWE-908 CWE-362 CWE-909 CWE-319 CWE-667 CWE-833",
  "keyphrases": {
    "original_query": "In the Linux kernel, the following vulnerability has been resolved sctp detect and prevent references to a freed transport in sendmsg sctp_sendmsg() re-uses associations and transports when possible by doing a lookup based on the socket endpoint and the message destination address, and then sctp_sendmsg_to_asoc() sets the selected transport in all the message chunks to be sent. Theres a possible race condition if another thread triggers the removal of that selected transport, for instance, by explicitly unbinding an address with setsockopt(SCTP_SOCKOPT_BINDX_REM), after the chunks have been set up and before the message is sent. This can happen if the send buffer is full, during the period when the sender thread temporarily releases the socket lock in sctp_wait_for_sndbuf(). This causes the access to the transport data in sctp_outq_select_transport(), when the association outqueue is flushed, to result in a use-after-free read. This change avoids this scenario by having sctp_transport_free() signal the freeing of the transport, tagging it as dead. In order to do this, the patch restores the dead bit in struct sctp_transport, which was removed in commit 47faa1e4c50e (sctp remove the dead field of sctp_transport). Then, in the scenario where the sender thread has released the socket lock in sctp_wait_for_sndbuf(), the bit is checked again after re-acquiring the socket lock to detect the deletion. This is done while holding a reference to the transport to prevent it from being freed in the process. If the transport was deleted while the socket lock was relinquished, sctp_sendmsg_to_asoc() will return -EAGAIN to let userspace retry the send. The bug was found by a private syzbot instance (see the error report [1] and the C reproducer that triggers it [2]).",
    "enhanced_query": "In the Linux kernel, the following vulnerability has been resolved sctp detect and prevent references to a freed transport in sendmsg sctp_sendmsg() re-uses associations and transports when possible by doing a lookup based on the socket endpoint and the message destination address, and then sctp_sendmsg_to_asoc() sets the selected transport in all the message chunks to be sent. Theres a possible race condition if another thread triggers the removal of that selected transport, for instance, by explicitly unbinding an address with setsockopt(SCTP_SOCKOPT_BINDX_REM), after the chunks have been set up and before the message is sent. This can happen if the send buffer is full, during the period when the sender thread temporarily releases the socket lock in sctp_wait_for_sndbuf(). This causes the access to the transport data in sctp_outq_select_transport(), when the association outqueue is flushed, to result in a use-after-free read. This change avoids this scenario by having sctp_transport_free() signal the freeing of the transport, tagging it as dead. In order to do this, the patch restores the dead bit in struct sctp_transport, which was removed in commit 47faa1e4c50e (sctp remove the dead field of sctp_transport). Then, in the scenario where the sender thread has released the socket lock in sctp_wait_for_sndbuf(), the bit is checked again after re-acquiring the socket lock to detect the deletion. This is done while holding a reference to the transport to prevent it from being freed in the process. If the transport was deleted while the socket lock was relinquished, sctp_sendmsg_to_asoc() will return -EAGAIN to let userspace retry the send. The bug was found by a private syzbot instance (see the error report [1] and the C reproducer that triggers it [2]). Consider specifically these CWEs: CWE-366 CWE-367 CWE-401 CWE-908 CWE-362 CWE-909 CWE-319 CWE-667 CWE-833",
    "cwe_mentions": [
      "CWE-366",
      "CWE-367",
      "CWE-401",
      "CWE-908",
      "CWE-362",
      "CWE-909",
      "CWE-319",
      "CWE-667",
      "CWE-833"
    ],
    "search_time": 3.5745842456817627
  },
  "timestamp": "2025-07-12 10:15:38",
  "cve_id": "CVE-2025-23142",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "609",
      "name": "Double-Checked Locking",
      "type": "base",
      "score": 2.8651999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "908",
      "name": "Use of Uninitialized Resource",
      "type": "Base",
      "score": 2.8170437247400515,
      "relationship_count": 0
    },
    {
      "cwe_id": "386",
      "name": "Symbolic Name not Mapping to Correct Object",
      "type": "base",
      "score": 2.3764000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "390",
      "name": "Detection of Error Condition Without Action",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "319",
      "name": "Cleartext Transmission of Sensitive Information",
      "type": "base",
      "score": 2.1189999999999998,
      "relationship_count": 0
    },
    {
      "cwe_id": "456",
      "name": "Missing Initialization of a Variable",
      "type": "variant",
      "score": 1.83936,
      "relationship_count": 0
    },
    {
      "cwe_id": "123",
      "name": "Write-what-where Condition",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "120",
      "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "909",
      "name": "Missing Initialization of Resource",
      "type": "Class",
      "score": 1.7546029404272474,
      "relationship_count": 0
    },
    {
      "cwe_id": "366",
      "name": "Race Condition within a Thread",
      "type": "Base",
      "score": 1.7105410248875605,
      "relationship_count": 0
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 1.6986474183890603,
      "relationship_count": 0
    },
    {
      "cwe_id": "367",
      "name": "Time-of-check Time-of-use (TOCTOU) Race Condition",
      "type": "Base",
      "score": 1.6897553217689492,
      "relationship_count": 0
    },
    {
      "cwe_id": "1265",
      "name": "Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "252",
      "name": "Unchecked Return Value",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "1325",
      "name": "Improperly Controlled Sequential Memory Allocation",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "662",
      "name": "Improper Synchronization",
      "type": "class",
      "score": 1.6736000000000002,
      "relationship_count": 0
    },
    {
      "cwe_id": "61",
      "name": "UNIX Symbolic Link (Symlink) Following",
      "type": "compound",
      "score": 1.61,
      "relationship_count": 0
    },
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "type": "Base",
      "score": 1.5391438838196216,
      "relationship_count": 0
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "type": "Variant",
      "score": 1.4360504470843842,
      "relationship_count": 0
    },
    {
      "cwe_id": "134",
      "name": "Use of Externally-Controlled Format String",
      "type": "base",
      "score": 1.3010400000000002,
      "relationship_count": 0
    }
  ]
}