# Vulnerability Information: CVE-2024-42140

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved riscv kexec Avoid deadlock in kexec crash path If the kexec crash code is called in the interrupt context, the machine_kexec_mask_interrupts() function will trigger a deadlock while trying to acquire the irqdesc spinlock and then deactivate irqchip in irq_set_irqchip_state() function. Unlike arm64, riscv only requires irq_eoi handler to complete EOI and keeping irq_set_irqchip_state() will only leave this possible deadlock without any use. So we simply remove it.

### Vulnerability Description Key Phrases
- **rootcause:** **deadlock in the interrupt context**
- **impact:** deadlock
- **product:** Linux kernel
- **component:** riscv kexec

## CVE Reference Links Content Summary
The provided content describes a fix for a deadlock vulnerability in the Linux kernel's kexec crash path on RISC-V architecture. This is achieved by removing a redundant call to `irq_set_irqchip_state()`.

- **Root cause of vulnerability**: The `machine_kexec_mask_interrupts()` function, when called in an interrupt context, attempted to acquire the `irqdesc` spinlock and then deactivate the irqchip using `irq_set_irqchip_state()`. This resulted in a deadlock since the spinlock was already held in interrupt context.
- **Weaknesses/vulnerabilities present**: The code was attempting to deactivate the irqchip using `irq_set_irqchip_state()` even though on RISC-V, only the `irq_eoi` handler is required to complete EOI. This unnecessary call introduced a potential deadlock.
- **Impact of exploitation**: A deadlock would occur when the kexec crash code was called within an interrupt context, causing the system to hang.
- **Attack vectors**: The vulnerability is triggered when the kexec crash path is executed in the interrupt context. The kexec crash path is triggered by user-space via `kexec_load`.
- **Required attacker capabilities/position**: An attacker would need the ability to trigger a kernel crash (e.g. `panic()`) after initiating a kexec load in an environment where the kexec crash path is entered in the interrupt context to trigger a deadlock.

The patch removes the call to `irq_set_irqchip_state()` and instead uses only the `irq_eoi` handler to complete the EOI process in the `machine_kexec_mask_interrupts()` function for the RISC-V architecture.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.420 |
| 2 | 833 | Deadlock | Base | Allowed | sparse | 0.402 |
| 3 | 663 | Use of a Non-reentrant Function in a Concurrent Context | Base | Allowed | sparse | 0.369 |
| 4 | 459 | Incomplete Cleanup | Base | Allowed | sparse | 0.353 |
| 5 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.345 |
| 6 | 364 | Signal Handler Race Condition | Base | Allowed | sparse | 0.342 |
| 7 | 787 | Out-of-bounds Write | Base | Allowed | sparse | 0.339 |
| 8 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.338 |
| 9 | 1342 | Information Exposure through Microarchitectural State after Transient Execution | Base | Allowed | dense | 0.492 |
| 10 | 1265 | Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls | Base | Allowed | graph | 0.002 |

