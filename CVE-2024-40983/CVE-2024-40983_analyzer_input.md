# Vulnerability Information: CVE-2024-40983

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved tipc force a dst refcount before doing decryption As it says in commit 3bc07321ccc2 (xfrm Force a dst refcount before entering the xfrm type handlers) Crypto requests might return asynchronous. In this case we leave the rcu protected region, so force a refcount on the skbs destination entry before we enter the xfrm type input/output handlers. On TIPC decryption path it has the same problem, and skb_dst_force() should be called before doing decryption to avoid a possible crash. Shuang reported this issue when this warning is triggered [] WARNING include/net/dst.h337 tipc_sk_rcv+0x1055/0x1ea0 [tipc] [] Kdump loaded Tainted G W --------- - - 4.18.0-496.el8.x86_64+debug [] Workqueue crypto cryptd_queue_worker [] RIP 0010tipc_sk_rcv+0x1055/0x1ea0 [tipc] [] Call Trace [] tipc_sk_mcast_rcv+0x548/0xea0 [tipc] [] tipc_rcv+0xcf5/0x1060 [tipc] [] tipc_aead_decrypt_done+0x215/0x2e0 [tipc] [] cryptd_aead_crypt+0xdb/0x190 [] cryptd_queue_worker+0xed/0x190 [] process_one_work+0x93d/0x17e0

### Vulnerability Description Key Phrases
- **impact:** possible crash
- **product:** Linux kernel
- **version:** 4.18.0-496.el8.x86_64+debug
- **component:** TIPC

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of the vulnerability:

**Root Cause:**
The vulnerability lies in the TIPC (Transparent Inter-Process Communication) module of the Linux kernel. Specifically, the issue is that when decrypting TIPC packets, the code does not force a reference count on the skb's (socket buffer) destination entry before entering the decryption handler. This is problematic because the cryptographic operation might be asynchronous, potentially causing the code to leave the RCU (Read-Copy-Update) protected region without a valid reference, leading to a potential use-after-free condition and crash.

**Weaknesses/Vulnerabilities:**
- **Missing Reference Counting:** The core issue is the absence of `skb_dst_force(skb)` before the call to `tipc_crypto_rcv`. This function is meant to ensure that the destination entry associated with the socket buffer remains valid while the cryptographic operation, which might be asynchronous, is in progress.
- **Asynchronous Operations:** The asynchronous nature of the crypto requests is a contributing factor as it allows the code to exit the RCU protected region without the needed reference count on the destination entry.

**Impact of Exploitation:**
- **Kernel Crash:** The primary impact is a kernel crash due to the use-after-free vulnerability. This happens when the destination entry is freed while the decryption operation is still pending or in progress, and the code later tries to access it.
- **Denial of Service:** The crash can lead to a denial of service, as the system becomes unusable.

**Attack Vectors:**
- **Network Communication:** The attack vector is through network communication using the TIPC protocol.
- **Encrypted TIPC packets:** The vulnerability is triggered specifically during the decryption of TIPC packets

**Required Attacker Capabilities/Position:**
- **Network Access:** The attacker needs to be able to send crafted, encrypted TIPC packets to a vulnerable system.
- **Knowledge of TIPC Protocol:** The attacker needs to have a basic understanding of the TIPC protocol to formulate the malicious packets.
- **No special privileges:** The attacker does not need special privileges on the target system other than the ability to send TIPC packets.

**More Details than CVE Description:**

The provided content gives more context than a typical CVE description, including:
- The specific code change that fixes the vulnerability, `skb_dst_force(skb)`
- The warning message that triggers the issue, "WARNING: include/net/dst.h:337 tipc\_sk\_rcv+0x1055/0x1ea0 [tipc]" along with the kernel crash trace information.
- The commit message from the fix which references the xfrm subsystem as having similar issues, and why the fix is needed.
- The specific functions involved in the crash and call trace.

In summary, this is a use-after-free vulnerability in the TIPC module triggered by missing reference counting on the destination entry of a socket buffer before decryption, which can cause a kernel crash, triggered by sending encrypted TIPC packets.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | sparse | 0.180 |
| 2 | 415 | Double Free | Variant | Allowed | sparse | 0.160 |
| 3 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.153 |
| 4 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.151 |
| 5 | 203 | Observable Discrepancy | Base | Allowed | sparse | 0.149 |
| 6 | 327 | Use of a Broken or Risky Cryptographic Algorithm | Class | Allowed-with-Review | sparse | 0.149 |
| 7 | 617 | Reachable Assertion | Base | Allowed | sparse | 0.146 |
| 8 | 911 | Improper Update of Reference Count | Base | Allowed | sparse | 0.145 |
| 9 | 667 | Improper Locking | Class | Allowed-with-Review | dense | 0.481 |
| 10 | 364 | Signal Handler Race Condition | Base | Allowed | graph | 0.003 |

