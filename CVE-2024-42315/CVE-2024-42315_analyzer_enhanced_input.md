## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved exfat fix **potential deadlock** on __exfat_get_dentry_set When accessing a file with more entries than ES_MAX_ENTRY_NUM, the bh-array is allocated in __exfat_get_entry_set. The problem is that the bh-array is allocated with GFP_KERNEL. It does not make sense. In the following cases, a deadlock for sbi->s_lock between the two processes may occur. CPU0 CPU1 ---- ---- kswapd balance_pgdat lock(fs_reclaim) exfat_iterate lock(&sbi->s_lock) exfat_readdir exfat_get_uniname_from_ext_entry exfat_get_dentry_set __exfat_get_dentry_set kmalloc_array ... lock(fs_reclaim) ... evict exfat_evict_inode lock(&sbi->s_lock) To fix this, lets allocate bh-array with GFP_NOFS.

### Vulnerability Description Key Phrases
- **rootcause:** **potential deadlock**
- **vector:** accessing a file with more entries than ES_MAX_ENTRY_NUM
- **product:** Linux kernel

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of the vulnerability:

**Root Cause:**
The root cause of the vulnerability is an incorrect allocation flag (`GFP_KERNEL`) used when allocating memory for the `bh` array in the `__exfat_get_dentry_set` function within the exFAT filesystem driver in the Linux kernel. This occurs when accessing files with a large number of directory entries (more than `ES_MAX_ENTRY_NUM`).

**Weaknesses/Vulnerabilities Present:**
- **Incorrect Memory Allocation Flag:** The use of `GFP_KERNEL` for allocating the `bh` array, which may lead to waiting for memory and can cause deadlocks.
- **Potential Deadlock:** The incorrect allocation can lead to a deadlock scenario involving `sbi->s_lock`. This occurs because `GFP_KERNEL` can sleep while waiting for memory. This can block a process holding `sbi->s_lock` while kswapd is trying to reclaim memory, and also requires `sbi->s_lock`.

**Impact of Exploitation:**
- **System Deadlock:** The deadlock can cause the system to become unresponsive, requiring a reboot to recover.

**Attack Vectors:**
- The vulnerability can be triggered by accessing a file within an exFAT filesystem that contains a large number of directory entries. This will cause `__exfat_get_entry_set` to allocate `bh` array with `GFP_KERNEL` and potentially trigger deadlock with other processes.

**Required Attacker Capabilities/Position:**
- The attacker needs to have the ability to create or access an exFAT filesystem with a file containing more entries than `ES_MAX_ENTRY_NUM`. No specific privileges are required other than those needed to interact with a filesystem.

**Additional Notes:**
- The fix involves changing the allocation flag from `GFP_KERNEL` to `GFP_NOFS`. `GFP_NOFS` will not sleep while waiting for memory and prevents the deadlock.
- This issue affects multiple kernel versions including stable trees since v5.10+.
- The vulnerability was reported by syzbot.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.545 |
| 2 | 833 | Deadlock | Base | Allowed | sparse | 0.497 |
| 3 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.394 |
| 4 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.385 |
| 5 | 190 | Integer Overflow or Wraparound | Base | Allowed | sparse | 0.381 |
| 6 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.378 |
| 7 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.374 |
| 8 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | sparse | 0.370 |
| 9 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | dense | 0.473 |
| 10 | 364 | Signal Handler Race Condition | Base | Allowed | graph | 0.002 |



# Complete CWE Specifications

CWE-667: Improper Locking

CWE-833: Deadlock

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-1284: Improper Validation of Specified Quantity in Input

CWE-190: Integer Overflow or Wraparound

CWE-125: Out-of-bounds Read

CWE-770: Allocation of Resources Without Limits or Throttling

CWE-789: Memory Allocation with Excessive Size Value

CWE-909: Missing Initialization of Resource

CWE-364: Signal Handler Race Condition