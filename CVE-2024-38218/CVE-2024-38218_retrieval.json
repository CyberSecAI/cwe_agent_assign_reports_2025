{
  "vulnerability_info": "VulnerabilityInfo(cve_id='CVE-2024-38218', description='Microsoft Edge (HTML-based) Memory Corruption Vulnerability', key_phrases={'rootcause': '', 'weakness': 'memory corruption', 'impact': '', 'vector': '', 'attacker': '', 'product': 'Microsoft Edge', 'version': '', 'component': 'HTML-based'}, reference_content='UNRELATED', similar_info={'cwe_distribution': {95: {'cwe_counts': defaultdict(<class 'int'>, {'CWE-NVD-noinfo': 1, 'CWE-787': 1}), 'total_samples': 2, 'distribution': [{'cwes': ['CWE-NVD-noinfo'], 'frequency': 1, 'proportion': 0.5}, {'cwes': ['CWE-787'], 'frequency': 1, 'proportion': 0.5}]}, 90: {'cwe_counts': defaultdict(<class 'int'>, {'CWE-NVD-noinfo': 1, 'CWE-787': 1}), 'total_samples': 2, 'distribution': [{'cwes': ['CWE-NVD-noinfo'], 'frequency': 1, 'proportion': 0.5}, {'cwes': ['CWE-787'], 'frequency': 1, 'proportion': 0.5}]}, 85: {'cwe_counts': defaultdict(<class 'int'>, {'CWE-NVD-noinfo': 1, 'CWE-787': 1}), 'total_samples': 2, 'distribution': [{'cwes': ['CWE-NVD-noinfo'], 'frequency': 1, 'proportion': 0.5}, {'cwes': ['CWE-787'], 'frequency': 1, 'proportion': 0.5}]}, 80: {'cwe_counts': defaultdict(<class 'int'>, {'CWE-787': 2, 'CWE-NVD-noinfo': 1}), 'total_samples': 3, 'distribution': [{'cwes': ['CWE-787'], 'frequency': 2, 'proportion': 0.667}, {'cwes': ['CWE-NVD-noinfo'], 'frequency': 1, 'proportion': 0.333}]}, 75: {'cwe_counts': defaultdict(<class 'int'>, {'CWE-787': 2, 'CWE-NVD-noinfo': 1}), 'total_samples': 3, 'distribution': [{'cwes': ['CWE-787'], 'frequency': 2, 'proportion': 0.667}, {'cwes': ['CWE-NVD-noinfo'], 'frequency': 1, 'proportion': 0.333}]}, 70: {'cwe_counts': defaultdict(<class 'int'>, {'CWE-787': 2, 'CWE-NVD-noinfo': 1}), 'total_samples': 3, 'distribution': [{'cwes': ['CWE-787'], 'frequency': 2, 'proportion': 0.667}, {'cwes': ['CWE-NVD-noinfo'], 'frequency': 1, 'proportion': 0.333}]}}, 'cwe_consensus': 'CWE-787', 'similarity_stats': {'thresholds': [95, 90, 85, 80, 75, 70], 'total_samples_by_threshold': {95: 2, 90: 2, 85: 2, 80: 3, 75: 3, 70: 3}, 'top_cwes_by_threshold': {95: [('CWE-NVD-noinfo', 1), ('CWE-787', 1)], 90: [('CWE-NVD-noinfo', 1), ('CWE-787', 1)], 85: [('CWE-NVD-noinfo', 1), ('CWE-787', 1)], 80: [('CWE-787', 2), ('CWE-NVD-noinfo', 1)], 75: [('CWE-787', 2), ('CWE-NVD-noinfo', 1)], 70: [('CWE-787', 2), ('CWE-NVD-noinfo', 1)]}}, 'raw_matches': [{'similarity': 95, 'cwes': ['NVD-noinfo'], 'total': 2, 'frequency': 1, 'proportion': 0.5}, {'similarity': 95, 'cwes': ['787'], 'total': 2, 'frequency': 1, 'proportion': 0.5}, {'similarity': 90, 'cwes': ['NVD-noinfo'], 'total': 2, 'frequency': 1, 'proportion': 0.5}, {'similarity': 90, 'cwes': ['787'], 'total': 2, 'frequency': 1, 'proportion': 0.5}, {'similarity': 85, 'cwes': ['NVD-noinfo'], 'total': 2, 'frequency': 1, 'proportion': 0.5}, {'similarity': 85, 'cwes': ['787'], 'total': 2, 'frequency': 1, 'proportion': 0.5}, {'similarity': 80, 'cwes': ['787'], 'total': 3, 'frequency': 2, 'proportion': 0.667}, {'similarity': 80, 'cwes': ['NVD-noinfo'], 'total': 3, 'frequency': 1, 'proportion': 0.333}, {'similarity': 75, 'cwes': ['787'], 'total': 3, 'frequency': 2, 'proportion': 0.667}, {'similarity': 75, 'cwes': ['NVD-noinfo'], 'total': 3, 'frequency': 1, 'proportion': 0.333}, {'similarity': 70, 'cwes': ['787'], 'total': 3, 'frequency': 2, 'proportion': 0.667}, {'similarity': 70, 'cwes': ['NVD-noinfo'], 'total': 3, 'frequency': 1, 'proportion': 0.333}]}, similarity_summary=SimilarityInsight(consensus_cwe='CWE-787', top_cwes=[('CWE-787', 9), ('CWE-NVD-noinfo', 6)], confidence_levels={'high': [], 'medium': [], 'low': []}, total_samples=15), analysis='', analysis_with_relationships='', criticism='', resolution='', relevant_cwes=[{'metadata': {'doc_id': '787', 'name': 'Out-of-bounds Write', 'source': 'alternate_terms', 'original_match': 'AlternateTerms: Memory Corruption', 'match_reason': 'exact_match_whole_phrase'}, 'similarity': 1000.0, 'alternate_term_match': True}, {'metadata': {'doc_id': '843', 'name': \"Access of Resource Using Incompatible Type ('Type Confusion')\", 'source': 'sparse'}, 'similarity': np.float64(67.60603023958426)}, {'metadata': {'doc_id': '416', 'name': 'Use After Free', 'source': 'sparse'}, 'similarity': np.float64(60.782740992322296)}, {'metadata': {'doc_id': '122', 'name': 'Heap-based Buffer Overflow', 'source': 'sparse'}, 'similarity': np.float64(59.76424520678538)}, {'metadata': {'doc_id': '415', 'name': 'Double Free', 'source': 'sparse'}, 'similarity': np.float64(53.504177185489525)}, {'metadata': {'doc_id': '316', 'name': 'Cleartext Storage of Sensitive Information in Memory', 'type': 'Variant', 'original_content': 'The product stores sensitive information in cleartext in memory.', 'keyphrase_source': 'weakness:memory corruption', 'source': 'dense', 'mapping_notes': {'usage': 'Allowed', 'rationale': 'This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.', 'comments': \"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\", 'reasons': ['Acceptable-Use']}, 'score_info': {'retrievers': ['dense'], 'retriever_count': 1, 'normalized_scores': {'dense': 0.5530907529031421}}}, 'similarity': 0.5530907529031421}, {'doc_id': '123', 'text': 'CWE-123: Write-what-where Condition', 'score': 3.5671999999999997, 'metadata': {'doc_id': '123', 'name': 'Write-what-where Condition', 'type': 'base', 'original_content': 'CWE-123: Write-what-where Condition', 'relationships': [{'source_id': '123', 'target_id': '590', 'label': 'CANFOLLOW', 'properties': {'view_id': '1000'}}, {'source_id': '123', 'target_id': '479', 'label': 'CANFOLLOW', 'properties': {'view_id': '1000'}}, {'source_id': '123', 'target_id': '416', 'label': 'CANFOLLOW', 'properties': {'view_id': '1000'}}, {'source_id': '123', 'target_id': '364', 'label': 'CANFOLLOW', 'properties': {'view_id': '1000'}}, {'source_id': '123', 'target_id': '134', 'label': 'CANFOLLOW', 'properties': {'view_id': '1000'}}, {'source_id': '123', 'target_id': '120', 'label': 'CANFOLLOW', 'properties': {'view_id': '1000'}}, {'source_id': '123', 'target_id': '119', 'label': 'CHILDOF', 'properties': {'ordinal': 'Primary', 'view_id': '1340'}}, {'source_id': '123', 'target_id': '119', 'label': 'CHILDOF', 'properties': {'ordinal': 'Primary', 'view_id': '1305'}}, {'source_id': '123', 'target_id': '787', 'label': 'CHILDOF', 'properties': {'ordinal': 'Primary', 'view_id': '1000'}}, {'source_id': '787', 'target_id': '123', 'label': 'PARENTOF', 'properties': {'ordinal': 'Primary', 'view_id': '1000'}}, {'source_id': '590', 'target_id': '123', 'label': 'CANPRECEDE', 'properties': {'view_id': '1000'}}, {'source_id': '479', 'target_id': '123', 'label': 'CANPRECEDE', 'properties': {'view_id': '1000'}}, {'source_id': '416', 'target_id': '123', 'label': 'CANPRECEDE', 'properties': {'view_id': '1000'}}, {'source_id': '415', 'target_id': '123', 'label': 'PEEROF', 'properties': {'view_id': '1000'}}, {'source_id': '364', 'target_id': '123', 'label': 'CANPRECEDE', 'properties': {'view_id': '1000'}}, {'source_id': '134', 'target_id': '123', 'label': 'CANPRECEDE', 'properties': {'view_id': '1000'}}, {'source_id': '120', 'target_id': '123', 'label': 'CANPRECEDE', 'properties': {'view_id': '1000'}}, {'source_id': '119', 'target_id': '123', 'label': 'PARENTOF', 'properties': {'ordinal': 'Primary', 'view_id': '1305'}}], 'score_components': {'relationship_chain': 1.0, 'abstraction_path': 0.7200000000000001, 'sequence_path': 1.0, 'peer_group': 0.9}, 'abstraction_factor': 1.3, 'graph_path_info': {'path_types': ['relationship_chain', 'abstraction_path_down', 'vulnerability_sequence_forward', 'peer_relationship'], 'best_paths': {'relationship_chain': {'path': [('416', '123', 'CANPRECEDE')], 'score': 1.0, 'type': 'relationship_chain', 'source': '416'}, 'abstraction_path_down': {'path': [('787', '123', 'PARENTOF')], 'score': 0.7200000000000001, 'type': 'abstraction_path_down', 'source': '787'}, 'vulnerability_sequence_forward': {'path': [('416', '123', 'CANPRECEDE')], 'score': 1.0, 'type': 'vulnerability_sequence_forward', 'source': '416'}, 'peer_relationship': {'path': [('415', '123', 'PEEROF')], 'score': 0.9, 'type': 'peer_relationship', 'source': '415'}}}, 'abstraction_level': 'base', 'position': 'after', 'sources': ['graph'], 'source': 'graph', 'mapping_notes': {'usage': 'Allowed', 'rationale': 'This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.', 'comments': \"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\", 'reasons': ['Acceptable-Use']}, 'score_info': {'retrievers': ['graph'], 'retriever_count': 1, 'normalized_scores': {'graph': 3.5671999999999997}}}, 'similarity': 3.5671999999999997}, {'metadata': {'doc_id': '190', 'name': 'Integer Overflow or Wraparound', 'source': 'sparse'}, 'similarity': np.float64(51.530627528621274)}, {'metadata': {'doc_id': '788', 'name': 'Access of Memory Location After End of Buffer', 'source': 'sparse'}, 'similarity': np.float64(51.05905723022035)}, {'metadata': {'doc_id': '366', 'name': 'Race Condition within a Thread', 'source': 'sparse'}, 'similarity': np.float64(50.5279456484442)}], identified_cwes={'analyzer': [], 'critic_additional': []})",
  "retrieval_results": {
    "has_multiple_keyphrases": false,
    "raw_search_results": {
      "all_results": [
        {
          "metadata": {
            "doc_id": "787",
            "name": "Out-of-bounds Write",
            "type": "Base",
            "original_content": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "keyphrase_source": "weakness:memory corruption",
            "source": "dense",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense",
                "sparse",
                "graph"
              ],
              "retriever_count": 3,
              "normalized_scores": {
                "dense": 0.6044956188779271,
                "sparse": 1000.0,
                "graph": 1.9494031032124015
              }
            }
          },
          "similarity": 0.6044956188779271
        },
        {
          "metadata": {
            "doc_id": "416",
            "name": "Use After Free",
            "type": "Variant",
            "original_content": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
            "source": "dense",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense",
                "sparse",
                "graph"
              ],
              "retriever_count": 3,
              "normalized_scores": {
                "dense": 0.5564290782764135,
                "sparse": 60.782740992322296,
                "graph": 2.262891626614683
              }
            }
          },
          "similarity": 0.5564290782764135
        },
        {
          "metadata": {
            "doc_id": "843",
            "name": "Access of Resource Using Incompatible Type ('Type Confusion')",
            "type": "Base",
            "original_content": "The product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.",
            "keyphrase_source": "weakness:memory corruption",
            "source": "dense",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense",
                "sparse",
                "graph"
              ],
              "retriever_count": 3,
              "normalized_scores": {
                "dense": 0.5532373381039504,
                "sparse": 67.60603023958426,
                "graph": 2.5257713361350778
              }
            }
          },
          "similarity": 0.5532373381039504
        },
        {
          "metadata": {
            "doc_id": "316",
            "name": "Cleartext Storage of Sensitive Information in Memory",
            "type": "Variant",
            "original_content": "The product stores sensitive information in cleartext in memory.",
            "keyphrase_source": "weakness:memory corruption",
            "source": "dense",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "dense": 0.5530907529031421
              }
            }
          },
          "similarity": 0.5530907529031421
        },
        {
          "metadata": {
            "doc_id": "1260",
            "name": "Improper Handling of Overlap Between Protected Memory Ranges",
            "type": "Base",
            "original_content": "The product allows address regions to overlap, which can result in the bypassing of intended memory protection.",
            "keyphrase_source": "weakness:memory corruption",
            "source": "dense",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense",
                "graph"
              ],
              "retriever_count": 2,
              "normalized_scores": {
                "dense": 0.5423218496153519,
                "graph": 2.372747119777513
              }
            }
          },
          "similarity": 0.5423218496153519
        },
        {
          "metadata": {
            "doc_id": "788",
            "name": "Access of Memory Location After End of Buffer",
            "type": "Base",
            "original_content": "The product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.",
            "keyphrase_source": "weakness:memory corruption",
            "source": "dense",
            "mapping_notes": {
              "usage": "Discouraged",
              "rationale": "The CWE entry might be misused when lower-level CWE entries might be available. It also overlaps existing CWE entries and might be deprecated in the future.",
              "comments": "If the \"Access\" operation is known to be a read or a write, then investigate children of entries such as CWE-787: Out-of-bounds Write and CWE-125: Out-of-bounds Read.",
              "reasons": [
                "Potential Deprecation",
                "Frequent Misuse"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense",
                "sparse"
              ],
              "retriever_count": 2,
              "normalized_scores": {
                "dense": 0.5413483969451229,
                "sparse": 51.05905723022035
              }
            }
          },
          "similarity": 0.5413483969451229
        },
        {
          "metadata": {
            "doc_id": "127",
            "name": "Buffer Under-read",
            "type": "Variant",
            "original_content": "The product reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations prior to the targeted buffer.",
            "keyphrase_source": "weakness:memory corruption",
            "source": "dense",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "dense": 0.5349246760880122
              }
            }
          },
          "similarity": 0.5349246760880122
        },
        {
          "metadata": {
            "doc_id": "822",
            "name": "Untrusted Pointer Dereference",
            "type": "Base",
            "original_content": "The product obtains a value from an untrusted source, converts this value to a pointer, and dereferences the resulting pointer.",
            "keyphrase_source": "weakness:memory corruption",
            "source": "dense",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense",
                "sparse"
              ],
              "retriever_count": 2,
              "normalized_scores": {
                "dense": 0.5331898988837035,
                "sparse": 48.46614763081808
              }
            }
          },
          "similarity": 0.5331898988837035
        },
        {
          "metadata": {
            "doc_id": "124",
            "name": "Buffer Underwrite ('Buffer Underflow')",
            "type": "Base",
            "original_content": "The product writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.",
            "keyphrase_source": "weakness:memory corruption",
            "source": "dense",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "dense": 0.5304708044548463
              }
            }
          },
          "similarity": 0.5304708044548463
        },
        {
          "metadata": {
            "doc_id": "704",
            "name": "Incorrect Type Conversion or Cast",
            "type": "Class",
            "original_content": "The product does not correctly convert an object, resource, or structure from one type to a different type.",
            "keyphrase_source": "weakness:memory corruption",
            "source": "dense",
            "mapping_notes": {
              "usage": "Allowed-with-Review",
              "rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
              "comments": "Examine children of this entry to see if there is a better fit",
              "reasons": [
                "Abstraction"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "dense": 0.5272079352444721
              }
            }
          },
          "similarity": 0.5272079352444721
        },
        {
          "metadata": {
            "doc_id": "789",
            "name": "Memory Allocation with Excessive Size Value",
            "type": "Variant",
            "original_content": "The product allocates memory based on an untrusted, large size value, but it does not ensure that the size is within expected limits, allowing arbitrary amounts of memory to be allocated.",
            "source": "dense",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "dense": 0.509625927918915
              }
            }
          },
          "similarity": 0.509625927918915
        },
        {
          "metadata": {
            "doc_id": "366",
            "name": "Race Condition within a Thread",
            "type": "Base",
            "original_content": "If two threads of execution use a resource simultaneously, there exists the possibility that resources may be used while invalid, in turn making the state of execution undefined.",
            "source": "dense",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense",
                "sparse"
              ],
              "retriever_count": 2,
              "normalized_scores": {
                "dense": 0.5095764723959488,
                "sparse": 50.5279456484442
              }
            }
          },
          "similarity": 0.5095764723959488
        },
        {
          "metadata": {
            "doc_id": "401",
            "name": "Missing Release of Memory after Effective Lifetime",
            "type": "Variant",
            "original_content": "The product does not sufficiently track and release allocated memory after it has been used, which slowly consumes remaining memory.",
            "source": "dense",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "dense": 0.5090974239680022
              }
            }
          },
          "similarity": 0.5090974239680022
        },
        {
          "metadata": {
            "doc_id": "80",
            "name": "Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS)",
            "type": "Variant",
            "original_content": "The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special characters such as \"<\", \">\", and \"&\" that could be interpreted as web-scripting elements when they are sent to a downstream component that processes web pages.",
            "source": "dense",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "dense": 0.5070815204945177
              }
            }
          },
          "similarity": 0.5070815204945177
        },
        {
          "metadata": {
            "doc_id": "122",
            "name": "Heap-based Buffer Overflow",
            "type": "Variant",
            "original_content": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
            "source": "dense",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense",
                "sparse",
                "graph"
              ],
              "retriever_count": 3,
              "normalized_scores": {
                "dense": 0.5070551867766302,
                "sparse": 59.76424520678538,
                "graph": 2.1624
              }
            }
          },
          "similarity": 0.5070551867766302
        },
        {
          "metadata": {
            "doc_id": "823",
            "name": "Use of Out-of-range Pointer Offset",
            "type": "Base",
            "original_content": "The product performs pointer arithmetic on a valid pointer, but it uses an offset that can point outside of the intended range of valid memory locations for the resulting pointer.",
            "source": "dense",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "dense": 0.5056866376391194
              }
            }
          },
          "similarity": 0.5056866376391194
        },
        {
          "metadata": {
            "doc_id": "119",
            "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
            "type": "Class",
            "original_content": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
            "source": "dense",
            "mapping_notes": {
              "usage": "Discouraged",
              "rationale": "CWE-119 is commonly misused in low-information vulnerability reports when lower-level CWEs could be used instead, or when more details about the vulnerability are available.",
              "comments": "Look at CWE-119's children and consider mapping to CWEs such as CWE-787: Out-of-bounds Write, CWE-125: Out-of-bounds Read, or others.",
              "reasons": [
                "Frequent Misuse"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "dense": 0.504740424629194
              }
            }
          },
          "similarity": 0.504740424629194
        },
        {
          "metadata": {
            "doc_id": "125",
            "name": "Out-of-bounds Read",
            "type": "Base",
            "original_content": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "source": "dense",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "dense": 0.5042019323869635
              }
            }
          },
          "similarity": 0.5042019323869635
        },
        {
          "metadata": {
            "doc_id": "126",
            "name": "Buffer Over-read",
            "type": "Variant",
            "original_content": "The product reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations after the targeted buffer.",
            "source": "dense",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "dense": 0.502493536294006
              }
            }
          },
          "similarity": 0.502493536294006
        },
        {
          "metadata": {
            "doc_id": "1342",
            "name": "Information Exposure through Microarchitectural State after Transient Execution",
            "type": "Base",
            "original_content": "The processor does not properly clear microarchitectural state after incorrect microcode assists or speculative execution, resulting in transient execution.",
            "source": "dense",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "dense": 0.5024177349997196
              }
            }
          },
          "similarity": 0.5024177349997196
        },
        {
          "cwe_id": "787",
          "name": "Out-of-bounds Write",
          "description": "The product writes data past the end, or before the beginning, of the intended buffer.",
          "score": 1000.0,
          "matched_text": "AlternateTerms: Memory Corruption",
          "matched_phrase": "memory corruption",
          "matched_term": "memory corruption",
          "type": "Base",
          "source": "sparse",
          "search_source": "alternate_term_match",
          "match_reason": "exact_match_whole_phrase",
          "metadata": {
            "source": "sparse",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            }
          }
        },
        {
          "cwe_id": "843",
          "name": "Access of Resource Using Incompatible Type ('Type Confusion')",
          "description": "The product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.",
          "score": 67.60603023958426,
          "matched_text": "CWE-843: Access of Resource Using Incompatible Type ('Type Confusion')\n\nType: Base\n\nStatus: Incomplete\n\nAlternative Terms:\n\nObject Type Confusion\n\nObject Type Confusion\n\nObject Type Confusion\n\nDescription:\n\nThe product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.\n\nExtended Details:\n\n\n\nWhen the product accesses the resource using an incompatible type, this could trigger logical errors because the resource does not have expected properties. In languages without memory safety, such as C and C++, type confusion can lead to out-of-bounds memory access.\n\n\nWhile this weakness is frequently associated with unions when parsing data with many different embedded object types in C, it can be present in any application that can interpret the same variable or memory location in multiple ways.\n\n\nThis weakness is not unique to C and C++. For example, errors in PHP applications can be triggered by providing array parameters when scalars are expected, or vice versa. Languages such as Perl, which perform automatic conversion of a variable of one type when it is accessed as if it were another type, can also contain these issues.\n\n\nReal-World Examples:\n\n- CVE-2010-4577: Type confusion in CSS sequence leads to out-of-bounds read.\n\n- CVE-2011-0611: Size inconsistency allows code execution, first discovered when it was actively exploited in-the-wild.\n\n- CVE-2010-0258: Improperly-parsed file containing records of different types leads to code execution when a memory location is interpreted as a different object than intended.\n\nTop 25 CWE Examples:\n\n- CVE-2021-0352: In RT regmap driver, there is a possible memory corruption due to type confusion. This could lead to local denial of service with System execution privileges needed. User interaction is not needed for exploitation. Product: Android; Versions: Android-10, Android-11; Patch ID: ALPS05453809.\n\n- CVE-2021-21230: Type confusion in V8 in Google Chrome prior to 90.0.4430.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-23954: Using the new logical assignment operators in a JavaScript switch statement could have caused a type confusion, leading to a memory corruption and a potentially exploitable crash. This vulnerability affects Firefox < 85, Thunderbird < 78.7, and Firefox ESR < 78.7.\n\n- CVE-2021-30513: Type confusion in V8 in Google Chrome prior to 90.0.4430.212 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30517: Type confusion in V8 in Google Chrome prior to 90.0.4430.212 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30551: Type confusion in V8 in Google Chrome prior to 91.0.4472.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30561: Type Confusion in V8 in Google Chrome prior to 91.0.4472.164 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30563: Type Confusion in V8 in Google Chrome prior to 91.0.4472.164 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30588: Type confusion in V8 in Google Chrome prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30627: Type confusion in Blink layout in Google Chrome prior to 93.0.4577.82 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-38001: Type confusion in V8 in Google Chrome prior to 95.0.4638.69 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-23443: This affects the package edge.js before 5.3.2. A type confusion vulnerability can be used to bypass input sanitization when the input to be rendered is an array (instead of a string or a SafeValue), even if {{ }} are used.\n\n- CVE-2021-23447: This affects the package teddy before 0.5.9. A type confusion vulnerability can be used to bypass input sanitization when the model content is an array (instead of a string).\n\n- CVE-2021-32696: The npm package \"striptags\" is an implementation of PHP's strip_tags in Typescript. In striptags before version 3.2.0, a type-confusion vulnerability can cause `striptags` to concatenate unsanitized strings when an array-like object is passed in as the `html` parameter. This can be abused by an attacker who can control the shape of their input, e.g. if query parameters are passed directly into the function. This can lead to a XSS.\n\n- CVE-2021-23807: This affects the package jsonpointer before 5.0.0. A type confusion vulnerability can lead to a bypass of a previous Prototype Pollution fix when the pointer components are arrays.\n\n- CVE-2020-16103: Type confusion in Gallagher Command Centre Server allows a remote attacker to crash the server or possibly cause remote code execution. This issue affects: Gallagher Command Centre 8.30 versions prior to 8.30.1236(MR1); 8.20 versions prior to 8.20.1166(MR3); 8.10 versions prior to 8.10.1211(MR5); version 8.00 and prior versions.\n\n- CVE-2020-7081: A type confusion vulnerability in the Autodesk FBX-SDK versions 2019.0 and earlier may lead to arbitary code read/write on the system running it.\n\n- CVE-2021-26600: ImpressCMS before 1.4.3 has plugins/preloads/autologin.php type confusion with resultant Authentication Bypass (!= instead of !==).\n\n- CVE-2020-16009: Inappropriate implementation in V8 in Google Chrome prior to 86.0.4240.183 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2020-27932: A type confusion issue was addressed with improved state handling. This issue is fixed in macOS Big Sur 11.0.1, watchOS 7.1, iOS 12.4.9, watchOS 6.2.9, Security Update 2020-006 High Sierra, Security Update 2020-006 Mojave, iOS 14.2 and iPadOS 14.2, watchOS 5.3.9, macOS Catalina 10.15.7 Supplemental Update, macOS Catalina 10.15.7 Update. A malicious application may be able to execute arbitrary code with kernel privileges.\n\n- CVE-2020-6418: Type confusion in V8 in Google Chrome prior to 80.0.3987.122 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-1789: A type confusion issue was addressed with improved state handling. This issue is fixed in macOS Big Sur 11.2, Security Update 2021-001 Catalina, Security Update 2021-001 Mojave, tvOS 14.4, watchOS 7.3, iOS 14.4 and iPadOS 14.4, Safari 14.0.3. Processing maliciously crafted web content may lead to arbitrary code execution.\n\n- CVE-2021-21224: Type confusion in V8 in Google Chrome prior to 90.0.4430.85 allowed a remote attacker to execute arbitrary code inside a sandbox via a crafted HTML page.\n\n- CVE-2021-30869: A type confusion issue was addressed with improved state handling. This issue is fixed in iOS 12.5.5, iOS 14.4 and iPadOS 14.4, macOS Big Sur 11.2, Security Update 2021-001 Catalina, Security Update 2021-001 Mojave, Security Update 2021-006 Catalina. A malicious application may be able to execute arbitrary code with kernel privileges. Apple is aware of reports that an exploit for this issue exists in the wild.\n\n- CVE-2021-26635: In the code that verifies the file size in the ark library, it is possible to manipulate the offset read from the target file due to the wrong use of the data type. An attacker could use this vulnerability to cause a stack buffer overflow and as a result, perform an attack such as remote code execution.\n\n- CVE-2021-38007: Type confusion in V8 in Google Chrome prior to 96.0.4664.45 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-38012: Type confusion in V8 in Google Chrome prior to 96.0.4664.45 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4056: Type confusion in loader in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4061: Type confusion in V8 in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4078: Type confusion in V8 in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0102: Type confusion in V8 in Google Chrome prior to 97.0.4692.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0457: Type confusion in V8 in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0795: Type confusion in Blink Layout in Google Chrome prior to 99.0.4844.51 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1096: Type confusion in V8 in Google Chrome prior to 99.0.4844.84 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1134: Type confusion in V8 in Google Chrome prior to 100.0.4896.60 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1232: Type confusion in V8 in Google Chrome prior to 100.0.4896.75 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1314: Type confusion in V8 in Google Chrome prior to 100.0.4896.88 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1364: Type confusion in V8 Turbofan in Google Chrome prior to 100.0.4896.127 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1869: Type Confusion in V8 in Google Chrome prior to 102.0.5005.61 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-20461: In pinReplyNative of com_android_bluetooth_btservice_AdapterService.cpp, there is a possible out of bounds read due to type confusion. This could lead to local escalation of privilege of BLE with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-228602963\n\n- CVE-2022-26433: In mailbox, there is a possible out of bounds write due to type confusion. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07138400; Issue ID: ALPS07138400.\n\n- CVE-2022-3315: Type confusion in Blink in Google Chrome prior to 106.0.5249.62 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: Low)\n\n- CVE-2022-3889: Type confusion in V8 in Google Chrome prior to 107.0.5304.106 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4174: Type confusion in V8 in Google Chrome prior to 108.0.5359.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-25721: Memory corruption in video driver due to type confusion error during video playback\n\n- CVE-2022-2295: Type confusion in V8 in Google Chrome prior to 103.0.5060.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-34918: An issue was discovered in the Linux kernel through 5.18.9. A type confusion bug in nft_set_elem_init (leading to a buffer overflow) could be used by a local attacker to escalate privileges, a different vulnerability than CVE-2022-32250. (The attacker can obtain root access, but must start with an unprivileged user namespace to obtain CAP_NET_ADMIN access.) This can be fixed in nft_setelem_parse_data in net/netfilter/nf_tables_api.c.\n\n- CVE-2022-3652: Type confusion in V8 in Google Chrome prior to 107.0.5304.62 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-23583: Tensorflow is an Open Source Machine Learning Framework. A malicious user can cause a denial of service by altering a `SavedModel` such that any binary op would trigger `CHECK` failures. This occurs when the protobuf part corresponding to the tensor arguments is modified such that the `dtype` no longer matches the `dtype` expected by the op. In that case, calling the templated binary operator for the binary op would receive corrupted data, due to the type confusion involved. If `Tin` and `Tout` don't match the type of data in `out` and `input_*` tensors then `flat<*>` would interpret it wrongly. In most cases, this would be a silent failure, but we have noticed scenarios where this results in a `CHECK` crash, hence a denial of service. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.\n\n- CVE-2022-3723: Type confusion in V8 in Google Chrome prior to 107.0.5304.87 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4262: Type confusion in V8 in Google Chrome prior to 108.0.5359.94 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-41033: Windows COM+ Event System Service Elevation of Privilege Vulnerability\n\n- CVE-2022-42856: A type confusion issue was addressed with improved state handling. This issue is fixed in Safari 16.2, tvOS 16.2, macOS Ventura 13.1, iOS 15.7.2 and iPadOS 15.7.2, iOS 16.1.2. Processing maliciously crafted web content may lead to arbitrary code execution. Apple is aware of a report that this issue may have been actively exploited against versions of iOS released before iOS 15.1..\n\n- CVE-2022-21656: Envoy is an open source edge and service proxy, designed for cloud-native applications. The default_validator.cc implementation used to implement the default certificate validation routines has a \"type confusion\" bug when processing subjectAltNames. This processing allows, for example, an rfc822Name or uniformResourceIndicator to be authenticated as a domain name. This confusion allows for the bypassing of nameConstraints, as processed by the underlying OpenSSL/BoringSSL implementation, exposing the possibility of impersonation of arbitrary servers. As a result Envoy will trust upstream certificates that should not be trusted.\n\n- CVE-2021-33624: In kernel/bpf/verifier.c in the Linux kernel before 5.12.13, a branch can be mispredicted (e.g., because of type confusion) and consequently an unprivileged BPF program can read arbitrary memory locations via a side-channel attack, aka CID-9183671af6db.\n\nRelated Weaknesses:\n\n- CWE-704 (ChildOf)\n\n- CWE-704 (ChildOf)\n\n- CWE-119 (CanPrecede)",
          "type": "Base",
          "source": "sparse",
          "search_source": "weakness:memory corruption",
          "sources": [
            "base",
            "weakness"
          ],
          "boost_factor": 2.8,
          "boosted": true,
          "metadata": {
            "source": "sparse",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            }
          }
        },
        {
          "cwe_id": "416",
          "name": "Use After Free",
          "description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
          "score": 60.782740992322296,
          "matched_text": "CWE-416: Use After Free\n\nType: Variant\n\nStatus: Stable\n\nAlternative Terms:\n\nDangling pointer - a pointer that no longer points to valid memory, often after it has been freed\nUAF - commonly used acronym for Use After Free\nUse-After-Free\n\nDangling pointer - a pointer that no longer points to valid memory, often after it has been freed\nUAF - commonly used acronym for Use After Free\nUse-After-Free\n\nDangling pointer - a pointer that no longer points to valid memory, often after it has been freed\nUAF - commonly used acronym for Use After Free\nUse-After-Free\n\nDescription:\n\nThe product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.\n\nReal-World Examples:\n\n- CVE-2022-20141: Chain: an operating system kernel has insufficent resource locking (CWE-413) leading to a use after free (CWE-416).\n\n- CVE-2022-2621: Chain: two threads in a web browser use the same resource (CWE-366), but one of those threads can destroy the resource before the other has completed (CWE-416).\n\n- CVE-2021-0920: Chain: mobile platform race condition (CWE-362) leading to use-after-free (CWE-416), as exploited in the wild per CISA KEV.\n\n- CVE-2020-6819: Chain: race condition (CWE-362) leads to use-after-free (CWE-416), as exploited in the wild per CISA KEV.\n\n- CVE-2010-4168: Use-after-free triggered by closing a connection while data is still being transmitted.\n\n- CVE-2010-2941: Improper allocation for invalid data leads to use-after-free.\n\n- CVE-2010-2547: certificate with a large number of Subject Alternate Names not properly handled in realloc, leading to use-after-free\n\n- CVE-2010-1772: Timers are not disabled when a related object is deleted\n\n- CVE-2010-1437: Access to a \"dead\" object that is being cleaned up\n\n- CVE-2010-1208: object is deleted even with a non-zero reference count, and later accessed\n\n- CVE-2010-0629: use-after-free involving request containing an invalid version number\n\n- CVE-2010-0378: unload of an object that is currently being accessed by other functionality\n\n- CVE-2010-0302: incorrectly tracking a reference count leads to use-after-free\n\n- CVE-2010-0249: use-after-free related to use of uninitialized memory\n\n- CVE-2010-0050: HTML document with incorrectly-nested tags\n\n- CVE-2009-3658: Use after free in ActiveX object by providing a malformed argument to a method\n\n- CVE-2009-3616: use-after-free by disconnecting during data transfer, or a message containing incorrect data types\n\n- CVE-2009-3553: disconnect during a large data transfer causes incorrect reference count, leading to use-after-free\n\n- CVE-2009-2416: use-after-free found by fuzzing\n\n- CVE-2009-1837: Chain: race condition (CWE-362) from improper handling of a page transition in web client while an applet is loading (CWE-368) leads to use after free (CWE-416)\n\n- CVE-2009-0749: realloc generates new buffer and pointer, but previous pointer is still retained, leading to use after free\n\n- CVE-2010-3328: Use-after-free in web browser, probably resultant from not initializing memory.\n\n- CVE-2008-5038: use-after-free when one thread accessed memory that was freed by another thread\n\n- CVE-2008-0077: assignment of malformed values to certain properties triggers use after free\n\n- CVE-2006-4434: mail server does not properly handle a long header.\n\n- CVE-2010-2753: chain: integer overflow leads to use-after-free\n\n- CVE-2006-4997: freed pointer dereference\n\nTop 25 CWE Examples:\n\n- CVE-2021-0310: In LazyServiceRegistrar of LazyServiceRegistrar.cpp, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android; Versions: Android-11; Android ID: A-170212632.\n\n- CVE-2021-0332: In bootFinished of SurfaceFlinger.cpp, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with User execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11 Android-10Android ID: A-169256435\n\n- CVE-2021-0335: In process of C2SoftHevcDec.cpp, there is a possible out of bounds write due to a use after free. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-11Android ID: A-160346309\n\n- CVE-2021-0342: In tun_get_user of tun.c, there is possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges required. User interaction is not required for exploitation. Product: Android; Versions: Android kernel; Android ID: A-146554327.\n\n- CVE-2021-0349: In display driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Product: Android; Versions: Android-9, Android-10, Android-11; Patch ID: ALPS05362646.\n\n- CVE-2021-0365: In display driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Product: Android; Versions: Android-10, Android-11; Patch ID: ALPS05454782.\n\n- CVE-2021-0395: In StopServicesAndLogViolations of reboot.cpp, there is possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11Android ID: A-170315126\n\n- CVE-2021-0399: In qtaguid_untag of xt_qtaguid.c, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-176919394References: Upstream kernel\n\n- CVE-2021-0429: In pollOnce of ALooper.cpp, there is possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-9 Android-10 Android-11 Android-8.1Android ID: A-175074139\n\n- CVE-2021-0475: In on_l2cap_data_ind of btif_sock_l2cap.cc, there is possible memory corruption due to a use after free. This could lead to remote code execution over Bluetooth with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11 Android-10Android ID: A-175686168\n\n- CVE-2021-0482: In BinderDiedCallback of MediaCodec.cpp, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11Android ID: A-173791720\n\n- CVE-2021-0496: In memory management driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-183467912\n\n- CVE-2021-0497: In memory management driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-183461320\n\n- CVE-2021-0527: In memory management driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-185193931\n\n- CVE-2021-0531: In memory management driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-185195272\n\n- CVE-2021-0535: In wpas_ctrl_msg_queue_timeout of ctrl_iface_unix.c, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11Android ID: A-168314741\n\n- CVE-2021-0611: In m4u, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05403499; Issue ID: ALPS05425810.\n\n- CVE-2021-0612: In m4u, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05403499; Issue ID: ALPS05425834.\n\n- CVE-2021-0629: In mdlactl driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05776625; Issue ID: ALPS05776625.\n\n- CVE-2021-0656: In edma driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05709376; Issue ID: ALPS05709376.\n\n- CVE-2021-0664: In ccu, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05827158; Issue ID: ALPS05827158.\n\n- CVE-2021-0667: In apusys, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05670581; Issue ID: ALPS05670581.\n\n- CVE-2021-0669: In apusys, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05681550; Issue ID: ALPS05681550.\n\n- CVE-2021-0670: In apusys, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05654663; Issue ID: ALPS05654663.\n\n- CVE-2021-0684: In TouchInputMapper::sync of TouchInputMapper.cpp, there is a possible out of bounds write due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-8.1 Android-9Android ID: A-179839665\n\n- CVE-2021-0695: In get_sock_stat of xt_qtaguid.c, there is a possible out of bounds read due to a use after free. This could lead to local information disclosure with User execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-184018316References: Upstream kernel\n\n- CVE-2021-0936: In acc_read of f_accessory.c, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-173789633References: Upstream kernel\n\n- CVE-2021-20204: A heap memory corruption problem (use after free) can be triggered in libgetdata v0.10.0 when processing maliciously crafted dirfile databases. This degrades the confidentiality, integrity and availability of third-party software that uses libgetdata as a library. This vulnerability may lead to arbitrary code execution or privilege escalation depending on input/skills of attacker.\n\n- CVE-2021-20231: A flaw was found in gnutls. A use after free issue in client sending key_share extension may lead to memory corruption and other consequences.\n\n- CVE-2021-20232: A flaw was found in gnutls. A use after free issue in client_send_params in lib/ext/pre_shared_key.c may lead to memory corruption and other potential consequences.\n\n- CVE-2021-21112: Use after free in Blink in Google Chrome prior to 87.0.4280.141 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21114: Use after free in audio in Google Chrome prior to 87.0.4280.141 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21119: Use after free in Media in Google Chrome prior to 88.0.4324.96 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21120: Use after free in WebSQL in Google Chrome prior to 88.0.4324.96 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21122: Use after free in Blink in Google Chrome prior to 88.0.4324.96 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21145: Use after free in Fonts in Google Chrome prior to 88.0.4324.146 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21157: Use after free in Web Sockets in Google Chrome on Linux prior to 88.0.4324.182 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21159: Heap buffer overflow in TabStrip in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21162: Use after free in WebRTC in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21167: Use after free in bookmarks in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21179: Use after free in Network Internals in Google Chrome on Linux prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21180: Use after free in tab search in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21188: Use after free in Blink in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21191: Use after free in WebRTC in Google Chrome prior to 89.0.4389.90 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21193: Use after free in Blink in Google Chrome prior to 89.0.4389.90 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21194: Use after free in screen sharing in Google Chrome prior to 89.0.4389.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21195: Use after free in V8 in Google Chrome prior to 89.0.4389.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21199: Use after free in Aura in Google Chrome on Linux prior to 89.0.4389.114 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21203: Use after free in Blink in Google Chrome prior to 90.0.4430.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21204: Use after free in Blink in Google Chrome on OS X prior to 90.0.4430.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21206: Use after free in Blink in Google Chrome prior to 89.0.4389.128 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21213: Use after free in WebMIDI in Google Chrome prior to 90.0.4430.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21214: Use after free in Network API in Google Chrome prior to 90.0.4430.72 allowed a remote attacker to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2021-21232: Use after free in Dev Tools in Google Chrome prior to 90.0.4430.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21775: A use-after-free vulnerability exists in the way certain events are processed for ImageLoader objects of Webkit WebKitGTK 2.30.4. A specially crafted web page can lead to a potential information leak and further memory corruption. In order to trigger the vulnerability, a victim must be tricked into visiting a malicious webpage.\n\n- CVE-2021-21779: A use-after-free vulnerability exists in the way Webkit\u2019s GraphicsContext handles certain events in WebKitGTK 2.30.4. A specially crafted web page can lead to a potential information leak and further memory corruption. A victim must be tricked into visiting a malicious web page to trigger this vulnerability.\n\n- CVE-2021-22543: An issue was discovered in Linux: KVM through Improper handling of VM_IO|VM_PFNMAP vmas in KVM can bypass RO checks and can lead to pages being freed while still accessible by the VMM and guest. This allows users with the ability to start and control a VM to read/write random pages of memory and can result in local privilege escalation.\n\n- CVE-2021-22930: Node.js before 16.6.0, 14.17.4, and 12.22.4 is vulnerable to a use after free attack where an attacker might be able to exploit the memory corruption, to change process behavior.\n\n- CVE-2021-22940: Node.js before 16.6.1, 14.17.5, and 12.22.5 is vulnerable to a use after free attack where an attacker might be able to exploit the memory corruption, to change process behavior.\n\n- CVE-2021-28702: PCI devices with RMRRs not deassigned correctly Certain PCI devices in a system might be assigned Reserved Memory Regions (specified via Reserved Memory Region Reporting, \"RMRR\"). These are typically used for platform tasks such as legacy USB emulation. If such a device is passed through to a guest, then on guest shutdown the device is not properly deassigned. The IOMMU configuration for these devices which are not properly deassigned ends up pointing to a freed data structure, including the IO Pagetables. Subsequent DMA or interrupts from the device will have unpredictable behaviour, ranging from IOMMU faults to memory corruption.\n\n- CVE-2021-29970: A malicious webpage could have triggered a use-after-free, memory corruption, and a potentially exploitable crash. *This bug could only be triggered when accessibility was enabled.*. This vulnerability affects Thunderbird < 78.12, Firefox ESR < 78.12, and Firefox < 90.\n\n- CVE-2021-29985: A use-after-free vulnerability in media channels could have led to memory corruption and a potentially exploitable crash. This vulnerability affects Thunderbird < 78.13, Thunderbird < 91, Firefox ESR < 78.13, and Firefox < 91.\n\n- CVE-2021-30510: Use after free in Aura in Google Chrome prior to 90.0.4430.212 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30512: Use after free in Notifications in Google Chrome prior to 90.0.4430.212 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30514: Use after free in Autofill in Google Chrome prior to 90.0.4430.212 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30515: Use after free in File API in Google Chrome prior to 90.0.4430.212 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30519: Use after free in Payments in Google Chrome prior to 90.0.4430.212 allowed an attacker who convinced a user to install a malicious payments app to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30520: Use after free in Tab Strip in Google Chrome prior to 90.0.4430.212 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30522: Use after free in WebAudio in Google Chrome prior to 91.0.4472.77 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30523: Use after free in WebRTC in Google Chrome prior to 91.0.4472.77 allowed a remote attacker to potentially exploit heap corruption via a crafted SCTP packet.\n\n- CVE-2021-30524: Use after free in TabStrip in Google Chrome prior to 91.0.4472.77 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30525: Use after free in TabGroups in Google Chrome prior to 91.0.4472.77 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30527: Use after free in WebUI in Google Chrome prior to 91.0.4472.77 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30528: Use after free in WebAuthentication in Google Chrome on Android prior to 91.0.4472.77 allowed a remote attacker who had compromised the renderer process of a user who had saved a credit card in their Google account to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30529: Use after free in Bookmarks in Google Chrome prior to 91.0.4472.77 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30541: Use after free in V8 in Google Chrome prior to 91.0.4472.164 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30542: Use after free in Tab Strip in Google Chrome prior to 91.0.4472.77 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30543: Use after free in Tab Strip in Google Chrome prior to 91.0.4472.77 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30544: Use after free in BFCache in Google Chrome prior to 91.0.4472.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30545: Use after free in Extensions in Google Chrome prior to 91.0.4472.101 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30546: Use after free in Autofill in Google Chrome prior to 91.0.4472.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30548: Use after free in Loader in Google Chrome prior to 91.0.4472.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30549: Use after free in Spell check in Google Chrome prior to 91.0.4472.101 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30550: Use after free in Accessibility in Google Chrome prior to 91.0.4472.101 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30552: Use after free in Extensions in Google Chrome prior to 91.0.4472.101 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30553: Use after free in Network service in Google Chrome prior to 91.0.4472.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30554: Use after free in WebGL in Google Chrome prior to 91.0.4472.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30555: Use after free in Sharing in Google Chrome prior to 91.0.4472.114 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page and user gesture.\n\n- CVE-2021-30556: Use after free in WebAudio in Google Chrome prior to 91.0.4472.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30557: Use after free in TabGroups in Google Chrome prior to 91.0.4472.114 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30560: Use after free in Blink XSLT in Google Chrome prior to 91.0.4472.164 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30562: Use after free in WebSerial in Google Chrome prior to 91.0.4472.164 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30567: Use after free in DevTools in Google Chrome prior to 92.0.4515.107 allowed an attacker who convinced a user to open DevTools to potentially exploit heap corruption via specific user gesture.\n\n- CVE-2021-30569: Use after free in sqlite in Google Chrome prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30572: Use after free in Autofill in Google Chrome prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30573: Use after free in GPU in Google Chrome prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30574: Use after free in protocol handling in Google Chrome prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30576: Use after free in DevTools in Google Chrome prior to 92.0.4515.107 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30579: Use after free in UI framework in Google Chrome prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30581: Use after free in DevTools in Google Chrome prior to 92.0.4515.107 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30585: Use after free in sensor handling in Google Chrome on Windows prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30586: Use after free in dialog box handling in Windows in Google Chrome prior to 92.0.4515.107 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30591: Use after free in File System API in Google Chrome prior to 92.0.4515.131 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30594: Use after free in Page Info UI in Google Chrome prior to 92.0.4515.131 allowed a remote attacker to potentially exploit heap corruption via physical access to the device.\n\n- CVE-2021-30597: Use after free in Browser UI in Google Chrome on Chrome prior to 92.0.4515.131 allowed a remote attacker to potentially exploit heap corruption via physical access to the device.\n\n- CVE-2021-30600: Use after free in Printing in Google Chrome prior to 92.0.4515.159 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30601: Use after free in Extensions API in Google Chrome prior to 92.0.4515.159 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30602: Use after free in WebRTC in Google Chrome prior to 92.0.4515.159 allowed an attacker who convinced a user to visit a malicious website to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30604: Use after free in ANGLE in Google Chrome prior to 92.0.4515.159 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30625: Use after free in Selection API in Google Chrome prior to 93.0.4577.82 allowed a remote attacker who convinced the user the visit a malicious website to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30629: Use after free in Permissions in Google Chrome prior to 93.0.4577.82 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37956: Use after free in Offline use in Google Chrome on Android prior to 94.0.4606.54 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37957: Use after free in WebGPU in Google Chrome prior to 94.0.4606.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37959: Use after free in Task Manager in Google Chrome prior to 94.0.4606.54 allowed an attacker who convinced a user to enage in a series of user gestures to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37961: Use after free in Tab Strip in Google Chrome prior to 94.0.4606.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37962: Use after free in Performance Manager in Google Chrome prior to 94.0.4606.54 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37970: Use after free in File System API in Google Chrome prior to 94.0.4606.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37974: Use after free in Safebrowsing in Google Chrome prior to 94.0.4606.71 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37975: Use after free in V8 in Google Chrome prior to 94.0.4606.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37977: Use after free in Garbage Collection in Google Chrome prior to 94.0.4606.81 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37982: Use after free in Incognito in Google Chrome prior to 95.0.4638.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37983: Use after free in Dev Tools in Google Chrome prior to 95.0.4638.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37985: Use after free in V8 in Google Chrome prior to 95.0.4638.54 allowed a remote attacker who had convinced a user to allow for connection to debugger to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37987: Use after free in Network APIs in Google Chrome prior to 95.0.4638.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37988: Use after free in Profiles in Google Chrome prior to 95.0.4638.54 allowed a remote attacker who convinced a user to engage in specific gestures to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37993: Use after free in PDF Accessibility in Google Chrome prior to 95.0.4638.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37997: Use after free in Sign-In in Google Chrome prior to 95.0.4638.69 allowed a remote attacker who convinced a user to sign into Chrome to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37998: Use after free in Garbage Collection in Google Chrome prior to 95.0.4638.69 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-38496: During operations on MessageTasks, a task may have been removed while it was still scheduled, resulting in memory corruption and a potentially exploitable crash. This vulnerability affects Thunderbird < 78.15, Thunderbird < 91.2, Firefox ESR < 91.2, Firefox ESR < 78.15, and Firefox < 93.\n\n- CVE-2021-38498: During process shutdown, a document could have caused a use-after-free of a languages service object, leading to memory corruption and a potentially exploitable crash. This vulnerability affects Firefox < 93, Thunderbird < 91.2, and Firefox ESR < 91.2.\n\n- CVE-2021-43057: An issue was discovered in the Linux kernel before 5.14.8. A use-after-free in selinux_ptrace_traceme (aka the SELinux handler for PTRACE_TRACEME) could be used by local attackers to cause memory corruption and escalate privileges, aka CID-a3727a8bac0a. This occurs because of an attempt to access the subjective credentials of another task.\n\n- CVE-2021-43790: Lucet is a native WebAssembly compiler and runtime. There is a bug in the main branch of `lucet-runtime` affecting all versions published to crates.io that allows a use-after-free in an Instance object that could result in memory corruption, data race, or other related issues. This bug was introduced early in the development of Lucet and is present in all releases. As a result of this bug, and dependent on the memory backing for the Instance objects, it is possible to trigger a use-after-free when the Instance is dropped. Users should upgrade to the main branch of the Lucet repository. Lucet no longer provides versioned releases on crates.io. There is no way to remediate this vulnerability without upgrading.\n\n- CVE-2021-44047: A use-after-free vulnerability exists when reading a DWF/DWFX file using Open Design Alliance Drawings SDK before 2022.11. The specific issue exists with parsing DWF/DWFX files. Crafted data in a DWF/DWFX file and lack of proper validation of input data can trigger a write operation past the end of an allocated buffer. An attacker can leverage this vulnerability to execute code in the context of the current process.\n\n- CVE-2021-1651: Diagnostics Hub Standard Collector Elevation of Privilege Vulnerability\n\n- CVE-2021-26900: Windows Win32k Elevation of Privilege Vulnerability\n\n- CVE-2021-31170: Windows Graphics Component Elevation of Privilege Vulnerability\n\n- CVE-2021-31188: Windows Graphics Component Elevation of Privilege Vulnerability\n\n- CVE-2021-34486: Windows Event Tracing Elevation of Privilege Vulnerability\n\n- CVE-2021-40449: Win32k Elevation of Privilege Vulnerability\n\n- CVE-2021-40125: A vulnerability in the Internet Key Exchange Version 2 (IKEv2) implementation of Cisco Adaptive Security Appliance (ASA) Software and Cisco Firepower Threat Defense (FTD) Software could allow an authenticated, remote attacker to trigger a denial of service (DoS) condition on an affected device. This vulnerability is due to improper control of a resource. An attacker with the ability to spoof a trusted IKEv2 site-to-site VPN peer and in possession of valid IKEv2 credentials for that peer could exploit this vulnerability by sending malformed, authenticated IKEv2 messages to an affected device. A successful exploit could allow the attacker to trigger a reload of the device.\n\n- CVE-2021-34498: Windows GDI Elevation of Privilege Vulnerability\n\n- CVE-2021-22893: Pulse Connect Secure 9.0R3/9.1R1 and higher is vulnerable to an authentication bypass vulnerability exposed by the Windows File Share Browser and Pulse Secure Collaboration features of Pulse Connect Secure that can allow an unauthenticated user to perform remote arbitrary code execution on the Pulse Connect Secure gateway. This vulnerability has been exploited in the wild.\n\n- CVE-2021-22348: There is a Memory Buffer Improper Operation Limit Vulnerability in Huawei Smartphone. Successful exploitation of this vulnerability may cause code to execute.\n\n- CVE-2021-22350: There is a Memory Buffer Improper Operation Limit Vulnerability in Huawei Smartphone. Successful exploitation of this vulnerability may cause the device to crash and restart.\n\n- CVE-2021-22353: There is a Memory Buffer Improper Operation Limit Vulnerability in Huawei Smartphone. Successful exploitation of this vulnerability may cause the kernel to restart.\n\n- CVE-2021-22390: There is a Memory Buffer Improper Operation Limit Vulnerability in Huawei Smartphone.Successful exploitation of this vulnerability may cause certain codes to be executed.\n\n- CVE-2020-24349: njs through 0.4.3, used in NGINX, allows control-flow hijack in njs_value_property in njs_value.c. NOTE: the vendor considers the issue to be \"fluff\" in the NGINX use case because there is no remote attack surface.\n\n- CVE-2021-37045: There is an UAF vulnerability in Huawei Smartphone.Successful exploitation of this vulnerability may cause the device to restart unexpectedly and the kernel-mode code to be executed.\n\n- CVE-2021-39803: In ~Impl of C2AllocatorIon.cpp, there is a possible out of bounds read due to a use after free. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12LAndroid ID: A-193790350\n\n- CVE-2021-42612: A use after free in cleanup_index in index.c in Halibut 1.2 allows an attacker to cause a segmentation fault or possibly have other unspecified impact via a crafted text document.\n\n- CVE-2021-42614: A use after free in info_width_internal in bk_info.c in Halibut 1.2 allows an attacker to cause a segmentation fault or possibly have unspecified other impact via a crafted text document.\n\n- CVE-2020-0674: A remote code execution vulnerability exists in the way that the scripting engine handles objects in memory in Internet Explorer, aka 'Scripting Engine Memory Corruption Vulnerability'. This CVE ID is unique from CVE-2020-0673, CVE-2020-0710, CVE-2020-0711, CVE-2020-0712, CVE-2020-0713, CVE-2020-0767.\n\n- CVE-2020-16017: Use after free in site isolation in Google Chrome prior to 86.0.4240.198 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2020-3992: OpenSLP as used in VMware ESXi (7.0 before ESXi_7.0.1-0.0.16850804, 6.7 before ESXi670-202010401-SG, 6.5 before ESXi650-202010401-SG) has a use-after-free issue. A malicious actor residing in the management network who has access to port 427 on an ESXi machine may be able to trigger a use-after-free in the OpenSLP service resulting in remote code execution.\n\n- CVE-2020-6572: Use after free in Media in Google Chrome prior to 81.0.4044.92 allowed a remote attacker to execute arbitrary code via a crafted HTML page.\n\n- CVE-2021-1048: In ep_loop_check_proc of eventpoll.c, there is a possible way to corrupt memory due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-204573007References: Upstream kernel\n\n- CVE-2021-1905: Possible use after free due to improper handling of memory mapping of multiple processes simultaneously. in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2021-28550: Acrobat Reader DC versions versions 2021.001.20150 (and earlier), 2020.001.30020 (and earlier) and 2017.011.30194 (and earlier) are affected by a Use After Free vulnerability. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-28663: The Arm Mali GPU kernel driver allows privilege escalation or information disclosure because GPU memory operations are mishandled, leading to a use-after-free. This affects Bifrost r0p0 through r28p0 before r29p0, Valhall r19p0 through r28p0 before r29p0, and Midgard r4p0 through r30p0.\n\n- CVE-2021-30633: Use after free in Indexed DB API in Google Chrome prior to 93.0.4577.82 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2021-30661: A use after free issue was addressed with improved memory management. This issue is fixed in Safari 14.1, iOS 12.5.3, iOS 14.5 and iPadOS 14.5, watchOS 7.4, tvOS 14.5, macOS Big Sur 11.3. Processing maliciously crafted web content may lead to arbitrary code execution. Apple is aware of a report that this issue may have been actively exploited..\n\n- CVE-2021-30762: A use after free issue was addressed with improved memory management. This issue is fixed in iOS 12.5.4. Processing maliciously crafted web content may lead to arbitrary code execution. Apple is aware of a report that this issue may have been actively exploited..\n\n- CVE-2021-30858: A use after free issue was addressed with improved memory management. This issue is fixed in iOS 14.8 and iPadOS 14.8, macOS Big Sur 11.6. Processing maliciously crafted web content may lead to arbitrary code execution. Apple is aware of a report that this issue may have been actively exploited.\n\n- CVE-2021-31166: HTTP Protocol Stack Remote Code Execution Vulnerability\n\n- CVE-2021-37973: Use after free in Portals in Google Chrome prior to 94.0.4606.61 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2021-35120: Improper handling between export and release functions on the same handle from client can lead to use after free in Snapdragon Compute, Snapdragon Connectivity, Snapdragon Industrial IOT, Snapdragon Mobile\n\n- CVE-2021-3700: A use-after-free vulnerability was found in usbredir in versions prior to 0.11.0 in the usbredirparser_serialize() in usbredirparser/usbredirparser.c. This issue occurs when serializing large amounts of buffered write data in the case of a slow or blocked destination.\n\n- CVE-2021-38005: Use after free in loader in Google Chrome prior to 96.0.4664.45 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-38006: Use after free in storage foundation in Google Chrome prior to 96.0.4664.45 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-38008: Use after free in media in Google Chrome prior to 96.0.4664.45 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-38011: Use after free in storage foundation in Google Chrome prior to 96.0.4664.45 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-39812: In TBD of TBD, there is a possible out of bounds read due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-205522359References: N/A\n\n- CVE-2021-4052: Use after free in web apps in Google Chrome prior to 96.0.4664.93 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2021-4053: Use after free in UI in Google Chrome on Linux prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4057: Use after free in file API in Google Chrome prior to 96.0.4664.93 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4063: Use after free in developer tools in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4064: Use after free in screen capture in Google Chrome on ChromeOS prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4065: Use after free in autofill in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4067: Use after free in window manager in Google Chrome on ChromeOS prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4099: Use after free in Swiftshader in Google Chrome prior to 96.0.4664.110 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4102: Use after free in V8 in Google Chrome prior to 96.0.4664.110 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0096: Use after free in Storage in Google Chrome prior to 97.0.4692.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0098: Use after free in Screen Capture in Google Chrome on Chrome OS prior to 97.0.4692.71 allowed an attacker who convinced a user to perform specific user gestures to potentially exploit heap corruption via specific user gestures.\n\n- CVE-2022-0099: Use after free in Sign-in in Google Chrome prior to 97.0.4692.71 allowed a remote attacker who convinced a user to perform specific user gestures to potentially exploit heap corruption via specific user gesture.\n\n- CVE-2022-0103: Use after free in SwiftShader in Google Chrome prior to 97.0.4692.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0105: Use after free in PDF Accessibility in Google Chrome prior to 97.0.4692.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0106: Use after free in Autofill in Google Chrome prior to 97.0.4692.71 allowed a remote attacker who convinced a user to perform specific user gesture to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0107: Use after free in File Manager API in Google Chrome on Chrome OS prior to 97.0.4692.71 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0289: Use after free in Safe browsing in Google Chrome prior to 97.0.4692.99 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0293: Use after free in Web packaging in Google Chrome prior to 97.0.4692.99 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0295: Use after free in Omnibox in Google Chrome prior to 97.0.4692.99 allowed a remote attacker who convinced the user to engage is specific user interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0296: Use after free in Printing in Google Chrome prior to 97.0.4692.99 allowed a remote attacker who convinced the user to engage is specific user interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0297: Use after free in Vulkan in Google Chrome prior to 97.0.4692.99 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0298: Use after free in Scheduling in Google Chrome prior to 97.0.4692.99 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0300: Use after free in Text Input Method Editor in Google Chrome on Android prior to 97.0.4692.99 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0301: Heap buffer overflow in DevTools in Google Chrome prior to 97.0.4692.99 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0302: Use after free in Omnibox in Google Chrome prior to 97.0.4692.99 allowed an attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0304: Use after free in Bookmarks in Google Chrome prior to 97.0.4692.99 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0307: Use after free in Optimization Guide in Google Chrome prior to 97.0.4692.99 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0308: Use after free in Data Transfer in Google Chrome on Chrome OS prior to 97.0.4692.99 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0453: Use after free in Reader Mode in Google Chrome prior to 98.0.4758.80 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0456: Use after free in Web Search in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via profile destruction.\n\n- CVE-2022-0458: Use after free in Thumbnail Tab Strip in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0459: Use after free in Screen Capture in Google Chrome prior to 98.0.4758.80 allowed a remote attacker who had compromised the renderer process and convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0460: Use after free in Window Dialogue in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0463: Use after free in Accessibility in Google Chrome prior to 98.0.4758.80 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via user interaction.\n\n- CVE-2022-0464: Use after free in Accessibility in Google Chrome prior to 98.0.4758.80 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via user interaction.\n\n- CVE-2022-0465: Use after free in Extensions in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via user interaction.\n\n- CVE-2022-0468: Use after free in Payments in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0469: Use after free in Cast in Google Chrome prior to 98.0.4758.80 allowed a remote attacker who convinced a user to engage in specific interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0603: Use after free in File Manager in Google Chrome on Chrome OS prior to 98.0.4758.102 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0605: Use after free in Webstore API in Google Chrome prior to 98.0.4758.102 allowed an attacker who convinced a user to install a malicious extension and convinced a user to enage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0606: Use after free in ANGLE in Google Chrome prior to 98.0.4758.102 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0607: Use after free in GPU in Google Chrome prior to 98.0.4758.102 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0609: Use after free in Animation in Google Chrome prior to 98.0.4758.102 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0646: A flaw use after free in the Linux kernel Management Component Transport Protocol (MCTP) subsystem was found in the way user triggers cancel_work_sync after the unregister_netdev during removing device. A local user could use this flaw to crash the system or escalate their privileges on the system. It is actual from Linux Kernel 5.17-rc1 (when mctp-serial.c introduced) till 5.17-rc5.\n\n- CVE-2022-0791: Use after free in Omnibox in Google Chrome prior to 99.0.4844.51 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via user interactions.\n\n- CVE-2022-0793: Use after free in Cast in Google Chrome prior to 99.0.4844.51 allowed an attacker who convinced a user to install a malicious extension and engage in specific user interaction to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2022-0794: Use after free in WebShare in Google Chrome prior to 99.0.4844.51 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0796: Use after free in Media in Google Chrome prior to 99.0.4844.51 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0798: Use after free in MediaStream in Google Chrome prior to 99.0.4844.51 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2022-0805: Use after free in Browser Switcher in Google Chrome prior to 99.0.4844.51 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via user interaction.\n\n- CVE-2022-0808: Use after free in Chrome OS Shell in Google Chrome on Chrome OS prior to 99.0.4844.51 allowed a remote attacker who convinced a user to engage in a series of user interaction to potentially exploit heap corruption via user interactions.\n\n- CVE-2022-0971: Use after free in Blink Layout in Google Chrome on Android prior to 99.0.4844.74 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0972: Use after free in Extensions in Google Chrome prior to 99.0.4844.74 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0973: Use after free in Safe Browsing in Google Chrome prior to 99.0.4844.74 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0974: Use after free in Splitscreen in Google Chrome on Chrome OS prior to 99.0.4844.74 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0975: Use after free in ANGLE in Google Chrome prior to 99.0.4844.74 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0977: Use after free in Browser UI in Google Chrome on Chrome OS prior to 99.0.4844.74 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0978: Use after free in ANGLE in Google Chrome prior to 99.0.4844.74 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0979: Use after free in Safe Browsing in Google Chrome on Android prior to 99.0.4844.74 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0980: Use after free in New Tab Page in Google Chrome prior to 99.0.4844.74 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-1125: Use after free in Portals in Google Chrome prior to 100.0.4896.60 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via user interaction.\n\n- CVE-2022-1127: Use after free in QR Code Generator in Google Chrome prior to 100.0.4896.60 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via user interaction.\n\n- CVE-2022-1131: Use after free in Cast UI in Google Chrome prior to 100.0.4896.60 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1133: Use after free in WebRTC Perf in Google Chrome prior to 100.0.4896.60 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1135: Use after free in Shopping Cart in Google Chrome prior to 100.0.4896.60 allowed a remote attacker to potentially exploit heap corruption via standard feature user interaction.\n\n- CVE-2022-1136: Use after free in Tab Strip in Google Chrome prior to 100.0.4896.60 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via specific set of user gestures.\n\n- CVE-2022-1141: Use after free in File Manager in Google Chrome prior to 100.0.4896.60 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via specific user gesture.\n\n- CVE-2022-1144: Use after free in WebUI in Google Chrome prior to 100.0.4896.60 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via specific input into DevTools.\n\n- CVE-2022-1145: Use after free in Extensions in Google Chrome prior to 100.0.4896.60 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via specific user interaction and profile destruction.\n\n- CVE-2022-1305: Use after free in storage in Google Chrome prior to 100.0.4896.88 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1308: Use after free in BFCache in Google Chrome prior to 100.0.4896.88 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1310: Use after free in regular expressions in Google Chrome prior to 100.0.4896.88 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1311: Use after free in shell in Google Chrome on ChromeOS prior to 100.0.4896.88 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1313: Use after free in tab groups in Google Chrome prior to 100.0.4896.88 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1477: Use after free in Vulkan in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1478: Use after free in SwiftShader in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1479: Use after free in ANGLE in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1481: Use after free in Sharing in Google Chrome on Mac prior to 101.0.4951.41 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1485: Use after free in File System API in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1487: Use after free in Ozone in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via running a Wayland test.\n\n- CVE-2022-1490: Use after free in Browser Switcher in Google Chrome prior to 101.0.4951.41 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1491: Use after free in Bookmarks in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via specific and direct user interaction.\n\n- CVE-2022-1493: Use after free in Dev Tools in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via specific and direct user interaction.\n\n- CVE-2022-1496: Use after free in File Manager in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via specific and direct user interaction.\n\n- CVE-2022-1633: Use after free in Sharesheet in Google Chrome on Chrome OS prior to 101.0.4951.64 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-1634: Use after free in Browser UI in Google Chrome prior to 101.0.4951.64 allowed a remote attacker who had convinced a user to engage in specific UI interaction to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-1635: Use after free in Permission Prompts in Google Chrome prior to 101.0.4951.64 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-1636: Use after free in Performance APIs in Google Chrome prior to 101.0.4951.64 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1639: Use after free in ANGLE in Google Chrome prior to 101.0.4951.64 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1640: Use after free in Sharing in Google Chrome prior to 101.0.4951.64 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1641: Use after free in Web UI Diagnostics in Google Chrome on Chrome OS prior to 101.0.4951.64 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via specific user interaction.\n\n- CVE-2022-1734: A flaw in Linux Kernel found in nfcmrvl_nci_unregister_dev() in drivers/nfc/nfcmrvl/main.c can lead to use after free both read or write when non synchronized between cleanup routine and firmware download routine.\n\n- CVE-2022-1854: Use after free in ANGLE in Google Chrome prior to 102.0.5005.61 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1855: Use after free in Messaging in Google Chrome prior to 102.0.5005.61 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1856: Use after free in User Education in Google Chrome prior to 102.0.5005.61 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension or specific user interaction.\n\n- CVE-2022-1859: Use after free in Performance Manager in Google Chrome prior to 102.0.5005.61 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1860: Use after free in UI Foundations in Google Chrome on Chrome OS prior to 102.0.5005.61 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-1861: Use after free in Sharing in Google Chrome on Chrome OS prior to 102.0.5005.61 allowed a remote attacker who convinced a user to enage in specific user interactions to potentially exploit heap corruption via specific user interaction.\n\n- CVE-2022-1863: Use after free in Tab Groups in Google Chrome prior to 102.0.5005.61 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension and specific user interaction.\n\n- CVE-2022-1864: Use after free in WebApp Installs in Google Chrome prior to 102.0.5005.61 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension and specific user interaction.\n\n- CVE-2022-1865: Use after free in Bookmarks in Google Chrome prior to 102.0.5005.61 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension and specific user interaction.\n\n- CVE-2022-1866: Use after free in Tablet Mode in Google Chrome on Chrome OS prior to 102.0.5005.61 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-1870: Use after free in App Service in Google Chrome prior to 102.0.5005.61 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2022-1919: Use after free in Codecs in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2007: Use after free in WebGPU in Google Chrome prior to 102.0.5005.115 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2011: Use after free in ANGLE in Google Chrome prior to 102.0.5005.115 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-20447: In PAN_WriteBuf of pan_api.cc, there is a possible out of bounds read due to a use after free. This could lead to remote information disclosure over Bluetooth with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-233604485\n\n- CVE-2022-20552: In btif_a2dp_sink_command_ready of btif_a2dp_sink.cc, there is a possible out of bounds read due to a use after free. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-243922806\n\n- CVE-2022-20554: In removeEventHubDevice of InputDevice.cpp, there is a possible OOB read due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-245770596\n\n- CVE-2022-20581: In the Pixel camera driver, there is a possible use after free due to a logic error in the code. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-245916120References: N/A\n\n- CVE-2022-2156: Use after free in Core in Google Chrome prior to 103.0.5060.53 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2157: Use after free in Interest groups in Google Chrome prior to 103.0.5060.53 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2158: Type confusion in V8 in Google Chrome prior to 103.0.5060.53 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2161: Use after free in WebApp Provider in Google Chrome prior to 103.0.5060.53 allowed a remote attacker who convinced the user to engage in specific user interactions to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2163: Use after free in Cast UI and Toolbar in Google Chrome prior to 103.0.5060.134 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via UI interaction.\n\n- CVE-2022-2296: Use after free in Chrome OS Shell in Google Chrome on Chrome OS prior to 103.0.5060.114 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via direct UI interactions.\n\n- CVE-2022-23608: PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In versions up to and including 2.11.1 when in a dialog set (or forking) scenario, a hash key shared by multiple UAC dialogs can potentially be prematurely freed when one of the dialogs is destroyed . The issue may cause a dialog set to be registered in the hash table multiple times (with different hash keys) leading to undefined behavior such as dialog list collision which eventually leading to endless loop. A patch is available in commit db3235953baa56d2fb0e276ca510fefca751643f which will be included in the next release. There are no known workarounds for this issue.\n\n- CVE-2022-2399: Use after free in WebGPU in Google Chrome prior to 100.0.4896.88 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2477: Use after free in Guest View in Google Chrome prior to 103.0.5060.134 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2478: Use after free in PDF in Google Chrome prior to 103.0.5060.134 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2480: Use after free in Service Worker API in Google Chrome prior to 103.0.5060.134 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2481: Use after free in Views in Google Chrome prior to 103.0.5060.134 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via UI interaction.\n\n- CVE-2022-2603: Use after free in Omnibox in Google Chrome prior to 104.0.5112.79 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2604: Use after free in Safe Browsing in Google Chrome prior to 104.0.5112.79 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2606: Use after free in Managed devices API in Google Chrome prior to 104.0.5112.79 allowed a remote attacker who convinced a user to enable a specific Enterprise policy to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2613: Use after free in Input in Google Chrome on Chrome OS prior to 104.0.5112.79 allowed a remote attacker who convinced a user to enage in specific user interactions to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2614: Use after free in Sign-In Flow in Google Chrome prior to 104.0.5112.79 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-28269: Acrobat Reader DC versions 22.001.20085 (and earlier), 20.005.3031x (and earlier) and 17.012.30205 (and earlier) are affected by a use-after-free vulnerability in the processing of Annotation objects that could result in a memory leak in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2022-2852: Use after free in FedCM in Google Chrome prior to 104.0.5112.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2855: Use after free in ANGLE in Google Chrome prior to 104.0.5112.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2858: Use after free in Sign-In Flow in Google Chrome prior to 104.0.5112.101 allowed a remote attacker to potentially exploit heap corruption via specific UI interaction.\n\n- CVE-2022-2859: Use after free in Chrome OS Shell in Google Chrome prior to 104.0.5112.101 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2896: Measuresoft ScadaPro Server (All Versions) allows use after free while processing a specific project file.\n\n- CVE-2022-2998: Use after free in Browser Creation in Google Chrome prior to 104.0.5112.101 allowed a remote attacker who had convinced a user to engage in a specific UI interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3038: Use after free in Network Service in Google Chrome prior to 105.0.5195.52 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3039: Use after free in WebSQL in Google Chrome prior to 105.0.5195.52 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3041: Use after free in WebSQL in Google Chrome prior to 105.0.5195.52 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3046: Use after free in Browser Tag in Google Chrome prior to 105.0.5195.52 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3055: Use after free in Passwords in Google Chrome prior to 105.0.5195.52 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3058: Use after free in Sign-In Flow in Google Chrome prior to 105.0.5195.52 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via crafted UI interaction.\n\n- CVE-2022-3196: Use after free in PDF in Google Chrome prior to 105.0.5195.125 allowed a remote attacker to potentially exploit heap corruption via a crafted PDF file. (Chromium security severity: High)\n\n- CVE-2022-3197: Use after free in PDF in Google Chrome prior to 105.0.5195.125 allowed a remote attacker to potentially exploit heap corruption via a crafted PDF file. (Chromium security severity: High)\n\n- CVE-2022-3198: Use after free in PDF in Google Chrome prior to 105.0.5195.125 allowed a remote attacker to potentially exploit heap corruption via a crafted PDF file. (Chromium security severity: High)\n\n- CVE-2022-3199: Use after free in Frames in Google Chrome prior to 105.0.5195.125 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-32317: The MPlayer Project v1.5 was discovered to contain a heap use-after-free resulting in a double free in the preinit function at libvo/vo_v4l2.c. This vulnerability can lead to a Denial of Service (DoS) via a crafted file. The device=strdup statement is not executed on every call. Note: This has been disputed by third parties as invalid and not reproduceable.\n\n- CVE-2022-3445: Use after free in Skia in Google Chrome prior to 106.0.5249.119 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-3448: Use after free in Permissions API in Google Chrome prior to 106.0.5249.119 allowed a remote attacker who convinced a user to engage in specific UI gestures to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-34484: The Mozilla Fuzzing Team reported potential vulnerabilities present in Thunderbird 91.10. Some of these bugs showed evidence of memory corruption and we presume that with enough effort some of these could have been exploited to run arbitrary code. This vulnerability affects Firefox < 102, Firefox ESR < 91.11, Thunderbird < 102, and Thunderbird < 91.11.\n\n- CVE-2022-3449: Use after free in Safe Browsing in Google Chrome prior to 106.0.5249.119 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension. (Chromium security severity: High)\n\n- CVE-2022-34568: SDL v1.2 was discovered to contain a use-after-free via the XFree function at /src/video/x11/SDL_x11yuv.c.\n\n- CVE-2022-3654: Use after free in Layout in Google Chrome prior to 107.0.5304.62 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-3657: Use after free in Extensions in Google Chrome prior to 107.0.5304.62 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension. (Chromium security severity: Medium)\n\n- CVE-2022-3658: Use after free in Feedback service on Chrome OS in Google Chrome on Chrome OS prior to 107.0.5304.62 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via specific UI interaction. (Chromium security severity: Medium)\n\n- CVE-2022-3659: Use after free in Accessibility in Google Chrome on Chrome OS prior to 107.0.5304.62 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via specific UI interactions. (Chromium security severity: Medium)\n\n- CVE-2022-3842: Use after free in Passwords in Google Chrome prior to 105.0.5195.125 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-3863: Use after free in Browser History in Google Chrome prior to 100.0.4896.75 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chrome security severity: High)\n\n- CVE-2022-3885: Use after free in V8 in Google Chrome prior to 107.0.5304.106 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-3886: Use after free in Speech Recognition in Google Chrome prior to 107.0.5304.106 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-3887: Use after free in Web Workers in Google Chrome prior to 107.0.5304.106 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-3888: Use after free in WebCodecs in Google Chrome prior to 107.0.5304.106 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4175: Use after free in Camera Capture in Google Chrome prior to 108.0.5359.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4177: Use after free in Extensions in Google Chrome prior to 108.0.5359.71 allowed an attacker who convinced a user to install an extension to potentially exploit heap corruption via a crafted Chrome Extension and UI interaction. (Chromium security severity: High)\n\n- CVE-2022-4178: Use after free in Mojo in Google Chrome prior to 108.0.5359.71 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4179: Use after free in Audio in Google Chrome prior to 108.0.5359.71 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension. (Chromium security severity: High)\n\n- CVE-2022-4180: Use after free in Mojo in Google Chrome prior to 108.0.5359.71 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension. (Chromium security severity: High)\n\n- CVE-2022-4181: Use after free in Forms in Google Chrome prior to 108.0.5359.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4191: Use after free in Sign-In in Google Chrome prior to 108.0.5359.71 allowed a remote attacker who convinced a user to engage in specific UI interaction to potentially exploit heap corruption via profile destruction. (Chromium security severity: Medium)\n\n- CVE-2022-4192: Use after free in Live Caption in Google Chrome prior to 108.0.5359.71 allowed a remote attacker who convinced a user to engage in specific UI interaction to potentially exploit heap corruption via UI interaction. (Chromium security severity: Medium)\n\n- CVE-2022-4194: Use after free in Accessibility in Google Chrome prior to 108.0.5359.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: Medium)\n\n- CVE-2022-42332: x86 shadow plus log-dirty mode use-after-free In environments where host assisted address translation is necessary but Hardware Assisted Paging (HAP) is unavailable, Xen will run guests in so called shadow mode. Shadow mode maintains a pool of memory used for both shadow page tables as well as auxiliary data structures. To migrate or snapshot guests, Xen additionally runs them in so called log-dirty mode. The data structures needed by the log-dirty tracking are part of aformentioned auxiliary data. In order to keep error handling efforts within reasonable bounds, for operations which may require memory allocations shadow mode logic ensures up front that enough memory is available for the worst case requirements. Unfortunately, while page table memory is properly accounted for on the code path requiring the potential establishing of new shadows, demands by the log-dirty infrastructure were not taken into consideration. As a result, just established shadow page tables could be freed again immediately, while other code is still accessing them on the assumption that they would remain allocated.\n\n- CVE-2022-4436: Use after free in Blink Media in Google Chrome prior to 108.0.5359.124 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4437: Use after free in Mojo IPC in Google Chrome prior to 108.0.5359.124 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4438: Use after free in Blink Frames in Google Chrome prior to 108.0.5359.124 allowed a remote attacker who convinced the user to engage in specific UI interactions to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4439: Use after free in Aura in Google Chrome on Windows prior to 108.0.5359.124 allowed a remote attacker who convinced the user to engage in specific UI interactions to potentially exploit heap corruption via specific UI interactions. (Chromium security severity: High)\n\n- CVE-2022-4440: Use after free in Profiles in Google Chrome prior to 108.0.5359.124 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: Medium)\n\n- CVE-2022-44550: The graphics display module has a UAF vulnerability when traversing graphic layers. Successful exploitation of this vulnerability may affect system availability.\n\n- CVE-2022-45406: If an out-of-memory condition occurred when creating a JavaScript global, a JavaScript realm may be deleted while references to it lived on in a BaseShape. This could lead to a use-after-free causing a potentially exploitable crash. This vulnerability affects Firefox ESR < 102.5, Thunderbird < 102.5, and Firefox < 107.\n\n- CVE-2022-29228: Envoy is a cloud-native high-performance proxy. In versions prior to 1.22.1 the OAuth filter would try to invoke the remaining filters in the chain after emitting a local response, which triggers an ASSERT() in newer versions and corrupts memory on earlier versions. continueDecoding() shouldn\u2019t ever be called from filters after a local reply has been sent. Users are advised to upgrade. There are no known workarounds for this issue.\n\n- CVE-2022-23459: Jsonxx or Json++ is a JSON parser, writer and reader written in C++. In affected versions of jsonxx use of the Value class may lead to memory corruption via a double free or via a use after free. The value class has a default assignment operator which may be used with pointer types which may point to alterable data where the pointer itself is not updated. This issue exists on the current commit of the jsonxx project. The project itself has been archived and updates are not expected. Users are advised to find a replacement.\n\n- CVE-2022-3370: Use after free in Custom Elements in Google Chrome prior to 106.0.5249.91 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-43945: The Linux kernel NFSD implementation prior to versions 5.19.17 and 6.0.2 are vulnerable to buffer overflow. NFSD tracks the number of pages held by each NFSD thread by combining the receive and send buffers of a remote procedure call (RPC) into a single array of pages. A client can force the send buffer to shrink by sending an RPC message over TCP with garbage data added at the end of the message. The RPC message with garbage data is still correctly formed according to the specification and is passed forward to handlers. Vulnerable code in NFSD is not expecting the oversized request and writes beyond the allocated buffer space. CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H\n\n- CVE-2021-1048: In ep_loop_check_proc of eventpoll.c, there is a possible way to corrupt memory due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-204573007References: Upstream kernel\n\n- CVE-2021-21193: Use after free in Blink in Google Chrome prior to 89.0.4389.90 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21206: Use after free in Blink in Google Chrome prior to 89.0.4389.128 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30554: Use after free in WebGL in Google Chrome prior to 91.0.4472.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37975: Use after free in V8 in Google Chrome prior to 94.0.4606.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-22620: A use after free issue was addressed with improved memory management. This issue is fixed in macOS Monterey 12.2.1, iOS 15.3.1 and iPadOS 15.3.1, Safari 15.3 (v. 16612.4.9.1.8 and 15612.4.9.1.8). Processing maliciously crafted web content may lead to arbitrary code execution. Apple is aware of a report that this issue may have been actively exploited..\n\n- CVE-2022-26485: Removing an XSLT parameter during processing could have lead to an exploitable use-after-free. We have had reports of attacks in the wild abusing this flaw. This vulnerability affects Firefox < 97.0.2, Firefox ESR < 91.6.1, Firefox for Android < 97.3.0, Thunderbird < 91.6.2, and Focus < 97.3.0.\n\n- CVE-2022-26486: An unexpected message in the WebGPU IPC framework could lead to a use-after-free and exploitable sandbox escape. We have had reports of attacks in the wild abusing this flaw. This vulnerability affects Firefox < 97.0.2, Firefox ESR < 91.6.1, Firefox for Android < 97.3.0, Thunderbird < 91.6.2, and Focus < 97.3.0.\n\n- CVE-2022-38181: The Arm Mali GPU kernel driver allows unprivileged users to access freed memory because GPU memory operations are mishandled. This affects Bifrost r0p0 through r38p1, and r39p0; Valhall r19p0 through r38p1, and r39p0; and Midgard r4p0 through r32p0.\n\n- CVE-2022-0523: Use After Free in GitHub repository radareorg/radare2 prior to 5.6.2.\n\n- CVE-2022-22034: Windows Graphics Component Elevation of Privilege Vulnerability\n\n- CVE-2022-0581: Crash in the CMS protocol dissector in Wireshark 3.6.0 to 3.6.1 and 3.4.0 to 3.4.11 allows denial of service via packet injection or crafted capture file\n\n- CVE-2022-3541: A vulnerability classified as critical has been found in Linux Kernel. This affects the function spl2sw_nvmem_get_mac_address of the file drivers/net/ethernet/sunplus/spl2sw_driver.c of the component BPF. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier VDB-211041 was assigned to this vulnerability.\n\n- CVE-2022-3545: A vulnerability has been found in Linux Kernel and classified as critical. Affected by this vulnerability is the function area_cache_get of the file drivers/net/ethernet/netronome/nfp/nfpcore/nfp_cppcore.c of the component IPsec. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier VDB-211045 was assigned to this vulnerability.\n\n- CVE-2022-3559: A vulnerability was found in Exim and classified as problematic. This issue affects some unknown processing of the component Regex Handler. The manipulation leads to use after free. The name of the patch is 4e9ed49f8f12eb331b29bd5b6dc3693c520fddc2. It is recommended to apply a patch to fix this issue. The identifier VDB-211073 was assigned to this vulnerability.\n\n- CVE-2022-3620: A vulnerability was found in Exim and classified as problematic. This issue affects the function dmarc_dns_lookup of the file dmarc.c of the component DMARC Handler. The manipulation leads to use after free. The attack may be initiated remotely. The name of the patch is 12fb3842f81bcbd4a4519d5728f2d7e0e3ca1445. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211919.\n\n- CVE-2022-3625: A vulnerability was found in Linux Kernel. It has been classified as critical. This affects the function devlink_param_set/devlink_param_get of the file net/core/devlink.c of the component IPsec. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier VDB-211929 was assigned to this vulnerability.\n\n- CVE-2022-3636: A vulnerability, which was classified as critical, was found in Linux Kernel. This affects the function __mtk_ppe_check_skb of the file drivers/net/ethernet/mediatek/mtk_ppe.c of the component Ethernet Handler. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211935.\n\n- CVE-2022-3640: A vulnerability, which was classified as critical, was found in Linux Kernel. Affected is the function l2cap_conn_del of the file net/bluetooth/l2cap_core.c of the component Bluetooth. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211944.\n\n- CVE-2022-3649: A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is the function nilfs_new_inode of the file fs/nilfs2/inode.c of the component BPF. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211992.\n\n- CVE-2022-3705: A vulnerability was found in vim and classified as problematic. Affected by this issue is the function qf_update_buffer of the file quickfix.c of the component autocmd Handler. The manipulation leads to use after free. The attack may be launched remotely. Upgrading to version 9.0.0805 is able to address this issue. The name of the patch is d0fab10ed2a86698937e3c3fed2f10bd9bb5e731. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-212324.\n\n- CVE-2021-30262: Improper validation of a socket state when socket events are being sent to clients can lead to invalid access of memory in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2022-35254: An unauthenticated attacker can cause a denial-of-service to the following products: Ivanti Connect Secure (ICS) in versions prior to 9.1R14.3, 9.1R15.2, 9.1R16.2, and 22.2R4, Ivanti Policy Secure (IPS) in versions prior to 9.1R17 and 22.3R1, and Ivanti Neurons for Zero-Trust Access in versions prior to 22.3R1.\n\nRelated Weaknesses:\n\n- CWE-825 (ChildOf)\n\n- CWE-672 (ChildOf)\n\n- CWE-672 (ChildOf)\n\n- CWE-672 (ChildOf)\n\n- CWE-120 (CanPrecede)\n\n- CWE-123 (CanPrecede)",
          "type": "Variant",
          "source": "sparse",
          "search_source": "weakness:memory corruption",
          "sources": [
            "base",
            "weakness"
          ],
          "boost_factor": 2.8,
          "boosted": true,
          "metadata": {
            "source": "sparse",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            }
          }
        },
        {
          "cwe_id": "122",
          "name": "Heap-based Buffer Overflow",
          "description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
          "score": 59.76424520678538,
          "matched_text": "CWE-122: Heap-based Buffer Overflow\n\nType: Variant\n\nStatus: Draft\n\nDescription:\n\nA heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().\n\nReal-World Examples:\n\n- CVE-2021-43537: Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n\n- CVE-2007-4268: Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)\n\n- CVE-2009-2523: Chain: product does not handle when an input string is not NULL terminated (CWE-170), leading to buffer over-read (CWE-125) or heap-based buffer overflow (CWE-122).\n\n- CVE-2021-29529: Chain: machine-learning product can have a heap-based buffer overflow (CWE-122) when some integer-oriented bounds are calculated by using ceiling() and floor() on floating point values (CWE-1339)\n\n- CVE-2010-1866: Chain: integer overflow (CWE-190) causes a negative signed value, which later bypasses a maximum-only check (CWE-839), leading to heap-based buffer overflow (CWE-122).\n\nTop 25 CWE Examples:\n\n- CVE-2020-11176: While processing server certificate from IPSec server, certificate validation for subject alternative name API can cause heap overflow which can lead to memory corruption in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Mobile\n\n- CVE-2020-11182: Possible heap overflow while parsing NAL header due to lack of check of length of data received from user in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile\n\n- CVE-2020-18900: A heap-based buffer overflow in the libexe_io_handle_read_coff_optional_header function of libyal libexe before 20181128. NOTE: the vendor has disputed this as described in libyal/libexe issue 1 on GitHub\n\n- CVE-2020-21600: libde265 v1.0.4 contains a heap buffer overflow in the put_weighted_pred_avg_16_fallback function, which can be exploited via a crafted a file.\n\n- CVE-2020-21602: libde265 v1.0.4 contains a heap buffer overflow in the put_weighted_bipred_16_fallback function, which can be exploited via a crafted a file.\n\n- CVE-2020-21606: libde265 v1.0.4 contains a heap buffer overflow fault in the put_epel_16_fallback function, which can be exploited via a crafted a file.\n\n- CVE-2020-21677: A heap-based buffer overflow in the sixel_encoder_output_without_macro function in encoder.c of Libsixel 1.8.4 allows attackers to cause a denial of service (DOS) via converting a crafted PNG file into Sixel format.\n\n- CVE-2020-21814: A heap based buffer overflow issue exists in GNU LibreDWG 0.10.2641 via htmlwescape ../../programs/escape.c:97.\n\n- CVE-2020-21818: A heap based buffer overflow vulnerability exists in GNU LibreDWG 0.10.2641 via htmlescape ../../programs/escape.c:48.\n\n- CVE-2020-21819: A heap based buffer overflow vulnerability exists in GNU LibreDWG 0.10.2641via htmlescape ../../programs/escape.c:51.\n\n- CVE-2020-21827: A heap based buffer overflow vulnerability exists in GNU LibreDWG 0.10 via read_2004_compressed_section ../../src/decode.c:2379.\n\n- CVE-2020-21830: A heap based buffer overflow vulneraibility exists in GNU LibreDWG 0.10 via bit_calc_CRC ../../src/bits.c:2213.\n\n- CVE-2020-21831: A heap based buffer overflow vulnerability exists in GNU LibreDWG 0.10 via read_2004_section_handles ../../src/decode.c:2637.\n\n- CVE-2020-21832: A heap based buffer overflow vulnerability exists in GNU LibreDWG 0.10 via read_2004_compressed_section ../../src/decode.c:2417.\n\n- CVE-2020-21833: A heap based buffer overflow vulnerability exits in GNU LibreDWG 0.10 via: read_2004_section_classes ../../src/decode.c:2440.\n\n- CVE-2020-21838: A heap based buffer overflow vulnerability exits in GNU LibreDWG 0.10 via: read_2004_section_appinfo ../../src/decode.c:2842.\n\n- CVE-2020-21840: A heap based buffer overflow vulnerability exits in GNU LibreDWG 0.10 via bit_search_sentinel ../../src/bits.c:1985.\n\n- CVE-2020-21841: A heap based buffer overflow vulnerability exits in GNU LibreDWG 0.10 via bit_read_B ../../src/bits.c:135.\n\n- CVE-2020-21842: A heap based buffer overflow vulnerability exists in GNU LibreDWG 0.10 via read_2004_section_revhistory ../../src/decode.c:3051.\n\n- CVE-2020-21843: A heap based buffer overflow vulnerability exits in GNU LibreDWG 0.10 via bit_read_RC ../../src/bits.c:318.\n\n- CVE-2020-22016: A heap-based Buffer Overflow vulnerability in FFmpeg 4.2 at libavcodec/get_bits.h when writing .mov files, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22017: A heap-based Buffer Overflow vulnerability exists in FFmpeg 4.2 at ff_fill_rectangle in libavfilter/drawutils.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22022: A heap-based Buffer Overflow vulnerability exists in FFmpeg 4.2 in filter_frame at libavfilter/vf_fieldorder.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22023: A heap-based Buffer Overflow vulnerabililty exists in FFmpeg 4.2 in filter_frame at libavfilter/vf_bitplanenoise.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22025: A heap-based Buffer Overflow vulnerability exists in gaussian_blur at libavfilter/vf_edgedetect.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22027: A heap-based Buffer Overflow vulnerability exits in FFmpeg 4.2 in deflate16 at libavfilter/vf_neighbor.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22029: A heap-based Buffer Overflow vulnerability exists in FFmpeg 4.2 at libavfilter/vf_colorconstancy.c: in slice_get_derivative, which crossfade_samples_fltp, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22030: A heap-based Buffer Overflow vulnerability exists in FFmpeg 4.2 at libavfilter/af_afade.c in crossfade_samples_fltp, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22031: A Heap-based Buffer Overflow vulnerability exists in FFmpeg 4.2 at libavfilter/vf_w3fdif.c in filter16_complex_low, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22032: A heap-based Buffer Overflow vulnerability exists FFmpeg 4.2 at libavfilter/vf_edgedetect.c in gaussian_blur, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22033: A heap-based Buffer Overflow Vulnerability exists FFmpeg 4.2 at libavfilter/vf_vmafmotion.c in convolution_y_8bit, which could let a remote malicious user cause a Denial of Service.\n\n- CVE-2020-22034: A heap-based Buffer Overflow vulnerability exists FFmpeg 4.2 at libavfilter/vf_floodfill.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22035: A heap-based Buffer Overflow vulnerability exists in FFmpeg 4.2 in get_block_row at libavfilter/vf_bm3d.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22036: A heap-based Buffer Overflow vulnerability exists in FFmpeg 4.2 in filter_intra at libavfilter/vf_bwdif.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22675: An issue was discovered in gpac 0.8.0. The GetGhostNum function in stbl_read.c has a heap-based buffer overflow which can lead to a denial of service (DOS) via a crafted input.\n\n- CVE-2020-22677: An issue was discovered in gpac 0.8.0. The dump_data_hex function in box_dump.c has a heap-based buffer overflow which can lead to a denial of service (DOS) via a crafted input.\n\n- CVE-2020-22678: An issue was discovered in gpac 0.8.0. The gf_media_nalu_remove_emulation_bytes function in av_parsers.c has a heap-based buffer overflow which can lead to a denial of service (DOS) via a crafted input.\n\n- CVE-2020-23266: An issue was discovered in gpac 0.8.0. The OD_ReadUTF8String function in odf_code.c has a heap-based buffer overflow which can lead to a denial of service (DOS) via a crafted media file.\n\n- CVE-2020-23267: An issue was discovered in gpac 0.8.0. The gf_hinter_track_process function in isom_hinter_track_process.c has a heap-based buffer overflow which can lead to a denial of service (DOS) via a crafted media file\n\n- CVE-2020-23269: An issue was discovered in gpac 0.8.0. The stbl_GetSampleSize function in isomedia/stbl_read.c has a heap-based buffer overflow which can lead to a denial of service (DOS) via a crafted media file.\n\n- CVE-2020-23332: A heap-based buffer overflow exists in the AP4_StdcFileByteStream::ReadPartial component located in /StdC/Ap4StdCFileByteStream.cpp of Bento4 version 06c39d9. This issue can lead to a denial of service (DOS).\n\n- CVE-2020-23333: A heap-based buffer overflow exists in the AP4_CttsAtom::AP4_CttsAtom component located in /Core/Ap4Utils.h of Bento4 version 06c39d9. This can lead to a denial of service (DOS).\n\n- CVE-2020-23706: A heap-based buffer overflow vulnerability in the function ok_jpg_decode_block_subsequent_scan() ok_jpg.c:1102 of ok-file-formats through 2020-06-26 allows attackers to cause a Denial of Service (DOS) via a crafted jpeg file.\n\n- CVE-2020-23707: A heap-based buffer overflow vulnerability in the function ok_jpg_decode_block_progressive() at ok_jpg.c:1054 of ok-file-formats through 2020-06-26 allows attackers to cause a Denial of Service (DOS) via a crafted jpeg file.\n\n- CVE-2020-23852: A heap based buffer overflow vulnerability exists in ffjpeg through 2020-07-02 in the jfif_decode(void *ctxt, BMP *pb) function at ffjpeg/src/jfif.c (line 544 & line 545), which could cause a denial of service by submitting a malicious jpeg image.\n\n- CVE-2020-23861: A heap-based buffer overflow vulnerability exists in LibreDWG 0.10.1 via the read_system_page function at libredwg-0.10.1/src/decode_r2007.c:666:5, which causes a denial of service by submitting a dwg file.\n\n- CVE-2020-23886: XnView MP v0.96.4 was discovered to contain a heap overflow which allows attackers to cause a denial of service (DoS) via a crafted pict file. Related to a User Mode Write AV starting at ntdll!RtlpLowFragHeapFree.\n\n- CVE-2020-23887: XnView MP v0.96.4 was discovered to contain a heap overflow which allows attackers to cause a denial of service (DoS) via a crafted ico file. Related to a Read Access Violation starting at USER32!SmartStretchDIBits+0x33.\n\n- CVE-2020-23907: An issue was discovered in retdec v3.3. In function canSplitFunctionOn() of ir_modifications.cpp, there is a possible out of bounds read due to a heap buffer overflow. The impact is: Deny of Service, Memory Disclosure, and Possible Code Execution.\n\n- CVE-2020-24133: A heap buffer overflow vulnerability in the r_asm_swf_disass function of Radare2-extras before commit e74a93c allows attackers to execute arbitrary code or carry out denial of service (DOS) attacks.\n\n- CVE-2020-24829: An issue was discovered in GPAC v0.8.0, as demonstrated by MP4Box. It contains a heap-based buffer overflow in gf_m2ts_section_complete in media_tools/mpegts.c that can cause a denial of service (DOS) via a crafted MP4 file.\n\n- CVE-2020-26797: Mediainfo before version 20.08 has a heap buffer overflow vulnerability via MediaInfoLib::File_Gxf::ChooseParser_ChannelGrouping.\n\n- CVE-2020-28011: Exim 4 before 4.94.2 allows Heap-based Buffer Overflow in queue_run via two sender options: -R and -S. This may cause privilege escalation from exim to root.\n\n- CVE-2020-28013: Exim 4 before 4.94.2 allows Heap-based Buffer Overflow because it mishandles \"-F '.('\" on the command line, and thus may allow privilege escalation from any user to root. This occurs because of the interpretation of negative sizes in strncpy.\n\n- CVE-2020-28592: A heap-based buffer overflow vulnerability exists in the configuration server functionality of the Cosori Smart 5.8-Quart Air Fryer CS158-AF 1.1.0. A specially crafted JSON object can lead to remote code execution. An attacker can send a malicious packet to trigger this vulnerability.\n\n- CVE-2020-29614: This issue was addressed with improved checks. This issue is fixed in macOS Big Sur 11.2, Security Update 2021-001 Catalina, Security Update 2021-001 Mojave, macOS Big Sur 11.1, Security Update 2020-001 Catalina, Security Update 2020-007 Mojave, iOS 14.3 and iPadOS 14.3, tvOS 14.3. Processing a maliciously crafted file may lead to heap corruption.\n\n- CVE-2020-35979: An issue was discovered in GPAC version 0.8.0 and 1.0.1. There is heap-based buffer overflow in the function gp_rtp_builder_do_avc() in ietf/rtp_pck_mpeg4.c.\n\n- CVE-2020-36400: ZeroMQ libzmq 4.3.3 has a heap-based buffer overflow in zmq::tcp_read, a different vulnerability than CVE-2021-20235.\n\n- CVE-2020-36428: matio (aka MAT File I/O Library) 1.5.18 through 1.5.21 has a heap-based buffer overflow in ReadInt32DataDouble (called from ReadInt32Data and Mat_VarRead4).\n\n- CVE-2020-36430: libass 0.15.x before 0.15.1 has a heap-based buffer overflow in decode_chars (called from decode_font and process_text) because the wrong integer data type is used for subtraction.\n\n- CVE-2020-7461: In FreeBSD 12.1-STABLE before r365010, 11.4-STABLE before r365011, 12.1-RELEASE before p9, 11.4-RELEASE before p3, and 11.3-RELEASE before p13, dhclient(8) fails to handle certain malformed input related to handling of DHCP option 119 resulting a heap overflow. The heap overflow could in principle be exploited to achieve remote code execution. The affected process runs with reduced privileges in a Capsicum sandbox, limiting the immediate impact of an exploit.\n\n- CVE-2021-0325: In ih264d_parse_pslice of ih264d_parse_pslice.c, there is a possible out of bounds write due to a heap buffer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-8.1 Android-9 Android-10 Android-11Android ID: A-174238784\n\n- CVE-2021-0353: In kisd, there is a possible memory corruption due to a heap buffer overflow. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Product: Android; Versions: Android-11; Patch ID: ALPS05425247.\n\n- CVE-2021-0426: In parsePrimaryFieldFirstUidAnnotation of LogEvent.cpp, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11Android ID: A-174485572\n\n- CVE-2021-0427: In parseExclusiveStateAnnotation of LogEvent.cpp, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11Android ID: A-174488848\n\n- CVE-2021-0457: In the FingerTipS touch screen driver, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-157155375\n\n- CVE-2021-0464: In sound_trigger_event_alloc of platform.h, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-167663878\n\n- CVE-2021-0474: In avrc_msg_cback of avrc_api.cc, there is a possible out of bounds write due to a heap buffer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11 Android-8.1 Android-9 Android-10Android ID: A-177611958\n\n- CVE-2021-0512: In __hidinput_change_resolution_multipliers of hid-input.c, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-173843328References: Upstream kernel\n\n- CVE-2021-0519: In BITSTREAM_FLUSH of ih264e_bitstream.h, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-8.1 Android-9Android ID: A-176533109\n\n- CVE-2021-0577: In flv extractor, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-187161771\n\n- CVE-2021-0690: In ih264d_mark_err_slice_skip of ih264d_parse_pslice.c, there is a possible out of bounds write due to a heap buffer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-9 Android-10 Android-11 Android-8.1Android ID: A-182152757\n\n- CVE-2021-1767: This issue was addressed with improved checks. This issue is fixed in macOS Big Sur 11.2, Security Update 2021-001 Catalina, Security Update 2021-001 Mojave, iOS 14.4 and iPadOS 14.4. Processing a maliciously crafted image may lead to heap corruption.\n\n- CVE-2021-1883: This issue was addressed with improved checks. This issue is fixed in Security Update 2021-004 Mojave, iOS 14.5 and iPadOS 14.5, watchOS 7.4, Security Update 2021-003 Catalina, tvOS 14.5, macOS Big Sur 11.3. Processing maliciously crafted server messages may lead to heap corruption.\n\n- CVE-2021-1975: Possible heap overflow due to improper length check of domain while parsing the DNS response in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2021-20194: There is a vulnerability in the linux kernel versions higher than 5.2 (if kernel compiled with config params CONFIG_BPF_SYSCALL=y , CONFIG_BPF=y , CONFIG_CGROUPS=y , CONFIG_CGROUP_BPF=y , CONFIG_HARDENED_USERCOPY not set, and BPF hook to getsockopt is registered). As result of BPF execution, the local user can trigger bug in __cgroup_bpf_run_filter_getsockopt() function that can lead to heap overflow (because of non-hardened usercopy). The impact of attack could be deny of service or possibly privileges escalation.\n\n- CVE-2021-20284: A flaw was found in GNU Binutils 2.35.1, where there is a heap-based buffer overflow in _bfd_elf_slurp_secondary_reloc_section in elf.c due to the number of symbols not calculated correctly. The highest threat from this vulnerability is to system availability.\n\n- CVE-2021-20494: IBM Security Identity Manager Adapters 6.0 and 7.0 are vulnerable to a heap based buffer overflow, caused by improper bounds. An authenticared user could overflow the buffer and cause the service to crash. IBM X-Force ID: 197882.\n\n- CVE-2021-20573: IBM Security Identity Manager Adapters 6.0 and 7.0 are vulnerable to a heap-based buffer overflow, caused by improper bounds checking. A remote authenticated attacker could overflow the and cause the server to crash. IBM X-Force ID: 199249.\n\n- CVE-2021-20587: Heap-based buffer overflow vulnerability in Mitsubishi Electric FA Engineering Software (CPU Module Logging Configuration Tool versions 1.112R and prior, CW Configurator versions 1.011M and prior, Data Transfer versions 3.44W and prior, EZSocket versions 5.4 and prior, FR Configurator all versions, FR Configurator SW3 all versions, FR Configurator2 versions 1.24A and prior, GT Designer3 Version1(GOT1000) versions 1.250L and prior, GT Designer3 Version1(GOT2000) versions 1.250L and prior, GT SoftGOT1000 Version3 versions 3.245F and prior, GT SoftGOT2000 Version1 versions 1.250L and prior, GX Configurator-DP versions 7.14Q and prior, GX Configurator-QP all versions, GX Developer versions 8.506C and prior, GX Explorer all versions, GX IEC Developer all versions, GX LogViewer versions 1.115U and prior, GX RemoteService-I all versions, GX Works2 versions 1.597X and prior, GX Works3 versions 1.070Y and prior, iQ Monozukuri ANDON (Data Transfer) all versions, iQ Monozukuri Process Remote Monitoring (Data Transfer) all versions, M_CommDTM-HART all versions, M_CommDTM-IO-Link versions 1.03D and prior, MELFA-Works versions 4.4 and prior, MELSEC WinCPU Setting Utility all versions, MELSOFT EM Software Development Kit (EM Configurator) versions 1.015R and prior, MELSOFT Navigator versions 2.74C and prior, MH11 SettingTool Version2 versions 2.004E and prior, MI Configurator versions 1.004E and prior, MT Works2 versions 1.167Z and prior, MX Component versions 5.001B and prior, Network Interface Board CC IE Control utility versions 1.29F and prior, Network Interface Board CC IE Field Utility versions 1.16S and prior, Network Interface Board CC-Link Ver.2 Utility versions 1.23Z and prior, Network Interface Board MNETH utility versions 34L and prior, PX Developer versions 1.53F and prior, RT ToolBox2 versions 3.73B and prior, RT ToolBox3 versions 1.82L and prior, Setting/monitoring tools for the C Controller module (SW4PVC-CCPU) versions 4.12N and prior and SLMP Data Collector versions 1.04E and prior) allows a remote unauthenticated attacker to cause a DoS condition of the software products, and possibly to execute a malicious program on the personal computer running the software products although it has not been reproduced, by spoofing MELSEC, GOT or FREQROL and returning crafted reply packets.\n\n- CVE-2021-21017: Acrobat Reader DC versions versions 2020.013.20074 (and earlier), 2020.001.30018 (and earlier) and 2017.011.30188 (and earlier) are affected by a heap-based buffer overflow vulnerability. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-21077: Adobe Animate version 21.0.3 (and earlier) is affected by a Heap-based Buffer Overflow vulnerability. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-21113: Heap buffer overflow in Skia in Google Chrome prior to 87.0.4280.141 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21116: Heap buffer overflow in audio in Google Chrome prior to 87.0.4280.141 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21128: Heap buffer overflow in Blink in Google Chrome prior to 88.0.4324.96 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21143: Heap buffer overflow in Extensions in Google Chrome prior to 88.0.4324.146 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2021-21144: Heap buffer overflow in Tab Groups in Google Chrome prior to 88.0.4324.146 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2021-21148: Heap buffer overflow in V8 in Google Chrome prior to 88.0.4324.150 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21152: Heap buffer overflow in Media in Google Chrome on Linux prior to 88.0.4324.182 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21154: Heap buffer overflow in Tab Strip in Google Chrome prior to 88.0.4324.182 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2021-21155: Heap buffer overflow in Tab Strip in Google Chrome on Windows prior to 88.0.4324.182 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2021-21156: Heap buffer overflow in V8 in Google Chrome prior to 88.0.4324.182 allowed a remote attacker to potentially exploit heap corruption via a crafted script.\n\n- CVE-2021-21160: Heap buffer overflow in WebAudio in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21161: Heap buffer overflow in TabStrip in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21192: Heap buffer overflow in tab groups in Google Chrome prior to 89.0.4389.90 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21196: Heap buffer overflow in TabStrip in Google Chrome on Windows prior to 89.0.4389.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21197: Heap buffer overflow in TabStrip in Google Chrome prior to 89.0.4389.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21222: Heap buffer overflow in V8 in Google Chrome prior to 90.0.4430.85 allowed a remote attacker who had compromised the renderer process to bypass site isolation via a crafted HTML page.\n\n- CVE-2021-21225: Out of bounds memory access in V8 in Google Chrome prior to 90.0.4430.85 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21233: Heap buffer overflow in ANGLE in Google Chrome on Windows prior to 90.0.4430.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21555: Dell PowerEdge R640, R740, R740XD, R840, R940, R940xa, MX740c, MX840c, and T640 Server BIOS contain a heap-based buffer overflow vulnerability in systems with NVDIMM-N installed. A local malicious user with high privileges may potentially exploit this vulnerability, leading to a denial of Service, arbitrary code execution, or information disclosure in UEFI or BIOS Preboot Environment.\n\n- CVE-2021-21795: A heap-based buffer overflow vulnerability exists in the PSD read_icc_icCurve_data functionality of Accusoft ImageGear 19.9. A specially crafted malformed file can lead to an integer overflow that, in turn, leads to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21808: A memory corruption vulnerability exists in the PNG png_palette_process functionality of Accusoft ImageGear 19.9. A specially crafted malformed file can lead to a heap buffer overflow. An attacker can provide malicious inputs to trigger this vulnerability.\n\n- CVE-2021-21810: A memory corruption vulnerability exists in the XML-parsing ParseAttribs functionality of AT&T Labs\u2019 Xmill 0.7. A specially crafted XML file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21811: A memory corruption vulnerability exists in the XML-parsing CreateLabelOrAttrib functionality of AT&T Labs\u2019 Xmill 0.7. A specially crafted XML file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21825: A heap-based buffer overflow vulnerability exists in the XML Decompression PlainTextUncompressor::UncompressItem functionality of AT&T Labs\u2019 Xmill 0.7. A specially crafted XMI file can lead to remote code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21826: A heap-based buffer overflow vulnerability exists in the XML Decompression DecodeTreeBlock functionality of AT&T Labs Xmill 0.7. Within `DecodeTreeBlock` which is called during the decompression of an XMI file, a UINT32 is loaded from the file and used as trusted input as the length of a buffer. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21827: A heap-based buffer overflow vulnerability exists in the XML Decompression DecodeTreeBlock functionality of AT&T Labs Xmill 0.7. Within `DecodeTreeBlock` which is called during the decompression of an XMI file, a UINT32 is loaded from the file and used as trusted input as the length of a buffer. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21828: A heap-based buffer overflow vulnerability exists in the XML Decompression DecodeTreeBlock functionality of AT&T Labs Xmill 0.7. In the default case of DecodeTreeBlock a label is created via CurPath::AddLabel in order to track the label for later reference. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21829: A heap-based buffer overflow vulnerability exists in the XML Decompression EnumerationUncompressor::UncompressItem functionality of AT&T Labs\u2019 Xmill 0.7. A specially crafted XMI file can lead to remote code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21830: A heap-based buffer overflow vulnerability exists in the XML Decompression LabelDict::Load functionality of AT&T Labs\u2019 Xmill 0.7. A specially crafted XMI file can lead to remote code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21897: A code execution vulnerability exists in the DL_Dxf::handleLWPolylineData functionality of Ribbonsoft dxflib 3.17.0. A specially-crafted .dxf file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21899: A code execution vulnerability exists in the dwgCompressor::copyCompBytes21 functionality of LibreCad libdxfrw 2.2.0-rc2-19-ge02f3580. A specially-crafted .dwg file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21940: A heap-based buffer overflow vulnerability exists in the pushMuxer processRtspInfo functionality of Anker Eufy Homebase 2 2.1.6.9h. A specially-crafted network packet can lead to a heap buffer overflow. An attacker can send a malicious packet to trigger this vulnerability.\n\n- CVE-2021-22427: There is a Heap-based Buffer Overflow Vulnerability in Huawei Smartphone.Successful exploitation of this vulnerability may lead to authentication bypass.\n\n- CVE-2021-22465: A component of the HarmonyOS has a Heap-based Buffer Overflow vulnerability. Local attackers may exploit this vulnerability to cause Kernel System unavailable.\n\n- CVE-2021-22641: A heap-based buffer overflow issue has been identified in the way the application processes project files, allowing an attacker to craft a special project file that may allow arbitrary code execution on the Tellus Lite V-Simulator and V-Server Lite (versions prior to 4.0.10.0).\n\n- CVE-2021-25289: An issue was discovered in Pillow before 8.1.1. TiffDecode has a heap-based buffer overflow when decoding crafted YCbCr files because of certain interpretation conflicts with LibTIFF in RGBA mode. NOTE: this issue exists because of an incomplete fix for CVE-2020-35654.\n\n- CVE-2021-25475: A possible heap-based buffer overflow vulnerability in DSP kernel driver prior to SMR Oct-2021 Release 1 allows arbitrary memory write and code execution.\n\n- CVE-2021-25479: A possible heap-based buffer overflow vulnerability in Exynos CP Chipset prior to SMR Oct-2021 Release 1 allows arbitrary memory write and code execution.\n\n- CVE-2021-25495: A possible heap buffer overflow vulnerability in libSPenBase library of Samsung Notes prior to Samsung Note version 4.3.02.61 allows arbitrary code execution.\n\n- CVE-2021-25832: A heap buffer overflow vulnerability inside of BMP image processing was found at [core] module of ONLYOFFICE DocumentServer v4.0.0-9-v6.0.0. Using this vulnerability, an attacker is able to gain remote code executions on DocumentServer.\n\n- CVE-2021-25900: An issue was discovered in the smallvec crate before 0.6.14 and 1.x before 1.6.1 for Rust. There is a heap-based buffer overflow in SmallVec::insert_many.\n\n- CVE-2021-26096: Multiple instances of heap-based buffer overflow in the command shell of FortiSandbox before 4.0.0 may allow an authenticated attacker to manipulate memory and alter its content by means of specifically crafted command line arguments.\n\n- CVE-2021-26603: A heap overflow issue was found in ARK library of bandisoft Co., Ltd when the Ark_DigPathA function parsed a file path. This vulnerability is due to missing support for string length check.\n\n- CVE-2021-26691: In Apache HTTP Server versions 2.4.0 to 2.4.46 a specially crafted SessionHeader sent by an origin server could cause a heap overflow\n\n- CVE-2021-26951: An issue was discovered in the calamine crate before 0.17.0 for Rust. It allows attackers to overwrite heap-memory locations because Vec::set_len is used without proper memory claiming, and this uninitialized memory is used for a user-provided Read operation, as demonstrated by Sectors::get.\n\n- CVE-2021-27034: A heap-based buffer overflow could occur while parsing PICT, PCX, RCL or TIFF files in Autodesk Design Review 2018, 2017, 2013, 2012, 2011. This vulnerability can be exploited to execute arbitrary code.\n\n- CVE-2021-27954: A heap-based buffer overflow vulnerability exists on the ecobee3 lite 4.5.81.200 device in the HKProcessConfig function of the HomeKit Wireless Access Control setup process. A threat actor can exploit this vulnerability to force the device to connect to a SSID or cause a denial of service.\n\n- CVE-2021-28026: jpeg-xl v0.3.2 is affected by a heap buffer overflow in /lib/jxl/coeff_order.cc ReadPermutation. When decoding a malicous jxl file using djxl, an attacker can trigger arbitrary code execution or a denial of service.\n\n- CVE-2021-28211: A heap overflow in LzmaUefiDecompressGetInfo function in EDK II.\n\n- CVE-2021-28233: Heap-based Buffer Overflow vulnerability exists in ok-file-formats 1 via the ok_jpg_generate_huffman_table function in ok_jpg.c.\n\n- CVE-2021-28603: Adobe After Effects version 18.2 (and earlier) is affected by a Heap-based Buffer Overflow vulnerability when parsing a specially crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-28604: Adobe After Effects version 18.2 (and earlier) is affected by a Heap-based Buffer Overflow vulnerability when parsing a specially crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-28607: Adobe After Effects version 18.2 (and earlier) is affected by a heap corruption vulnerability when parsing a specially crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-28608: Adobe After Effects version 18.2 (and earlier) is affected by a Heap-based Buffer Overflow vulnerability when parsing a specially crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-28610: Adobe After Effects version 18.2 (and earlier) is affected by a Heap-based Buffer Overflow vulnerability when parsing a specially crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-29323: OpenSource Moddable v10.5.0 was discovered to contain a heap buffer overflow via the component /modules/network/wifi/esp/modwifi.c.\n\n- CVE-2021-29325: OpenSource Moddable v10.5.0 was discovered to contain a heap buffer overflow in the fx_String_prototype_repeat function at /moddable/xs/sources/xsString.c.\n\n- CVE-2021-29326: OpenSource Moddable v10.5.0 was discovered to contain a heap buffer overflow in the fxIDToString function at /moddable/xs/sources/xsSymbol.c.\n\n- CVE-2021-29327: OpenSource Moddable v10.5.0 was discovered to contain a heap buffer overflow in the fx_ArrayBuffer function at /moddable/xs/sources/xsDataView.c.\n\n- CVE-2021-29464: Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. A heap buffer overflow was found in Exiv2 versions v0.27.3 and earlier. The heap overflow is triggered when Exiv2 is used to write metadata into a crafted image file. An attacker could potentially exploit the vulnerability to gain code execution, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when writing the metadata, which is a less frequently used Exiv2 operation than reading the metadata. For example, to trigger the bug in the Exiv2 command-line application, you need to add an extra command-line argument such as `insert`. The bug is fixed in version v0.27.4.\n\n- CVE-2021-29512: TensorFlow is an end-to-end open source platform for machine learning. If the `splits` argument of `RaggedBincount` does not specify a valid `SparseTensor`(https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor), then an attacker can trigger a heap buffer overflow. This will cause a read from outside the bounds of the `splits` tensor buffer in the implementation of the `RaggedBincount` op(https://github.com/tensorflow/tensorflow/blob/8b677d79167799f71c42fd3fa074476e0295413a/tensorflow/core/kernels/bincount_op.cc#L430-L433). Before the `for` loop, `batch_idx` is set to 0. The user controls the `splits` array, making it contain only one element, 0. Thus, the code in the `while` loop would increment `batch_idx` and then try to read `splits(1)`, which is outside of bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3, as these are also affected.\n\n- CVE-2021-29514: TensorFlow is an end-to-end open source platform for machine learning. If the `splits` argument of `RaggedBincount` does not specify a valid `SparseTensor`(https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor), then an attacker can trigger a heap buffer overflow. This will cause a read from outside the bounds of the `splits` tensor buffer in the implementation of the `RaggedBincount` op(https://github.com/tensorflow/tensorflow/blob/8b677d79167799f71c42fd3fa074476e0295413a/tensorflow/core/kernels/bincount_op.cc#L430-L446). Before the `for` loop, `batch_idx` is set to 0. The attacker sets `splits(0)` to be 7, hence the `while` loop does not execute and `batch_idx` remains 0. This then results in writing to `out(-1, bin)`, which is before the heap allocated buffer for the output tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3, as these are also affected.\n\n- CVE-2021-29520: TensorFlow is an end-to-end open source platform for machine learning. Missing validation between arguments to `tf.raw_ops.Conv3DBackprop*` operations can result in heap buffer overflows. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/4814fafb0ca6b5ab58a09411523b2193fed23fed/tensorflow/core/kernels/conv_grad_shape_utils.cc#L94-L153) assumes that the `input`, `filter_sizes` and `out_backprop` tensors have the same shape, as they are accessed in parallel. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29535: TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedMul` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/87cf4d3ea9949051e50ca3f071fc909538a51cd0/tensorflow/core/kernels/quantized_mul_op.cc#L287-L290) assumes that the 4 arguments are always valid scalars and tries to access the numeric value directly. However, if any of these tensors is empty, then `.flat<T>()` is an empty buffer and accessing the element at position 0 results in overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29536: TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedReshape` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a324ac84e573fba362a5e53d4e74d5de6729933e/tensorflow/core/kernels/quantized_reshape_op.cc#L38-L55) assumes that the 2 arguments are always valid scalars and tries to access the numeric value directly. However, if any of these tensors is empty, then `.flat<T>()` is an empty buffer and accessing the element at position 0 results in overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29537: TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedResizeBilinear` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/50711818d2e61ccce012591eeb4fdf93a8496726/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L705-L706) assumes that the 2 arguments are always valid scalars and tries to access the numeric value directly. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29540: TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow to occur in `Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1b0296c3b8dd9bd948f924aa8cd62f87dbb7c3da/tensorflow/core/kernels/conv_grad_filter_ops.cc#L495-L497) computes the size of the filter tensor but does not validate that it matches the number of elements in `filter_sizes`. Later, when reading/writing to this buffer, code uses the value computed here, instead of the number of elements in the tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29542: TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow by passing crafted inputs to `tf.raw_ops.StringNGrams`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1cdd4da14282210cc759e468d9781741ac7d01bf/tensorflow/core/kernels/string_ngrams_op.cc#L171-L185) fails to consider corner cases where input would be split in such a way that the generated tokens should only contain padding elements. If input is such that `num_tokens` is 0, then, for `data_start_index=0` (when left padding is present), the marked line would result in reading `data[-1]`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29558: TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `tf.raw_ops.SparseSplit`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/699bff5d961f0abfde8fa3f876e6d241681fbef8/tensorflow/core/util/sparse/sparse_tensor.h#L528-L530) accesses an array element based on a user controlled offset. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29560: TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `tf.raw_ops.RaggedTensorToTensor`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/d94227d43aa125ad8b54115c03cece54f6a1977b/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L219-L222) uses the same index to access two arrays in parallel. Since the user controls the shape of the input arguments, an attacker could trigger a heap OOB access when `parent_output_index` is shorter than `row_split`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29576: TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPool3DGradGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/596c05a159b6fbb9e39ca10b3f7753b7244fa1e9/tensorflow/core/kernels/pooling_ops_3d.cc#L694-L696) does not check that the initialization of `Pool3dParameters` completes successfully. Since the constructor(https://github.com/tensorflow/tensorflow/blob/596c05a159b6fbb9e39ca10b3f7753b7244fa1e9/tensorflow/core/kernels/pooling_ops_3d.cc#L48-L88) uses `OP_REQUIRES` to validate conditions, the first assertion that fails interrupts the initialization of `params`, making it contain invalid data. In turn, this might cause a heap buffer overflow, depending on default initialized values. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29577: TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.AvgPool3DGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/d80ffba9702dc19d1fac74fc4b766b3fa1ee976b/tensorflow/core/kernels/pooling_ops_3d.cc#L376-L450) assumes that the `orig_input_shape` and `grad` tensors have similar first and last dimensions but does not check that this assumption is validated. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29578: TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.FractionalAvgPoolGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/dcba796a28364d6d7f003f6fe733d82726dda713/tensorflow/core/kernels/fractional_avg_pool_op.cc#L216) fails to validate that the pooling sequence arguments have enough elements as required by the `out_backprop` tensor shape. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29579: TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/ab1e644b48c82cb71493f4362b4dd38f4577a1cf/tensorflow/core/kernels/maxpooling_op.cc#L194-L203) fails to validate that indices used to access elements of input/output arrays are valid. Whereas accesses to `input_backprop_flat` are guarded by `FastBoundsCheck`, the indexing in `out_backprop_flat` can result in OOB access. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29998: An issue was discovered in Wind River VxWorks before 6.5. There is a possible heap overflow in dhcp client.\n\n- CVE-2021-30019: In the adts_dmx_process function in filters/reframe_adts.c in GPAC 1.0.1, a crafted file may cause ctx->hdr.frame_size to be smaller than ctx->hdr.hdr_size, resulting in size to be a negative number and a heap overflow in the memcpy.\n\n- CVE-2021-30020: In the function gf_hevc_read_pps_bs_internal function in media_tools/av_parsers.c in GPAC 1.0.1 there is a loop, which with crafted file, pps->num_tile_columns may be larger than sizeof(pps->column_width), which results in a heap overflow in the loop.\n\n- CVE-2021-30186: CODESYS V2 runtime system SP before 2.4.7.55 has a Heap-based Buffer Overflow.\n\n- CVE-2021-30498: A flaw was found in libcaca. A heap buffer overflow in export.c in function export_tga might lead to memory corruption and other potential consequences.\n\n- CVE-2021-30508: Heap buffer overflow in Media Feeds in Google Chrome prior to 90.0.4430.212 allowed an attacker who convinced a user to enable certain features in Chrome to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30516: Heap buffer overflow in History in Google Chrome prior to 90.0.4430.212 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30518: Heap buffer overflow in Reader Mode in Google Chrome prior to 90.0.4430.212 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30521: Heap buffer overflow in Autofill in Google Chrome on Android prior to 91.0.4472.77 allowed a remote attacker to perform out of bounds memory access via a crafted HTML page.\n\n- CVE-2021-30559: Out of bounds write in ANGLE in Google Chrome prior to 91.0.4472.164 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30564: Heap buffer overflow in WebXR in Google Chrome prior to 91.0.4472.164 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30568: Heap buffer overflow in WebGL in Google Chrome prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30575: Out of bounds write in Autofill in Google Chrome prior to 92.0.4515.107 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30590: Heap buffer overflow in Bookmarks in Google Chrome prior to 92.0.4515.131 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30614: Chromium: CVE-2021-30614 Heap buffer overflow in TabStrip\n\n- CVE-2021-30632: Out of bounds write in V8 in Google Chrome prior to 93.0.4577.82 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-31254: Buffer overflow in the tenc_box_read function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file, related invalid IV sizes.\n\n- CVE-2021-31320: Telegram Android <7.1.0 (2090), Telegram iOS <7.1, and Telegram macOS <7.1 are affected by a Heap Buffer Overflow in the VGradientCache::generateGradientColorTable function of their custom fork of the rlottie library. A remote attacker might be able to overwrite heap memory out-of-bounds on a victim device via a malicious animated sticker.\n\n- CVE-2021-31322: Telegram Android <7.1.0 (2090), Telegram iOS <7.1, and Telegram macOS <7.1 are affected by a Heap Buffer Overflow in the LOTGradient::populate function of their custom fork of the rlottie library. A remote attacker might be able to access heap memory out-of-bounds on a victim device via a malicious animated sticker.\n\n- CVE-2021-31323: Telegram Android <7.1.0 (2090), Telegram iOS <7.1, and Telegram macOS <7.1 are affected by a Heap Buffer Overflow in the LottieParserImpl::parseDashProperty function of their custom fork of the rlottie library. A remote attacker might be able to access heap memory out-of-bounds on a victim device via a malicious animated sticker.\n\n- CVE-2021-31598: An issue was discovered in libezxml.a in ezXML 0.8.6. The function ezxml_decode() performs incorrect memory handling while parsing crafted XML files, leading to a heap-based buffer overflow.\n\n- CVE-2021-32136: Heap buffer overflow in the print_udta function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.\n\n- CVE-2021-32137: Heap buffer overflow in the URL_GetProtocolType function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.\n\n- CVE-2021-32263: ok-file-formats through 2021-04-29 has a heap-based buffer overflow in the ok_csv_circular_buffer_read function in ok_csv.c.\n\n- CVE-2021-3246: A heap buffer overflow vulnerability in msadpcm_decode_block of libsndfile 1.0.30 allows attackers to execute arbitrary code via a crafted WAV file.\n\n- CVE-2021-32484: In modem 2G RRM, there is a possible system crash due to a heap buffer overflow. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: MOLY00500621; Issue ID: ALPS04964917.\n\n- CVE-2021-32485: In modem 2G RRM, there is a possible system crash due to a heap buffer overflow. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: MOLY00500621; Issue ID: ALPS04964926.\n\n- CVE-2021-32486: In modem 2G RRM, there is a possible system crash due to a heap buffer overflow. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: MOLY00500621; Issue ID: ALPS04964928.\n\n- CVE-2021-32487: In modem 2G RRM, there is a possible system crash due to a heap buffer overflow. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: MOLY00500736; Issue ID: ALPS04938456.\n\n- CVE-2021-32493: A flaw was found in djvulibre-3.5.28 and earlier. A heap buffer overflow in function DJVU::GBitmap::decode() via crafted djvu file may lead to application crash and other consequences.\n\n- CVE-2021-33000: Parsing a maliciously crafted project file may cause a heap-based buffer overflow, which may allow an attacker to perform arbitrary code execution. User interaction is required on the WebAccess HMI Designer (versions 2.1.9.95 and prior).\n\n- CVE-2021-33023: Advantech WebAccess versions 9.02 and prior are vulnerable to a heap-based buffer overflow, which may allow an attacker to remotely execute code.\n\n- CVE-2021-33285: In NTFS-3G versions < 2021.8.22, when a specially crafted NTFS attribute is supplied to the function ntfs_get_attribute_value, a heap buffer overflow can occur allowing for memory disclosure or denial of service. The vulnerability is caused by an out-of-bound buffer access which can be triggered by mounting a crafted ntfs partition. The root cause is a missing consistency check after reading an MFT record : the \"bytes_in_use\" field should be less than the \"bytes_allocated\" field. When it is not, the parsing of the records proceeds into the wild.\n\n- CVE-2021-33286: In NTFS-3G versions < 2021.8.22, when a specially crafted unicode string is supplied in an NTFS image a heap buffer overflow can occur and allow for code execution.\n\n- CVE-2021-33287: In NTFS-3G versions < 2021.8.22, when specially crafted NTFS attributes are read in the function ntfs_attr_pread_i, a heap buffer overflow can occur and allow for writing to arbitrary memory or denial of service of the application.\n\n- CVE-2021-33289: In NTFS-3G versions < 2021.8.22, when a specially crafted MFT section is supplied in an NTFS image a heap buffer overflow can occur and allow for code execution.\n\n- CVE-2021-3345: _gcry_md_block_write in cipher/hash-common.c in Libgcrypt version 1.9.0 has a heap-based buffer overflow when the digest final function sets a large count value. It is recommended to upgrade to 1.9.1 or later.\n\n- CVE-2021-33485: CODESYS Control Runtime system before 3.5.17.10 has a Heap-based Buffer Overflow.\n\n- CVE-2021-3404: In ytnef 1.9.3, the SwapWord function in lib/ytnef.c allows remote attackers to cause a denial-of-service (and potentially code execution) due to a heap buffer overflow which can be triggered via a crafted file.\n\n- CVE-2021-3405: A flaw was found in libebml before 1.4.2. A heap overflow bug exists in the implementation of EbmlString::ReadData and EbmlUnicodeString::ReadData in libebml.\n\n- CVE-2021-34067: Heap based buffer overflow in tsMuxer 2.6.16 allows attackers to cause a Denial of Service (DoS) by running the application with a crafted file.\n\n- CVE-2021-34068: Heap based buffer overflow in tsMuxer 2.6.16 allows attackers to cause a Denial of Service (DoS) by running the application with a crafted file.\n\n- CVE-2021-34071: Heap based buffer overflow in tsMuxer 2.6.16 allows attackers to cause a Denial of Service (DoS) by running the application with a crafted file.\n\n- CVE-2021-34373: Trusty trusted Linux kernel (TLK) contains a vulnerability in the NVIDIA TLK kernel where a lack of heap hardening could cause heap overflows, which might lead to information disclosure and denial of service.\n\n- CVE-2021-34380: Bootloader contains a vulnerability in NVIDIA MB2 where potential heap overflow might cause corruption of the heap metadata, which might lead to arbitrary code execution, denial of service, and information disclosure during secure boot.\n\n- CVE-2021-34383: Bootloader contains a vulnerability in NVIDIA MB2 where a potential heap overflow might lead to denial of service or escalation of privileges.\n\n- CVE-2021-34384: Bootloader contains a vulnerability in NVIDIA MB2 where a potential heap overflow could cause memory corruption, which might lead to denial of service or code execution.\n\n- CVE-2021-34388: Bootloader contains a vulnerability in NVIDIA TegraBoot where a potential heap overflow might allow an attacker to control all the RAM after the heap block, leading to denial of service or code execution.\n\n- CVE-2021-3470: A heap overflow issue was found in Redis in versions before 5.0.10, before 6.0.9 and before 6.2.0 when using a heap allocator other than jemalloc or glibc's malloc, leading to potential out of bound write or process crash. Effectively this flaw does not affect the vast majority of users, who use jemalloc or glibc malloc.\n\n- CVE-2021-3491: The io_uring subsystem in the Linux kernel allowed the MAX_RW_COUNT limit to be bypassed in the PROVIDE_BUFFERS operation, which led to negative values being usedin mem_rw when reading /proc/<PID>/mem. This could be used to create a heap overflow leading to arbitrary code execution in the kernel. It was addressed via commit d1f82808877b (\"io_uring: truncate lengths larger than MAX_RW_COUNT on provide buffers\") (v5.13-rc1) and backported to the stable kernels in v5.12.4, v5.11.21, and v5.10.37. It was introduced in ddf0322db79c (\"io_uring: add IORING_OP_PROVIDE_BUFFERS\") (v5.7-rc1).\n\n- CVE-2021-3496: A heap-based buffer overflow was found in jhead in version 3.06 in Get16u() in exif.c when processing a crafted file.\n\n- CVE-2021-3498: GStreamer before 1.18.4 might cause heap corruption when parsing certain malformed Matroska files.\n\n- CVE-2021-3507: A heap buffer overflow was found in the floppy disk emulator of QEMU up to 6.0.0 (including). It could occur in fdctrl_transfer_handler() in hw/block/fdc.c while processing DMA read data transfers from the floppy drive to the guest system. A privileged guest user could use this flaw to crash the QEMU process on the host resulting in DoS scenario, or potential information leakage from the host memory.\n\n- CVE-2021-35266: In NTFS-3G versions < 2021.8.22, when a specially crafted NTFS inode pathname is supplied in an NTFS image a heap buffer overflow can occur resulting in memory disclosure, denial of service and even code execution.\n\n- CVE-2021-35268: In NTFS-3G versions < 2021.8.22, when a specially crafted NTFS inode is loaded in the function ntfs_inode_real_open, a heap buffer overflow can occur allowing for code execution and escalation of privileges.\n\n- CVE-2021-35269: NTFS-3G versions < 2021.8.22, when a specially crafted NTFS attribute from the MFT is setup in the function ntfs_attr_setup_flag, a heap buffer overflow can occur allowing for code execution and escalation of privileges.\n\n- CVE-2021-35344: tsMuxer v2.6.16 was discovered to contain a heap-based buffer overflow via the function BitStreamReader::getCurVal in bitStream.h.\n\n- CVE-2021-35346: tsMuxer v2.6.16 was discovered to contain a heap-based buffer overflow via the function HevcSpsUnit::short_term_ref_pic_set(int) in hevc.cpp.\n\n- CVE-2021-35392: Realtek Jungle SDK version v2.x up to v3.4.14B provides a 'WiFi Simple Config' server that implements both UPnP and SSDP protocols. The binary is usually named wscd or mini_upnpd and is the successor to miniigd. The server is vulnerable to a heap buffer overflow that is present due to unsafe crafting of SSDP NOTIFY messages from received M-SEARCH messages ST header.\n\n- CVE-2021-36065: Adobe Photoshop versions 21.2.10 (and earlier) and 22.4.3 (and earlier) are affected by a heap-based buffer overflow vulnerability that could result in arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-36073: Adobe Bridge version 11.1 (and earlier) is affected by a heap-based buffer overflow vulnerability when parsing a crafted .SGI file. An attacker could leverage this vulnerability to execute code in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-36089: Grok 7.6.6 through 9.2.0 has a heap-based buffer overflow in grk::FileFormatDecompress::apply_palette_clr (called from grk::FileFormatDecompress::applyColour).\n\n- CVE-2021-3625: Buffer overflow in Zephyr USB DFU DNLOAD. Zephyr versions >= v2.5.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-c3gr-hgvr-f363\n\n- CVE-2021-3634: A flaw has been found in libssh in versions prior to 0.9.6. The SSH protocol keeps track of two shared secrets during the lifetime of the session. One of them is called secret_hash and the other session_id. Initially, both of them are the same, but after key re-exchange, previous session_id is kept and used as an input to new secret_hash. Historically, both of these buffers had shared length variable, which worked as long as these buffers were same. But the key re-exchange operation can also change the key exchange method, which can be based on hash of different size, eventually creating \"secret_hash\" of different size than the session_id has. This becomes an issue when the session_id memory is zeroed or when it is used again during second key re-exchange.\n\n- CVE-2021-36530: ngiflib 0.4 has a heap overflow in GetByteStr() at ngiflib.c:108 in NGIFLIB_NO_FILE mode, GetByteStr() copy memory buffer without checking the boundary.\n\n- CVE-2021-36531: ngiflib 0.4 has a heap overflow in GetByte() at ngiflib.c:70 in NGIFLIB_NO_FILE mode, GetByte() reads memory buffer without checking the boundary.\n\n- CVE-2021-36584: An issue was discovered in GPAC 1.0.1. There is a heap-based buffer overflow in the function gp_rtp_builder_do_tx3g function in ietf/rtp_pck_3gpp.c, as demonstrated by MP4Box. This can cause a denial of service (DOS).\n\n- CVE-2021-36977: matio (aka MAT File I/O Library) 1.5.20 and 1.5.21 has a heap-based buffer overflow in H5MM_memcpy (called from H5MM_malloc and H5C_load_entry), related to use of HDF5 1.12.0.\n\n- CVE-2021-36978: QPDF 9.x through 9.1.1 and 10.x through 10.0.4 has a heap-based buffer overflow in Pl_ASCII85Decoder::write (called from Pl_AES_PDF::flush and Pl_AES_PDF::finish) when a certain downstream write fails.\n\n- CVE-2021-37022: There is a Heap-based Buffer Overflow vulnerability in Huawei Smartphone.Successful exploitation of this vulnerability will cause root permission which can be escalated.\n\n- CVE-2021-3756: libmysofa is vulnerable to Heap-based Buffer Overflow\n\n- CVE-2021-37650: TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.ExperimentalDatasetToTFRecord` and `tf.raw_ops.DatasetToTFRecord` can trigger heap buffer overflow and segmentation fault. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/data/experimental/to_tf_record_op.cc#L93-L102) assumes that all records in the dataset are of string type. However, there is no check for that, and the example given above uses numeric types. We have patched the issue in GitHub commit e0b6e58c328059829c3eb968136f17aa72b6c876. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.\n\n- CVE-2021-3770: vim is vulnerable to Heap-based Buffer Overflow\n\n- CVE-2021-37978: Heap buffer overflow in Blink in Google Chrome prior to 94.0.4606.81 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37979: heap buffer overflow in WebRTC in Google Chrome prior to 94.0.4606.81 allowed a remote attacker who convinced a user to browse to a malicious website to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37981: Heap buffer overflow in Skia in Google Chrome prior to 95.0.4638.54 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2021-37984: Heap buffer overflow in PDFium in Google Chrome prior to 95.0.4638.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-38098: Corel PDF Fusion 2.6.2.0 is affected by a Heap Corruption vulnerability when parsing a crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious PDF file.\n\n- CVE-2021-38592: Wasm3 0.5.0 has a heap-based buffer overflow in op_Const64 (called from EvaluateExpression and m3_LoadModule).\n\n- CVE-2021-38614: Polipo through 1.1.1, when NDEBUG is used, allows a heap-based buffer overflow during parsing of a Range header. NOTE: This vulnerability only affects products that are no longer supported by the maintainer\n\n- CVE-2021-39256: A crafted NTFS image can cause a heap-based buffer overflow in ntfs_inode_lookup_by_name in NTFS-3G < 2021.8.22.\n\n- CVE-2021-39261: A crafted NTFS image can cause a heap-based buffer overflow in ntfs_compressed_pwrite in NTFS-3G < 2021.8.22.\n\n- CVE-2021-39518: An issue was discovered in libjpeg through 2020021. LineBuffer::FetchRegion() in linebuffer.cpp has a heap-based buffer overflow.\n\n- CVE-2021-39522: An issue was discovered in libredwg through v0.10.1.3751. bit_wcs2len() in bits.c has a heap-based buffer overflow.\n\n- CVE-2021-39525: An issue was discovered in libredwg through v0.10.1.3751. bit_read_fixed() in bits.c has a heap-based buffer overflow.\n\n- CVE-2021-39527: An issue was discovered in libredwg through v0.10.1.3751. appinfo_private() in decode.c has a heap-based buffer overflow.\n\n- CVE-2021-39530: An issue was discovered in libredwg through v0.10.1.3751. bit_wcs2nlen() in bits.c has a heap-based buffer overflow.\n\n- CVE-2021-39533: An issue was discovered in libslax through v0.22.1. slaxLexer() in slaxlexer.c has a heap-based buffer overflow.\n\n- CVE-2021-39534: An issue was discovered in libslax through v0.22.1. slaxIsCommentStart() in slaxlexer.c has a heap-based buffer overflow.\n\n- CVE-2021-39536: An issue was discovered in libxsmm through v1.16.1-93. The JIT code has a heap-based buffer overflow.\n\n- CVE-2021-39537: An issue was discovered in ncurses through v6.2-1. _nc_captoinfo in captoinfo.c has a heap-based buffer overflow.\n\n- CVE-2021-39544: An issue was discovered in sela through 20200412. file::WavFile::writeToFile() in wav_file.c has a heap-based buffer overflow.\n\n- CVE-2021-39546: An issue was discovered in sela through 20200412. rice::RiceDecoder::process() in rice_decoder.cpp has a heap-based buffer overflow.\n\n- CVE-2021-39550: An issue was discovered in sela through 20200412. file::SelaFile::readFromFile() in sela_file.cpp has a heap-based buffer overflow.\n\n- CVE-2021-39551: An issue was discovered in sela through 20200412. file::SelaFile::readFromFile() in sela_file.c has a heap-based buffer overflow.\n\n- CVE-2021-39552: An issue was discovered in sela through 20200412. file::WavFile::readFromFile() in wav_file.c has a heap-based buffer overflow.\n\n- CVE-2021-3968: vim is vulnerable to Heap-based Buffer Overflow\n\n- CVE-2021-3973: vim is vulnerable to Heap-based Buffer Overflow\n\n- CVE-2020-12895: Pool/Heap Overflow in AMD Graphics Driver for Windows 10 in Escape 0x110037 may lead to escalation of privilege, information disclosure or denial of service.\n\n- CVE-2020-13600: Malformed SPI in response for eswifi can corrupt kernel memory. Zephyr versions >= 1.14.2, >= 2.3.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-hx4p-j86p-2mhr\n\n- CVE-2020-18735: A heap buffer overflow in /src/dds_stream.c of Eclipse IOT Cyclone DDS Project v0.1.0 causes the DDS subscriber server to crash.\n\n- CVE-2020-19721: A heap buffer overflow vulnerability in Ap4TrunAtom.cpp of Bento 1.5.1-628 may lead to an out-of-bounds write while running mp42aac, leading to system crashes and a denial of service (DOS).\n\n- CVE-2020-21547: Libsixel 1.8.2 contains a heap-based buffer overflow in the dither_func_fs function in tosixel.c.\n\n- CVE-2020-21548: Libsixel 1.8.3 contains a heap-based buffer overflow in the sixel_encode_highcolor function in tosixel.c.\n\n- CVE-2020-21594: libde265 v1.0.4 contains a heap buffer overflow in the put_epel_hv_fallback function, which can be exploited via a crafted a file.\n\n- CVE-2020-21595: libde265 v1.0.4 contains a heap buffer overflow in the mc_luma function, which can be exploited via a crafted a file.\n\n- CVE-2020-21597: libde265 v1.0.4 contains a heap buffer overflow in the mc_chroma function, which can be exploited via a crafted a file.\n\n- CVE-2020-21598: libde265 v1.0.4 contains a heap buffer overflow in the ff_hevc_put_unweighted_pred_8_sse function, which can be exploited via a crafted a file.\n\n- CVE-2020-21599: libde265 v1.0.4 contains a heap buffer overflow in the de265_image::available_zscan function, which can be exploited via a crafted a file.\n\n- CVE-2020-21603: libde265 v1.0.4 contains a heap buffer overflow in the put_qpel_0_0_fallback_16 function, which can be exploited via a crafted a file.\n\n- CVE-2020-21604: libde265 v1.0.4 contains a heap buffer overflow fault in the _mm_loadl_epi64 function, which can be exploited via a crafted a file.\n\n- CVE-2020-21813: A heap based buffer overflow issue exists in GNU LibreDWG 0.10.2641 via output_TEXT ../../programs/dwg2SVG.c:114.\n\n- CVE-2020-21836: A heap based buffer overflow vulnerability exists in GNU LibreDWG 0.10 via read_2004_section_preview ../../src/decode.c:3175.\n\n- CVE-2021-44143: A flaw was found in mbsync in isync 1.4.0 through 1.4.3. Due to an unchecked condition, a malicious or compromised IMAP server could use a crafted mail message that lacks headers (i.e., one that starts with an empty line) to provoke a heap overflow, which could conceivably be exploited for remote code execution.\n\n- CVE-2021-42327: dp_link_settings_write in drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c in the Linux kernel through 5.14.14 allows a heap-based buffer overflow by an attacker who can write a string to the AMD GPU display drivers debug filesystem. There are no checks on size within parse_write_buffer_into_params when it uses the size of copy_from_user to copy a userspace buffer into a 40-byte heap buffer.\n\n- CVE-2021-31610: The Bluetooth Classic implementation on AB32VG1 devices does not properly handle the reception of continuous unsolicited LMP responses, allowing attackers in radio range to trigger a denial of service (either restart or deadlock the device) by flooding a device with LMP_AU_rand data.\n\n- CVE-2021-34143: The Bluetooth Classic implementation in the Zhuhai Jieli AC6366C_DEMO_V1.0 does not properly handle the reception of continuous unsolicited LMP responses, allowing attackers in radio range to trigger a denial of service (deadlock) of the device by flooding it with LMP_AU_Rand packets after paging procedure. User intervention is required to restart the device.\n\n- CVE-2021-34149: The Bluetooth Classic implementation on the Texas Instruments CC256XCQFN-EM does not properly handle the reception of continuous LMP_AU_Rand packets, allowing attackers in radio range to trigger a denial of service (deadlock) of the device by flooding it with LMP_AU_Rand packets after the paging procedure.\n\n- CVE-2020-28022: Exim 4 before 4.94.2 has Improper Restriction of Write Operations within the Bounds of a Memory Buffer. This occurs when processing name=value pairs within MAIL FROM and RCPT TO commands.\n\n- CVE-2021-22335: There is a Memory Buffer Improper Operation Limit vulnerability in Huawei Smartphone. Successful exploitation of this vulnerability may cause exceptions in image processing.\n\n- CVE-2021-32020: The kernel in Amazon Web Services FreeRTOS before 10.4.3 has insufficient bounds checking during management of heap memory.\n\n- CVE-2021-34326: A vulnerability has been identified in JT2Go (All versions < V13.2), Solid Edge SE2021 (All Versions < SE2021MP5), Teamcenter Visualization (All versions < V13.2). The plmxmlAdapterSE70.dll library in affected applications lacks proper validation of user-supplied data when parsing PAR files. This could result in an out of bounds write past the fixed-length heap-based buffer. An attacker could leverage this vulnerability to execute code in the context of the current process. (ZDI-CAN-13422)\n\n- CVE-2021-43247: Windows TCP/IP Driver Elevation of Privilege Vulnerability\n\n- CVE-2020-23273: Heap-buffer overflow in the randomize_iparp function in edit_packet.c. of Tcpreplay v4.3.2 allows attackers to cause a denial of service (DOS) via a crafted pcap.\n\n- CVE-2020-23873: pdf2xml v2.0 was discovered to contain a heap-buffer overflow in the function TextPage::dump.\n\n- CVE-2020-23874: pdf2xml v2.0 was discovered to contain a heap-buffer overflow in the function TextPage::addAttributsNode.\n\n- CVE-2021-46790: ntfsck in NTFS-3G through 2021.8.22 has a heap-based buffer overflow involving buffer+512*3-2. NOTE: the upstream position is that ntfsck is deprecated; however, it is shipped by some Linux distributions.\n\n- CVE-2020-15999: Heap buffer overflow in Freetype in Google Chrome prior to 86.0.4240.111 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2020-16010: Heap buffer overflow in UI in Google Chrome on Android prior to 86.0.4240.185 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2020-16013: Inappropriate implementation in V8 in Google Chrome prior to 86.0.4240.198 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2020-9819: A memory consumption issue was addressed with improved memory handling. This issue is fixed in iOS 13.5 and iPadOS 13.5, iOS 12.4.7, watchOS 6.2.5, watchOS 5.3.7. Processing a maliciously crafted mail message may lead to heap corruption.\n\n- CVE-2020-1027: An elevation of privilege vulnerability exists in the way that the Windows Kernel handles objects in memory, aka 'Windows Kernel Elevation of Privilege Vulnerability'. This CVE ID is unique from CVE-2020-0913, CVE-2020-1000, CVE-2020-1003.\n\n- CVE-2021-20043: A Heap-based buffer overflow vulnerability in SonicWall SMA100 getBookmarks method allows a remote authenticated attacker to potentially execute code as the nobody user in the appliance. This vulnerability affected SMA 200, 210, 400, 410 and 500v appliances.\n\n- CVE-2021-21793: An out-of-bounds write vulnerability exists in the JPG sof_nb_comp header processing functionality of Accusoft ImageGear 19.8 and 19.9. A specially crafted malformed file can lead to memory corruption. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21962: A heap-based buffer overflow vulnerability exists in the OTA Update u-download functionality of Sealevel Systems, Inc. SeaConnect 370W v1.3.34. A series of specially-crafted MQTT payloads can lead to remote code execution. An attacker must perform a man-in-the-middle attack in order to trigger this vulnerability.\n\n- CVE-2021-23157: WECON LeviStudioU Versions 2019-09-21 and prior are vulnerable to a heap-based buffer overflow, which may allow an attacker to remotely execute code.\n\n- CVE-2021-23165: A flaw was found in htmldoc before v1.9.12. Heap buffer overflow in pspdf_prepare_outpages(), in ps-pdf.cxx may lead to execute arbitrary code and denial of service.\n\n- CVE-2021-23169: A heap-buffer overflow was found in the copyIntoFrameBuffer function of OpenEXR in versions before 3.0.1. An attacker could use this flaw to execute arbitrary code with the permissions of the user running the application compiled against OpenEXR.\n\n- CVE-2021-26252: A flaw was found in htmldoc in v1.9.12. Heap buffer overflow in pspdf_prepare_page(),in ps-pdf.cxx may lead to execute arbitrary code and denial of service.\n\n- CVE-2021-26259: A flaw was found in htmldoc in v1.9.12. Heap buffer overflow in render_table_row(),in ps-pdf.cxx may lead to arbitrary code execution and denial of service.\n\n- CVE-2021-28237: LibreDWG v0.12.3 was discovered to contain a heap-buffer overflow via decode_preR13.\n\n- CVE-2021-28277: A Heap-based Buffer Overflow vulnerabilty exists in jhead 3.04 and 3.05 is affected by: Buffer Overflow via the RemoveUnknownSections function in jpgfile.c.\n\n- CVE-2021-28278: A Heap-based Buffer Overflow vulnerability exists in jhead 3.04 and 3.05 via the RemoveSectionType function in jpgfile.c.\n\n- CVE-2021-33657: There is a heap overflow problem in video/SDL_pixels.c in SDL (Simple DirectMedia Layer) 2.x to 2.0.18 versions. By crafting a malicious .BMP file, an attacker can cause the application using this library to crash, denial of service or Code execution.\n\n- CVE-2021-33912: libspf2 before 1.2.11 has a four-byte heap-based buffer overflow that might allow remote attackers to execute arbitrary code (via an unauthenticated e-mail message from anywhere on the Internet) with a crafted SPF DNS record, because of incorrect sprintf usage in SPF_record_expand_data in spf_expand.c. The vulnerable code may be part of the supply chain of a site's e-mail infrastructure (e.g., with additional configuration, Exim can use libspf2; the Postfix web site links to unofficial patches for use of libspf2 with Postfix; older versions of spfquery relied on libspf2) but most often is not.\n\n- CVE-2021-33913: libspf2 before 1.2.11 has a heap-based buffer overflow that might allow remote attackers to execute arbitrary code (via an unauthenticated e-mail message from anywhere on the Internet) with a crafted SPF DNS record, because of SPF_record_expand_data in spf_expand.c. The amount of overflowed data depends on the relationship between the length of an entire domain name and the length of its leftmost label. The vulnerable code may be part of the supply chain of a site's e-mail infrastructure (e.g., with additional configuration, Exim can use libspf2; the Postfix web site links to unofficial patches for use of libspf2 with Postfix; older versions of spfquery relied on libspf2) but most often is not.\n\n- CVE-2021-34583: Crafted web server requests may cause a heap-based buffer overflow and could therefore trigger a denial-of- service condition due to a crash in the CODESYS V2 web server prior to V1.1.9.22.\n\n- CVE-2021-3575: A heap-based buffer overflow was found in openjpeg in color.c:379:42 in sycc420_to_rgb when decompressing a crafted .j2k file. An attacker could use this to execute arbitrary code with the permissions of the application compiled against openjpeg.\n\n- CVE-2021-3610: A heap-based buffer overflow vulnerability was found in ImageMagick in versions prior to 7.0.11-14 in ReadTIFFImage() in coders/tiff.c. This issue is due to an incorrect setting of the pixel array size, which can lead to a crash and segmentation fault.\n\n- CVE-2021-36173: A heap-based buffer overflow in the firmware signature verification function of FortiOS versions 7.0.1, 7.0.0, 6.4.0 through 6.4.6, 6.2.0 through 6.2.9, and 6.0.0 through 6.0.13 may allow an attacker to execute arbitrary code via specially crafted installation images.\n\n- CVE-2021-36412: A heap-based buffer overflow vulnerability exists in MP4Box in GPAC 1.0.1 via the gp_rtp_builder_do_mpeg12_video function, which allows attackers to possibly have unspecified other impact via a crafted file in the MP4Box command,\n\n- CVE-2021-36417: A heap-based buffer overflow vulnerability exists in GPAC v1.0.1 in the gf_isom_dovi_config_get function in MP4Box, which causes a denial of service or execute arbitrary code via a crafted file.\n\n- CVE-2021-37049: There is a Heap-based buffer overflow vulnerability in Huawei Smartphone.Successful exploitation of this vulnerability may rewrite the memory of adjacent objects.\n\n- CVE-2021-38013: Heap buffer overflow in fingerprint recognition in Google Chrome on ChromeOS prior to 96.0.4664.45 allowed a remote attacker who had compromised a WebUI renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2021-3835: Buffer overflow in usb device class. Zephyr versions >= v2.6.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-fm6v-8625-99jf\n\n- CVE-2021-3861: The RNDIS USB device class includes a buffer overflow vulnerability. Zephyr versions >= v2.6.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-hvfp-w4h8-gxvj\n\n- CVE-2021-39665: In checkSpsUpdated of AAVCAssembler.cpp, there is a possible out of bounds read due to a heap buffer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-12Android ID: A-204077881\n\n- CVE-2021-39667: In ih264d_parse_decode_slice of ih264d_parse_slice.c, there is a possible out of bounds write due to a heap buffer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12Android ID: A-205702093\n\n- CVE-2021-39675: In GKI_getbuf of gki_buffer.cc, there is a possible out of bounds write due to a heap buffer overflow. This could lead to remote escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-12Android ID: A-205729183\n\n- CVE-2021-39996: There is a Heap-based buffer overflow vulnerability with the NFC module in smartphones. Successful exploitation of this vulnerability may cause memory overflow.\n\n- CVE-2021-40010: The bone voice ID TA has a heap overflow vulnerability.Successful exploitation of this vulnerability may result in malicious code execution.\n\n- CVE-2021-40014: The bone voice ID trusted application (TA) has a heap overflow vulnerability. Successful exploitation of this vulnerability may affect data confidentiality. \n\n- CVE-2021-40026: There is a Heap-based buffer overflow vulnerability in the AOD module in smartphones. Successful exploitation of this vulnerability may affect service integrity.\n\n- CVE-2021-40058: There is a heap-based buffer overflow vulnerability in the video framework. Successful exploitation of this vulnerability may affect availability.\n\n- CVE-2021-40060: There is a heap-based buffer overflow vulnerability in the video framework. Successful exploitation of this vulnerability may affect availability.\n\n- CVE-2021-40064: There is a heap-based buffer overflow vulnerability in system components. Successful exploitation of this vulnerability may affect system stability.\n\n- CVE-2021-40164: A heap-based buffer overflow could occur while parsing TIFF, PICT, TGA, or RLC files. This vulnerability may be exploited to execute arbitrary code.\n\n- CVE-2021-4055: Heap buffer overflow in extensions in Google Chrome prior to 96.0.4664.93 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2021-4058: Heap buffer overflow in ANGLE in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4062: Heap buffer overflow in BFCache in Google Chrome prior to 96.0.4664.93 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4079: Out of bounds write in WebRTC in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via crafted WebRTC packets.\n\n- CVE-2021-4101: Heap buffer overflow in Swiftshader in Google Chrome prior to 96.0.4664.110 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-41017: Multiple heap-based buffer overflow vulnerabilities in some web API controllers of FortiWeb 6.4.1, 6.4.0, and 6.3.0 through 6.3.15 may allow a remote authenticated attacker to execute arbitrary code or commands via specifically crafted HTTP requests.\n\n- CVE-2021-41396: Live555 through 1.08 does not handle socket connections properly. A huge number of incoming socket connections in a short time invokes the error-handling module, in which a heap-based buffer overflow happens. An attacker can leverage this to launch a DoS attack.\n\n- CVE-2021-41736: Faust v2.35.0 was discovered to contain a heap-buffer overflow in the function realPropagate() at propagate.cpp.\n\n- CVE-2021-41987: In the SCEP Server of RouterOS in certain Mikrotik products, an attacker can trigger a heap-based buffer overflow that leads to remote code execution. The attacker must know the scep_server_name value. This affects RouterOS 6.46.8, 6.47.9, and 6.47.10.\n\n- CVE-2021-4214: A heap overflow flaw was found in libpngs' pngimage.c program. This flaw allows an attacker with local network access to pass a specially crafted PNG file to the pngimage utility, causing an application to crash, leading to a denial of service.\n\n- CVE-2021-42199: An issue was discovered in swftools through 20201222. A heap buffer overflow exists in the function swf_FontExtract_DefineTextCallback() located in swftext.c. It allows an attacker to cause code execution.\n\n- CVE-2021-42585: A heap buffer overflow was discovered in copy_compressed_bytes in decode_r2007.c in dwgread before 0.12.4 via a crafted dwg file.\n\n- CVE-2021-42586: A heap buffer overflow was discovered in copy_bytes in decode_r2007.c in dwgread before 0.12.4 via a crafted dwg file.\n\n- CVE-2021-42739: The firewire subsystem in the Linux kernel through 5.14.13 has a buffer overflow related to drivers/media/firewire/firedtv-avc.c and drivers/media/firewire/firedtv-ci.c, because avc_ca_pmt mishandles bounds checking.\n\n- CVE-2021-42781: Heap buffer overflow issues were found in Opensc before version 0.22.0 in pkcs15-oberthur.c that could potentially crash programs using the library.\n\n- CVE-2021-43071: A heap-based buffer overflow in Fortinet FortiWeb version 6.4.1 and 6.4.0, version 6.3.15 and below, version 6.2.6 and below allows attacker to execute unauthorized code or commands via crafted HTTP requests to the LogReport API controller.\n\n- CVE-2021-43304: Heap buffer overflow in Clickhouse's LZ4 compression codec when parsing a malicious query. There is no verification that the copy operations in the LZ4::decompressImpl loop and especially the arbitrary copy operation wildCopy<copy_amount>(op, ip, copy_end), don\u2019t exceed the destination buffer\u2019s limits.\n\n- CVE-2021-43305: Heap buffer overflow in Clickhouse's LZ4 compression codec when parsing a malicious query. There is no verification that the copy operations in the LZ4::decompressImpl loop and especially the arbitrary copy operation wildCopy<copy_amount>(op, ip, copy_end), don\u2019t exceed the destination buffer\u2019s limits. This issue is very similar to CVE-2021-43304, but the vulnerable copy operation is in a different wildCopy call.\n\n- CVE-2021-43311: A heap-based buffer overflow was discovered in upx, during the generic pointer 'p' points to an inaccessible address in func get_le32(). The problem is essentially caused in PackLinuxElf32::elf_lookup() at p_lx_elf.cpp:5382.\n\n- CVE-2021-43312: A heap-based buffer overflow was discovered in upx, during the variable 'bucket' points to an inaccessible address. The issue is being triggered in the function PackLinuxElf64::invert_pt_dynamic at p_lx_elf.cpp:5239.\n\n- CVE-2021-43313: A heap-based buffer overflow was discovered in upx, during the variable 'bucket' points to an inaccessible address. The issue is being triggered in the function PackLinuxElf32::invert_pt_dynamic at p_lx_elf.cpp:1688.\n\n- CVE-2021-43314: A heap-based buffer overflows was discovered in upx, during the generic pointer 'p' points to an inaccessible address in func get_le32(). The problem is essentially caused in PackLinuxElf32::elf_lookup() at p_lx_elf.cpp:5368\n\n- CVE-2021-43315: A heap-based buffer overflows was discovered in upx, during the generic pointer 'p' points to an inaccessible address in func get_le32(). The problem is essentially caused in PackLinuxElf32::elf_lookup() at p_lx_elf.cpp:5349\n\n- CVE-2021-43316: A heap-based buffer overflow was discovered in upx, during the generic pointer 'p' points to an inaccessible address in func get_le64().\n\n- CVE-2021-43317: A heap-based buffer overflows was discovered in upx, during the generic pointer 'p' points to an inaccessible address in func get_le32(). The problem is essentially caused in PackLinuxElf64::elf_lookup() at p_lx_elf.cpp:5404\n\n- CVE-2021-43527: NSS (Network Security Services) versions prior to 3.73 or 3.68.1 ESR are vulnerable to a heap overflow when handling DER-encoded DSA or RSA-PSS signatures. Applications using NSS for handling signatures encoded within CMS, S/MIME, PKCS \\\\#7, or PKCS \\\\#12 are likely to be impacted. Applications using NSS for certificate validation or other TLS, X.509, OCSP or CRL functionality may be impacted, depending on how they configure NSS. *Note: This vulnerability does NOT impact Mozilla Firefox.* However, email clients and PDF viewers that use NSS for signature verification, such as Thunderbird, LibreOffice, Evolution and Evince are believed to be impacted. This vulnerability affects NSS < 3.73 and NSS < 3.68.1.\n\n- CVE-2021-43529: Thunderbird versions prior to 91.3.0 are vulnerable to the heap overflow described in CVE-2021-43527 when processing S/MIME messages. Thunderbird versions 91.3.0 and later will not call the vulnerable code when processing S/MIME messages that contain certificates with DER-encoded DSA or RSA-PSS signatures.\n\n- CVE-2021-44648: GNOME gdk-pixbuf 2.42.6 is vulnerable to a heap-buffer overflow vulnerability when decoding the lzw compressed stream of image data in GIF files with lzw minimum code size equals to 12.\n\n- CVE-2021-44708: Acrobat Reader DC version 21.007.20099 (and earlier), 20.004.30017 (and earlier) and 17.011.30204 (and earlier) are affected by a heap overflow vulnerability due to insecure handling of a crafted file, potentially resulting in arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-44709: Acrobat Reader DC version 21.007.20099 (and earlier), 20.004.30017 (and earlier) and 17.011.30204 (and earlier) are affected by a heap overflow vulnerability due to insecure handling of a crafted file, potentially resulting in arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-44956: Two Heap based buffer overflow vulnerabilities exist in ffjpeg through 01.01.2021. It is similar to CVE-2020-23852. Issues that are in the jfif_decode function at ffjpeg/src/jfif.c (line 552) could cause a Denial of Service by using a crafted jpeg file.\n\n- CVE-2021-45005: Artifex MuJS v1.1.3 was discovered to contain a heap buffer overflow which is caused by conflicting JumpList of nested try/finally statements.\n\n- CVE-2021-45078: stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact, as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.\n\n- CVE-2021-45417: AIDE before 0.17.4 allows local users to obtain root privileges via crafted file metadata (such as XFS extended attributes or tmpfs ACLs), because of a heap-based buffer overflow.\n\n- CVE-2021-45830: A heap-based buffer overflow vulnerability exists in HDF5 1.13.1-1 via H5F_addr_decode_len in /hdf5/src/H5Fint.c, which could cause a Denial of Service.\n\n- CVE-2021-45863: tsMuxer git-2678966 was discovered to contain a heap-based buffer overflow via the function HevcUnit::updateBits in hevc.cpp.\n\n- CVE-2021-45909: An issue was discovered in gif2apng 1.9. There is a heap-based buffer overflow vulnerability in the DecodeLZW function. It allows an attacker to write a large amount of arbitrary data outside the boundaries of a buffer.\n\n- CVE-2021-45910: An issue was discovered in gif2apng 1.9. There is a heap-based buffer overflow within the main function. It allows an attacker to write data outside of the allocated buffer. The attacker has control over a part of the address that data is written to, control over the written data, and (to some extent) control over the amount of data that is written.\n\n- CVE-2021-45911: An issue was discovered in gif2apng 1.9. There is a heap-based buffer overflow in the main function. It allows an attacker to write 2 bytes outside the boundaries of the buffer.\n\n- CVE-2021-45932: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow (4 bytes) in MqttDecode_Publish (called from MqttClient_DecodePacket and MqttClient_HandlePacket).\n\n- CVE-2021-45933: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow (8 bytes) in MqttDecode_Publish (called from MqttClient_DecodePacket and MqttClient_HandlePacket).\n\n- CVE-2021-45934: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttClient_DecodePacket (called from MqttClient_HandlePacket and MqttClient_WaitType).\n\n- CVE-2021-45935: Grok 9.5.0 has a heap-based buffer overflow in openhtj2k::T1OpenHTJ2K::decompress (called from std::__1::__packaged_task_func<std::__1::__bind<grk::T1DecompressScheduler::deco and std::__1::packaged_task<int).\n\n- CVE-2021-45936: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttDecode_Disconnect (called from MqttClient_DecodePacket and MqttClient_WaitType).\n\n- CVE-2021-45937: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttClient_DecodePacket (called from MqttClient_WaitType and MqttClient_Connect).\n\n- CVE-2021-45938: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttClient_DecodePacket (called from MqttClient_WaitType and MqttClient_Unsubscribe).\n\n- CVE-2021-45939: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttClient_DecodePacket (called from MqttClient_WaitType and MqttClient_Subscribe).\n\n- CVE-2021-45940: libbpf 0.6.0 and 0.6.1 has a heap-based buffer overflow (4 bytes) in __bpf_object__open (called from bpf_object__open_mem and bpf-object-fuzzer.c).\n\n- CVE-2021-45941: libbpf 0.6.0 and 0.6.1 has a heap-based buffer overflow (8 bytes) in __bpf_object__open (called from bpf_object__open_mem and bpf-object-fuzzer.c).\n\n- CVE-2021-45942: OpenEXR 3.1.x before 3.1.4 has a heap-based buffer overflow in Imf_3_1::LineCompositeTask::execute (called from IlmThread_3_1::NullThreadPoolProvider::addTask and IlmThread_3_1::ThreadPool::addGlobalTask). NOTE: db217f2 may be inapplicable.\n\n- CVE-2021-45943: GDAL 3.3.0 through 3.4.0 has a heap-based buffer overflow in PCIDSK::CPCIDSKFile::ReadFromFile (called from PCIDSK::CPCIDSKSegment::ReadFromFile and PCIDSK::CPCIDSKBinarySegment::CPCIDSKBinarySegment).\n\n- CVE-2021-45948: Open Asset Import Library (aka assimp) 5.1.0 and 5.1.1 has a heap-based buffer overflow in _m3d_safestr (called from m3d_load and Assimp::M3DWrapper::M3DWrapper).\n\n- CVE-2021-45949: Ghostscript GhostPDL 9.50 through 9.54.0 has a heap-based buffer overflow in sampled_data_finish (called from sampled_data_continue and interp).\n\n- CVE-2021-46474: Jsish v3.5.0 was discovered to contain a heap buffer overflow via jsiEvalCodeSub in src/jsiEval.c. This vulnerability can lead to a Denial of Service (DoS).\n\n- CVE-2021-46475: Jsish v3.5.0 was discovered to contain a heap buffer overflow via jsi_ArraySliceCmd in src/jsiArray.c. This vulnerability can lead to a Denial of Service (DoS).\n\n- CVE-2021-46477: Jsish v3.5.0 was discovered to contain a heap buffer overflow via RegExp_constructor in src/jsiRegexp.c. This vulnerability can lead to a Denial of Service (DoS).\n\n- CVE-2021-46478: Jsish v3.5.0 was discovered to contain a heap buffer overflow via jsiClearStack in src/jsiEval.c. This vulnerability can lead to a Denial of Service (DoS).\n\n- CVE-2021-46480: Jsish v3.5.0 was discovered to contain a heap buffer overflow via jsiValueObjDelete in src/jsiEval.c. This vulnerability can lead to a Denial of Service (DoS).\n\n- CVE-2021-46482: Jsish v3.5.0 was discovered to contain a heap buffer overflow via NumberConstructor at src/jsiNumber.c.\n\n- CVE-2021-46483: Jsish v3.5.0 was discovered to contain a heap buffer overflow via BooleanConstructor at src/jsiBool.c.\n\n- CVE-2021-46518: Cesanta MJS v2.20.0 was discovered to contain a heap buffer overflow via mjs_disown at src/mjs_core.c.\n\n- CVE-2021-46519: Cesanta MJS v2.20.0 was discovered to contain a heap buffer overflow via mjs_array_length at src/mjs_array.c.\n\n- CVE-2021-46520: Cesanta MJS v2.20.0 was discovered to contain a heap buffer overflow via mjs_jprintf at src/mjs_util.c.\n\n- CVE-2021-46522: Cesanta MJS v2.20.0 was discovered to contain a heap buffer overflow via /usr/lib/x86_64-linux-gnu/libasan.so.4+0xaff53.\n\n- CVE-2021-46523: Cesanta MJS v2.20.0 was discovered to contain a heap buffer overflow via to_json_or_debug at mjs/src/mjs_json.c.\n\n- CVE-2021-46524: Cesanta MJS v2.20.0 was discovered to contain a heap buffer overflow via snquote at mjs/src/mjs_json.c.\n\n- CVE-2021-46527: Cesanta MJS v2.20.0 was discovered to contain a heap buffer overflow via mjs_get_cstring at src/mjs_string.c.\n\n- CVE-2021-46822: The PPM reader in libjpeg-turbo through 2.0.90 mishandles use of tjLoadImage for loading a 16-bit binary PPM file into a grayscale buffer and loading a 16-bit binary PGM file into an RGB buffer. This is related to a heap-based buffer overflow in the get_word_rgb_row function in rdppm.c.\n\n- CVE-2022-0100: Heap buffer overflow in Media streams API in Google Chrome prior to 97.0.4692.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0101: Heap buffer overflow in Bookmarks in Google Chrome prior to 97.0.4692.71 allowed a remote attacker who convinced a user to perform specific user gesture to potentially exploit heap corruption via specific user gesture.\n\n- CVE-2022-0104: Heap buffer overflow in ANGLE in Google Chrome prior to 97.0.4692.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0137: A heap buffer overflow in image_set_mask function of HTMLDOC before 1.9.15 allows an attacker to write outside the buffer boundaries.\n\n- CVE-2022-0261: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.\n\n- CVE-2022-0306: Heap buffer overflow in PDFium in Google Chrome prior to 97.0.4692.99 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0310: Heap buffer overflow in Task Manager in Google Chrome prior to 97.0.4692.99 allowed a remote attacker to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-0311: Heap buffer overflow in Task Manager in Google Chrome prior to 97.0.4692.99 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0318: Heap-based Buffer Overflow in vim/vim prior to 8.2.\n\n- CVE-2022-0367: A heap-based buffer overflow flaw was found in libmodbus in function modbus_reply() in src/modbus.c.\n\n- CVE-2022-0454: Heap buffer overflow in ANGLE in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0470: Out of bounds memory access in V8 in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0518: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.6.2.\n\n- CVE-2022-0572: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.\n\n- CVE-2022-0604: Heap buffer overflow in Tab Groups in Google Chrome prior to 98.0.4758.102 allowed an attacker who convinced a user to install a malicious extension and engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0610: Inappropriate implementation in Gamepad API in Google Chrome prior to 98.0.4758.102 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0676: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.6.4.\n\n- CVE-2022-0713: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.6.4.\n\n- CVE-2022-0789: Heap buffer overflow in ANGLE in Google Chrome prior to 99.0.4844.51 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0800: Heap buffer overflow in Cast UI in Google Chrome prior to 99.0.4844.51 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0809: Out of bounds memory access in WebXR in Google Chrome prior to 99.0.4844.51 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0891: A heap buffer overflow in ExtractImageSection function in tiffcrop.c in libtiff library Version 4.3.0 allows attacker to trigger unsafe or out of bounds memory access via crafted TIFF image file which could result into application crash, potential information disclosure or any other context-dependent impact\n\n- CVE-2022-0976: Heap buffer overflow in GPU in Google Chrome prior to 99.0.4844.74 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1052: Heap Buffer Overflow in iterate_chained_fixups in GitHub repository radareorg/radare2 prior to 5.6.6.\n\n- CVE-2022-1061: Heap Buffer Overflow in parseDragons in GitHub repository radareorg/radare2 prior to 5.6.8.\n\n- CVE-2022-1142: Heap buffer overflow in WebUI in Google Chrome prior to 100.0.4896.60 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via specific input into DevTools.\n\n- CVE-2022-1143: Heap buffer overflow in WebUI in Google Chrome prior to 100.0.4896.60 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via specific input into DevTools.\n\n- CVE-2022-1238: Out-of-bounds Write in libr/bin/format/ne/ne.c in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability is heap overflow and may be exploitable. For more general description of heap buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/122.html).\n\n- CVE-2022-1240: Heap buffer overflow in libr/bin/format/mach0/mach0.c in GitHub repository radareorg/radare2 prior to 5.8.6. If address sanitizer is disabled during the compiling, the program should executes into the `r_str_ncpy` function. Therefore I think it is very likely to be exploitable. For more general description of heap buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/122.html).\n\n- CVE-2022-1270: In GraphicsMagick, a heap buffer overflow was found when parsing MIFF.\n\n- CVE-2022-1354: A heap buffer overflow flaw was found in Libtiffs' tiffinfo.c in TIFFReadRawDataStriped() function. This flaw allows an attacker to pass a crafted TIFF file to the tiffinfo tool, triggering a heap buffer overflow issue and causing a crash that leads to a denial of service.\n\n- CVE-2022-1383: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.6.8. The bug causes the program reads data past the end of the intented buffer. Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash.\n\n- CVE-2022-1437: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.7.0. The bug causes the program reads data past the end of the intented buffer. Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash.\n\n- CVE-2022-1482: Inappropriate implementation in WebGL in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1483: Heap buffer overflow in WebGPU in Google Chrome prior to 101.0.4951.41 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1484: Heap buffer overflow in Web UI Settings in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1489: Out of bounds memory access in UI Shelf in Google Chrome on Chrome OS, Lacros prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-1621: Heap buffer overflow in vim_strncpy find_word in GitHub repository vim/vim prior to 8.2.4919. This vulnerability is capable of crashing software, Bypass Protection Mechanism, Modify Memory, and possible remote execution\n\n- CVE-2022-1638: Heap buffer overflow in V8 Internationalization in Google Chrome prior to 101.0.4951.64 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1876: Heap buffer overflow in DevTools in Google Chrome prior to 102.0.5005.61 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-20106: In MM service, there is a possible out of bounds write due to a heap-based buffer overflow. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: DTV03330460; Issue ID: DTV03330460.\n\n- CVE-2022-20166: In various methods of kernel base drivers, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-182388481References: Upstream kernel\n\n- CVE-2022-20202: In ih264_resi_trans_quant_4x4_sse42 of ih264_resi_trans_quant_sse42.c, there is a possible out of bounds read due to a heap buffer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-12LAndroid ID: A-204704614\n\n- CVE-2022-20209: In hme_add_new_node_to_a_sorted_array of hme_utils.c, there is a possible out of bounds read due to a heap buffer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-12LAndroid ID: A-207502397\n\n- CVE-2022-20247: In Media, there is a possible out of bounds read due to a heap buffer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-229858836\n\n- CVE-2022-20273: In Bluetooth, there is a possible out of bounds read due to a heap buffer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-206478022\n\n- CVE-2022-29210: TensorFlow is an open source platform for machine learning. In version 2.8.0, the `TensorKey` hash function used total estimated `AllocatedBytes()`, which (a) is an estimate per tensor, and (b) is a very poor hash function for constants (e.g. `int32_t`). It also tried to access individual tensor bytes through `tensor.data()` of size `AllocatedBytes()`. This led to ASAN failures because the `AllocatedBytes()` is an estimate of total bytes allocated by a tensor, including any pointed-to constructs (e.g. strings), and does not refer to contiguous bytes in the `.data()` buffer. The discoverers could not use this byte vector anyway because types such as `tstring` include pointers, whereas they needed to hash the string values themselves. This issue is patched in Tensorflow versions 2.9.0 and 2.8.1.\n\n- CVE-2022-2991: A heap-based buffer overflow was found in the Linux kernel's LightNVM subsystem. The issue results from the lack of proper validation of the length of user-supplied data prior to copying it to a fixed-length heap-based buffer. This vulnerability allows a local attacker to escalate privileges and execute arbitrary code in the context of the kernel. The attacker must first obtain the ability to execute high-privileged code on the target system to exploit this vulnerability.\n\n- CVE-2022-29917: Mozilla developers Andrew McCreight, Gabriele Svelto, Tom Ritter and the Mozilla Fuzzing Team reported memory safety bugs present in Firefox 99 and Firefox ESR 91.8. Some of these bugs showed evidence of memory corruption and we presume that with enough effort some of these could have been exploited to run arbitrary code. This vulnerability affects Thunderbird < 91.9, Firefox ESR < 91.9, and Firefox < 100.\n\n- CVE-2022-30292: Heap-based buffer overflow in sqbaselib.cpp in SQUIRREL 3.2 due to lack of a certain sq_reservestack call.\n\n- CVE-2022-30293: In WebKitGTK through 2.36.0 (and WPE WebKit), there is a heap-based buffer overflow in WebCore::TextureMapperLayer::setContentsLayer in WebCore/platform/graphics/texmap/TextureMapperLayer.cpp.\n\n- CVE-2022-3040: Use after free in Layout in Google Chrome prior to 105.0.5195.52 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3043: Heap buffer overflow in Screen Capture in Google Chrome on Chrome OS prior to 105.0.5195.52 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-30474: Tenda AC Series Router AC18_V15.03.05.19(6318) was discovered to contain a heap overflow in the httpd module when handling /goform/saveParentControlInfo request.\n\n- CVE-2022-3437: A heap-based buffer overflow vulnerability was found in Samba within the GSSAPI unwrap_des() and unwrap_des3() routines of Heimdal. The DES and Triple-DES decryption routines in the Heimdal GSSAPI library allow a length-limited write buffer overflow on malloc() allocated memory when presented with a maliciously small packet. This flaw allows a remote user to send specially crafted malicious data to the application, possibly resulting in a denial of service (DoS) attack.\n\n- CVE-2022-34502: Radare2 v5.7.0 was discovered to contain a heap buffer overflow via the function consume_encoded_name_new at format/wasm/wasm.c. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted binary file.\n\n- CVE-2022-34503: QPDF v8.4.2 was discovered to contain a heap buffer overflow via the function QPDF::processXRefStream. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted PDF file.\n\n- CVE-2022-35104: SWFTools commit 772e55a2 was discovered to contain a heap-buffer overflow via DCTStream::reset() at /xpdf/Stream.cc.\n\n- CVE-2022-35105: SWFTools commit 772e55a2 was discovered to contain a heap-buffer overflow via /bin/png2swf+0x552cea.\n\n- CVE-2022-35109: SWFTools commit 772e55a2 was discovered to contain a heap-buffer overflow via draw_stroke at /gfxpoly/stroke.c.\n\n- CVE-2022-35113: SWFTools commit 772e55a2 was discovered to contain a heap-buffer overflow via swf_DefineLosslessBitsTagToImage at /modules/swfbits.c.\n\n- CVE-2022-35447: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b04de.\n\n- CVE-2022-35448: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b55af.\n\n- CVE-2022-35449: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b0466.\n\n- CVE-2022-35450: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b84b1.\n\n- CVE-2022-35451: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b03b5.\n\n- CVE-2022-35452: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b0b2c.\n\n- CVE-2022-35453: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6c08a6.\n\n- CVE-2022-35454: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b05aa.\n\n- CVE-2022-35455: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b0d63.\n\n- CVE-2022-35456: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x617087.\n\n- CVE-2022-35458: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b05ce.\n\n- CVE-2022-35459: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6e412a.\n\n- CVE-2022-35460: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x61731f.\n\n- CVE-2022-35461: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6c0a32.\n\n- CVE-2022-35462: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6c0bc3.\n\n- CVE-2022-35463: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b0478.\n\n- CVE-2022-35464: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6171b2.\n\n- CVE-2022-35465: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6c0414.\n\n- CVE-2022-35466: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6c0473.\n\n- CVE-2022-35467: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6e41b8.\n\n- CVE-2022-35468: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6e420d.\n\n- CVE-2022-35470: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x65fc97.\n\n- CVE-2022-35471: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6e41b0.\n\n- CVE-2022-35474: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b544e.\n\n- CVE-2022-35475: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6e41a8.\n\n- CVE-2022-35623: In Nordic nRF5 SDK for Mesh 5.0, a heap overflow vulnerability can be triggered by sending a series of segmented control packets and access packets with the same SeqAuth\n\n- CVE-2022-35624: In Nordic nRF5 SDK for Mesh 5.0, a heap overflow vulnerability can be triggered by sending a series of segmented packets with SegO > SegN\n\n- CVE-2022-3570: Multiple heap buffer overflows in tiffcrop.c utility in libtiff library Version 4.4.0 allows attacker to trigger unsafe or out of bounds memory access via crafted TIFF image file which could result into application crash, potential information disclosure or any other context-dependent impact\n\n- CVE-2022-35711: Adobe ColdFusion versions Update 14 (and earlier) and Update 4 (and earlier) are affected by a Heap-based Buffer Overflow vulnerability that could result in arbitrary code execution in the context of the current user. Exploitation of this issue does not require user interaction, the vulnerability is triggered when a crafted network packet is sent to the server.\n\n- CVE-2022-35712: Adobe ColdFusion versions Update 14 (and earlier) and Update 4 (and earlier) are affected by a Heap-based Buffer Overflow vulnerability that could result in arbitrary code execution in the context of the current user. Exploitation of this issue does not require user interaction, the vulnerability is triggered when a crafted network packet is sent to the server.\n\n- CVE-2022-36150: tifig v0.2.2 was discovered to contain a heap-buffer overflow via __asan_memmove at /asan/asan_interceptors_memintrinsics.cpp.\n\n- CVE-2022-4135: Heap buffer overflow in GPU in Google Chrome prior to 107.0.5304.121 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4141: Heap based buffer overflow in vim/vim 9.0.0946 and below by allowing an attacker to CTRL-W gf in the expression used in the RHS of the substitute command.\n\n- CVE-2022-41428: Bento4 v1.6.0-639 was discovered to contain a heap overflow via the AP4_BitReader::ReadBits function in mp4mux.\n\n- CVE-2022-41429: Bento4 v1.6.0-639 was discovered to contain a heap overflow via the AP4_Atom::TypeFromString function in mp4tag.\n\n- CVE-2022-41430: Bento4 v1.6.0-639 was discovered to contain a heap overflow via the AP4_BitReader::ReadBit function in mp4mux.\n\n- CVE-2022-41595: The phones have the heap overflow, out-of-bounds read, and null pointer vulnerabilities in the fingerprint trusted application (TA).Successful exploitation of this vulnerability may affect the fingerprint service.\n\n- CVE-2022-42499: In sms_SendMmCpErrMsg of sms_MmConManagement.c, there is a possible out of bounds write due to a heap buffer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-242001391References: N/A\n\n- CVE-2022-4291: The aswjsflt.dll library from Avast Antivirus windows contained a potentially exploitable heap corruption vulnerability that could enable an attacker to bypass the sandbox of the application it was loaded into, if applicable. This issue was fixed in version 18.0.1478 of the Script Shield Component. \n\n- CVE-2021-21958: A heap-based buffer overflow vulnerability exists in the Hword HwordApp.dll functionality of Hancom Office 2020 11.0.0.2353. A specially-crafted malformed file can lead to memory corruption and potential arbitrary code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2022-37434: zlib through 1.2.12 has a heap-based buffer over-read or buffer overflow in inflate in inflate.c via a large gzip header extra field. NOTE: only applications that call inflateGetHeader are affected. Some common applications bundle the affected zlib source code but may be unable to call inflateGetHeader (e.g., see the nodejs/node reference).\n\n- CVE-2022-46393: An issue was discovered in Mbed TLS before 2.28.2 and 3.x before 3.3.0. There is a potential heap-based buffer overflow and heap-based buffer over-read in DTLS if MBEDTLS_SSL_DTLS_CONNECTION_ID is enabled and MBEDTLS_SSL_CID_IN_LEN_MAX > 2 * MBEDTLS_SSL_CID_OUT_LEN_MAX.\n\n- CVE-2022-22612: A memory consumption issue was addressed with improved memory handling. This issue is fixed in tvOS 15.4, iOS 15.4 and iPadOS 15.4, iTunes 12.12.3 for Windows, watchOS 8.5, macOS Monterey 12.3. Processing a maliciously crafted image may lead to heap corruption.\n\n- CVE-2022-23318: A heap-buffer-overflow in pcf2bdf, versions >= 1.05 allows an attacker to trigger unsafe memory access via a specially crafted PCF font file. This out-of-bound read may lead to an application crash, information disclosure via program memory or other context-dependent impact.\n\n- CVE-2022-35557: A stack overflow vulnerability exists in /goform/wifiSSIDget in Tenda W6 V1.0.0.9(4122) version, which can be exploited by attackers to cause a denial of service (DoS) via the index parameter.\n\n- CVE-2022-4498: In TP-Link routers, Archer C5 and WR710N-V1, running the latest available code, when receiving HTTP Basic Authentication the httpd service can be sent a crafted packet that causes a heap overflow. This can result in either a DoS (by crashing the httpd process) or an arbitrary code execution.\n\n- CVE-2022-42475: A heap-based buffer overflow vulnerability [CWE-122] in FortiOS SSL-VPN 7.2.0 through 7.2.2, 7.0.0 through 7.0.8, 6.4.0 through 6.4.10, 6.2.0 through 6.2.11, 6.0.15 and earlier and FortiProxy SSL-VPN 7.2.0 through 7.2.1, 7.0.7 and earlier may allow a remote unauthenticated attacker to execute arbitrary code or commands via specifically crafted requests.\n\n- CVE-2022-2294: Heap buffer overflow in WebRTC in Google Chrome prior to 103.0.5060.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-26318: On WatchGuard Firebox and XTM appliances, an unauthenticated user can execute arbitrary code, aka FBX-22786. This vulnerability impacts Fireware OS before 12.7.2_U2, 12.x before 12.1.3_U8, and 12.2.x through 12.5.x before 12.5.9_U2.\n\n- CVE-2022-2598: Out-of-bounds Write to API in GitHub repository vim/vim prior to 9.0.0100. \n\n- CVE-2022-25363: WatchGuard Firebox and XTM appliances allow an authenticated remote attacker with unprivileged credentials to modify privileged management user credentials. This vulnerability impacts Fireware OS before 12.7.2_U2, 12.x before 12.1.3_U8, and 12.2.x through 12.5.x before 12.5.9_U2.\n\n- CVE-2022-3974: A vulnerability classified as critical was found in Axiomatic Bento4. Affected by this vulnerability is the function AP4_StdcFileByteStream::ReadPartial of the file Ap4StdCFileByteStream.cpp of the component mp4info. The manipulation leads to heap-based buffer overflow. The attack can be launched remotely. The exploit has been disclosed to the public and may be used. The identifier VDB-213553 was assigned to this vulnerability.\n\n- CVE-2021-40647: In man2html 1.6g, a specific string being read in from a file will overwrite the size parameter in the top chunk of the heap. This at least causes the program to segmentation abort if the heap size parameter isn't aligned correctly. In version before GLIBC version 2.29 and aligned correctly, it allows arbitrary write anywhere in the programs memory.\n\n- CVE-2021-3567: A flaw was found in Caribou due to a regression of CVE-2020-25712 fix. An attacker could use this flaw to bypass screen-locking applications that leverage Caribou as an input mechanism. The highest threat from this vulnerability is to system availability.\n\nRelated Weaknesses:\n\n- CWE-788 (ChildOf)\n\n- CWE-787 (ChildOf)",
          "type": "Variant",
          "source": "sparse",
          "search_source": "weakness:memory corruption",
          "sources": [
            "base",
            "weakness"
          ],
          "boost_factor": 2.8,
          "boosted": true,
          "metadata": {
            "source": "sparse",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            }
          }
        },
        {
          "cwe_id": "415",
          "name": "Double Free",
          "description": "The product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.",
          "score": 53.504177185489525,
          "matched_text": "CWE-415: Double Free\n\nType: Variant\n\nStatus: Draft\n\nAlternative Terms:\n\nDouble-free\n\nDouble-free\n\nDouble-free\n\nDescription:\n\nThe product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.\n\nExtended Details:\n\nWhen a program calls free() twice with the same argument, the program's memory management data structures become corrupted. This corruption can cause the program to crash or, in some circumstances, cause two later calls to malloc() to return the same pointer. If malloc() returns the same value twice and the program later gives the attacker control over the data that is written into this doubly-allocated memory, the program becomes vulnerable to a buffer overflow attack.\n\nReal-World Examples:\n\n- CVE-2006-5051: Chain: Signal handler contains too much functionality (CWE-828), introducing a race condition (CWE-362) that leads to a double free (CWE-415).\n\n- CVE-2004-0642: Double free resultant from certain error conditions.\n\n- CVE-2004-0772: Double free resultant from certain error conditions.\n\n- CVE-2005-1689: Double free resultant from certain error conditions.\n\n- CVE-2003-0545: Double free from invalid ASN.1 encoding.\n\n- CVE-2003-1048: Double free from malformed GIF.\n\n- CVE-2005-0891: Double free from malformed GIF.\n\n- CVE-2002-0059: Double free from malformed compressed data.\n\nTop 25 CWE Examples:\n\n- CVE-2020-11231: Two threads call one or both functions concurrently leading to corruption of pointers and reference counters which in turn can lead to heap corruption in Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile\n\n- CVE-2020-14354: A possible use-after-free and double-free in c-ares lib version 1.16.0 if ares_destroy() is called prior to ares_getaddrinfo() completing. This flaw possibly allows an attacker to crash the service that uses c-ares lib. The highest threat from this vulnerability is to this service availability.\n\n- CVE-2021-0392: In main of main.cpp, there is a possible memory corruption due to a double free. This could lead to local escalation of privilege with User execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-9Android ID: A-175124730\n\n- CVE-2021-0498: In memory management driver, there is a possible memory corruption due to a double free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-183461321\n\n- CVE-2021-0528: In memory management driver, there is a possible memory corruption due to a double free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-185195266\n\n- CVE-2021-1119: NVIDIA vGPU software contains a vulnerability in the Virtual GPU Manager (vGPU plugin), where it can double-free a pointer, which may lead to denial of service. This flaw may result in a write-what-where condition, allowing an attacker to execute arbitrary code impacting integrity and availability.\n\n- CVE-2021-1875: A double free issue was addressed with improved memory management. This issue is fixed in Security Update 2021-002 Catalina, Security Update 2021-003 Mojave, iOS 14.5 and iPadOS 14.5, watchOS 7.4, tvOS 14.5, macOS Big Sur 11.3. Processing a maliciously crafted file may lead to heap corruption.\n\n- CVE-2021-1888: Memory corruption in key parsing and import function due to double freeing the same heap allocation in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2021-1934: Possible memory corruption due to improper check when application loader object is explicitly destructed while application is unloading in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT\n\n- CVE-2021-30535: Double free in ICU in Google Chrome prior to 91.0.4472.77 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-32613: In radare2 through 5.3.0 there is a double free vulnerability in the pyc parse via a crafted file which can lead to DoS.\n\n- CVE-2021-3403: In ytnef 1.9.3, the TNEFSubjectHandler function in lib/ytnef.c allows remote attackers to cause a denial-of-service (and potentially code execution) due to a double free which can be triggered via a crafted file.\n\n- CVE-2021-3407: A flaw was found in mupdf 1.18.0. Double free of object during linearization may lead to memory corruption and other potential consequences.\n\n- CVE-2021-3564: A flaw double-free memory corruption in the Linux kernel HCI device initialization subsystem was found in the way user attach malicious HCI TTY Bluetooth device. A local user could use this flaw to crash the system. This flaw affects all the Linux kernel versions starting from 3.13.\n\n- CVE-2021-37652: TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.BoostedTreesCreateEnsemble` can result in a use after free error if an attacker supplies specially crafted arguments. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/boosted_trees/resource_ops.cc#L55) uses a reference counted resource and decrements the refcount if the initialization fails, as it should. However, when the code was written, the resource was represented as a naked pointer but later refactoring has changed it to be a smart pointer. Thus, when the pointer leaves the scope, a subsequent `free`-ing of the resource occurs, but this fails to take into account that the refcount has already reached 0, thus the resource has been already freed. During this double-free process, members of the resource object are accessed for cleanup but they are invalid as the entire resource has been freed. We have patched the issue in GitHub commit 5ecec9c6fbdbc6be03295685190a45e7eee726ab. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.\n\n- CVE-2020-14123: There is a pointer double free vulnerability in Some MIUI Services. When a function is called, the memory pointer is copied to two function modules, and an attacker can cause the pointer to be repeatedly released through malicious operations, resulting in the affected module crashing and affecting normal functionality, and if successfully exploited the vulnerability can cause elevation of privileges.\n\n- CVE-2021-42778: A heap double free issue was found in Opensc before version 0.22.0 in sc_pkcs15_free_tokeninfo.\n\n- CVE-2021-42613: A double free in cleanup_index in index.c in Halibut 1.2 allows an attacker to cause a denial of service or possibly have other unspecified impact via a crafted text document.\n\n- CVE-2021-22600: A double free bug in packet_set_ring() in net/packet/af_packet.c can be exploited by a local user through crafted syscalls to escalate privileges or deny service. We recommend upgrading kernel past the effected versions or rebuilding past ec6af094ea28f0f2dda1a6a33b14cd57e36a9755\n\n- CVE-2020-9859: A memory consumption issue was addressed with improved memory handling. This issue is fixed in iOS 13.5.1 and iPadOS 13.5.1, macOS Catalina 10.15.5 Supplemental Update, tvOS 13.4.6, watchOS 6.2.6. An application may be able to execute arbitrary code with kernel privileges.\n\n- CVE-2021-23158: A flaw was found in htmldoc in v1.9.12. Double-free in function pspdf_export(),in ps-pdf.cxx may result in a write-what-where condition, allowing an attacker to execute arbitrary code and denial of service.\n\n- CVE-2022-2008: Double free in WebGL in Google Chrome prior to 102.0.5005.115 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-40304: An issue was discovered in libxml2 before 2.10.3. Certain invalid XML entity definitions can corrupt a hash table key, potentially leading to subsequent logic errors. In one case, a double-free can be provoked.\n\nRelated Weaknesses:\n\n- CWE-825 (ChildOf)\n\n- CWE-1341 (ChildOf)\n\n- CWE-672 (ChildOf)\n\n- CWE-672 (ChildOf)\n\n- CWE-672 (ChildOf)\n\n- CWE-666 (ChildOf)\n\n- CWE-416 (PeerOf)\n\n- CWE-123 (PeerOf)",
          "type": "Variant",
          "source": "sparse",
          "search_source": "weakness:memory corruption",
          "sources": [
            "base",
            "weakness"
          ],
          "boost_factor": 2.8,
          "boosted": true,
          "metadata": {
            "source": "sparse",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            }
          }
        },
        {
          "cwe_id": "190",
          "name": "Integer Overflow or Wraparound",
          "description": "The product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.",
          "score": 51.530627528621274,
          "matched_text": "CWE-190: Integer Overflow or Wraparound\n\nType: Base\n\nStatus: Stable\n\nAlternative Terms:\n\nOverflow - The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nWraparound - The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nwrap, wrap-around, wrap around - Alternate spellings of \"wraparound\"\n\nOverflow - The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nWraparound - The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nwrap, wrap-around, wrap around - Alternate spellings of \"wraparound\"\n\nOverflow - The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nWraparound - The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nwrap, wrap-around, wrap around - Alternate spellings of \"wraparound\"\n\nDescription:\n\nThe product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.\n\nReal-World Examples:\n\n- CVE-2021-43537: Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n\n- CVE-2022-21668: Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n\n- CVE-2022-0545: Chain: 3D renderer has an integer overflow (CWE-190) leading to write-what-where condition (CWE-123) using a crafted image.\n\n- CVE-2021-30860: Chain: improper input validation (CWE-20) leads to integer overflow (CWE-190) in mobile OS, as exploited in the wild per CISA KEV.\n\n- CVE-2021-30663: Chain: improper input validation (CWE-20) leads to integer overflow (CWE-190) in mobile OS, as exploited in the wild per CISA KEV.\n\n- CVE-2018-10887: Chain: unexpected sign extension (CWE-194) leads to integer overflow (CWE-190), causing an out-of-bounds read (CWE-125)\n\n- CVE-2019-1010006: Chain: compiler optimization (CWE-733) removes or modifies code used to detect integer overflow (CWE-190), allowing out-of-bounds write (CWE-787).\n\n- CVE-2010-1866: Chain: integer overflow (CWE-190) causes a negative signed value, which later bypasses a maximum-only check (CWE-839), leading to heap-based buffer overflow (CWE-122).\n\n- CVE-2010-2753: Chain: integer overflow leads to use-after-free\n\n- CVE-2005-1513: Chain: integer overflow in securely-coded mail program leads to buffer overflow. In 2005, this was regarded as unrealistic to exploit, but in 2020, it was rediscovered to be easier to exploit due to evolutions of the technology.\n\n- CVE-2002-0391: Integer overflow via a large number of arguments.\n\n- CVE-2002-0639: Integer overflow in OpenSSH as listed in the demonstrative examples.\n\n- CVE-2005-1141: Image with large width and height leads to integer overflow.\n\n- CVE-2005-0102: Length value of -1 leads to allocation of 0 bytes and resultant heap overflow.\n\n- CVE-2004-2013: Length value of -1 leads to allocation of 0 bytes and resultant heap overflow.\n\n- CVE-2017-1000121: chain: unchecked message size metadata allows integer overflow (CWE-190) leading to buffer overflow (CWE-119).\n\n- CVE-2013-1591: Chain: an integer overflow (CWE-190) in the image size calculation causes an infinite loop (CWE-835) which sequentially allocates buffers without limits (CWE-1325) until the stack is full.\n\nTop 25 CWE Examples:\n\n- CVE-2020-11279: Memory corruption while processing crafted SDES packets due to improper length check in sdes packets recieved in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2020-28020: Exim 4 before 4.92 allows Integer Overflow to Buffer Overflow, in which an unauthenticated remote attacker can execute arbitrary code by leveraging the mishandling of continuation lines during header-length restriction.\n\n- CVE-2020-35198: An issue was discovered in Wind River VxWorks 7. The memory allocator has a possible integer overflow in calculating a memory block's size to be allocated by calloc(). As a result, the actual memory allocated is smaller than the buffer size specified by the arguments, leading to memory corruption.\n\n- CVE-2021-0355: In kisd, there is a possible out of bounds write due to an integer overflow. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Product: Android; Versions: Android-11; Patch ID: ALPS05425581.\n\n- CVE-2021-0436: In CryptoPlugin::decrypt of CryptoPlugin.cpp, there is a possible out of bounds read due to integer overflow. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-8.1 Android-9 Android-10 Android-11Android ID: A-176496160\n\n- CVE-2021-0458: In the FingerTipS touch screen driver, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-157156744\n\n- CVE-2021-0460: In the FingerTipS touch screen driver, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-156739245\n\n- CVE-2021-0494: In memory management driver, there is a possible out of bounds write due to an integer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-183461318\n\n- CVE-2021-0610: In memory management driver, there is a possible memory corruption due to an integer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05403499; Issue ID: ALPS05411456.\n\n- CVE-2021-0621: In asf extractor, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05489178; Issue ID: ALPS05561383.\n\n- CVE-2021-0623: In asf extractor, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05489178; Issue ID: ALPS05585817.\n\n- CVE-2021-0627: In OMA DRM, there is a possible memory corruption due to an integer overflow. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05722434; Issue ID: ALPS05722434.\n\n- CVE-2021-21309: Redis is an open-source, in-memory database that persists on disk. In affected versions of Redis an integer overflow bug in 32-bit Redis version 4.0 or newer could be exploited to corrupt the heap and potentially result with remote code execution. Redis 4.0 or newer uses a configurable limit for the maximum supported bulk input size. By default, it is 512MB which is a safe value for all platforms. If the limit is significantly increased, receiving a large request from a client may trigger several integer overflow scenarios, which would result with buffer overflow and heap corruption. We believe this could in certain conditions be exploited for remote code execution. By default, authenticated Redis users have access to all configuration parameters and can therefore use the \u201cCONFIG SET proto-max-bulk-len\u201d to change the safe default, making the system vulnerable. **This problem only affects 32-bit Redis (on a 32-bit system, or as a 32-bit executable running on a 64-bit system).** The problem is fixed in version 6.2, and the fix is back ported to 6.0.11 and 5.0.11. Make sure you use one of these versions if you are running 32-bit Redis. An additional workaround to mitigate the problem without patching the redis-server executable is to prevent clients from directly executing `CONFIG SET`: Using Redis 6.0 or newer, ACL configuration can be used to block the command. Using older versions, the `rename-command` configuration directive can be used to rename the command to a random string unknown to users, rendering it inaccessible. Please note that this workaround may have an additional impact on users or operational systems that expect `CONFIG SET` to behave in certain ways.\n\n- CVE-2021-21807: An integer overflow vulnerability exists in the DICOM parse_dicom_meta_info functionality of Accusoft ImageGear 19.9. A specially crafted malformed file can lead to a stack-based buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21834: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input when decoding the atom for the \u201cco64\u201d FOURCC can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21835: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input when decoding the atom associated with the \u201ccsgp\u201d FOURCC can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21836: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input using the \u201cctts\u201d FOURCC code can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21837: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21838: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21839: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21840: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input used to process an atom using the \u201csaio\u201d FOURCC code cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21841: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input when reading an atom using the 'sbgp' FOURCC code can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21842: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow when processing an atom using the 'ssix' FOURCC code, due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21843: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. After validating the number of ranges, at [41] the library will multiply the count by the size of the GF_SubsegmentRangeInfo structure. On a 32-bit platform, this multiplication can result in an integer overflow causing the space of the array being allocated to be less than expected. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21844: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input when encountering an atom using the \u201cstco\u201d FOURCC code, can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21845: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input in \u201cstsc\u201d decoder can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21846: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input in \u201cstsz\u201d decoder can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21847: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input in \u201cstts\u201d decoder can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21848: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. The library will actually reuse the parser for atoms with the \u201cstsz\u201d FOURCC code when parsing atoms that use the \u201cstz2\u201d FOURCC code and can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21849: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow when the library encounters an atom using the \u201ctfra\u201d FOURCC code due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21850: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow when the library encounters an atom using the \u201ctrun\u201d FOURCC code due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21851: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input at \u201ccsgp\u201d decoder sample group description indices can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21852: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input at \u201cstss\u201d decoder can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21853: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked addition arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21854: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked addition arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21855: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked addition arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21856: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked addition arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21857: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked addition arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21858: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked addition arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-22412: There is an Integer Overflow Vulnerability in Huawei Smartphone.Successful exploitation of this vulnerability may cause random kernel address access.\n\n- CVE-2021-22413: There is an Integer Overflow Vulnerability in Huawei Smartphone.Successful exploitation of this vulnerability may cause the system to reset.\n\n- CVE-2021-23215: An integer overflow leading to a heap-buffer overflow was found in the DwaCompressor of OpenEXR in versions before 3.0.1. An attacker could use this flaw to crash an application compiled with OpenEXR.\n\n- CVE-2021-24025: Due to incorrect string size calculations inside the preg_quote function, a large input string passed to the function can trigger an integer overflow leading to a heap overflow. This issue affects HHVM versions prior to 4.56.3, all versions between 4.57.0 and 4.80.1, all versions between 4.81.0 and 4.93.1, and versions 4.94.0, 4.95.0, 4.96.0, 4.97.0, 4.98.0.\n\n- CVE-2021-24036: Passing an attacker controlled size when creating an IOBuf could cause integer overflow, leading to an out of bounds write on the heap with the possibility of remote code execution. This issue affects versions of folly prior to v2021.07.22.00. This issue affects HHVM versions prior to 4.80.5, all versions between 4.81.0 and 4.102.1, all versions between 4.103.0 and 4.113.0, and versions 4.114.0, 4.115.0, 4.116.0, 4.117.0, 4.118.0 and 4.118.1.\n\n- CVE-2021-25803: A buffer overflow vulnerability in the vlc_input_attachment_New component of VideoLAN VLC Media Player 3.0.11 allows attackers to cause an out-of-bounds read via a crafted .avi file.\n\n- CVE-2021-26260: An integer overflow leading to a heap-buffer overflow was found in the DwaCompressor of OpenEXR in versions before 3.0.1. An attacker could use this flaw to crash an application compiled with OpenEXR. This is a different flaw from CVE-2021-23215.\n\n- CVE-2021-26461: Apache Nuttx Versions prior to 10.1.0 are vulnerable to integer wrap-around in functions malloc, realloc and memalign. This improper memory assignment can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-26825: An integer overflow issue exists in Godot Engine up to v3.2 that can be triggered when loading specially crafted.TGA image files. The vulnerability exists in ImageLoaderTGA::load_image() function at line: const size_t buffer_size = (tga_header.image_width * tga_header.image_height) * pixel_size; The bug leads to Dynamic stack buffer overflow. Depending on the context of the application, attack vector can be local or remote, and can lead to code execution and/or system crash.\n\n- CVE-2021-26945: An integer overflow leading to a heap-buffer overflow was found in OpenEXR in versions before 3.0.1. An attacker could use this flaw to crash an application compiled with OpenEXR.\n\n- CVE-2021-30354: Amazon Kindle e-reader prior to and including version 5.13.4 contains an Integer Overflow that leads to a Heap-Based Buffer Overflow in function CJBig2Image::expand() and results in a memory corruption that leads to code execution when parsing a crafted PDF book.\n\n- CVE-2021-31292: An integer overflow in CrwMap::encode0x1810 of Exiv2 0.27.3 allows attackers to trigger a heap-based buffer overflow and cause a denial of service (DOS) via crafted metadata.\n\n- CVE-2021-31870: An issue was discovered in klibc before 2.0.9. Multiplication in the calloc() function may result in an integer overflow and a subsequent heap buffer overflow.\n\n- CVE-2021-31871: An issue was discovered in klibc before 2.0.9. An integer overflow in the cpio command may result in a NULL pointer dereference on 64-bit systems.\n\n- CVE-2021-31873: An issue was discovered in klibc before 2.0.9. Additions in the malloc() function may result in an integer overflow and a subsequent heap buffer overflow.\n\n- CVE-2021-32625: Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker. An integer overflow bug in Redis version 6.0 or newer, could be exploited using the STRALGO LCS command to corrupt the heap and potentially result with remote code execution. This is a result of an incomplete fix by CVE-2021-29477. The problem is fixed in version 6.2.4 and 6.0.14. An additional workaround to mitigate the problem without patching the redis-server executable is to use ACL configuration to prevent clients from using the STRALGO LCS command. On 64 bit systems which have the fixes of CVE-2021-29477 (6.2.3 or 6.0.13), it is sufficient to make sure that the proto-max-bulk-len config parameter is smaller than 2GB (default is 512MB).\n\n- CVE-2021-32628: Redis is an open source, in-memory database that persists on disk. An integer overflow bug in the ziplist data structure used by all versions of Redis can be exploited to corrupt the heap and potentially result with remote code execution. The vulnerability involves modifying the default ziplist configuration parameters (hash-max-ziplist-entries, hash-max-ziplist-value, zset-max-ziplist-entries or zset-max-ziplist-value) to a very large value, and then constructing specially crafted commands to create very large ziplists. The problem is fixed in Redis versions 6.2.6, 6.0.16, 5.0.14. An additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from modifying the above configuration parameters. This can be done using ACL to restrict unprivileged users from using the CONFIG SET command.\n\n- CVE-2021-34385: Trusty TLK contains a vulnerability in the NVIDIA TLK kernel where an integer overflow in the calculation of a length could lead to a heap overflow.\n\n- CVE-2021-34386: Trusty TLK contains a vulnerability in the NVIDIA TLK kernel where an integer overflow in the calloc size calculation can cause the multiplication of count and size can overflow, which might lead to heap overflows.\n\n- CVE-2021-39254: A crafted NTFS image can cause an integer overflow in memmove, leading to a heap-based buffer overflow in the function ntfs_attr_record_resize, in NTFS-3G < 2021.8.22.\n\n- CVE-2021-40346: An integer overflow exists in HAProxy 2.0 through 2.5 in htx_add_header that can be exploited to perform an HTTP request smuggling attack, allowing an attacker to bypass all configured http-request HAProxy ACLs and possibly other ACLs.\n\n- CVE-2021-41864: prealloc_elems_and_freelist in kernel/bpf/stackmap.c in the Linux kernel before 5.14.12 allows unprivileged users to trigger an eBPF multiplication integer overflow with a resultant out-of-bounds write.\n\n- CVE-2021-41991: The in-memory certificate cache in strongSwan before 5.9.4 has a remote integer overflow upon receiving many requests with different certificates to fill the cache and later trigger the replacement of cache entries. The code attempts to select a less-often-used cache entry by means of a random number generator, but this is not done correctly. Remote code execution might be a slight possibility.\n\n- CVE-2021-43784: runc is a CLI tool for spawning and running containers on Linux according to the OCI specification. In runc, netlink is used internally as a serialization system for specifying the relevant container configuration to the `C` portion of the code (responsible for the based namespace setup of containers). In all versions of runc prior to 1.0.3, the encoder did not handle the possibility of an integer overflow in the 16-bit length field for the byte array attribute type, meaning that a large enough malicious byte array attribute could result in the length overflowing and the attribute contents being parsed as netlink messages for container configuration. This vulnerability requires the attacker to have some control over the configuration of the container and would allow the attacker to bypass the namespace restrictions of the container by simply adding their own netlink payload which disables all namespaces. The main users impacted are those who allow untrusted images with untrusted configurations to run on their machines (such as with shared cloud infrastructure). runc version 1.0.3 contains a fix for this bug. As a workaround, one may try disallowing untrusted namespace paths from your container. It should be noted that untrusted namespace paths would allow the attacker to disable namespace protections entirely even in the absence of this bug.\n\n- CVE-2021-36155: LengthPrefixedMessageReader in gRPC Swift 1.1.0 and earlier allocates buffers of arbitrary length, which allows remote attackers to cause uncontrolled resource consumption and deny service.\n\n- CVE-2020-28009: Exim 4 before 4.94.2 allows Integer Overflow to Buffer Overflow because get_stdinput allows unbounded reads that are accompanied by unbounded increases in a certain size variable. NOTE: exploitation may be impractical because of the execution time needed to overflow (multiple days).\n\n- CVE-2020-28017: Exim 4 before 4.94.2 allows Integer Overflow to Buffer Overflow in receive_add_recipient via an e-mail message with fifty million recipients. NOTE: remote exploitation may be difficult because of resource consumption.\n\n- CVE-2021-22323: There is an Integer Overflow Vulnerability in Huawei Smartphone. Successful exploitation of these vulnerabilities may escalate the permission to that of the root user.\n\n- CVE-2021-32027: A flaw was found in postgresql in versions before 13.3, before 12.7, before 11.12, before 10.17 and before 9.6.22. While modifying certain SQL array values, missing bounds checks let authenticated database users write arbitrary bytes to a wide area of server memory. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.\n\n- CVE-2021-3410: A flaw was found in libcaca v0.99.beta19. A buffer overflow issue in caca_resize function in libcaca/caca/canvas.c may lead to local execution of arbitrary code in the user context.\n\n- CVE-2020-14344: An integer overflow leading to a heap-buffer overflow was found in The X Input Method (XIM) client was implemented in libX11 before version 1.6.10. As per upstream this is security relevant when setuid programs call XIM client functions while running with elevated privileges. No such programs are shipped with Red Hat Enterprise Linux.\n\n- CVE-2020-6059: An exploitable out of bounds read vulnerability exists in the way MiniSNMPD version 1.4 parses incoming SNMP packets. A specially crafted SNMP request can trigger an out of bounds memory read which can result in sensitive information disclosure and Denial Of Service. In order to trigger this vulnerability, an attacker needs to send a specially crafted packet to the vulnerable server.\n\n- CVE-2020-6099: An exploitable code execution vulnerability exists in the file format parsing functionality of Graphisoft BIMx Desktop Viewer 2019.2.2328. A specially crafted file can cause a heap buffer overflow resulting in a code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-22680: NXP MQX Versions 5.1 and prior are vulnerable to integer overflow in mem_alloc, _lwmem_alloc and _partition functions. This unverified memory assignment can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-27419: uClibc-ng versions prior to 1.0.37 are vulnerable to integer wrap-around in functions malloc-simple. This improper memory assignment can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-27425: Cesanta Software Mongoose-OS v2.17.0 is vulnerable to integer wrap-around in function mm_malloc. This improper memory assignment can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-27427: RIOT OS version 2020.01.1 is vulnerable to integer wrap-around in its implementation of calloc function, which can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-27433: ARM mbed-ualloc memory library version 1.3.0 is vulnerable to integer wrap-around in function mbed_krbs, which can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-27435: ARM mbed product Version 6.3.0 is vulnerable to integer wrap-around in malloc_wrapper function, which can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-27439: TencentOS-tiny version 3.1.0 is vulnerable to integer wrap-around in function 'tos_mmheap_alloc incorrect calculation of effective memory allocation size. This improper memory assignment can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-27417: eCosCentric eCosPro RTOS Versions 2.0.1 through 4.5.3 are vulnerable to integer wraparound in function calloc (an implementation of malloc). The unverified memory assignment can lead to arbitrary memory allocation, resulting in a heap-based buffer overflow.\n\n- CVE-2021-30663: An integer overflow was addressed with improved input validation. This issue is fixed in iOS 14.5.1 and iPadOS 14.5.1, tvOS 14.6, iOS 12.5.3, Safari 14.1.1, macOS Big Sur 11.3.1. Processing maliciously crafted web content may lead to arbitrary code execution.\n\n- CVE-2021-30860: An integer overflow was addressed with improved input validation. This issue is fixed in Security Update 2021-005 Catalina, iOS 14.8 and iPadOS 14.8, macOS Big Sur 11.6, watchOS 7.6.2. Processing a maliciously crafted PDF may lead to arbitrary code execution. Apple is aware of a report that this issue may have been actively exploited.\n\n- CVE-2021-0677: In ccu driver, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05827154; Issue ID: ALPS05827154.\n\n- CVE-2021-1047: In valid_ipc_dram_addr of cm_access_control.c, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-197966306References: N/A\n\n- CVE-2021-21832: A memory corruption vulnerability exists in the ISO Parsing functionality of Disc Soft Ltd Deamon Tools Pro 8.3.0.0767. A specially crafted malformed file can lead to an out-of-bounds write. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21914: A heap-based buffer overflow vulnerability exists in the DecoderStream::Append functionality of Accusoft ImageGear 19.10. A specially-crafted file can lead to code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21948: A heap-based buffer overflow vulnerability exists in the readDatHeadVec functionality of AnyCubic Chitubox AnyCubic Plugin 1.0.0. A specially-crafted GF file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-22437: There is a software integer overflow leading to a TOCTOU condition in smartphones. Successful exploitation of this vulnerability may cause random address access.\n\n- CVE-2021-3782: An internal reference count is held on the buffer pool, incremented every time a new buffer is created from the pool. The reference count is maintained as an int; on LP64 systems this can cause the reference count to overflow if the client creates a large number of wl_shm buffer objects, or if it can coerce the server to create a large number of external references to the buffer storage. With the reference count overflowing, a use-after-free can be constructed on the wl_shm_pool tracking structure, where values may be incremented or decremented; it may also be possible to construct a limited oracle to leak 4 bytes of server-side memory to the attacking client at a time.\n\n- CVE-2021-39762: In tremolo, there is a possible out of bounds read due to an integer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-12LAndroid ID: A-210625816\n\n- CVE-2021-40417: When parsing a file that is submitted to the DPDecoder service as a job, the service will use the combination of decoding parameters that were submitted with the job along with fields that were parsed for the submitted video by the R3D SDK to calculate the size of a heap buffer. Due to an integer overflow with regards to this calculation, this can result in an undersized heap buffer being allocated. When this heap buffer is written to, a heap-based buffer overflow will occur. This can result in code execution under the context of the application.\n\n- CVE-2021-4206: A flaw was found in the QXL display device emulation in QEMU. An integer overflow in the cursor_alloc() function can lead to the allocation of a small cursor object followed by a subsequent heap-based buffer overflow. This flaw allows a malicious privileged guest user to crash the QEMU process on the host or potentially execute arbitrary code within the context of the QEMU process.\n\n- CVE-2021-46829: GNOME GdkPixbuf (aka GDK-PixBuf) before 2.42.8 allows a heap-based buffer overflow when compositing or clearing frames in GIF files, as demonstrated by io-gif-animation.c composite_frame. This overflow is controllable and could be abused for code execution, especially on 32-bit systems.\n\n- CVE-2022-0204: A heap overflow vulnerability was found in bluez in versions prior to 5.63. An attacker with local network access could pass specially crafted files causing an application to halt or crash, leading to a denial of service.\n\n- CVE-2022-0545: An integer overflow in the processing of loaded 2D images leads to a write-what-where vulnerability and an out-of-bounds read vulnerability, allowing an attacker to leak sensitive information or achieve code execution in the context of the Blender process when a specially crafted image file is loaded. This flaw affects Blender versions prior to 2.83.19, 2.93.8 and 3.1.\n\n- CVE-2022-0608: Integer overflow in Mojo in Google Chrome prior to 98.0.4758.102 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1922: DOS / potential heap overwrite in mkv demuxing using zlib decompression. Integer overflow in matroskademux element in gst_matroska_decompress_data function which causes a segfault, or could cause a heap overwrite, depending on libc and OS. Depending on the libc used, and the underlying OS capabilities, it could be just a segfault or a heap overwrite. If the libc uses mmap for large chunks, and the OS supports mmap, then it is just a segfault (because the realloc before the integer overflow will use mremap to reduce the size of the chunk, and it will start to write to unmapped memory). However, if using a libc implementation that does not use mmap, or if the OS does not support mmap while using libc, then this could result in a heap overwrite.\n\n- CVE-2022-1923: DOS / potential heap overwrite in mkv demuxing using bzip decompression. Integer overflow in matroskademux element in bzip decompression function which causes a segfault, or could cause a heap overwrite, depending on libc and OS. Depending on the libc used, and the underlying OS capabilities, it could be just a segfault or a heap overwrite. If the libc uses mmap for large chunks, and the OS supports mmap, then it is just a segfault (because the realloc before the integer overflow will use mremap to reduce the size of the chunk, and it will start to write to unmapped memory). However, if using a libc implementation that does not use mmap, or if the OS does not support mmap while using libc, then this could result in a heap overwrite.\n\n- CVE-2022-1924: DOS / potential heap overwrite in mkv demuxing using lzo decompression. Integer overflow in matroskademux element in lzo decompression function which causes a segfault, or could cause a heap overwrite, depending on libc and OS. Depending on the libc used, and the underlying OS capabilities, it could be just a segfault or a heap overwrite. If the libc uses mmap for large chunks, and the OS supports mmap, then it is just a segfault (because the realloc before the integer overflow will use mremap to reduce the size of the chunk, and it will start to write to unmapped memory). However, if using a libc implementation that does not use mmap, or if the OS does not support mmap while using libc, then this could result in a heap overwrite.\n\n- CVE-2022-1925: DOS / potential heap overwrite in mkv demuxing using HEADERSTRIP decompression. Integer overflow in matroskaparse element in gst_matroska_decompress_data function which causes a heap overflow. Due to restrictions on chunk sizes in the matroskademux element, the overflow can't be triggered, however the matroskaparse element has no size checks.\n\n- CVE-2022-21729: Tensorflow is an Open Source Machine Learning Framework. The implementation of `UnravelIndex` is vulnerable to a division by zero caused by an integer overflow bug. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.\n\n- CVE-2022-21743: In ion, there is a possible use after free due to an integer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS06371108; Issue ID: ALPS06371108.\n\n- CVE-2022-22074: Memory Corruption during wma file playback due to integer overflow in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2022-22081: Memory corruption in audio module due to integer overflow in Snapdragon Auto, Snapdragon Connectivity, Snapdragon Mobile, Snapdragon Wearables\n\n- CVE-2022-22106: Memory corruption in multimedia due to improper length check while copying the data in Snapdragon Auto\n\n- CVE-2022-2329: A CWE-190: Integer Overflow or Wraparound vulnerability exists that could cause heap-based buffer overflow, leading to denial of service and potentially remote code execution when an attacker sends multiple specially crafted messages. Affected Products: IGSS Data Server - IGSSdataServer.exe (Versions prior to V15.0.0.22073)\n\n- CVE-2022-23559: Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would cause an integer overflow in embedding lookup operations. Both `embedding_size` and `lookup_size` are products of values provided by the user. Hence, a malicious user could trigger overflows in the multiplication. In certain scenarios, this can then result in heap OOB read/write. Users are advised to upgrade to a patched version.\n\n- CVE-2022-24310: A CWE-190: Integer Overflow or Wraparound vulnerability exists that could cause heap-based buffer overflow, leading to denial of service and potentially remote code execution when an attacker sends multiple specially crafted messages. Affected Product: Interactive Graphical SCADA System Data Server (V15.0.0.22020 and prior)\n\n- CVE-2022-24724: cmark-gfm is GitHub's extended version of the C reference implementation of CommonMark. Prior to versions 0.29.0.gfm.3 and 0.28.3.gfm.21, an integer overflow in cmark-gfm's table row parsing `table.c:row_from_string` may lead to heap memory corruption when parsing tables who's marker rows contain more than UINT16_MAX columns. The impact of this heap corruption ranges from Information Leak to Arbitrary Code Execution depending on how and where `cmark-gfm` is used. If `cmark-gfm` is used for rendering remote user controlled markdown, this vulnerability may lead to Remote Code Execution (RCE) in applications employing affected versions of the `cmark-gfm` library. This vulnerability has been patched in the following cmark-gfm versions 0.29.0.gfm.3 and 0.28.3.gfm.21. A workaround is available. The vulnerability exists in the table markdown extensions of cmark-gfm. Disabling the table extension will prevent this vulnerability from being triggered.\n\n- CVE-2022-24795: yajl-ruby is a C binding to the YAJL JSON parsing and generation library. The 1.x branch and the 2.x branch of `yajl` contain an integer overflow which leads to subsequent heap memory corruption when dealing with large (~2GB) inputs. The reallocation logic at `yajl_buf.c#L64` may result in the `need` 32bit integer wrapping to 0 when `need` approaches a value of 0x80000000 (i.e. ~2GB of data), which results in a reallocation of buf->alloc into a small heap chunk. These integers are declared as `size_t` in the 2.x branch of `yajl`, which practically prevents the issue from triggering on 64bit platforms, however this does not preclude this issue triggering on 32bit builds on which `size_t` is a 32bit integer. Subsequent population of this under-allocated heap chunk is based on the original buffer size, leading to heap memory corruption. This vulnerability mostly impacts process availability. Maintainers believe exploitation for arbitrary code execution is unlikely. A patch is available and anticipated to be part of yajl-ruby version 1.4.2. As a workaround, avoid passing large inputs to YAJL.\n\n- CVE-2022-25291: An integer overflow in WatchGuard Firebox and XTM appliances allows an authenticated remote attacker to trigger a heap-based buffer overflow and potentially execute arbitrary code by initiating a firmware update with a malicious upgrade image. This vulnerability impacts Fireware OS before 12.7.2_U2, 12.x before 12.1.3_U8, and 12.2.x through 12.5.x before 12.5.9_U2.\n\n- CVE-2022-2566: A heap out-of-bounds memory write exists in FFMPEG since version 5.1. The size calculation in `build_open_gop_key_points()` goes through all entries in the loop and adds `sc->ctts_data[i].count` to `sc->sample_offsets_count`. This can lead to an integer overflow resulting in a small allocation with `av_calloc()`. An attacker can cause remote code execution via a malicious mp4 file. We recommend upgrading past commit c953baa084607dd1d84c3bfcce3cf6a87c3e6e05\n\n- CVE-2022-26459: In vow, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07032634; Issue ID: ALPS07032634.\n\n- CVE-2022-26495: In nbd-server in nbd before 3.24, there is an integer overflow with a resultant heap-based buffer overflow. A value of 0xffffffff in the name length field will cause a zero-sized buffer to be allocated for the name, resulting in a write to a dangling pointer. This issue exists for the NBD_OPT_INFO, NBD_OPT_GO, and NBD_OPT_EXPORT_NAME messages.\n\n- CVE-2022-28331: On Windows, Apache Portable Runtime 1.7.0 and earlier may write beyond the end of a stack based buffer in apr_socket_sendv(). This is a result of integer overflow.\n\n- CVE-2022-28471: In ffjpeg (commit hash: caade60), the function bmp_load() in bmp.c contains an integer overflow vulnerability, which eventually results in the heap overflow in jfif_encode() in jfif.c. This is due to the incomplete patch for issue 38\n\n- CVE-2022-29203: TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.SpaceToBatchND` (in all backends such as XLA and handwritten kernels) is vulnerable to an integer overflow: The result of this integer overflow is used to allocate the output tensor, hence we get a denial of service via a `CHECK`-failure (assertion failure), as in TFSA-2021-198. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue.\n\n- CVE-2022-29886: An integer overflow vulnerability exists in the way ESTsoft Alyac 2.5.8.544 parses OLE files. A specially-crafted OLE file can lead to a heap buffer overflow, which can result in arbitrary code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2022-32543: An integer overflow vulnerability exists in the way ESTsoft Alyac 2.5.8.544 parses OLE files. A specially-crafted OLE file can lead to a heap buffer overflow which can result in arbitrary code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2022-33266: Memory corruption in Audio due to integer overflow to buffer overflow while music playback of clips like amr,evrc,qcelp with modified content.\n\n- CVE-2022-35289: A write-what-where condition in hermes caused by an integer overflow, prior to commit 5b6255ae049fa4641791e47fad994e8e8c4da374 allows attackers to potentially execute arbitrary code via crafted JavaScript. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected.\n\n- CVE-2022-35951: Redis is an in-memory database that persists on disk. Versions 7.0.0 and above, prior to 7.0.5 are vulnerable to an Integer Overflow. Executing an `XAUTOCLAIM` command on a stream key in a specific state, with a specially crafted `COUNT` argument may cause an integer overflow, a subsequent heap overflow, and potentially lead to remote code execution. This has been patched in Redis version 7.0.5. No known workarounds exist.\n\n- CVE-2022-39343: Azure RTOS FileX is a FAT-compatible file system that\u2019s fully integrated with Azure RTOS ThreadX. In versions before 6.2.0, the Fault Tolerant feature of Azure RTOS FileX includes integer under and overflows which may be exploited to achieve buffer overflow and modify memory contents. When a valid log file with correct ID and checksum is detected by the `_fx_fault_tolerant_enable` function an attempt to recover the previous failed write operation is taken by call of `_fx_fault_tolerant_apply_logs`. This function iterates through the log entries and performs required recovery operations. When properly crafted a log including entries of type `FX_FAULT_TOLERANT_DIR_LOG_TYPE` may be utilized to introduce unexpected behavior. This issue has been patched in version 6.2.0. A workaround to fix line 218 in fx_fault_tolerant_apply_logs.c is documented in the GHSA.\n\n- CVE-2022-41318: A buffer over-read was discovered in libntlmauth in Squid 2.5 through 5.6. Due to incorrect integer-overflow protection, the SSPI and SMB authentication helpers are vulnerable to reading unintended memory locations. In some configurations, cleartext credentials from these locations are sent to a client. This is fixed in 5.7.\n\n- CVE-2022-4172: An integer overflow and buffer overflow issues were found in the ACPI Error Record Serialization Table (ERST) device of QEMU in the read_erst_record() and write_erst_record() functions. Both issues may allow the guest to overrun the host buffer allocated for the ERST memory device. A malicious guest could use these flaws to crash the QEMU process on the host.\n\n- CVE-2022-42898: PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has \"a similar bug.\"\n\n- CVE-2022-44638: In libpixman in Pixman before 0.42.2, there is an out-of-bounds write (aka heap-based buffer overflow) in rasterize_edges_8 due to an integer overflow in pixman_sample_floor_y.\n\n- CVE-2022-3970: A vulnerability was found in LibTIFF. It has been classified as critical. This affects the function TIFFReadRGBATileExt of the file libtiff/tif_getimage.c. The manipulation leads to integer overflow. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used. The name of the patch is 227500897dfb07fb7d27f7aa570050e62617e3be. It is recommended to apply a patch to fix this issue. The identifier VDB-213549 was assigned to this vulnerability.\n\n- CVE-2022-4202: A vulnerability, which was classified as problematic, was found in GPAC 2.1-DEV-rev490-g68064e101-master. Affected is the function lsr_translate_coords of the file laser/lsr_dec.c. The manipulation leads to integer overflow. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used. The name of the patch is b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908. It is recommended to apply a patch to fix this issue. VDB-214518 is the identifier assigned to this vulnerability.\n\n- CVE-2022-25705: Memory corruption in modem due to integer overflow to buffer overflow while handling APDU response\n\n- CVE-2022-25748: Memory corruption in WLAN due to integer overflow to buffer overflow while parsing GTK frames. in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer Electronics Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables, Snapdragon Wired Infrastructure and Networking\n\n- CVE-2022-33219: Memory corruption in Automotive due to integer overflow to buffer overflow while registering a new listener with shared buffer.\n\n- CVE-2022-39907: Integer overflow vulnerability in Samsung decoding library for video thumbnails prior to SMR Dec-2022 Release 1 allows local attacker to perform Out-Of-Bounds Write.\n\n- CVE-2022-40530: Memory corruption in WLAN due to integer overflow to buffer overflow in WLAN during initialization phase.\n\n- CVE-2021-20268: An out-of-bounds access flaw was found in the Linux kernel's implementation of the eBPF code verifier in the way a user running the eBPF script calls dev_map_init_map or sock_map_alloc. This flaw allows a local user to crash the system or possibly escalate their privileges. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.\n\n- CVE-2022-28937: FISCO-BCOS release-3.0.0-rc2 was discovered to contain an issue where a malicious node, via an invalid proposal with an invalid header, will cause normal nodes to stop producing new blocks and processing new clients' requests.\n\n- CVE-2022-1699: Uncontrolled Resource Consumption in GitHub repository causefx/organizr prior to 2.1.2000. This vulnerability can be abused by doing a DDoS attack for which genuine users will not able to access resources/applications.\n\nRelated Weaknesses:\n\n- CWE-682 (ChildOf)\n\n- CWE-682 (ChildOf)\n\n- CWE-20 (ChildOf)\n\n- CWE-119 (CanPrecede)",
          "type": "Base",
          "source": "sparse",
          "search_source": "weakness:memory corruption",
          "sources": [
            "base",
            "weakness"
          ],
          "boost_factor": 2.8,
          "boosted": true,
          "metadata": {
            "source": "sparse",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Be careful of terminology problems with \"overflow,\" \"underflow,\" and \"wraparound\" - see Terminology Notes. Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ],
              "suggestions": [
                {
                  "CweID": "191",
                  "Comment": "Integer Underflow (Wrap or Wraparound). Consider CWE-191 when the result is less than the minimum value that can be represented (sometimes called \"underflows\")."
                }
              ]
            }
          }
        },
        {
          "cwe_id": "788",
          "name": "Access of Memory Location After End of Buffer",
          "description": "The product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.",
          "score": 51.05905723022035,
          "matched_text": "CWE-788: Access of Memory Location After End of Buffer\n\nType: Base\n\nStatus: Incomplete\n\nDescription:\n\nThe product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.\n\nExtended Details:\n\nThis typically occurs when a pointer or its index is incremented to a position after the buffer; or when pointer arithmetic results in a position after the buffer.\n\nReal-World Examples:\n\n- CVE-2009-2550: Classic stack-based buffer overflow in media player using a long entry in a playlist\n\n- CVE-2009-2403: Heap-based buffer overflow in media player using a long entry in a playlist\n\n- CVE-2009-0689: large precision value in a format string triggers overflow\n\n- CVE-2009-0558: attacker-controlled array index leads to code execution\n\n- CVE-2008-4113: OS kernel trusts userland-supplied length value, allowing reading of sensitive information\n\n- CVE-2007-4268: Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)\n\nTop 25 CWE Examples:\n\n- CVE-2021-28602: Adobe After Effects version 18.2 (and earlier) is affected by a memory corruption vulnerability when parsing a specially crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-28605: Adobe After Effects version 18.2 (and earlier) is affected by a memory corruption vulnerability when parsing a specially crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-36059: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-36067: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-36068: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-36069: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-36076: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-36077: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious SVG file, potentially resulting in local application denial of service in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-36078: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-39816: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-39817: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-39818: Adobe InCopy version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious TIFF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-39819: Adobe InCopy version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious XML file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-39824: Adobe Premiere Elements version 2021.2235820 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious png file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-39830: Adobe Framemaker versions 2019 Update 8 (and earlier) and 2020 Release Update 2 (and earlier) are affected by a memory corruption vulnerability due to insecure handling of a malicious PDF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-39832: Adobe Framemaker versions 2019 Update 8 (and earlier) and 2020 Release Update 2 (and earlier) are affected by a memory corruption vulnerability due to insecure handling of a malicious PDF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40700: Adobe Premiere Elements version 2021.2235820 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious TIFF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40701: Adobe Premiere Elements version 2021.2235820 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious m4a file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40702: Adobe Premiere Elements version 2021.2235820 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious psd file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40703: Adobe Premiere Elements version 2021.2235820 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious m4a file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40710: Adobe Premiere Pro version 15.4 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious .svg file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40715: Adobe Premiere Pro version 15.4 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious .exr file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40733: Adobe Animate version 21.0.9 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious .psd file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40751: Adobe After Effects version 18.4 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious .m4a file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40752: Adobe After Effects version 18.4 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious .m4a file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40753: Adobe After Effects version 18.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious SVG file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40754: Adobe After Effects version 18.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40755: Adobe After Effects version 18.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious SGI file in the DoReadContinue function, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40757: Adobe After Effects version 18.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious MXF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40758: Adobe After Effects version 18.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40759: Adobe After Effects version 18.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious .m4a file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40760: Adobe After Effects version 18.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious .m4a file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40770: Adobe Prelude version 10.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40771: Adobe Prelude version 10.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40772: Adobe Prelude version 10.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40775: Adobe Prelude version 10.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious SVG file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-42266: Adobe Animate version 21.0.9 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious FLA file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42723: Adobe Bridge version 11.1.1 (and earlier) is affected by an out-of-bounds read vulnerability when parsing a crafted SGI file, which could result in a read past the end of an allocated memory structure. An attacker could leverage this vulnerability to execute code in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-42726: Adobe Bridge version 11.1.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42737: Adobe Prelude version 10.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-42738: Adobe Prelude version 10.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious MXF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-43011: Adobe Prelude version 10.1 (and earlier) are affected by a memory corruption vulnerability. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious M4A file.\n\n- CVE-2021-43012: Adobe Prelude version 10.1 (and earlier) are affected by a memory corruption vulnerability. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious M4A file.\n\n- CVE-2021-43013: Adobe Media Encoder version 15.4.1 (and earlier) are affected by a memory corruption vulnerability. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-43015: Adobe InCopy version 16.4 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious GIF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-42721: Acrobat Bridge versions 11.1.1 and earlier are affected by a use-after-free vulnerability in the processing of Format event actions that could result in arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-42267: Adobe Animate version 21.0.9 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious FLA file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-36070: Adobe Media Encoder version 15.1 (and earlier) is affected by an improper memory access vulnerability when parsing a crafted .SVG file. An attacker could leverage this vulnerability to execute code in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-40142: In OPC Foundation Local Discovery Server (LDS) before 1.04.402.463, remote attackers can cause a denial of service (DoS) by sending carefully crafted messages that lead to Access of a Memory Location After the End of a Buffer.\n\n- CVE-2021-41771: ImportedSymbols in debug/macho (for Open or OpenFat) in Go before 1.16.10 and 1.17.x before 1.17.3 Accesses a Memory Location After the End of a Buffer, aka an out-of-bounds slice situation.\n\n- CVE-2021-45067: Acrobat Reader DC version 21.007.20099 (and earlier), 20.004.30017 (and earlier) and 17.011.30204 (and earlier) are affected by an Access of Memory Location After End of Buffer vulnerability that could lead to disclosure of sensitive memory. An attacker could leverage this vulnerability to bypass mitigations such as ASLR. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-44712: Acrobat Reader DC version 21.007.20099 (and earlier), 20.004.30017 (and earlier) and 17.011.30204 (and earlier) are affected by an Access of Memory Location After End of Buffer vulnerability that could lead to application denial-of-service. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-39820: Adobe InDesign versions 16.3 (and earlier), and 16.3.1 (and earlier) is affected by an Out-of-bounds Write vulnerability due to insecure handling of a malicious TIFF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40734: Adobe Audition version 14.4 (and earlier) is affected by a memory corruption vulnerability when parsing a SVG file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40735: Adobe Audition version 14.4 (and earlier) is affected by a memory corruption vulnerability, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40736: Adobe Audition version 14.4 (and earlier) is affected by a memory corruption vulnerability, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40738: Adobe Audition version 14.4 (and earlier) is affected by a memory corruption vulnerability when parsing a WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40739: Adobe Audition version 14.4 (and earlier) is affected by a memory corruption vulnerability when parsing a M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40740: Adobe Audition version 14.4 (and earlier) is affected by a memory corruption vulnerability when parsing a M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40763: Adobe Character Animator version 4.4 (and earlier) is affected by a memory corruption vulnerability when parsing a WAF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40764: Adobe Character Animator version 4.4 (and earlier) is affected by a memory corruption vulnerability when parsing a M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40765: Adobe Character Animator version 4.4 (and earlier) is affected by a memory corruption vulnerability when parsing a M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40777: Adobe Media Encoder version 15.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40779: Adobe Media Encoder version 15.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40780: Adobe Media Encoder version 15.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40783: Adobe Premiere Rush version 1.5.16 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40784: Adobe Premiere Rush version 1.5.16 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40786: Adobe Premiere Elements 20210809.daily.2242976 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40787: Adobe Premiere Elements 20210809.daily.2242976 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40792: Adobe Premiere Pro version 15.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40793: Adobe Premiere Pro version 15.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40794: Adobe Premiere Pro version 15.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42526: Adobe Premiere Elements 20210809.daily.2242976 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42527: Adobe Premiere Elements 20210809.daily.2242976 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42724: Adobe Bridge version 11.1.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42725: Adobe Bridge version 11.1.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42729: Adobe Bridge version 11.1.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42730: Adobe Bridge version 11.1.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious PSD file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-43754: Adobe Prelude version 22.1.1 (and earlier) is affected by an Out-of-bounds Write vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-43755: Adobe After Effects versions 22.0 (and earlier) and 18.4.2 (and earlier) are affected by an Out-of-bounds Write vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-43756: Adobe Media Encoder versions 22.0, 15.4.2 (and earlier) are affected by an Out-of-bounds Write vulnerability. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2022-0521: Access of Memory Location After End of Buffer in GitHub repository radareorg/radare2 prior to 5.6.2.\n\nRelated Weaknesses:\n\n- CWE-119 (ChildOf)\n\n- CWE-119 (ChildOf)\n\n- CWE-119 (ChildOf)",
          "type": "Base",
          "source": "sparse",
          "search_source": "weakness:memory corruption",
          "sources": [
            "base",
            "weakness"
          ],
          "boost_factor": 2.8,
          "boosted": true,
          "metadata": {
            "source": "sparse",
            "mapping_notes": {
              "usage": "Discouraged",
              "rationale": "The CWE entry might be misused when lower-level CWE entries might be available. It also overlaps existing CWE entries and might be deprecated in the future.",
              "comments": "If the \"Access\" operation is known to be a read or a write, then investigate children of entries such as CWE-787: Out-of-bounds Write and CWE-125: Out-of-bounds Read.",
              "reasons": [
                "Potential Deprecation",
                "Frequent Misuse"
              ]
            }
          }
        },
        {
          "cwe_id": "366",
          "name": "Race Condition within a Thread",
          "description": "If two threads of execution use a resource simultaneously, there exists the possibility that resources may be used while invalid, in turn making the state of execution undefined.",
          "score": 50.5279456484442,
          "matched_text": "CWE-366: Race Condition within a Thread\n\nType: Base\n\nStatus: Draft\n\nDescription:\n\nIf two threads of execution use a resource simultaneously, there exists the possibility that resources may be used while invalid, in turn making the state of execution undefined.\n\nReal-World Examples:\n\n- CVE-2022-2621: Chain: two threads in a web browser use the same resource (CWE-366), but one of those threads can destroy the resource before the other has completed (CWE-416).\n\nTop 25 CWE Examples:\n\n- CVE-2021-0652: In VectorDrawable::VectorDrawable of VectorDrawable.java, there is a possible way to introduce a memory corruption due to sharing of not thread-safe objects. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-8.1 Android-9 Android-10 Android-11Android ID: A-185178568\n\n- CVE-2021-21165: Data race in audio in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21166: Data race in audio in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-26569: Race Condition within a Thread vulnerability in iscsi_snapshot_comm_core in Synology DiskStation Manager (DSM) before 6.2.3-25426-3 allows remote attackers to execute arbitrary code via crafted web requests.\n\n- CVE-2020-36447: An issue was discovered in the v9 crate through 2020-12-18 for Rust. There is an unconditional implementation of Sync for SyncRef<T>.\n\n- CVE-2020-36448: An issue was discovered in the cache crate through 2020-11-24 for Rust. There are unconditional implementations of Send and Sync for Cache<K>.\n\n- CVE-2020-36449: An issue was discovered in the kekbit crate before 0.3.4 for Rust. For ShmWriter<H>, Send is implemented without requiring H: Send.\n\n- CVE-2020-36450: An issue was discovered in the bunch crate through 2020-11-12 for Rust. There are unconditional implementations of Send and Sync for Bunch<T>.\n\n- CVE-2020-36451: An issue was discovered in the rcu_cell crate through 2020-11-14 for Rust. There are unconditional implementations of Send and Sync for RcuCell<T>.\n\n- CVE-2020-36455: An issue was discovered in the slock crate through 2020-11-17 for Rust. Slock<T> unconditionally implements Send and Sync.\n\n- CVE-2020-36456: An issue was discovered in the toolshed crate through 2020-11-15 for Rust. In CopyCell<T>, the Send trait lacks bounds on the contained type.\n\n- CVE-2020-36457: An issue was discovered in the lever crate before 0.1.1 for Rust. AtomicBox<T> implements the Send and Sync traits for all types T.\n\n- CVE-2020-36458: An issue was discovered in the lexer crate through 2020-11-10 for Rust. For ReaderResult<T, E>, there is an implementation of Sync with a trait bound of T: Send, E: Send.\n\n- CVE-2020-36459: An issue was discovered in the dces crate through 2020-12-09 for Rust. The World type is marked as Send but lacks bounds on its EntityStore and ComponentStore.\n\n- CVE-2020-36461: An issue was discovered in the noise_search crate through 2020-12-10 for Rust. There are unconditional implementations of Send and Sync for MvccRwLock.\n\n- CVE-2020-36462: An issue was discovered in the syncpool crate before 0.1.6 for Rust. There is an unconditional implementation of Send for Bucket2.\n\n- CVE-2020-36463: An issue was discovered in the multiqueue crate through 2020-12-25 for Rust. There are unconditional implementations of Send for InnerSend<RW, T>, InnerRecv<RW, T>, FutInnerSend<RW, T>, and FutInnerRecv<RW, T>.\n\n- CVE-2021-33078: Race condition within a thread in firmware for some Intel(R) Optane(TM) SSD and Intel(R) SSD DC Products may allow a privileged user to potentially enable denial of service via local access.\n\n- CVE-2021-44733: A use-after-free exists in drivers/tee/tee_shm.c in the TEE subsystem in the Linux kernel through 5.15.11. This occurs because of a race condition in tee_shm_get_from_id during an attempt to free a shared memory object.\n\n- CVE-2022-20148: In TBD of TBD, there is a possible use-after-free due to a race condition. This could lead to local escalation of privilege in the kernel with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-219513976References: Upstream kernel\n\n- CVE-2022-2607: Use after free in Tab Strip in Google Chrome on Chrome OS prior to 104.0.5112.79 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2608: Use after free in Overview Mode in Google Chrome on Chrome OS prior to 104.0.5112.79 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2609: Use after free in Nearby Share in Google Chrome on Chrome OS prior to 104.0.5112.79 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2617: Use after free in Extensions API in Google Chrome prior to 104.0.5112.79 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2621: Use after free in Extensions in Google Chrome prior to 104.0.5112.79 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2857: Use after free in Blink in Google Chrome prior to 104.0.5112.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2742: Use after free in Exosphere in Google Chrome on Chrome OS and Lacros prior to 104.0.5112.79 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via crafted UI interactions. (Chrome security severity: High)\n\n- CVE-2022-2854: Use after free in SwiftShader in Google Chrome prior to 104.0.5112.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3049: Use after free in SplitScreen in Google Chrome on Chrome OS, Lacros prior to 105.0.5195.52 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3071: Use after free in Tab Strip in Google Chrome on Chrome OS, Lacros prior to 105.0.5195.52 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via crafted UI interaction.\n\nRelated Weaknesses:\n\n- CWE-362 (ChildOf)\n\n- CWE-662 (ChildOf)\n\n- CWE-662 (ChildOf)",
          "type": "Base",
          "source": "sparse",
          "search_source": "weakness:memory corruption",
          "sources": [
            "base",
            "weakness"
          ],
          "boost_factor": 2.8,
          "boosted": true,
          "metadata": {
            "source": "sparse",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            }
          }
        },
        {
          "cwe_id": "822",
          "name": "Untrusted Pointer Dereference",
          "description": "The product obtains a value from an untrusted source, converts this value to a pointer, and dereferences the resulting pointer.",
          "score": 48.46614763081808,
          "matched_text": "CWE-822: Untrusted Pointer Dereference\n\nType: Base\n\nStatus: Incomplete\n\nDescription:\n\nThe product obtains a value from an untrusted source, converts this value to a pointer, and dereferences the resulting pointer.\n\nExtended Details:\n\n\n\nAn attacker can supply a pointer for memory locations that the product is not expecting. If the pointer is dereferenced for a write operation, the attack might allow modification of critical state variables, cause a crash, or execute code. If the dereferencing operation is for a read, then the attack might allow reading of sensitive data, cause a crash, or set a variable to an unexpected value (since the value will be read from an unexpected memory location).\n\n\nThere are several variants of this weakness, including but not necessarily limited to:\n\n\n  - The untrusted value is directly invoked as a function call.\n\n  - In OS kernels or drivers where there is a boundary between \"userland\" and privileged memory spaces, an untrusted pointer might enter through an API or system call (see CWE-781 for one such example).\n\n  - Inadvertently accepting the value from an untrusted control sphere when it did not have to be accepted as input at all. This might occur when the code was originally developed to be run by a single user in a non-networked environment, and the code is then ported to or otherwise exposed to a networked environment.\n\n\n\nReal-World Examples:\n\n- CVE-2007-5655: message-passing framework interprets values in packets as pointers, causing a crash.\n\n- CVE-2010-2299: labeled as a \"type confusion\" issue, also referred to as a \"stale pointer.\" However, the bug ID says \"contents are simply interpreted as a pointer... renderer ordinarily doesn't supply this pointer directly\". The \"handle\" in the untrusted area is replaced in one function, but not another - thus also, effectively, exposure to wrong sphere (CWE-668).\n\n- CVE-2009-1719: Untrusted dereference using undocumented constructor.\n\n- CVE-2009-1250: An error code is incorrectly checked and interpreted as a pointer, leading to a crash.\n\n- CVE-2009-0311: An untrusted value is obtained from a packet and directly called as a function pointer, leading to code execution.\n\n- CVE-2010-1818: Undocumented attribute in multimedia software allows \"unmarshaling\" of an untrusted pointer.\n\n- CVE-2010-3189: ActiveX control for security software accepts a parameter that is assumed to be an initialized pointer.\n\n- CVE-2010-1253: Spreadsheet software treats certain record values that lead to \"user-controlled pointer\" (might be untrusted offset, not untrusted pointer).\n\nTop 25 CWE Examples:\n\n- CVE-2021-22649: Luxion KeyShot versions prior to 10.1, Luxion KeyShot Viewer versions prior to 10.1, Luxion KeyShot Network Rendering versions prior to 10.1, and Luxion KeyVR versions prior to 10.1 have multiple NULL pointer dereference issues while processing project files, which may allow an attacker to execute arbitrary code.\n\n- CVE-2021-40157: A user may be tricked into opening a malicious FBX file which may exploit an Untrusted Pointer Dereference vulnerability in FBX\u2019s Review version 1.5.0 and prior causing it to run arbitrary code on the system.\n\n- CVE-2021-1973: A FTM Diag command can allow an arbitrary write into modem OS space in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2021-20239: A flaw was found in the Linux kernel in versions before 5.4.92 in the BPF protocol. This flaw allows an attacker with a local account to leak information about kernel internal addresses. The highest threat from this vulnerability is to confidentiality.\n\n- CVE-2020-7452: In FreeBSD 12.1-STABLE before r357490, 12.1-RELEASE before 12.1-RELEASE-p3, 11.3-STABLE before r357489, and 11.3-RELEASE before 11.3-RELEASE-p7, incorrect use of a user-controlled pointer in the epair virtual network module allowed vnet jailed privileged users to panic the host system and potentially execute arbitrary code in the kernel.\n\n- CVE-2021-46019: An untrusted pointer dereference in rec_db_destroy() at rec-db.c of GNU Recutils v1.8.90 can lead to a segmentation fault or application crash.\n\n- CVE-2021-46237: An untrusted pointer dereference vulnerability exists in GPAC v1.1.0 via the function gf_node_unregister () at scenegraph/base_scenegraph.c. This vulnerability can lead to a Denial of Service (DoS).\n\n- CVE-2021-46243: An untrusted pointer dereference vulnerability exists in HDF5 v1.13.1-1 via the function H5O__dtype_decode_helper () at hdf5/src/H5Odtype.c. This vulnerability can lead to a Denial of Service (DoS).\n\n- CVE-2021-46020: An untrusted pointer dereference in mrb_vm_exec() of mruby v3.0.0 can lead to a segmentation fault or application crash.\n\n- CVE-2021-46023: An Untrusted Pointer Dereference was discovered in function mrb_vm_exec in mruby before 3.1.0-rc. The vulnerability causes a segmentation fault and application crash.\n\n- CVE-2022-22098: Memory corruption in multimedia driver due to untrusted pointer dereference while reading data from socket in Snapdragon Auto\n\n- CVE-2022-25661: Memory corruption due to untrusted pointer dereference in kernel in Snapdragon Auto, Snapdragon Compute, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile\n\n- CVE-2022-25658: Memory corruption due to incorrect pointer arithmetic when attempting to change the endianness in video parser function in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2021-41837: An issue was discovered in AhciBusDxe in the kernel 5.0 through 5.5 in Insyde InsydeH2O. Because of an Untrusted Pointer Dereference that causes SMM memory corruption, an attacker may be able to write fixed or predictable data to SMRAM. Exploiting this issue could lead to escalating privileges to SMM.\n\n- CVE-2021-41839: An issue was discovered in NvmExpressDxe in the kernel 5.0 through 5.5 in Insyde InsydeH2O. Because of an Untrusted Pointer Dereference that causes SMM memory corruption, an attacker may be able to write fixed or predictable data to SMRAM. Exploiting this issue could lead to escalating privileges to SMM.\n\n- CVE-2022-25662: Information disclosure due to untrusted pointer dereference in kernel in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile, Snapdragon Wearables\n\n- CVE-2022-22716: Microsoft Excel Information Disclosure Vulnerability\n\n- CVE-2022-29275: In UsbCoreDxe, untrusted input may allow SMRAM or OS memory tampering Use of untrusted pointers could allow OS or SMRAM memory tampering leading to escalation of privileges. This issue was discovered by Insyde during security review. It was fixed in: Kernel 5.0: version 05.09.21 Kernel 5.1: version 05.17.21 Kernel 5.2: version 05.27.21 Kernel 5.3: version 05.36.21 Kernel 5.4: version 05.44.21 Kernel 5.5: version 05.52.21 https://www.insyde.com/security-pledge/SA-2022058\n\n- CVE-2022-29279: Use of a untrusted pointer allows tampering with SMRAM and OS memory in SdHostDriver and SdMmcDevice Use of a untrusted pointer allows tampering with SMRAM and OS memory in SdHostDriver and SdMmcDevice. This issue was discovered by Insyde during security review. It was fixed in: Kernel 5.0: version 05.09.17 Kernel 5.1: version 05.17.17 Kernel 5.2: version 05.27.17 Kernel 5.3: version 05.36.17 Kernel 5.4: version 05.44.17 Kernel 5.5: version 05.52.17 https://www.insyde.com/security-pledge/SA-2022062\n\nRelated Weaknesses:\n\n- CWE-119 (ChildOf)\n\n- CWE-119 (ChildOf)\n\n- CWE-119 (ChildOf)\n\n- CWE-125 (CanPrecede)\n\n- CWE-787 (CanPrecede)",
          "type": "Base",
          "source": "sparse",
          "search_source": "weakness:memory corruption",
          "sources": [
            "base",
            "weakness"
          ],
          "boost_factor": 2.8,
          "boosted": true,
          "metadata": {
            "source": "sparse",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            }
          }
        },
        {
          "cwe_id": "908",
          "name": "Use of Uninitialized Resource",
          "description": "The product uses or accesses a resource that has not been initialized.",
          "score": 47.42449593239558,
          "matched_text": "CWE-908: Use of Uninitialized Resource\n\nType: Base\n\nStatus: Incomplete\n\nDescription:\n\nThe product uses or accesses a resource that has not been initialized.\n\nExtended Details:\n\nWhen a resource has not been properly initialized, the product may behave unexpectedly. This may lead to a crash or invalid memory access, but the consequences vary depending on the type of resource and how it is used within the product.\n\nReal-World Examples:\n\n- CVE-2019-9805: Chain: Creation of the packet client occurs before initialization is complete (CWE-696) resulting in a read from uninitialized memory (CWE-908), causing memory corruption.\n\n- CVE-2008-4197: Use of uninitialized memory may allow code execution.\n\n- CVE-2008-2934: Free of an uninitialized pointer leads to crash and possible code execution.\n\n- CVE-2008-0063: Product does not clear memory contents when generating an error message, leading to information leak.\n\n- CVE-2008-0062: Lack of initialization triggers NULL pointer dereference or double-free.\n\n- CVE-2008-0081: Uninitialized variable leads to code execution in popular desktop application.\n\n- CVE-2008-3688: Chain: Uninitialized variable leads to infinite loop.\n\n- CVE-2008-3475: Chain: Improper initialization leads to memory corruption.\n\n- CVE-2005-1036: Chain: Bypass of access restrictions due to improper authorization (CWE-862) of a user results from an improperly initialized (CWE-909) I/O permission bitmap\n\n- CVE-2008-3597: Chain: game server can access player data structures before initialization has happened leading to NULL dereference\n\n- CVE-2009-2692: Chain: uninitialized function pointers can be dereferenced allowing code execution\n\n- CVE-2009-0949: Chain: improper initialization of memory can lead to NULL dereference\n\n- CVE-2009-3620: Chain: some unprivileged ioctls do not verify that a structure has been initialized before invocation, leading to NULL dereference\n\nTop 25 CWE Examples:\n\n- CVE-2021-0473: In rw_t3t_process_error of rw_t3t.cc, there is a possible double free due to uninitialized data. This could lead to remote code execution over NFC with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-9 Android-10 Android-11 Android-8.1Android ID: A-179687208\n\n- CVE-2021-0495: In memory management driver, there is a possible out of bounds write due to uninitialized data. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-183459083\n\n- CVE-2021-0526: In memory management driver, there is a possible out of bounds write due to uninitialized data. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-185195264\n\n- CVE-2021-0530: In memory management driver, there is a possible out of bounds write due to uninitialized data. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-185196175\n\n- CVE-2021-0634: In display driver, there is a possible memory corruption due to uninitialized data. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05594994; Issue ID: ALPS05594994.\n\n- CVE-2021-25905: An issue was discovered in the bra crate before 0.1.1 for Rust. It lacks soundness because it can read uninitialized memory.\n\n- CVE-2021-28033: An issue was discovered in the byte_struct crate before 0.6.1 for Rust. There can be a drop of uninitialized memory if a certain deserialization method panics.\n\n- CVE-2021-29631: In FreeBSD 13.0-STABLE before n246941-20f96f215562, 12.2-STABLE before r370400, 11.4-STABLE before r370399, 13.0-RELEASE before p4, 12.2-RELEASE before p10, and 11.4-RELEASE before p13, certain VirtIO-based device models in bhyve failed to handle errors when fetching I/O descriptors. A malicious guest may cause the device model to operate on uninitialized I/O vectors leading to memory corruption, crashing of the bhyve process, and possibly arbitrary code execution in the bhyve process.\n\n- CVE-2021-29930: An issue was discovered in the arenavec crate through 2021-01-12 for Rust. A drop of uninitialized memory can sometimes occur upon a panic in T::default().\n\n- CVE-2021-29934: An issue was discovered in PartialReader in the uu_od crate before 0.0.4 for Rust. Attackers can read the contents of uninitialized memory locations via a user-provided Read operation.\n\n- CVE-2021-29980: Uninitialized memory in a canvas object could have caused an incorrect free() leading to memory corruption and a potentially exploitable crash. This vulnerability affects Thunderbird < 78.13, Thunderbird < 91, Firefox ESR < 78.13, and Firefox < 91.\n\n- CVE-2021-30454: An issue was discovered in the outer_cgi crate before 0.2.1 for Rust. A user-provided Read instance receives an uninitialized memory buffer from KeyValueReader.\n\n- CVE-2021-29937: An issue was discovered in the telemetry crate through 2021-02-17 for Rust. There is a drop of uninitialized memory if a value.clone() call panics within misc::vec_with_size().\n\n- CVE-2021-3545: An information disclosure vulnerability was found in the virtio vhost-user GPU device (vhost-user-gpu) of QEMU in versions up to and including 6.0. The flaw exists in virgl_cmd_get_capset_info() in contrib/vhost-user-gpu/virgl.c and could occur due to the read of uninitialized memory. A malicious guest could exploit this issue to leak memory from the host.\n\n- CVE-2020-36432: An issue was discovered in the alg_ds crate through 2020-08-25 for Rust. There is a drop of uninitialized memory in Matrix::new().\n\n- CVE-2020-36452: An issue was discovered in the array-tools crate before 0.3.2 for Rust. FixedCapacityDequeLike::clone() has a drop of uninitialized memory.\n\n- CVE-2021-28035: An issue was discovered in the stack_dst crate before 0.6.1 for Rust. Because of the push_inner behavior, a drop of uninitialized memory can occur upon a val.clone() panic.\n\n- CVE-2021-28029: An issue was discovered in the toodee crate before 0.3.0 for Rust. The row-insertion feature allows attackers to read the contents of uninitialized memory locations.\n\n- CVE-2021-36282: Dell EMC PowerScale OneFS versions 8.2.x - 9.1.0.x contain a use of uninitialized resource vulnerability. This can potentially allow an authenticated user with ISI_PRIV_LOGIN_CONSOLE or ISI_PRIV_LOGIN_SSH privileges to gain access up to 24 bytes of data within the /ifs kernel stack under certain conditions.\n\n- CVE-2021-43848: h2o is an open source http server. In code prior to the `8c0eca3` commit h2o may attempt to access uninitialized memory. When receiving QUIC frames in certain order, HTTP/3 server-side implementation of h2o can be misguided to treat uninitialized memory as HTTP/3 frames that have been received. When h2o is used as a reverse proxy, an attacker can abuse this vulnerability to send internal state of h2o to backend servers controlled by the attacker or third party. Also, if there is an HTTP endpoint that reflects the traffic sent from the client, an attacker can use that reflector to obtain internal state of h2o. This internal state includes traffic of other connections in unencrypted form and TLS session tickets. This vulnerability exists in h2o server with HTTP/3 support, between commit 93af138 and d1f0f65. None of the released versions of h2o are affected by this vulnerability. There are no known workarounds. Users of unreleased versions of h2o using HTTP/3 are advised to upgrade immediately.\n\n- CVE-2021-39671: In code generated by aidl_const_expressions.cpp, there is a possible out of bounds read due to uninitialized data. This could lead to information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-12Android ID: A-206718630\n\n- CVE-2022-26437: In httpclient, there is a possible out of bounds write due to uninitialized data. This could lead to remote escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: WSAP00103831; Issue ID: WSAP00103831.\n\n- CVE-2022-2949:  Altair HyperView Player versions 2021.1.0.27 and prior are vulnerable to the use of uninitialized memory vulnerability during parsing of H3D files. A DWORD is extracted from an uninitialized buffer and, after sign extension, is used as an index into a stack variable to increment a counter leading to memory corruption. \n\n- CVE-2022-2950:  Altair HyperView Player versions 2021.1.0.27 and prior are vulnerable to the use of uninitialized memory vulnerability during parsing of H3D files. A DWORD is extracted from an uninitialized buffer and, after sign extension, is used as an index into a stack variable to increment a counter leading to memory corruption. \n\n- CVE-2022-32615: In ccd, there is a possible out of bounds write due to uninitialized data. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07326559; Issue ID: ALPS07326559.\n\n- CVE-2022-32616: In isp, there is a possible out of bounds write due to uninitialized data. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07341258; Issue ID: ALPS07341258.\n\n- CVE-2022-39283: FreeRDP is a free remote desktop protocol library and clients. All FreeRDP based clients when using the `/video` command line switch might read uninitialized data, decode it as audio/video and display the result. FreeRDP based server implementations are not affected. This issue has been patched in version 2.8.1. If you cannot upgrade do not use the `/video` switch.\n\n- CVE-2022-20015: In kd_camera_hw driver, there is a possible information disclosure due to uninitialized data. This could lead to local information disclosure with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05862966; Issue ID: ALPS05862966.\n\n- CVE-2022-20357: In writeToParcel of SurfaceControl.cpp, there is a possible information disclosure due to uninitialized data. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-12 Android-12LAndroid ID: A-214999987\n\n- CVE-2022-38668: HTTP applications (servers) based on Crow through 1.0+4 may reveal potentially sensitive uninitialized data from stack memory when fulfilling a request for a static file smaller than 16 KB.\n\n- CVE-2022-0494: A kernel information leak flaw was identified in the scsi_ioctl function in drivers/scsi/scsi_ioctl.c in the Linux kernel. This flaw allows a local attacker with a special user privilege (CAP_SYS_ADMIN or CAP_SYS_RAWIO) to create issues with confidentiality.\n\nRelated Weaknesses:\n\n- CWE-665 (ChildOf)\n\n- CWE-665 (ChildOf)",
          "type": "Base",
          "source": "sparse",
          "search_source": "weakness:memory corruption",
          "sources": [
            "base",
            "weakness"
          ],
          "boost_factor": 2.8,
          "boosted": true,
          "metadata": {
            "source": "sparse",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            }
          }
        },
        {
          "cwe_id": "191",
          "name": "Integer Underflow (Wrap or Wraparound)",
          "description": "The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.",
          "score": 10.227986494513978,
          "matched_text": "CWE-191: Integer Underflow (Wrap or Wraparound)\n\nType: Base\n\nStatus: Draft\n\nAlternative Terms:\n\nInteger underflow - \n\n\"Integer underflow\" is sometimes used to identify signedness errors in which an originally positive number becomes negative as a result of subtraction. However, there are cases of bad subtraction in which unsigned integers are involved, so it's not always a signedness issue.\n\n\n\"Integer underflow\" is occasionally used to describe array index errors in which the index is negative.\n\n\nInteger underflow - \n\n\"Integer underflow\" is sometimes used to identify signedness errors in which an originally positive number becomes negative as a result of subtraction. However, there are cases of bad subtraction in which unsigned integers are involved, so it's not always a signedness issue.\n\n\n\"Integer underflow\" is occasionally used to describe array index errors in which the index is negative.\n\n\nInteger underflow - \n\n\"Integer underflow\" is sometimes used to identify signedness errors in which an originally positive number becomes negative as a result of subtraction. However, there are cases of bad subtraction in which unsigned integers are involved, so it's not always a signedness issue.\n\n\n\"Integer underflow\" is occasionally used to describe array index errors in which the index is negative.\n\n\nDescription:\n\nThe product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.\n\nExtended Details:\n\nThis can happen in signed and unsigned cases.\n\nReal-World Examples:\n\n- CVE-2004-0816: Integer underflow in firewall via malformed packet.\n\n- CVE-2004-1002: Integer underflow by packet with invalid length.\n\n- CVE-2005-0199: Long input causes incorrect length calculation.\n\n- CVE-2005-1891: Malformed icon causes integer underflow in loop counter variable.\n\nTop 25 CWE Examples:\n\n- CVE-2021-27486: FATEK Automation WinProladder Versions 3.30 and prior is vulnerable to an integer underflow, which may cause an out-of-bounds write and allow an attacker to execute arbitrary code.\n\n- CVE-2021-28027: An issue was discovered in the bam crate before 0.1.3 for Rust. There is an integer underflow and out-of-bounds write during the loading of a bgzip block.\n\n- CVE-2021-28362: An issue was discovered in Contiki through 3.0. When sending an ICMPv6 error message because of invalid extension header options in an incoming IPv6 packet, there is an attempt to remove the RPL extension headers. Because the packet length and the extension header length are unchecked (with respect to the available data) at this stage, and these variables are susceptible to integer underflow, it is possible to construct an invalid extension header that will cause memory corruption issues and lead to a Denial-of-Service condition. This is related to rpl-ext-header.c.\n\n- CVE-2021-3321: Integer Underflow in Zephyr in IEEE 802154 Fragment Reassembly Header Removal. Zephyr versions >= >=2.4.0 contain Integer Overflow to Buffer Overflow (CWE-680). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-w44j-66g7-xw99\n\n- CVE-2021-31178: Microsoft Office Information Disclosure Vulnerability\n\n- CVE-2021-4066: Integer underflow in ANGLE in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0185: A heap-based buffer overflow flaw was found in the way the legacy_parse_param function in the Filesystem Context functionality of the Linux kernel verified the supplied parameters length. An unprivileged (in case of unprivileged user namespaces enabled, otherwise needs namespaced CAP_SYS_ADMIN privilege) local user able to open a filesystem that does not support the Filesystem Context API (and thus fallbacks to legacy handling) could use this flaw to escalate their privileges on the system.\n\n- CVE-2022-0544: An integer underflow in the DDS loader of Blender leads to an out-of-bounds read, possibly allowing an attacker to read sensitive data using a crafted DDS image file. This flaw affects Blender versions prior to 2.83.19, 2.93.8 and 3.1.\n\n- CVE-2022-20073: In preloader (usb), there is a possible out of bounds write due to a integer underflow. This could lead to local escalation of privilege, for an attacker who has physical access to the device, with no additional execution privileges needed. User interaction is needed for exploitation. Patch ID: ALPS06160841; Issue ID: ALPS06160841.\n\n- CVE-2022-20393: In extract3GPPGlobalDescriptions of TextDescriptions.cpp, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure from the media server with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11 Android-12 Android-12LAndroid ID: A-233735886\n\n- CVE-2022-20483: In several functions that parse avrc response in avrc_pars_ct.cc and related files, there are possible out of bounds reads due to integer overflows. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-242459126\n\n- CVE-2022-20516: In rw_t3t_act_handle_check_ndef_rsp of rw_t3t.cc, there is a possible out of bounds read due to an integer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-224002331\n\n- CVE-2022-23613: xrdp is an open source remote desktop protocol (RDP) server. In affected versions an integer underflow leading to a heap overflow in the sesman server allows any unauthenticated attacker which is able to locally access a sesman server to execute code as root. This vulnerability has been patched in version 0.9.18.1 and above. Users are advised to upgrade. There are no known workarounds.\n\n- CVE-2022-39293: Azure RTOS USBX is a high-performance USB host, device, and on-the-go (OTG) embedded stack, that is fully integrated with Azure RTOS ThreadX. The case is, in [_ux_host_class_pima_read](https://github.com/azure-rtos/usbx/blob/master/common/usbx_host_classes/src/ux_host_class_pima_read.c), there is data length from device response, returned in the very first packet, and read by [L165 code](https://github.com/azure-rtos/usbx/blob/082fd9db09a3669eca3358f10b8837a5c1635c0b/common/usbx_host_classes/src/ux_host_class_pima_read.c#L165), as header_length. Then in [L178 code](https://github.com/azure-rtos/usbx/blob/082fd9db09a3669eca3358f10b8837a5c1635c0b/common/usbx_host_classes/src/ux_host_class_pima_read.c#L178), there is a \u201cif\u201d branch, which check the expression of \u201c(header_length - UX_HOST_CLASS_PIMA_DATA_HEADER_SIZE) > data_length\u201d where if header_length is smaller than UX_HOST_CLASS_PIMA_DATA_HEADER_SIZE, calculation could overflow and then [L182 code](https://github.com/azure-rtos/usbx/blob/082fd9db09a3669eca3358f10b8837a5c1635c0b/common/usbx_host_classes/src/ux_host_class_pima_read.c#L182) the calculation of data_length is also overflow, this way the later [while loop start from L192](https://github.com/azure-rtos/usbx/blob/082fd9db09a3669eca3358f10b8837a5c1635c0b/common/usbx_host_classes/src/ux_host_class_pima_read.c#L192) can move data_pointer to unexpected address and cause write buffer overflow. The fix has been included in USBX release [6.1.12](https://github.com/azure-rtos/usbx/releases/tag/v6.1.12_rel). The following can be used as a workaround: Add check of `header_length`: 1. It must be greater than `UX_HOST_CLASS_PIMA_DATA_HEADER_SIZE`. 1. It should be greater or equal to the current returned data length (`transfer_request -> ux_transfer_request_actual_length`).\n\n- CVE-2022-4338: An integer underflow in Organization Specific TLV was found in various versions of OpenvSwitch.\n\n- CVE-2021-31956: Windows NTFS Elevation of Privilege Vulnerability\n\n- CVE-2022-22715: Named Pipe File System Elevation of Privilege Vulnerability\n\nRelated Weaknesses:\n\n- CWE-682 (ChildOf)\n\n- CWE-682 (ChildOf)",
          "type": "Base",
          "search_source": "base_query",
          "metadata": {
            "source": "sparse",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            }
          }
        },
        {
          "cwe_id": "770",
          "name": "Allocation of Resources Without Limits or Throttling",
          "description": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
          "score": 9.972354828241215,
          "matched_text": "CWE-770: Allocation of Resources Without Limits or Throttling\n\nType: Base\n\nStatus: Incomplete\n\nDescription:\n\nThe product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.\n\nExtended Details:\n\n\n\nCode frequently has to work with limited resources, so programmers must be careful to ensure that resources are not consumed too quickly, or too easily. Without use of quotas, resource limits, or other protection mechanisms, it can be easy for an attacker to consume many resources by rapidly making many requests, or causing larger resources to be used than is needed. When too many resources are allocated, or if a single resource is too large, then it can prevent the code from working correctly, possibly leading to a denial of service.\n\n\nReal-World Examples:\n\n- CVE-2022-21668: Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n\n- CVE-2009-4017: Language interpreter does not restrict the number of temporary files being created when handling a MIME request with a large number of parts..\n\n- CVE-2009-2726: Driver does not use a maximum width when invoking sscanf style functions, causing stack consumption.\n\n- CVE-2009-2540: Large integer value for a length property in an object causes a large amount of memory allocation.\n\n- CVE-2009-2054: Product allows exhaustion of file descriptors when processing a large number of TCP packets.\n\n- CVE-2008-5180: Communication product allows memory consumption with a large number of SIP requests, which cause many sessions to be created.\n\n- CVE-2008-1700: Product allows attackers to cause a denial of service via a large number of directives, each of which opens a separate window.\n\n- CVE-2005-4650: CMS does not restrict the number of searches that can occur simultaneously, leading to resource exhaustion.\n\n- CVE-2020-15100: web application scanner attempts to read an excessively large file created by a user, causing process termination\n\n- CVE-2020-7218: Go-based workload orchestrator does not limit resource usage with unauthenticated connections, allowing a DoS by flooding the service\n\nTop 25 CWE Examples:\n\n- CVE-2020-19463: An issue has been found in function vfprintf in PDF2JSON 0.70 that allows attackers to cause a Denial of Service due to a stack overflow.\n\n- CVE-2020-19464: An issue has been found in function XRef::fetch in PDF2JSON 0.70 that allows attackers to cause a Denial of Service due to a stack overflow .\n\n- CVE-2021-29324: OpenSource Moddable v10.5.0 was discovered to contain a stack overflow via the component /moddable/xs/sources/xsScript.c.\n\n- CVE-2021-29329: OpenSource Moddable v10.5.0 was discovered to contain a stack overflow in the fxBinaryExpressionNodeDistribute function at /moddable/xs/sources/xsTree.c.\n\n- CVE-2021-41800: MediaWiki before 1.36.2 allows a denial of service (resource consumption because of lengthy query processing time). Visiting Special:Contributions can sometimes result in a long running SQL query because PoolCounter protection is mishandled.\n\n- CVE-2021-35492: Wowza Streaming Engine through 4.8.11+5 could allow an authenticated, remote attacker to exhaust filesystem resources via the /enginemanager/server/vhost/historical.jsdata vhost parameter. This is due to the insufficient management of available filesystem resources. An attacker could exploit this vulnerability through the Virtual Host Monitoring section by requesting random virtual-host historical data and exhausting available filesystem resources. A successful exploit could allow the attacker to cause database errors and cause the device to become unresponsive to web-based management. (Manual intervention is required to free filesystem resources and return the application to an operational state.)\n\n- CVE-2021-22174: Crash in USB HID dissector in Wireshark 3.4.0 to 3.4.2 allows denial of service via packet injection or crafted capture file\n\n- CVE-2020-22785: Etherpad < 1.8.3 is affected by a missing lock check which could cause a denial of service. Aggressively targeting random pad import endpoints with empty data would flatten all pads due to lack of rate limiting and missing ownership check.\n\n- CVE-2021-33831: api/account/register in the TH Wildau COVID-19 Contact Tracing application through 2021-09-01 has Incorrect Access Control. An attacker can interfere with tracing of infection chains by creating 500 random users within 2500 seconds.\n\n- CVE-2020-28200: The Sieve engine in Dovecot before 2.3.15 allows Uncontrolled Resource Consumption, as demonstrated by a situation with a complex regular expression for the regex extension.\n\n- CVE-2021-41591: ACINQ Eclair before 0.6.3 allows loss of funds because of dust HTLC exposure.\n\n- CVE-2021-41592: Blockstream c-lightning through 0.10.1 allows loss of funds because of dust HTLC exposure.\n\n- CVE-2021-41593: Lightning Labs lnd before 0.13.3-beta allows loss of funds because of dust HTLC exposure.\n\n- CVE-2020-24821: A vulnerability in the dwarf::cursor::skip_form function of Libelfin v0.3 allows attackers to cause a denial of service (DOS) through a segmentation fault via a crafted ELF file.\n\n- CVE-2020-24822: A vulnerability in the dwarf::cursor::uleb function of Libelfin v0.3 allows attackers to cause a denial of service (DOS) through a segmentation fault via a crafted ELF file.\n\n- CVE-2020-24823: A vulnerability in the dwarf::to_string function of Libelfin v0.3 allows attackers to cause a denial of service (DOS) through a segmentation fault via a crafted ELF file.\n\n- CVE-2020-24825: A vulnerability in the line_table::line_table function of Libelfin v0.3 allows attackers to cause a denial of service (DOS) through a segmentation fault via a crafted ELF file.\n\n- CVE-2020-24826: A vulnerability in the elf::section::as_strtab function of Libelfin v0.3 allows attackers to cause a denial of service (DOS) through a segmentation fault via a crafted ELF file.\n\n- CVE-2021-0217: A vulnerability in processing of certain DHCP packets from adjacent clients on EX Series and QFX Series switches running Juniper Networks Junos OS with DHCP local/relay server configured may lead to exhaustion of DMA memory causing a Denial of Service (DoS). Over time, exploitation of this vulnerability may cause traffic to stop being forwarded, or to crashing of the fxpc process. When Packet DMA heap utilization reaches 99%, the system will become unstable. Packet DMA heap utilization can be monitored through the following command: user@junos# request pfe execute target fpc0 timeout 30 command \"show heap\" ID Base Total(b) Free(b) Used(b) % Name -- ---------- ----------- ----------- ----------- --- ----------- 0 213301a8 536870488 387228840 149641648 27 Kernel 1 91800000 8388608 3735120 4653488 55 DMA 2 92000000 75497472 74452192 1045280 1 PKT DMA DESC 3 d330000 335544320 257091400 78452920 23 Bcm_sdk 4 96800000 184549376 2408 184546968 99 Packet DMA <--- 5 903fffe0 20971504 20971504 0 0 Blob An indication of the issue occurring may be observed through the following log messages: Dec 10 08:07:00.124 2020 hostname fpc0 brcm_pkt_buf_alloc:523 (buf alloc) failed allocating packet buffer Dec 10 08:07:00.126 2020 hostname fpc0 (buf alloc) failed allocating packet buffer Dec 10 08:07:00.128 2020 hostname fpc0 brcm_pkt_buf_alloc:523 (buf alloc) failed allocating packet buffer Dec 10 08:07:00.130 2020 hostnameC fpc0 (buf alloc) failed allocating packet buffer This issue affects Juniper Networks Junos OS on EX Series and QFX Series: 17.4R3 versions prior to 17.4R3-S3; 18.1R3 versions between 18.1R3-S6 and 18.1R3-S11; 18.2R3 versions prior to 18.2R3-S6; 18.3R3 versions prior to 18.3R3-S4; 18.4R2 versions prior to 18.4R2-S5; 18.4R3 versions prior to 18.4R3-S6; 19.1 versions between 19.1R2 and 19.1R3-S3; 19.2 versions prior to 19.2R3-S1; 19.3 versions prior to 19.3R2-S5, 19.3R3; 19.4 versions prior to 19.4R2-S2, 19.4R3; 20.1 versions prior to 20.1R2; 20.2 versions prior to 20.2R1-S2, 20.2R2. Junos OS versions prior to 17.4R3 are unaffected by this vulnerability.\n\n- CVE-2021-0242: A vulnerability due to the improper handling of direct memory access (DMA) buffers on EX4300 switches on Juniper Networks Junos OS allows an attacker sending specific unicast frames to trigger a Denial of Service (DoS) condition by exhausting DMA buffers, causing the FPC to crash and the device to restart. The DMA buffer leak is seen when receiving these specific, valid unicast frames on an interface without Layer 2 Protocol Tunneling (L2PT) or dot1x configured. Interfaces with either L2PT or dot1x configured are not vulnerable to this issue. When this issue occurs, DMA buffer usage keeps increasing and the following error log messages may be observed: Apr 14 14:29:34.360 /kernel: pid 64476 (pfex_junos), uid 0: exited on signal 11 (core dumped) Apr 14 14:29:33.790 init: pfe-manager (PID 64476) terminated by signal number 11. Core dumped! The DMA buffers on the FPC can be monitored by the executing vty command 'show heap': ID Base Total(b) Free(b) Used(b) % Name -- ---------- ----------- ----------- ----------- --- ----------- 0 4a46000 268435456 238230496 30204960 11 Kernel 1 18a46000 67108864 17618536 49490328 73 Bcm_sdk 2 23737000 117440512 18414552 99025960 84 DMA buf <<<<< keeps increasing 3 2a737000 16777216 16777216 0 0 DMA desc This issue affects Juniper Networks Junos OS on the EX4300: 17.3 versions prior to 17.3R3-S11; 17.4 versions prior to 17.4R2-S13, 17.4R3-S4; 18.1 versions prior to 18.1R3-S12; 18.2 versions prior to 18.2R2-S8, 18.2R3-S7; 18.3 versions prior to 18.3R3-S4; 18.4 versions prior to 18.4R1-S8, 18.4R2-S7, 18.4R3-S7; 19.1 versions prior to 19.1R1-S6, 19.1R2-S2, 19.1R3-S4; 19.2 versions prior to 19.2R1-S6, 19.2R3-S2; 19.3 versions prior to 19.3R3-S2; 19.4 versions prior to 19.4R2-S3, 19.4R3-S1; 20.1 versions prior to 20.1R2; 20.2 versions prior to 20.2R2-S1, 20.2R3; 20.3 versions prior to 20.3R1-S1, 20.3R2.\n\n- CVE-2021-0338: In SystemSettingsValidators, there is a possible permanent denial of service due to missing bounds checks on UI settings. This could lead to local denial of service with User execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11Android ID: A-156260178\n\n- CVE-2021-0420: In memory management driver, there is a possible system crash due to a missing bounds check. This could lead to local denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05403499; Issue ID: ALPS05381065.\n\n- CVE-2021-0422: In memory management driver, there is a possible system crash due to a missing bounds check. This could lead to local denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05403499; Issue ID: ALPS05381071.\n\n- CVE-2021-0424: In memory management driver, there is a possible system crash due to a missing bounds check. This could lead to local denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05403499; Issue ID: ALPS05393787.\n\n- CVE-2021-20185: It was found in Moodle before version 3.10.1, 3.9.4, 3.8.7 and 3.5.16 that messaging did not impose a character limit when sending messages, which could result in client-side (browser) denial of service for users receiving very large messages.\n\n- CVE-2021-29430: Sydent is a reference Matrix identity server. Sydent does not limit the size of requests it receives from HTTP clients. A malicious user could send an HTTP request with a very large body, leading to memory exhaustion and denial of service. Sydent also does not limit response size for requests it makes to remote Matrix homeservers. A malicious homeserver could return a very large response, again leading to memory exhaustion and denial of service. This affects any server which accepts registration requests from untrusted clients. This issue has been patched by releases 89071a1, 0523511, f56eee3. As a workaround request sizes can be limited in an HTTP reverse-proxy. There are no known workarounds for the problem with overlarge responses.\n\n- CVE-2021-29932: An issue was discovered in the parse_duration crate through 2021-03-18 for Rust. It allows attackers to cause a denial of service (CPU and memory consumption) via a duration string with a large exponent.\n\n- CVE-2021-32699: Wings is the control plane software for the open source Pterodactyl game management system. All versions of Pterodactyl Wings prior to `1.4.4` are vulnerable to system resource exhaustion due to improper container process limits being defined. A malicious user can consume more resources than intended and cause downstream impacts to other clients on the same hardware, eventually causing the physical server to stop responding. Users should upgrade to `1.4.4` to mitigate the issue. There is no non-code based workaround for impacted versions of the software. Users running customized versions of this software can manually set a PID limit for containers created.\n\n- CVE-2021-3478: There's a flaw in OpenEXR's scanline input file functionality in versions before 3.0.0-beta. An attacker able to submit a crafted file to be processed by OpenEXR could consume excessive system memory. The greatest impact of this flaw is to system availability.\n\n- CVE-2021-38463: The affected product does not properly control the allocation of resources. A user may be able to allocate unlimited memory buffers using API functions.\n\n- CVE-2021-38465: The webinstaller is a Golang web server executable that enables the generation of an Auvesy image agent. Resource consumption can be achieved by generating large amounts of installations, which are then saved without limitation in the temp folder of the webinstaller executable.\n\n- CVE-2021-3912: OctoRPKI tries to load the entire contents of a repository in memory, and in the case of a GZIP bomb, unzip it in memory, making it possible to create a repository that makes OctoRPKI run out of memory (and thus crash).\n\n- CVE-2021-41546: A vulnerability has been identified in RUGGEDCOM ROX MX5000 (All versions < V2.14.1), RUGGEDCOM ROX RX1400 (All versions < V2.14.1), RUGGEDCOM ROX RX1500 (All versions < V2.14.1), RUGGEDCOM ROX RX1501 (All versions < V2.14.1), RUGGEDCOM ROX RX1510 (All versions < V2.14.1), RUGGEDCOM ROX RX1511 (All versions < V2.14.1), RUGGEDCOM ROX RX1512 (All versions < V2.14.1), RUGGEDCOM ROX RX1524 (All versions < V2.14.1), RUGGEDCOM ROX RX1536 (All versions < V2.14.1), RUGGEDCOM ROX RX5000 (All versions < V2.14.1). Affected devices write crashdumps without checking if enough space is available on the filesystem. Once the crashdump fills the entire root filesystem, affected devices fail to boot successfully. An attacker can leverage this vulnerability to cause a permanent Denial-of-Service.\n\n- CVE-2021-21274: Synapse is a Matrix reference homeserver written in python (pypi package matrix-synapse). Matrix is an ecosystem for open federated Instant Messaging and VoIP. In Synapse before version 1.25.0, a malicious homeserver could redirect requests to their .well-known file to a large file. This can lead to a denial of service attack where homeservers will consume significantly more resources when requesting the .well-known file of a malicious homeserver. This affects any server which accepts federation requests from untrusted servers. Issue is resolved in version 1.25.0. As a workaround the `federation_domain_whitelist` setting can be used to restrict the homeservers communicated with over federation.\n\n- CVE-2021-21294: Http4s (http4s-blaze-server) is a minimal, idiomatic Scala interface for HTTP services. Http4s before versions 0.21.17, 0.22.0-M2, and 1.0.0-M14 have a vulnerability which can lead to a denial-of-service. Blaze-core, a library underlying http4s-blaze-server, accepts connections unboundedly on its selector pool. This has the net effect of amplifying degradation in services that are unable to handle their current request load, since incoming connections are still accepted and added to an unbounded queue. Each connection allocates a socket handle, which drains a scarce OS resource. This can also confound higher level circuit breakers which work based on detecting failed connections. http4s provides a general \"MaxActiveRequests\" middleware mechanism for limiting open connections, but it is enforced inside the Blaze accept loop, after the connection is accepted and the socket opened. Thus, the limit only prevents the number of connections which can be simultaneously processed, not the number of connections which can be held open. In 0.21.17, 0.22.0-M2, and 1.0.0-M14, a new \"maxConnections\" property, with a default value of 1024, has been added to the `BlazeServerBuilder`. Setting the value to a negative number restores unbounded behavior, but is strongly disrecommended. The NIO2 backend does not respect `maxConnections`. Its use is now deprecated in http4s-0.21, and the option is removed altogether starting in http4s-0.22. There are several possible workarounds described in the refrenced GitHub Advisory GHSA-xhv5-w9c5-2r2w.\n\n- CVE-2021-23053: On version 15.1.x before 15.1.3, 14.1.x before 14.1.3.1, and 13.1.x before 13.1.3.6, when the brute force protection feature of BIG-IP Advanced WAF or BIG-IP ASM is enabled on a virtual server and the virtual server is under brute force attack, the MySQL database may run out of disk space due to lack of row limit on undisclosed tables in the MYSQL database. Note: Software versions which have reached End of Technical Support (EoTS) are not evaluated.\n\n- CVE-2021-41167: modern-async is an open source JavaScript tooling library for asynchronous operations using async/await and promises. In affected versions a bug affecting two of the functions in this library: forEachSeries and forEachLimit. They should limit the concurrency of some actions but, in practice, they don't. Any code calling these functions will be written thinking they would limit the concurrency but they won't. This could lead to potential security issues in other projects. The problem has been patched in 1.0.4. There is no workaround.\n\n- CVE-2021-42262: An issue was discovered in Softing OPC UA C++ SDK before 5.70. An invalid XML element in the type dictionary makes the OPC/UA client crash due to an out-of-memory condition.\n\n- CVE-2020-35210: A vulnerability in Atomix v3.1.5 allows attackers to cause a denial of service (DoS) via a Raft session flooding attack using Raft OpenSessionRequest messages.\n\n- CVE-2021-32476: A denial-of-service risk was identified in the draft files area, due to it not respecting user file upload limits. Moodle versions 3.10 to 3.10.3, 3.9 to 3.9.6, 3.8 to 3.8.8, 3.5 to 3.5.17 and earlier unsupported versions are affected.\n\n- CVE-2021-43662: totolink EX300_v2, ver V4.0.3c.140_B20210429 and A720R ,ver V4.1.5cu.470_B20200911 have an issue which causes uncontrolled resource consumption.\n\n- CVE-2020-3566: A vulnerability in the Distance Vector Multicast Routing Protocol (DVMRP) feature of Cisco IOS XR Software could allow an unauthenticated, remote attacker to exhaust process memory of an affected device. The vulnerability is due to insufficient queue management for Internet Group Management Protocol (IGMP) packets. An attacker could exploit this vulnerability by sending crafted IGMP traffic to an affected device. A successful exploit could allow the attacker to cause memory exhaustion, resulting in instability of other processes. These processes may include, but are not limited to, interior and exterior routing protocols. Cisco will release software updates that address this vulnerability.\n\n- CVE-2020-3569: Multiple vulnerabilities in the Distance Vector Multicast Routing Protocol (DVMRP) feature of Cisco IOS XR Software could allow an unauthenticated, remote attacker to either immediately crash the Internet Group Management Protocol (IGMP) process or make it consume available memory and eventually crash. The memory consumption may negatively impact other processes that are running on the device. These vulnerabilities are due to the incorrect handling of IGMP packets. An attacker could exploit these vulnerabilities by sending crafted IGMP traffic to an affected device. A successful exploit could allow the attacker to immediately crash the IGMP process or cause memory exhaustion, resulting in other processes becoming unstable. These processes may include, but are not limited to, interior and exterior routing protocols. Cisco will release software updates that address these vulnerabilities.\n\n- CVE-2021-44988: Jerryscript v3.0.0 and below was discovered to contain a stack overflow via ecma_find_named_property in ecma-helpers.c.\n\n- CVE-2021-46050: A Stack Overflow vulnerability exists in Binaryen 103 via the printf_common function.\n\n- CVE-2022-29503: A memory corruption vulnerability exists in the libpthread linuxthreads functionality of uClibC 0.9.33.2 and uClibC-ng 1.0.40. Thread allocation can lead to memory corruption. An attacker can create threads to trigger this vulnerability.\n\n- CVE-2022-35107: SWFTools commit 772e55a2 was discovered to contain a stack overflow via vfprintf at /stdio-common/vfprintf.c.\n\n- CVE-2022-35111: SWFTools commit 772e55a2 was discovered to contain a stack overflow via __sanitizer::StackDepotNode::hash(__sanitizer::StackTrace const&) at /sanitizer_common/sanitizer_stackdepot.cpp.\n\n- CVE-2022-21716: Twisted is an event-based framework for internet applications, supporting Python 3.6+. Prior to 22.2.0, Twisted SSH client and server implement is able to accept an infinite amount of data for the peer's SSH version identifier. This ends up with a buffer using all the available memory. The attach is a simple as `nc -rv localhost 22 < /dev/zero`. A patch is available in version 22.2.0. There are currently no known workarounds.\n\n- CVE-2022-41288: A vulnerability has been identified in JT2Go (All versions < V14.1.0.6), Teamcenter Visualization V13.2 (All versions < V13.2.0.12), Teamcenter Visualization V13.3 (All versions < V13.3.0.8), Teamcenter Visualization V14.0 (All versions < V14.0.0.4), Teamcenter Visualization V14.1 (All versions < V14.1.0.6). The CGM_NIST_Loader.dll contains stack exhaustion vulnerability when parsing a CGM file. An attacker could leverage this vulnerability to crash the application causing denial of service condition.\n\n- CVE-2022-32559: An issue was discovered in Couchbase Server before 7.0.4. Random HTTP requests lead to leaked metrics.\n\n- CVE-2022-3273: Allocation of Resources Without Limits or Throttling in GitHub repository ikus060/rdiffweb prior to 2.5.0a4.\n\n- CVE-2021-3669: A flaw was found in the Linux kernel. Measuring usage of the shared memory does not scale with large shared memory segment counts which could lead to resource exhaustion and DoS.\n\n- CVE-2021-3759: A memory overflow vulnerability was found in the Linux kernel\u2019s ipc functionality of the memcg subsystem, in the way a user calls the semget function multiple times, creating semaphores. This flaw allows a local user to starve the resources, causing a denial of service. The highest threat from this vulnerability is to system availability.\n\n- CVE-2022-1708: A vulnerability was found in CRI-O that causes memory or disk space exhaustion on the node for anyone with access to the Kube API. The ExecSync request runs commands in a container and logs the output of the command. This output is then read by CRI-O after command execution, and it is read in a manner where the entire file corresponding to the output of the command is read in. Thus, if the output of the command is large it is possible to exhaust the memory or the disk space of the node when CRI-O reads the output of the command. The highest threat from this vulnerability is system availability.\n\n- CVE-2022-20143: In addAutomaticZenRule of ZenModeHelper.java, there is a possible permanent denial of service due to resource exhaustion. This could lead to local denial of service with User execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12LAndroid ID: A-220735360\n\n- CVE-2022-20478: In NotificationChannel of NotificationChannel.java, there is a possible failure to persist permissions settings due to resource exhaustion. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-241764135\n\n- CVE-2022-20479: In NotificationChannel of NotificationChannel.java, there is a possible failure to persist permissions settings due to resource exhaustion. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-241764340\n\n- CVE-2022-20480: In NotificationChannel of NotificationChannel.java, there is a possible failure to persist permissions settings due to resource exhaustion. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-241764350\n\n- CVE-2022-20484: In NotificationChannel of NotificationChannel.java, there is a possible failure to persist permissions settings due to resource exhaustion. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-242702851\n\n- CVE-2022-20485: In NotificationChannel of NotificationChannel.java, there is a possible failure to persist permissions settings due to resource exhaustion. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-242702935\n\n- CVE-2022-20486: In NotificationChannel of NotificationChannel.java, there is a possible failure to persist permissions settings due to resource exhaustion. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-242703118\n\n- CVE-2022-20487: In NotificationChannel of NotificationChannel.java, there is a possible failure to persist permissions settings due to resource exhaustion. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-242703202\n\n- CVE-2022-21952: A Missing Authentication for Critical Function vulnerability in spacewalk-java of SUSE Manager Server 4.1, SUSE Manager Server 4.2 allows remote attackers to easily exhaust available disk resources leading to DoS. This issue affects: SUSE Manager Server 4.1 spacewalk-java versions prior to 4.1.46. SUSE Manager Server 4.2 spacewalk-java versions prior to 4.2.37. \n\n- CVE-2022-23487: js-libp2p is the official javascript Implementation of libp2p networking stack. Versions older than `v0.38.0` of js-libp2p are vulnerable to targeted resource exhaustion attacks. These attacks target libp2p\u2019s connection, stream, peer, and memory management. An attacker can cause the allocation of large amounts of memory, ultimately leading to the process getting killed by the host\u2019s operating system. While a connection manager tasked with keeping the number of connections within manageable limits has been part of js-libp2p, this component was designed to handle the regular churn of peers, not a targeted resource exhaustion attack. Users are advised to update their js-libp2p dependency to `v0.38.0` or greater. There are no known workarounds for this vulnerability.\n\n- CVE-2022-23492: go-libp2p is the offical libp2p implementation in the Go programming language. Version `0.18.0` and older of go-libp2p are vulnerable to targeted resource exhaustion attacks. These attacks target libp2p\u2019s connection, stream, peer, and memory management. An attacker can cause the allocation of large amounts of memory, ultimately leading to the process getting killed by the host\u2019s operating system. While a connection manager tasked with keeping the number of connections within manageable limits has been part of go-libp2p, this component was designed to handle the regular churn of peers, not a targeted resource exhaustion attack. Users are advised to upgrade their version of go-libp2p to version `0.18.1` or newer. Users unable to upgrade may consult the denial of service (dos) mitigation page for more information on how to incorporate mitigation strategies, monitor your application, and respond to attacks.\n\n- CVE-2022-23913: In Apache ActiveMQ Artemis prior to 2.20.0 or 2.19.1, an attacker could partially disrupt availability (DoS) through uncontrolled resource consumption of memory.\n\n- CVE-2022-2406: The legacy Slack import feature in Mattermost version 6.7.0 and earlier fails to properly limit the sizes of imported files, which allows an authenticated attacker to crash the server by importing large files via the Slack import REST API.\n\n- CVE-2022-28871: A Denial-of-Service (DoS) vulnerability was discovered in F-Secure Atlant whereby the fsicapd component used in certain F-Secure products while scanning larger packages/fuzzed files consume too much memory eventually can crash the scanning engine. The exploit can be triggered remotely by an attacker.\n\n- CVE-2022-31075: KubeEdge is an open source system for extending native containerized application orchestration capabilities to hosts at Edge. Prior to versions 1.11.1, 1.10.2, and 1.9.4, EdgeCore may be susceptible to a DoS attack on CloudHub if an attacker was to send a well-crafted HTTP request to `/edge.crt`. If an attacker can send a well-crafted HTTP request to CloudHub, and that request has a very large body, that request can crash the HTTP service through a memory exhaustion vector. The request body is being read into memory, and a body that is larger than the available memory can lead to a successful attack. Because the request would have to make it through authorization, only authorized users may perform this attack. The consequence of the exhaustion is that CloudHub will be in denial of service. KubeEdge is affected only when users enable the CloudHub module in the file `cloudcore.yaml`. This bug has been fixed in Kubeedge 1.11.1, 1.10.2, and 1.9.4. As a workaround, disable the CloudHub switch in the config file `cloudcore.yaml`.\n\n- CVE-2022-31078: KubeEdge is an open source system for extending native containerized application orchestration capabilities to hosts at Edge. Prior to versions 1.11.1, 1.10.2, and 1.9.4, the CloudCore Router does not impose a limit on the size of responses to requests made by the REST handler. An attacker could use this weakness to make a request that will return an HTTP response with a large body and cause DoS of CloudCore. In the HTTP Handler API, the rest handler makes a request to a pre-specified handle. The handle will return an HTTP response that is then read into memory. The consequence of the exhaustion is that CloudCore will be in a denial of service. Only an authenticated user of the cloud can make an attack. It will be affected only when users enable `router` module in the config file `cloudcore.yaml`. This bug has been fixed in Kubeedge 1.11.1, 1.10.2, and 1.9.4. As a workaround, disable the router switch in the config file `cloudcore.yaml`.\n\n- CVE-2022-31079: KubeEdge is an open source system for extending native containerized application orchestration capabilities to hosts at Edge. Prior to versions 1.11.1, 1.10.2, and 1.9.4, the Cloud Stream server and the Edge Stream server reads the entire message into memory without imposing a limit on the size of this message. An attacker can exploit this by sending a large message to exhaust memory and cause a DoS. The Cloud Stream server and the Edge Stream server are under DoS attack in this case. The consequence of the exhaustion is that the CloudCore and EdgeCore will be in a denial of service. Only an authenticated user can cause this issue. It will be affected only when users enable `cloudStream` module in the config file `cloudcore.yaml` and enable `edgeStream` module in the config file `edgecore.yaml`. This bug has been fixed in Kubeedge 1.11.1, 1.10.2, and 1.9.4. As a workaround, disable cloudStream module in the config file `cloudcore.yaml` and disable edgeStream module in the config file `edgecore.yaml`.\n\n- CVE-2022-3147: Mattermost version 7.0.x and earlier fails to sufficiently limit the in-memory sizes of concurrently uploaded JPEG images, which allows authenticated users to cause resource exhaustion on specific system configurations, resulting in server-side Denial of Service.\n\n- CVE-2022-33749: XAPI open file limit DoS It is possible for an unauthenticated client on the network to cause XAPI to hit its file-descriptor limit. This causes XAPI to be unable to accept new requests for other (trusted) clients, and blocks XAPI from carrying out any tasks that require the opening of file descriptors.\n\n- CVE-2022-3423: Allocation of Resources Without Limits or Throttling in GitHub repository nocodb/nocodb prior to 0.92.0. \n\n- CVE-2022-35915: OpenZeppelin Contracts is a library for secure smart contract development. The target contract of an EIP-165 `supportsInterface` query can cause unbounded gas consumption by returning a lot of data, while it is generally assumed that this operation has a bounded cost. The issue has been fixed in v4.7.2. Users are advised to upgrade. There are no known workarounds for this issue.\n\n- CVE-2022-41932: XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. It's possible to make XWiki create many new schemas and fill them with tables just by using a crafted user identifier in the login form. This may lead to degraded database performance. The problem has been patched in XWiki 13.10.8, 14.6RC1 and 14.4.2. Users are advised to upgrade. There are no known workarounds for this issue.\n\n- CVE-2022-2134: Allocation of Resources Without Limits or Throttling in GitHub repository inventree/inventree prior to 0.8.0.\n\n- CVE-2022-43686: In Concrete CMS (formerly concrete5) below 8.5.10 and between 9.0.0 and 9.1.2, the authTypeConcreteCookieMap table can be filled up causing a denial of service (high load).\n\n- CVE-2022-41725: A denial of service is possible from excessive resource consumption in net/http and mime/multipart. Multipart form parsing with mime/multipart.Reader.ReadForm can consume largely unlimited amounts of memory and disk files. This also affects form parsing in the net/http package with the Request methods FormFile, FormValue, ParseMultipartForm, and PostFormValue. ReadForm takes a maxMemory parameter, and is documented as storing \"up to maxMemory bytes +10MB (reserved for non-file parts) in memory\". File parts which cannot be stored in memory are stored on disk in temporary files. The unconfigurable 10MB reserved for non-file parts is excessively large and can potentially open a denial of service vector on its own. However, ReadForm did not properly account for all memory consumed by a parsed form, such as map entry overhead, part names, and MIME headers, permitting a maliciously crafted form to consume well over 10MB. In addition, ReadForm contained no limit on the number of disk files created, permitting a relatively small request body to create a large number of disk temporary files. With fix, ReadForm now properly accounts for various forms of memory overhead, and should now stay within its documented limit of 10MB + maxMemory bytes of memory consumption. Users should still be aware that this limit is high and may still be hazardous. In addition, ReadForm now creates at most one on-disk temporary file, combining multiple form parts into a single temporary file. The mime/multipart.File interface type's documentation states, \"If stored on disk, the File's underlying concrete type will be an *os.File.\". This is no longer the case when a form contains more than one file part, due to this coalescing of parts into a single file. The previous behavior of using distinct files for each form part may be reenabled with the environment variable GODEBUG=multipartfiles=distinct. Users should be aware that multipart.ReadForm and the http.Request methods that call it do not limit the amount of disk consumed by temporary files. Callers can limit the size of form data with http.MaxBytesReader.\n\nRelated Weaknesses:\n\n- CWE-400 (ChildOf)\n\n- CWE-665 (ChildOf)\n\n- CWE-400 (ChildOf)",
          "type": "Base",
          "search_source": "base_query",
          "metadata": {
            "source": "sparse",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            }
          }
        },
        {
          "doc_id": "123",
          "text": "CWE-123: Write-what-where Condition",
          "score": 3.5671999999999997,
          "metadata": {
            "doc_id": "123",
            "name": "Write-what-where Condition",
            "type": "base",
            "original_content": "CWE-123: Write-what-where Condition",
            "relationships": [
              {
                "source_id": "123",
                "target_id": "590",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "123",
                "target_id": "479",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "123",
                "target_id": "416",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "123",
                "target_id": "364",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "123",
                "target_id": "134",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "123",
                "target_id": "120",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "123",
                "target_id": "119",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1340"
                }
              },
              {
                "source_id": "123",
                "target_id": "119",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1305"
                }
              },
              {
                "source_id": "123",
                "target_id": "787",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "787",
                "target_id": "123",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "590",
                "target_id": "123",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "479",
                "target_id": "123",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "416",
                "target_id": "123",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "415",
                "target_id": "123",
                "label": "PEEROF",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "364",
                "target_id": "123",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "134",
                "target_id": "123",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "120",
                "target_id": "123",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "119",
                "target_id": "123",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1305"
                }
              }
            ],
            "score_components": {
              "relationship_chain": 1.0,
              "abstraction_path": 0.7200000000000001,
              "sequence_path": 1.0,
              "peer_group": 0.9
            },
            "abstraction_factor": 1.3,
            "graph_path_info": {
              "path_types": [
                "relationship_chain",
                "abstraction_path_down",
                "vulnerability_sequence_forward",
                "peer_relationship"
              ],
              "best_paths": {
                "relationship_chain": {
                  "path": [
                    [
                      "416",
                      "123",
                      "CANPRECEDE"
                    ]
                  ],
                  "score": 1.0,
                  "type": "relationship_chain",
                  "source": "416"
                },
                "abstraction_path_down": {
                  "path": [
                    [
                      "787",
                      "123",
                      "PARENTOF"
                    ]
                  ],
                  "score": 0.7200000000000001,
                  "type": "abstraction_path_down",
                  "source": "787"
                },
                "vulnerability_sequence_forward": {
                  "path": [
                    [
                      "416",
                      "123",
                      "CANPRECEDE"
                    ]
                  ],
                  "score": 1.0,
                  "type": "vulnerability_sequence_forward",
                  "source": "416"
                },
                "peer_relationship": {
                  "path": [
                    [
                      "415",
                      "123",
                      "PEEROF"
                    ]
                  ],
                  "score": 0.9,
                  "type": "peer_relationship",
                  "source": "415"
                }
              }
            },
            "abstraction_level": "base",
            "position": "after",
            "sources": [
              "graph"
            ],
            "source": "graph",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "graph"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "graph": 3.5671999999999997
              }
            }
          },
          "similarity": 3.5671999999999997
        },
        {
          "doc_id": "843",
          "text": "The product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.",
          "score": 0.6087283403376947,
          "metadata": {
            "doc_id": "843",
            "name": "Access of Resource Using Incompatible Type ('Type Confusion')",
            "type": "Base",
            "extended_description": "\n\nWhen the product accesses the resource using an incompatible type, this could trigger logical errors because the resource does not have expected properties. In languages without memory safety, such as C and C++, type confusion can lead to out-of-bounds memory access.\n\n\nWhile this weakness is frequently associated with unions when parsing data with many different embedded object types in C, it can be present in any application that can interpret the same variable or memory location in multiple ways.\n\n\nThis weakness is not unique to C and C++. For example, errors in PHP applications can be triggered by providing array parameters when scalars are expected, or vice versa. Languages such as Perl, which perform automatic conversion of a variable of one type when it is accessed as if it were another type, can also contain these issues.\n",
            "alternate_terms": [
              "Object Type Confusion"
            ],
            "original_content": "The product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.",
            "relationships": [
              {
                "source_id": "843",
                "target_id": "119",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "843",
                "target_id": "704",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1003"
                }
              },
              {
                "source_id": "843",
                "target_id": "704",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "704",
                "target_id": "843",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "1287",
                "target_id": "843",
                "label": "PEEROF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "119",
                "target_id": "843",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              }
            ],
            "source": "graph",
            "sources": [
              "vector",
              "graph"
            ],
            "vector_score": 0.6087283403376947,
            "graph_score": 3.8038000000000003,
            "score_components": {
              "relationship_chain": 0.8,
              "explicit_mention": 1.0,
              "abstraction_path": 0.9,
              "sequence_path": 0.7200000000000001
            },
            "abstraction_factor": 1.3,
            "graph_path_info": {
              "path_types": [
                "relationship_chain",
                "vulnerability_sequence_forward"
              ],
              "best_paths": {
                "relationship_chain": {
                  "path": [
                    [
                      "1260",
                      "119",
                      "CANPRECEDE"
                    ],
                    [
                      "119",
                      "843",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.8,
                  "type": "relationship_chain",
                  "source": "1260"
                },
                "vulnerability_sequence_forward": {
                  "path": [
                    [
                      "1260",
                      "119",
                      "CANPRECEDE"
                    ],
                    [
                      "119",
                      "843",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.7200000000000001,
                  "type": "vulnerability_sequence_forward",
                  "source": "1260"
                }
              }
            },
            "is_explicit": true,
            "abstraction_level": "base",
            "position": "after",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense",
                "sparse",
                "graph"
              ],
              "retriever_count": 3,
              "normalized_scores": {
                "dense": 0.5532373381039504,
                "sparse": 67.60603023958426,
                "graph": 2.5257713361350778
              }
            }
          },
          "similarity": 2.5257713361350778
        },
        {
          "doc_id": "1260",
          "text": "The product allows address regions to overlap, which can result in the bypassing of intended memory protection.",
          "score": 0.5771677994437826,
          "metadata": {
            "doc_id": "1260",
            "name": "Improper Handling of Overlap Between Protected Memory Ranges",
            "type": "Base",
            "extended_description": "\n\nIsolated memory regions and access control (read/write) policies are used by hardware to protect privileged software. Software components are often allowed to change or remap memory region definitions in order to enable flexible and dynamically changeable memory management by system software.\n\n\nIf a software component running at lower privilege can program a memory address region to overlap with other memory regions used by software running at higher privilege, privilege escalation may be available to attackers. The memory protection unit (MPU) logic can incorrectly handle such an address overlap and allow the lower-privilege software to read or write into the protected memory region, resulting in privilege escalation attack. An address overlap weakness can also be used to launch a denial of service attack on the higher-privilege software memory regions.\n",
            "alternate_terms": [],
            "original_content": "The product allows address regions to overlap, which can result in the bypassing of intended memory protection.",
            "relationships": [
              {
                "source_id": "1260",
                "target_id": "119",
                "label": "CANPRECEDE",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "1260",
                "target_id": "284",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "284",
                "target_id": "1260",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "119",
                "target_id": "1260",
                "label": "CANFOLLOW",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              }
            ],
            "source": "graph",
            "sources": [
              "vector",
              "graph"
            ],
            "vector_score": 0.5771677994437826,
            "graph_score": 3.5698000000000003,
            "score_components": {
              "relationship_chain": 0.6,
              "explicit_mention": 1.0,
              "abstraction_path": 0.9,
              "sequence_path": 0.7200000000000001
            },
            "abstraction_factor": 1.3,
            "graph_path_info": {
              "path_types": [
                "relationship_chain",
                "vulnerability_sequence_forward"
              ],
              "best_paths": {
                "relationship_chain": {
                  "path": [
                    [
                      "415",
                      "123",
                      "PEEROF"
                    ],
                    [
                      "123",
                      "119",
                      "CHILDOF"
                    ],
                    [
                      "119",
                      "1260",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.6,
                  "type": "relationship_chain",
                  "source": "415"
                },
                "vulnerability_sequence_forward": {
                  "path": [
                    [
                      "843",
                      "119",
                      "CANPRECEDE"
                    ],
                    [
                      "119",
                      "1260",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.7200000000000001,
                  "type": "vulnerability_sequence_forward",
                  "source": "843"
                }
              }
            },
            "is_explicit": true,
            "abstraction_level": "base",
            "position": "after",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense",
                "graph"
              ],
              "retriever_count": 2,
              "normalized_scores": {
                "dense": 0.5423218496153519,
                "graph": 2.372747119777513
              }
            }
          },
          "similarity": 2.372747119777513
        },
        {
          "doc_id": "416",
          "text": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
          "score": 0.5992290665367083,
          "metadata": {
            "doc_id": "416",
            "name": "Use After Free",
            "type": "Variant",
            "extended_description": null,
            "alternate_terms": [
              "Dangling pointer",
              "UAF",
              "Use-After-Free"
            ],
            "original_content": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
            "relationships": [
              {
                "source_id": "416",
                "target_id": "754",
                "label": "CANFOLLOW",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "416",
                "target_id": "364",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "416",
                "target_id": "362",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "416",
                "target_id": "1265",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "416",
                "target_id": "123",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "416",
                "target_id": "120",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "416",
                "target_id": "672",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1340"
                }
              },
              {
                "source_id": "416",
                "target_id": "672",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1305"
                }
              },
              {
                "source_id": "416",
                "target_id": "672",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1003"
                }
              },
              {
                "source_id": "416",
                "target_id": "825",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "825",
                "target_id": "416",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "754",
                "target_id": "416",
                "label": "CANPRECEDE",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "672",
                "target_id": "416",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1003"
                }
              },
              {
                "source_id": "415",
                "target_id": "416",
                "label": "PEEROF",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "364",
                "target_id": "416",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "362",
                "target_id": "416",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "1265",
                "target_id": "416",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "123",
                "target_id": "416",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "120",
                "target_id": "416",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              }
            ],
            "source": "graph",
            "sources": [
              "vector",
              "graph"
            ],
            "vector_score": 0.5992290665367083,
            "graph_score": 3.372,
            "score_components": {
              "relationship_chain": 0.7,
              "explicit_mention": 1.0,
              "sequence_path": 0.8,
              "peer_group": 0.9
            },
            "abstraction_factor": 1.2,
            "graph_path_info": {
              "path_types": [
                "relationship_chain",
                "vulnerability_sequence_forward",
                "peer_relationship"
              ],
              "best_paths": {
                "relationship_chain": {
                  "path": [
                    [
                      "415",
                      "416",
                      "PEEROF"
                    ]
                  ],
                  "score": 0.7,
                  "type": "relationship_chain",
                  "source": "415"
                },
                "vulnerability_sequence_forward": {
                  "path": [
                    [
                      "415",
                      "364",
                      "CANFOLLOW"
                    ],
                    [
                      "364",
                      "416",
                      "CANPRECEDE"
                    ]
                  ],
                  "score": 0.8,
                  "type": "vulnerability_sequence_forward",
                  "source": "415"
                },
                "peer_relationship": {
                  "path": [
                    [
                      "415",
                      "416",
                      "PEEROF"
                    ]
                  ],
                  "score": 0.9,
                  "type": "peer_relationship",
                  "source": "415"
                }
              }
            },
            "is_explicit": true,
            "abstraction_level": "variant",
            "position": "after",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense",
                "sparse",
                "graph"
              ],
              "retriever_count": 3,
              "normalized_scores": {
                "dense": 0.5564290782764135,
                "sparse": 60.782740992322296,
                "graph": 2.262891626614683
              }
            }
          },
          "similarity": 2.262891626614683
        },
        {
          "doc_id": "415",
          "text": "The product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.",
          "score": 0.5710550232704926,
          "metadata": {
            "doc_id": "415",
            "name": "Double Free",
            "type": "Variant",
            "extended_description": "When a program calls free() twice with the same argument, the program's memory management data structures become corrupted. This corruption can cause the program to crash or, in some circumstances, cause two later calls to malloc() to return the same pointer. If malloc() returns the same value twice and the program later gives the attacker control over the data that is written into this doubly-allocated memory, the program becomes vulnerable to a buffer overflow attack.",
            "alternate_terms": [
              "Double-free"
            ],
            "original_content": "The product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.",
            "relationships": [
              {
                "source_id": "415",
                "target_id": "364",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "415",
                "target_id": "123",
                "label": "PEEROF",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "415",
                "target_id": "416",
                "label": "PEEROF",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "415",
                "target_id": "666",
                "label": "CHILDOF",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "415",
                "target_id": "672",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1340"
                }
              },
              {
                "source_id": "415",
                "target_id": "672",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1305"
                }
              },
              {
                "source_id": "415",
                "target_id": "672",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1003"
                }
              },
              {
                "source_id": "415",
                "target_id": "1341",
                "label": "CHILDOF",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "415",
                "target_id": "825",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "825",
                "target_id": "415",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "672",
                "target_id": "415",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1003"
                }
              },
              {
                "source_id": "666",
                "target_id": "415",
                "label": "PARENTOF",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "364",
                "target_id": "415",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "1341",
                "target_id": "415",
                "label": "PARENTOF",
                "properties": {
                  "view_id": "1000"
                }
              }
            ],
            "source": "graph",
            "sources": [
              "vector",
              "graph"
            ],
            "vector_score": 0.5710550232704926,
            "graph_score": 3.372,
            "score_components": {
              "explicit_mention": 1.0,
              "relationship_chain": 0.7,
              "sequence_path": 0.8,
              "peer_group": 0.9
            },
            "abstraction_factor": 1.2,
            "graph_path_info": {
              "path_types": [
                "relationship_chain",
                "vulnerability_sequence_forward",
                "peer_relationship"
              ],
              "best_paths": {
                "relationship_chain": {
                  "path": [
                    [
                      "415",
                      "416",
                      "PEEROF"
                    ]
                  ],
                  "score": 0.7,
                  "type": "relationship_chain",
                  "source": "416"
                },
                "vulnerability_sequence_forward": {
                  "path": [
                    [
                      "416",
                      "364",
                      "CANFOLLOW"
                    ],
                    [
                      "364",
                      "415",
                      "CANPRECEDE"
                    ]
                  ],
                  "score": 0.8,
                  "type": "vulnerability_sequence_forward",
                  "source": "416"
                },
                "peer_relationship": {
                  "path": [
                    [
                      "415",
                      "416",
                      "PEEROF"
                    ]
                  ],
                  "score": 0.9,
                  "type": "peer_relationship",
                  "source": "416"
                }
              }
            },
            "is_explicit": true,
            "abstraction_level": "variant",
            "position": "after",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "sparse",
                "graph"
              ],
              "retriever_count": 2,
              "normalized_scores": {
                "sparse": 53.504177185489525,
                "graph": 2.2516220093081967
              }
            }
          },
          "similarity": 2.2516220093081967
        },
        {
          "doc_id": "364",
          "text": "CWE-364: Signal Handler Race Condition",
          "score": 2.2100000000000004,
          "metadata": {
            "doc_id": "364",
            "name": "Signal Handler Race Condition",
            "type": "base",
            "original_content": "CWE-364: Signal Handler Race Condition",
            "relationships": [
              {
                "source_id": "364",
                "target_id": "831",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "364",
                "target_id": "828",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "364",
                "target_id": "432",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "364",
                "target_id": "123",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "364",
                "target_id": "416",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "364",
                "target_id": "415",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "364",
                "target_id": "362",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "831",
                "target_id": "364",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "828",
                "target_id": "364",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "432",
                "target_id": "364",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "416",
                "target_id": "364",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "415",
                "target_id": "364",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "368",
                "target_id": "364",
                "label": "CANALSOBE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "362",
                "target_id": "364",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "123",
                "target_id": "364",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              }
            ],
            "score_components": {
              "relationship_chain": 1.0,
              "sequence_path": 1.0
            },
            "abstraction_factor": 1.3,
            "graph_path_info": {
              "path_types": [
                "relationship_chain",
                "vulnerability_sequence_forward",
                "vulnerability_sequence_backward"
              ],
              "best_paths": {
                "relationship_chain": {
                  "path": [
                    [
                      "415",
                      "364",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 1.0,
                  "type": "relationship_chain",
                  "source": "415"
                },
                "vulnerability_sequence_forward": {
                  "path": [
                    [
                      "415",
                      "364",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.9,
                  "type": "vulnerability_sequence_forward",
                  "source": "415"
                },
                "vulnerability_sequence_backward": {
                  "path": [
                    [
                      "364",
                      "415",
                      "CANPRECEDE"
                    ]
                  ],
                  "score": 1.0,
                  "type": "vulnerability_sequence_backward",
                  "source": "415"
                }
              }
            },
            "position": "before",
            "sources": [
              "graph"
            ],
            "source": "graph",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "graph"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "graph": 2.2100000000000004
              }
            }
          },
          "similarity": 2.2100000000000004
        },
        {
          "doc_id": "825",
          "text": "CWE-825: Expired Pointer Dereference",
          "score": 2.2100000000000004,
          "metadata": {
            "doc_id": "825",
            "name": "Expired Pointer Dereference",
            "type": "base",
            "original_content": "CWE-825: Expired Pointer Dereference",
            "relationships": [
              {
                "source_id": "825",
                "target_id": "562",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "825",
                "target_id": "416",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "825",
                "target_id": "415",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "825",
                "target_id": "787",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "825",
                "target_id": "125",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "825",
                "target_id": "672",
                "label": "CHILDOF",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "825",
                "target_id": "119",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1340"
                }
              },
              {
                "source_id": "825",
                "target_id": "119",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1305"
                }
              },
              {
                "source_id": "825",
                "target_id": "119",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "787",
                "target_id": "825",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "672",
                "target_id": "825",
                "label": "PARENTOF",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "562",
                "target_id": "825",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "416",
                "target_id": "825",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "415",
                "target_id": "825",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "125",
                "target_id": "825",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "119",
                "target_id": "825",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              }
            ],
            "score_components": {
              "relationship_chain": 1.0,
              "sequence_path": 1.0
            },
            "abstraction_factor": 1.3,
            "graph_path_info": {
              "path_types": [
                "relationship_chain",
                "vulnerability_sequence_forward",
                "vulnerability_sequence_backward"
              ],
              "best_paths": {
                "relationship_chain": {
                  "path": [
                    [
                      "787",
                      "825",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 1.0,
                  "type": "relationship_chain",
                  "source": "787"
                },
                "vulnerability_sequence_forward": {
                  "path": [
                    [
                      "787",
                      "825",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.9,
                  "type": "vulnerability_sequence_forward",
                  "source": "787"
                },
                "vulnerability_sequence_backward": {
                  "path": [
                    [
                      "825",
                      "787",
                      "CANPRECEDE"
                    ]
                  ],
                  "score": 1.0,
                  "type": "vulnerability_sequence_backward",
                  "source": "787"
                }
              }
            },
            "position": "before",
            "sources": [
              "graph"
            ],
            "source": "graph",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "graph"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "graph": 2.2100000000000004
              }
            }
          },
          "similarity": 2.2100000000000004
        },
        {
          "doc_id": "120",
          "text": "CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
          "score": 2.2100000000000004,
          "metadata": {
            "doc_id": "120",
            "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
            "type": "base",
            "original_content": "CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
            "relationships": [
              {
                "source_id": "120",
                "target_id": "785",
                "label": "PARENTOF",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "120",
                "target_id": "456",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "120",
                "target_id": "416",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "120",
                "target_id": "231",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "120",
                "target_id": "170",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "120",
                "target_id": "20",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "700"
                }
              },
              {
                "source_id": "120",
                "target_id": "123",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "120",
                "target_id": "119",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1340"
                }
              },
              {
                "source_id": "120",
                "target_id": "119",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1305"
                }
              },
              {
                "source_id": "120",
                "target_id": "119",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1003"
                }
              },
              {
                "source_id": "120",
                "target_id": "119",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "785",
                "target_id": "120",
                "label": "CHILDOF",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "456",
                "target_id": "120",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "416",
                "target_id": "120",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "231",
                "target_id": "120",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "20",
                "target_id": "120",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "700"
                }
              },
              {
                "source_id": "196",
                "target_id": "120",
                "label": "CANALSOBE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "170",
                "target_id": "120",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "123",
                "target_id": "120",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "119",
                "target_id": "120",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              }
            ],
            "score_components": {
              "relationship_chain": 1.0,
              "sequence_path": 1.0
            },
            "abstraction_factor": 1.3,
            "graph_path_info": {
              "path_types": [
                "relationship_chain",
                "vulnerability_sequence_forward"
              ],
              "best_paths": {
                "relationship_chain": {
                  "path": [
                    [
                      "416",
                      "120",
                      "CANPRECEDE"
                    ]
                  ],
                  "score": 1.0,
                  "type": "relationship_chain",
                  "source": "416"
                },
                "vulnerability_sequence_forward": {
                  "path": [
                    [
                      "416",
                      "120",
                      "CANPRECEDE"
                    ]
                  ],
                  "score": 1.0,
                  "type": "vulnerability_sequence_forward",
                  "source": "416"
                }
              }
            },
            "position": "after",
            "sources": [
              "graph"
            ],
            "source": "graph",
            "mapping_notes": {
              "usage": "Allowed-with-Review",
              "rationale": "There are some indications that this CWE ID might be misused and selected simply because it mentions \"buffer overflow\" - an increasingly vague term. This CWE entry is only appropriate for \"Buffer Copy\" operations (not buffer reads), in which where there is no \"Checking [the] Size of Input\", and (by implication of the copy) writing past the end of the buffer.",
              "comments": "If the vulnerability being analyzed involves out-of-bounds reads, then consider CWE-125 or descendants. For root cause analysis: if there is any input validation, consider children of CWE-20 such as CWE-1284. If there is a calculation error for buffer sizes, consider CWE-131 or similar.",
              "reasons": [
                "Frequent Misuse"
              ]
            },
            "score_info": {
              "retrievers": [
                "graph"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "graph": 2.2100000000000004
              }
            }
          },
          "similarity": 2.2100000000000004
        },
        {
          "doc_id": "1265",
          "text": "CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
          "score": 2.2100000000000004,
          "metadata": {
            "doc_id": "1265",
            "name": "Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
            "type": "base",
            "original_content": "CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
            "relationships": [
              {
                "source_id": "1265",
                "target_id": "416",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "1265",
                "target_id": "663",
                "label": "PEEROF",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "1265",
                "target_id": "691",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "691",
                "target_id": "1265",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "416",
                "target_id": "1265",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              }
            ],
            "score_components": {
              "relationship_chain": 1.0,
              "sequence_path": 1.0
            },
            "abstraction_factor": 1.3,
            "graph_path_info": {
              "path_types": [
                "relationship_chain",
                "vulnerability_sequence_forward",
                "vulnerability_sequence_backward"
              ],
              "best_paths": {
                "relationship_chain": {
                  "path": [
                    [
                      "416",
                      "1265",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 1.0,
                  "type": "relationship_chain",
                  "source": "416"
                },
                "vulnerability_sequence_forward": {
                  "path": [
                    [
                      "416",
                      "1265",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.9,
                  "type": "vulnerability_sequence_forward",
                  "source": "416"
                },
                "vulnerability_sequence_backward": {
                  "path": [
                    [
                      "1265",
                      "416",
                      "CANPRECEDE"
                    ]
                  ],
                  "score": 1.0,
                  "type": "vulnerability_sequence_backward",
                  "source": "416"
                }
              }
            },
            "position": "before",
            "sources": [
              "graph"
            ],
            "source": "graph",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "graph"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "graph": 2.2100000000000004
              }
            }
          },
          "similarity": 2.2100000000000004
        },
        {
          "doc_id": "122",
          "text": "CWE-122: Heap-based Buffer Overflow",
          "score": 2.1624,
          "metadata": {
            "doc_id": "122",
            "name": "Heap-based Buffer Overflow",
            "type": "variant",
            "original_content": "CWE-122: Heap-based Buffer Overflow",
            "relationships": [
              {
                "source_id": "122",
                "target_id": "787",
                "label": "CHILDOF",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "122",
                "target_id": "788",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "788",
                "target_id": "122",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "787",
                "target_id": "122",
                "label": "PARENTOF",
                "properties": {
                  "view_id": "1000"
                }
              }
            ],
            "score_components": {
              "relationship_chain": 0.3,
              "explicit_mention": 1.0,
              "abstraction_path": 0.76
            },
            "abstraction_factor": 1.2,
            "graph_path_info": {
              "path_types": [
                "relationship_chain",
                "abstraction_path_down"
              ],
              "best_paths": {
                "relationship_chain": {
                  "path": [
                    [
                      "787",
                      "122",
                      "PARENTOF"
                    ]
                  ],
                  "score": 0.3,
                  "type": "relationship_chain",
                  "source": "787"
                },
                "abstraction_path_down": {
                  "path": [
                    [
                      "787",
                      "122",
                      "PARENTOF"
                    ]
                  ],
                  "score": 0.76,
                  "type": "abstraction_path_down",
                  "source": "787"
                }
              }
            },
            "is_explicit": true,
            "abstraction_level": "variant",
            "sources": [
              "graph"
            ],
            "source": "graph",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense",
                "sparse",
                "graph"
              ],
              "retriever_count": 3,
              "normalized_scores": {
                "dense": 0.5070551867766302,
                "sparse": 59.76424520678538,
                "graph": 2.1624
              }
            }
          },
          "similarity": 2.1624
        },
        {
          "doc_id": "787",
          "text": "The product writes data past the end, or before the beginning, of the intended buffer.",
          "score": 0.6420077580310037,
          "metadata": {
            "doc_id": "787",
            "name": "Out-of-bounds Write",
            "type": "Base",
            "extended_description": null,
            "alternate_terms": [
              "Memory Corruption"
            ],
            "original_content": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "relationships": [
              {
                "source_id": "787",
                "target_id": "825",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "787",
                "target_id": "824",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "787",
                "target_id": "823",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "787",
                "target_id": "822",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "787",
                "target_id": "124",
                "label": "PARENTOF",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "787",
                "target_id": "123",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "787",
                "target_id": "122",
                "label": "PARENTOF",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "787",
                "target_id": "121",
                "label": "PARENTOF",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "787",
                "target_id": "119",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1340"
                }
              },
              {
                "source_id": "787",
                "target_id": "119",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1305"
                }
              },
              {
                "source_id": "787",
                "target_id": "119",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1003"
                }
              },
              {
                "source_id": "787",
                "target_id": "119",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "825",
                "target_id": "787",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "824",
                "target_id": "787",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "823",
                "target_id": "787",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "822",
                "target_id": "787",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "124",
                "target_id": "787",
                "label": "CHILDOF",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "123",
                "target_id": "787",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "122",
                "target_id": "787",
                "label": "CHILDOF",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "121",
                "target_id": "787",
                "label": "CHILDOF",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "119",
                "target_id": "787",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              }
            ],
            "source": "graph",
            "sources": [
              "vector",
              "graph"
            ],
            "vector_score": 0.6420077580310037,
            "graph_score": 2.821,
            "score_components": {
              "relationship_chain": 0.6,
              "explicit_mention": 1.0,
              "abstraction_path": 0.9
            },
            "abstraction_factor": 1.3,
            "graph_path_info": {
              "path_types": [
                "relationship_chain",
                "abstraction_path_up"
              ],
              "best_paths": {
                "relationship_chain": {
                  "path": [
                    [
                      "1260",
                      "119",
                      "CANPRECEDE"
                    ],
                    [
                      "119",
                      "822",
                      "PARENTOF"
                    ],
                    [
                      "822",
                      "787",
                      "CANPRECEDE"
                    ]
                  ],
                  "score": 0.6,
                  "type": "relationship_chain",
                  "source": "1260"
                },
                "abstraction_path_up": {
                  "path": [
                    [
                      "122",
                      "787",
                      "CHILDOF"
                    ]
                  ],
                  "score": 0.5599999999999999,
                  "type": "abstraction_path_up",
                  "source": "122"
                }
              }
            },
            "is_explicit": true,
            "abstraction_level": "base",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "dense",
                "sparse",
                "graph"
              ],
              "retriever_count": 3,
              "normalized_scores": {
                "dense": 0.6044956188779271,
                "sparse": 1000.0,
                "graph": 1.9494031032124015
              }
            }
          },
          "similarity": 1.9494031032124015
        },
        {
          "doc_id": "562",
          "text": "CWE-562: Return of Stack Variable Address",
          "score": 1.7680000000000005,
          "metadata": {
            "doc_id": "562",
            "name": "Return of Stack Variable Address",
            "type": "base",
            "original_content": "CWE-562: Return of Stack Variable Address",
            "relationships": [
              {
                "source_id": "562",
                "target_id": "825",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "562",
                "target_id": "672",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "562",
                "target_id": "758",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "825",
                "target_id": "562",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "758",
                "target_id": "562",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "672",
                "target_id": "562",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              }
            ],
            "score_components": {
              "relationship_chain": 0.8,
              "sequence_path": 0.8
            },
            "abstraction_factor": 1.3,
            "graph_path_info": {
              "path_types": [
                "relationship_chain",
                "vulnerability_sequence_forward",
                "vulnerability_sequence_backward"
              ],
              "best_paths": {
                "relationship_chain": {
                  "path": [
                    [
                      "415",
                      "672",
                      "CHILDOF"
                    ],
                    [
                      "672",
                      "562",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.8,
                  "type": "relationship_chain",
                  "source": "415"
                },
                "vulnerability_sequence_forward": {
                  "path": [
                    [
                      "787",
                      "825",
                      "CANFOLLOW"
                    ],
                    [
                      "825",
                      "562",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.7200000000000001,
                  "type": "vulnerability_sequence_forward",
                  "source": "787"
                },
                "vulnerability_sequence_backward": {
                  "path": [
                    [
                      "825",
                      "787",
                      "CANPRECEDE"
                    ],
                    [
                      "562",
                      "825",
                      "CANPRECEDE"
                    ]
                  ],
                  "score": 0.8,
                  "type": "vulnerability_sequence_backward",
                  "source": "787"
                }
              }
            },
            "position": "before",
            "sources": [
              "graph"
            ],
            "source": "graph",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "graph"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "graph": 1.7680000000000005
              }
            }
          },
          "similarity": 1.7680000000000005
        },
        {
          "doc_id": "134",
          "text": "CWE-134: Use of Externally-Controlled Format String",
          "score": 1.6848000000000003,
          "metadata": {
            "doc_id": "134",
            "name": "Use of Externally-Controlled Format String",
            "type": "base",
            "original_content": "CWE-134: Use of Externally-Controlled Format String",
            "relationships": [
              {
                "source_id": "134",
                "target_id": "20",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "700"
                }
              },
              {
                "source_id": "134",
                "target_id": "123",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "134",
                "target_id": "668",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1003"
                }
              },
              {
                "source_id": "134",
                "target_id": "668",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "668",
                "target_id": "134",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "20",
                "target_id": "134",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "700"
                }
              },
              {
                "source_id": "123",
                "target_id": "134",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              }
            ],
            "score_components": {
              "relationship_chain": 0.8,
              "sequence_path": 0.7200000000000001
            },
            "abstraction_factor": 1.3,
            "graph_path_info": {
              "path_types": [
                "relationship_chain",
                "vulnerability_sequence_forward"
              ],
              "best_paths": {
                "relationship_chain": {
                  "path": [
                    [
                      "415",
                      "123",
                      "PEEROF"
                    ],
                    [
                      "123",
                      "134",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.8,
                  "type": "relationship_chain",
                  "source": "415"
                },
                "vulnerability_sequence_forward": {
                  "path": [
                    [
                      "416",
                      "123",
                      "CANPRECEDE"
                    ],
                    [
                      "123",
                      "134",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.7200000000000001,
                  "type": "vulnerability_sequence_forward",
                  "source": "416"
                }
              }
            },
            "position": "after",
            "sources": [
              "graph"
            ],
            "source": "graph",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "graph"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "graph": 1.6848000000000003
              }
            }
          },
          "similarity": 1.6848000000000003
        },
        {
          "doc_id": "170",
          "text": "CWE-170: Improper Null Termination",
          "score": 1.6848000000000003,
          "metadata": {
            "doc_id": "170",
            "name": "Improper Null Termination",
            "type": "base",
            "original_content": "CWE-170: Improper Null Termination",
            "relationships": [
              {
                "source_id": "170",
                "target_id": "682",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "170",
                "target_id": "193",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "170",
                "target_id": "20",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "700"
                }
              },
              {
                "source_id": "170",
                "target_id": "463",
                "label": "PEEROF",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "170",
                "target_id": "464",
                "label": "PEEROF",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "170",
                "target_id": "147",
                "label": "CANALSOBE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "170",
                "target_id": "126",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "170",
                "target_id": "120",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "170",
                "target_id": "707",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "707",
                "target_id": "170",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "682",
                "target_id": "170",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "20",
                "target_id": "170",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "700"
                }
              },
              {
                "source_id": "193",
                "target_id": "170",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "126",
                "target_id": "170",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "120",
                "target_id": "170",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              }
            ],
            "score_components": {
              "relationship_chain": 0.8,
              "sequence_path": 0.7200000000000001
            },
            "abstraction_factor": 1.3,
            "graph_path_info": {
              "path_types": [
                "relationship_chain",
                "vulnerability_sequence_forward"
              ],
              "best_paths": {
                "relationship_chain": {
                  "path": [
                    [
                      "416",
                      "120",
                      "CANPRECEDE"
                    ],
                    [
                      "120",
                      "170",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.8,
                  "type": "relationship_chain",
                  "source": "416"
                },
                "vulnerability_sequence_forward": {
                  "path": [
                    [
                      "416",
                      "120",
                      "CANPRECEDE"
                    ],
                    [
                      "120",
                      "170",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.7200000000000001,
                  "type": "vulnerability_sequence_forward",
                  "source": "416"
                }
              }
            },
            "position": "after",
            "sources": [
              "graph"
            ],
            "source": "graph",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "graph"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "graph": 1.6848000000000003
              }
            }
          },
          "similarity": 1.6848000000000003
        },
        {
          "doc_id": "1257",
          "text": "CWE-1257: Improper Access Control Applied to Mirrored or Aliased Memory Regions",
          "score": 1.6848000000000003,
          "metadata": {
            "doc_id": "1257",
            "name": "Improper Access Control Applied to Mirrored or Aliased Memory Regions",
            "type": "base",
            "original_content": "CWE-1257: Improper Access Control Applied to Mirrored or Aliased Memory Regions",
            "relationships": [
              {
                "source_id": "1257",
                "target_id": "119",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "1257",
                "target_id": "284",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "284",
                "target_id": "1257",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "119",
                "target_id": "1257",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              }
            ],
            "score_components": {
              "relationship_chain": 0.8,
              "sequence_path": 0.7200000000000001
            },
            "abstraction_factor": 1.3,
            "graph_path_info": {
              "path_types": [
                "relationship_chain",
                "vulnerability_sequence_forward"
              ],
              "best_paths": {
                "relationship_chain": {
                  "path": [
                    [
                      "1260",
                      "119",
                      "CANPRECEDE"
                    ],
                    [
                      "119",
                      "1257",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.8,
                  "type": "relationship_chain",
                  "source": "1260"
                },
                "vulnerability_sequence_forward": {
                  "path": [
                    [
                      "1260",
                      "119",
                      "CANPRECEDE"
                    ],
                    [
                      "119",
                      "1257",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.7200000000000001,
                  "type": "vulnerability_sequence_forward",
                  "source": "1260"
                }
              }
            },
            "position": "after",
            "sources": [
              "graph"
            ],
            "source": "graph",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "graph"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "graph": 1.6848000000000003
              }
            }
          },
          "similarity": 1.6848000000000003
        },
        {
          "doc_id": "128",
          "text": "CWE-128: Wrap-around Error",
          "score": 1.6848000000000003,
          "metadata": {
            "doc_id": "128",
            "name": "Wrap-around Error",
            "type": "base",
            "original_content": "CWE-128: Wrap-around Error",
            "relationships": [
              {
                "source_id": "128",
                "target_id": "190",
                "label": "PEEROF",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "128",
                "target_id": "119",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "128",
                "target_id": "682",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "682",
                "target_id": "128",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "119",
                "target_id": "128",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              }
            ],
            "score_components": {
              "relationship_chain": 0.8,
              "sequence_path": 0.7200000000000001
            },
            "abstraction_factor": 1.3,
            "graph_path_info": {
              "path_types": [
                "relationship_chain",
                "vulnerability_sequence_forward"
              ],
              "best_paths": {
                "relationship_chain": {
                  "path": [
                    [
                      "1260",
                      "119",
                      "CANPRECEDE"
                    ],
                    [
                      "119",
                      "128",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.8,
                  "type": "relationship_chain",
                  "source": "1260"
                },
                "vulnerability_sequence_forward": {
                  "path": [
                    [
                      "1260",
                      "119",
                      "CANPRECEDE"
                    ],
                    [
                      "119",
                      "128",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.7200000000000001,
                  "type": "vulnerability_sequence_forward",
                  "source": "1260"
                }
              }
            },
            "position": "after",
            "sources": [
              "graph"
            ],
            "source": "graph",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "graph"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "graph": 1.6848000000000003
              }
            }
          },
          "similarity": 1.6848000000000003
        },
        {
          "doc_id": "131",
          "text": "CWE-131: Incorrect Calculation of Buffer Size",
          "score": 1.6848000000000003,
          "metadata": {
            "doc_id": "131",
            "name": "Incorrect Calculation of Buffer Size",
            "type": "base",
            "original_content": "CWE-131: Incorrect Calculation of Buffer Size",
            "relationships": [
              {
                "source_id": "131",
                "target_id": "467",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "131",
                "target_id": "119",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "131",
                "target_id": "682",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1340"
                }
              },
              {
                "source_id": "131",
                "target_id": "682",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1305"
                }
              },
              {
                "source_id": "131",
                "target_id": "682",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1003"
                }
              },
              {
                "source_id": "131",
                "target_id": "682",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "682",
                "target_id": "131",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "467",
                "target_id": "131",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "119",
                "target_id": "131",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              }
            ],
            "score_components": {
              "relationship_chain": 0.8,
              "sequence_path": 0.7200000000000001
            },
            "abstraction_factor": 1.3,
            "graph_path_info": {
              "path_types": [
                "relationship_chain",
                "vulnerability_sequence_forward"
              ],
              "best_paths": {
                "relationship_chain": {
                  "path": [
                    [
                      "1260",
                      "119",
                      "CANPRECEDE"
                    ],
                    [
                      "119",
                      "131",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.8,
                  "type": "relationship_chain",
                  "source": "1260"
                },
                "vulnerability_sequence_forward": {
                  "path": [
                    [
                      "1260",
                      "119",
                      "CANPRECEDE"
                    ],
                    [
                      "119",
                      "131",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.7200000000000001,
                  "type": "vulnerability_sequence_forward",
                  "source": "1260"
                }
              }
            },
            "position": "after",
            "sources": [
              "graph"
            ],
            "source": "graph",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "graph"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "graph": 1.6848000000000003
              }
            }
          },
          "similarity": 1.6848000000000003
        },
        {
          "doc_id": "1339",
          "text": "CWE-1339: Insufficient Precision or Accuracy of a Real Number",
          "score": 1.6848000000000003,
          "metadata": {
            "doc_id": "1339",
            "name": "Insufficient Precision or Accuracy of a Real Number",
            "type": "base",
            "original_content": "CWE-1339: Insufficient Precision or Accuracy of a Real Number",
            "relationships": [
              {
                "source_id": "1339",
                "target_id": "119",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "1339",
                "target_id": "834",
                "label": "CANPRECEDE",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "1339",
                "target_id": "190",
                "label": "PEEROF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "1339",
                "target_id": "682",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "834",
                "target_id": "1339",
                "label": "CANFOLLOW",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "682",
                "target_id": "1339",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "119",
                "target_id": "1339",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              }
            ],
            "score_components": {
              "relationship_chain": 0.8,
              "sequence_path": 0.7200000000000001
            },
            "abstraction_factor": 1.3,
            "graph_path_info": {
              "path_types": [
                "relationship_chain",
                "vulnerability_sequence_forward"
              ],
              "best_paths": {
                "relationship_chain": {
                  "path": [
                    [
                      "1260",
                      "119",
                      "CANPRECEDE"
                    ],
                    [
                      "119",
                      "1339",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.8,
                  "type": "relationship_chain",
                  "source": "1260"
                },
                "vulnerability_sequence_forward": {
                  "path": [
                    [
                      "1260",
                      "119",
                      "CANPRECEDE"
                    ],
                    [
                      "119",
                      "1339",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.7200000000000001,
                  "type": "vulnerability_sequence_forward",
                  "source": "1260"
                }
              }
            },
            "position": "after",
            "sources": [
              "graph"
            ],
            "source": "graph",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "graph"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "graph": 1.6848000000000003
              }
            }
          },
          "similarity": 1.6848000000000003
        },
        {
          "doc_id": "190",
          "text": "CWE-190: Integer Overflow or Wraparound",
          "score": 1.6848000000000003,
          "metadata": {
            "doc_id": "190",
            "name": "Integer Overflow or Wraparound",
            "type": "base",
            "original_content": "CWE-190: Integer Overflow or Wraparound",
            "relationships": [
              {
                "source_id": "190",
                "target_id": "680",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "190",
                "target_id": "119",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "190",
                "target_id": "20",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "700"
                }
              },
              {
                "source_id": "190",
                "target_id": "682",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1003"
                }
              },
              {
                "source_id": "190",
                "target_id": "682",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "682",
                "target_id": "190",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "680",
                "target_id": "190",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "680",
                "target_id": "190",
                "label": "STARTSWITH",
                "properties": {
                  "view_id": "709"
                }
              },
              {
                "source_id": "20",
                "target_id": "190",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "700"
                }
              },
              {
                "source_id": "1339",
                "target_id": "190",
                "label": "PEEROF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "128",
                "target_id": "190",
                "label": "PEEROF",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "119",
                "target_id": "190",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              }
            ],
            "score_components": {
              "relationship_chain": 0.8,
              "sequence_path": 0.7200000000000001
            },
            "abstraction_factor": 1.3,
            "graph_path_info": {
              "path_types": [
                "relationship_chain",
                "vulnerability_sequence_forward"
              ],
              "best_paths": {
                "relationship_chain": {
                  "path": [
                    [
                      "1260",
                      "119",
                      "CANPRECEDE"
                    ],
                    [
                      "119",
                      "190",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.8,
                  "type": "relationship_chain",
                  "source": "1260"
                },
                "vulnerability_sequence_forward": {
                  "path": [
                    [
                      "1260",
                      "119",
                      "CANPRECEDE"
                    ],
                    [
                      "119",
                      "190",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.7200000000000001,
                  "type": "vulnerability_sequence_forward",
                  "source": "1260"
                }
              }
            },
            "position": "after",
            "sources": [
              "graph"
            ],
            "source": "graph",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Be careful of terminology problems with \"overflow,\" \"underflow,\" and \"wraparound\" - see Terminology Notes. Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ],
              "suggestions": [
                {
                  "CweID": "191",
                  "Comment": "Integer Underflow (Wrap or Wraparound). Consider CWE-191 when the result is less than the minimum value that can be represented (sometimes called \"underflows\")."
                }
              ]
            },
            "score_info": {
              "retrievers": [
                "sparse",
                "graph"
              ],
              "retriever_count": 2,
              "normalized_scores": {
                "sparse": 51.530627528621274,
                "graph": 1.6848000000000003
              }
            }
          },
          "similarity": 1.6848000000000003
        },
        {
          "doc_id": "193",
          "text": "CWE-193: Off-by-one Error",
          "score": 1.6848000000000003,
          "metadata": {
            "doc_id": "193",
            "name": "Off-by-one Error",
            "type": "base",
            "original_content": "CWE-193: Off-by-one Error",
            "relationships": [
              {
                "source_id": "193",
                "target_id": "119",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "193",
                "target_id": "170",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "193",
                "target_id": "617",
                "label": "CANPRECEDE",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "193",
                "target_id": "682",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1003"
                }
              },
              {
                "source_id": "193",
                "target_id": "682",
                "label": "CHILDOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "682",
                "target_id": "193",
                "label": "PARENTOF",
                "properties": {
                  "ordinal": "Primary",
                  "view_id": "1000"
                }
              },
              {
                "source_id": "617",
                "target_id": "193",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "170",
                "target_id": "193",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              },
              {
                "source_id": "119",
                "target_id": "193",
                "label": "CANFOLLOW",
                "properties": {
                  "view_id": "1000"
                }
              }
            ],
            "score_components": {
              "relationship_chain": 0.8,
              "sequence_path": 0.7200000000000001
            },
            "abstraction_factor": 1.3,
            "graph_path_info": {
              "path_types": [
                "relationship_chain",
                "vulnerability_sequence_forward"
              ],
              "best_paths": {
                "relationship_chain": {
                  "path": [
                    [
                      "1260",
                      "119",
                      "CANPRECEDE"
                    ],
                    [
                      "119",
                      "193",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.8,
                  "type": "relationship_chain",
                  "source": "1260"
                },
                "vulnerability_sequence_forward": {
                  "path": [
                    [
                      "1260",
                      "119",
                      "CANPRECEDE"
                    ],
                    [
                      "119",
                      "193",
                      "CANFOLLOW"
                    ]
                  ],
                  "score": 0.7200000000000001,
                  "type": "vulnerability_sequence_forward",
                  "source": "1260"
                }
              }
            },
            "position": "after",
            "sources": [
              "graph"
            ],
            "source": "graph",
            "mapping_notes": {
              "usage": "Allowed",
              "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
              "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
              "reasons": [
                "Acceptable-Use"
              ]
            },
            "score_info": {
              "retrievers": [
                "graph"
              ],
              "retriever_count": 1,
              "normalized_scores": {
                "graph": 1.6848000000000003
              }
            }
          },
          "similarity": 1.6848000000000003
        }
      ],
      "result_sources": {
        "CWE-787": [
          "dense",
          "sparse",
          "graph"
        ],
        "CWE-416": [
          "dense",
          "sparse",
          "graph"
        ],
        "CWE-843": [
          "dense",
          "sparse",
          "graph"
        ],
        "CWE-316": [
          "dense"
        ],
        "CWE-1260": [
          "dense",
          "graph"
        ],
        "CWE-788": [
          "dense",
          "sparse"
        ],
        "CWE-127": [
          "dense"
        ],
        "CWE-822": [
          "dense",
          "sparse"
        ],
        "CWE-124": [
          "dense"
        ],
        "CWE-704": [
          "dense"
        ],
        "CWE-789": [
          "dense"
        ],
        "CWE-366": [
          "dense",
          "sparse"
        ],
        "CWE-401": [
          "dense"
        ],
        "CWE-80": [
          "dense"
        ],
        "CWE-122": [
          "dense",
          "sparse",
          "graph"
        ],
        "CWE-823": [
          "dense"
        ],
        "CWE-119": [
          "dense"
        ],
        "CWE-125": [
          "dense"
        ],
        "CWE-126": [
          "dense"
        ],
        "CWE-1342": [
          "dense"
        ],
        "CWE-415": [
          "sparse",
          "graph"
        ],
        "CWE-190": [
          "sparse",
          "graph"
        ],
        "CWE-908": [
          "sparse"
        ],
        "CWE-191": [
          "sparse"
        ],
        "CWE-770": [
          "sparse"
        ],
        "CWE-123": [
          "graph"
        ],
        "CWE-364": [
          "graph"
        ],
        "CWE-825": [
          "graph"
        ],
        "CWE-120": [
          "graph"
        ],
        "CWE-1265": [
          "graph"
        ],
        "CWE-562": [
          "graph"
        ],
        "CWE-134": [
          "graph"
        ],
        "CWE-170": [
          "graph"
        ],
        "CWE-1257": [
          "graph"
        ],
        "CWE-128": [
          "graph"
        ],
        "CWE-131": [
          "graph"
        ],
        "CWE-1339": [
          "graph"
        ],
        "CWE-193": [
          "graph"
        ]
      },
      "result_scores": {
        "CWE-787": {
          "dense": 0.6044956188779271,
          "sparse": 1000.0,
          "graph": 1.9494031032124015
        },
        "CWE-416": {
          "dense": 0.5564290782764135,
          "sparse": 60.782740992322296,
          "graph": 2.262891626614683
        },
        "CWE-843": {
          "dense": 0.5532373381039504,
          "sparse": 67.60603023958426,
          "graph": 2.5257713361350778
        },
        "CWE-316": {
          "dense": 0.5530907529031421
        },
        "CWE-1260": {
          "dense": 0.5423218496153519,
          "graph": 2.372747119777513
        },
        "CWE-788": {
          "dense": 0.5413483969451229,
          "sparse": 51.05905723022035
        },
        "CWE-127": {
          "dense": 0.5349246760880122
        },
        "CWE-822": {
          "dense": 0.5331898988837035,
          "sparse": 48.46614763081808
        },
        "CWE-124": {
          "dense": 0.5304708044548463
        },
        "CWE-704": {
          "dense": 0.5272079352444721
        },
        "CWE-789": {
          "dense": 0.509625927918915
        },
        "CWE-366": {
          "dense": 0.5095764723959488,
          "sparse": 50.5279456484442
        },
        "CWE-401": {
          "dense": 0.5090974239680022
        },
        "CWE-80": {
          "dense": 0.5070815204945177
        },
        "CWE-122": {
          "dense": 0.5070551867766302,
          "sparse": 59.76424520678538,
          "graph": 2.1624
        },
        "CWE-823": {
          "dense": 0.5056866376391194
        },
        "CWE-119": {
          "dense": 0.504740424629194
        },
        "CWE-125": {
          "dense": 0.5042019323869635
        },
        "CWE-126": {
          "dense": 0.502493536294006
        },
        "CWE-1342": {
          "dense": 0.5024177349997196
        },
        "CWE-415": {
          "sparse": 53.504177185489525,
          "graph": 2.2516220093081967
        },
        "CWE-190": {
          "sparse": 51.530627528621274,
          "graph": 1.6848000000000003
        },
        "CWE-908": {
          "sparse": 47.42449593239558
        },
        "CWE-191": {
          "sparse": 10.227986494513978
        },
        "CWE-770": {
          "sparse": 9.972354828241215
        },
        "CWE-123": {
          "graph": 3.5671999999999997
        },
        "CWE-364": {
          "graph": 2.2100000000000004
        },
        "CWE-825": {
          "graph": 2.2100000000000004
        },
        "CWE-120": {
          "graph": 2.2100000000000004
        },
        "CWE-1265": {
          "graph": 2.2100000000000004
        },
        "CWE-562": {
          "graph": 1.7680000000000005
        },
        "CWE-134": {
          "graph": 1.6848000000000003
        },
        "CWE-170": {
          "graph": 1.6848000000000003
        },
        "CWE-1257": {
          "graph": 1.6848000000000003
        },
        "CWE-128": {
          "graph": 1.6848000000000003
        },
        "CWE-131": {
          "graph": 1.6848000000000003
        },
        "CWE-1339": {
          "graph": 1.6848000000000003
        },
        "CWE-193": {
          "graph": 1.6848000000000003
        }
      },
      "retriever_results": {
        "graph": [
          {
            "doc_id": "123",
            "text": "CWE-123: Write-what-where Condition",
            "score": 3.5671999999999997,
            "metadata": {
              "doc_id": "123",
              "name": "Write-what-where Condition",
              "type": "base",
              "original_content": "CWE-123: Write-what-where Condition",
              "relationships": [
                {
                  "source_id": "123",
                  "target_id": "590",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "123",
                  "target_id": "479",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "123",
                  "target_id": "416",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "123",
                  "target_id": "364",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "123",
                  "target_id": "134",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "123",
                  "target_id": "120",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "123",
                  "target_id": "119",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1340"
                  }
                },
                {
                  "source_id": "123",
                  "target_id": "119",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1305"
                  }
                },
                {
                  "source_id": "123",
                  "target_id": "787",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "787",
                  "target_id": "123",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "590",
                  "target_id": "123",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "479",
                  "target_id": "123",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "416",
                  "target_id": "123",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "415",
                  "target_id": "123",
                  "label": "PEEROF",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "364",
                  "target_id": "123",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "134",
                  "target_id": "123",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "120",
                  "target_id": "123",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "119",
                  "target_id": "123",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1305"
                  }
                }
              ],
              "score_components": {
                "relationship_chain": 1.0,
                "abstraction_path": 0.7200000000000001,
                "sequence_path": 1.0,
                "peer_group": 0.9
              },
              "abstraction_factor": 1.3,
              "graph_path_info": {
                "path_types": [
                  "relationship_chain",
                  "abstraction_path_down",
                  "vulnerability_sequence_forward",
                  "peer_relationship"
                ],
                "best_paths": {
                  "relationship_chain": {
                    "path": [
                      [
                        "416",
                        "123",
                        "CANPRECEDE"
                      ]
                    ],
                    "score": 1.0,
                    "type": "relationship_chain",
                    "source": "416"
                  },
                  "abstraction_path_down": {
                    "path": [
                      [
                        "787",
                        "123",
                        "PARENTOF"
                      ]
                    ],
                    "score": 0.7200000000000001,
                    "type": "abstraction_path_down",
                    "source": "787"
                  },
                  "vulnerability_sequence_forward": {
                    "path": [
                      [
                        "416",
                        "123",
                        "CANPRECEDE"
                      ]
                    ],
                    "score": 1.0,
                    "type": "vulnerability_sequence_forward",
                    "source": "416"
                  },
                  "peer_relationship": {
                    "path": [
                      [
                        "415",
                        "123",
                        "PEEROF"
                      ]
                    ],
                    "score": 0.9,
                    "type": "peer_relationship",
                    "source": "415"
                  }
                }
              },
              "abstraction_level": "base",
              "position": "after",
              "sources": [
                "graph"
              ],
              "source": "graph",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "graph"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "graph": 3.5671999999999997
                }
              }
            },
            "similarity": 3.5671999999999997
          },
          {
            "doc_id": "843",
            "text": "The product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.",
            "score": 0.6087283403376947,
            "metadata": {
              "doc_id": "843",
              "name": "Access of Resource Using Incompatible Type ('Type Confusion')",
              "type": "Base",
              "extended_description": "\n\nWhen the product accesses the resource using an incompatible type, this could trigger logical errors because the resource does not have expected properties. In languages without memory safety, such as C and C++, type confusion can lead to out-of-bounds memory access.\n\n\nWhile this weakness is frequently associated with unions when parsing data with many different embedded object types in C, it can be present in any application that can interpret the same variable or memory location in multiple ways.\n\n\nThis weakness is not unique to C and C++. For example, errors in PHP applications can be triggered by providing array parameters when scalars are expected, or vice versa. Languages such as Perl, which perform automatic conversion of a variable of one type when it is accessed as if it were another type, can also contain these issues.\n",
              "alternate_terms": [
                "Object Type Confusion"
              ],
              "original_content": "The product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.",
              "relationships": [
                {
                  "source_id": "843",
                  "target_id": "119",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "843",
                  "target_id": "704",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1003"
                  }
                },
                {
                  "source_id": "843",
                  "target_id": "704",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "704",
                  "target_id": "843",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "1287",
                  "target_id": "843",
                  "label": "PEEROF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "119",
                  "target_id": "843",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                }
              ],
              "source": "graph",
              "sources": [
                "vector",
                "graph"
              ],
              "vector_score": 0.6087283403376947,
              "graph_score": 3.8038000000000003,
              "score_components": {
                "relationship_chain": 0.8,
                "explicit_mention": 1.0,
                "abstraction_path": 0.9,
                "sequence_path": 0.7200000000000001
              },
              "abstraction_factor": 1.3,
              "graph_path_info": {
                "path_types": [
                  "relationship_chain",
                  "vulnerability_sequence_forward"
                ],
                "best_paths": {
                  "relationship_chain": {
                    "path": [
                      [
                        "1260",
                        "119",
                        "CANPRECEDE"
                      ],
                      [
                        "119",
                        "843",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.8,
                    "type": "relationship_chain",
                    "source": "1260"
                  },
                  "vulnerability_sequence_forward": {
                    "path": [
                      [
                        "1260",
                        "119",
                        "CANPRECEDE"
                      ],
                      [
                        "119",
                        "843",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.7200000000000001,
                    "type": "vulnerability_sequence_forward",
                    "source": "1260"
                  }
                }
              },
              "is_explicit": true,
              "abstraction_level": "base",
              "position": "after",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense",
                  "sparse",
                  "graph"
                ],
                "retriever_count": 3,
                "normalized_scores": {
                  "dense": 0.5532373381039504,
                  "sparse": 67.60603023958426,
                  "graph": 2.5257713361350778
                }
              }
            },
            "similarity": 2.5257713361350778
          },
          {
            "doc_id": "1260",
            "text": "The product allows address regions to overlap, which can result in the bypassing of intended memory protection.",
            "score": 0.5771677994437826,
            "metadata": {
              "doc_id": "1260",
              "name": "Improper Handling of Overlap Between Protected Memory Ranges",
              "type": "Base",
              "extended_description": "\n\nIsolated memory regions and access control (read/write) policies are used by hardware to protect privileged software. Software components are often allowed to change or remap memory region definitions in order to enable flexible and dynamically changeable memory management by system software.\n\n\nIf a software component running at lower privilege can program a memory address region to overlap with other memory regions used by software running at higher privilege, privilege escalation may be available to attackers. The memory protection unit (MPU) logic can incorrectly handle such an address overlap and allow the lower-privilege software to read or write into the protected memory region, resulting in privilege escalation attack. An address overlap weakness can also be used to launch a denial of service attack on the higher-privilege software memory regions.\n",
              "alternate_terms": [],
              "original_content": "The product allows address regions to overlap, which can result in the bypassing of intended memory protection.",
              "relationships": [
                {
                  "source_id": "1260",
                  "target_id": "119",
                  "label": "CANPRECEDE",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "1260",
                  "target_id": "284",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "284",
                  "target_id": "1260",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "119",
                  "target_id": "1260",
                  "label": "CANFOLLOW",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                }
              ],
              "source": "graph",
              "sources": [
                "vector",
                "graph"
              ],
              "vector_score": 0.5771677994437826,
              "graph_score": 3.5698000000000003,
              "score_components": {
                "relationship_chain": 0.6,
                "explicit_mention": 1.0,
                "abstraction_path": 0.9,
                "sequence_path": 0.7200000000000001
              },
              "abstraction_factor": 1.3,
              "graph_path_info": {
                "path_types": [
                  "relationship_chain",
                  "vulnerability_sequence_forward"
                ],
                "best_paths": {
                  "relationship_chain": {
                    "path": [
                      [
                        "415",
                        "123",
                        "PEEROF"
                      ],
                      [
                        "123",
                        "119",
                        "CHILDOF"
                      ],
                      [
                        "119",
                        "1260",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.6,
                    "type": "relationship_chain",
                    "source": "415"
                  },
                  "vulnerability_sequence_forward": {
                    "path": [
                      [
                        "843",
                        "119",
                        "CANPRECEDE"
                      ],
                      [
                        "119",
                        "1260",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.7200000000000001,
                    "type": "vulnerability_sequence_forward",
                    "source": "843"
                  }
                }
              },
              "is_explicit": true,
              "abstraction_level": "base",
              "position": "after",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense",
                  "graph"
                ],
                "retriever_count": 2,
                "normalized_scores": {
                  "dense": 0.5423218496153519,
                  "graph": 2.372747119777513
                }
              }
            },
            "similarity": 2.372747119777513
          },
          {
            "doc_id": "416",
            "text": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
            "score": 0.5992290665367083,
            "metadata": {
              "doc_id": "416",
              "name": "Use After Free",
              "type": "Variant",
              "extended_description": null,
              "alternate_terms": [
                "Dangling pointer",
                "UAF",
                "Use-After-Free"
              ],
              "original_content": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
              "relationships": [
                {
                  "source_id": "416",
                  "target_id": "754",
                  "label": "CANFOLLOW",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "416",
                  "target_id": "364",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "416",
                  "target_id": "362",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "416",
                  "target_id": "1265",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "416",
                  "target_id": "123",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "416",
                  "target_id": "120",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "416",
                  "target_id": "672",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1340"
                  }
                },
                {
                  "source_id": "416",
                  "target_id": "672",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1305"
                  }
                },
                {
                  "source_id": "416",
                  "target_id": "672",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1003"
                  }
                },
                {
                  "source_id": "416",
                  "target_id": "825",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "825",
                  "target_id": "416",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "754",
                  "target_id": "416",
                  "label": "CANPRECEDE",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "672",
                  "target_id": "416",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1003"
                  }
                },
                {
                  "source_id": "415",
                  "target_id": "416",
                  "label": "PEEROF",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "364",
                  "target_id": "416",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "362",
                  "target_id": "416",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "1265",
                  "target_id": "416",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "123",
                  "target_id": "416",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "120",
                  "target_id": "416",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                }
              ],
              "source": "graph",
              "sources": [
                "vector",
                "graph"
              ],
              "vector_score": 0.5992290665367083,
              "graph_score": 3.372,
              "score_components": {
                "relationship_chain": 0.7,
                "explicit_mention": 1.0,
                "sequence_path": 0.8,
                "peer_group": 0.9
              },
              "abstraction_factor": 1.2,
              "graph_path_info": {
                "path_types": [
                  "relationship_chain",
                  "vulnerability_sequence_forward",
                  "peer_relationship"
                ],
                "best_paths": {
                  "relationship_chain": {
                    "path": [
                      [
                        "415",
                        "416",
                        "PEEROF"
                      ]
                    ],
                    "score": 0.7,
                    "type": "relationship_chain",
                    "source": "415"
                  },
                  "vulnerability_sequence_forward": {
                    "path": [
                      [
                        "415",
                        "364",
                        "CANFOLLOW"
                      ],
                      [
                        "364",
                        "416",
                        "CANPRECEDE"
                      ]
                    ],
                    "score": 0.8,
                    "type": "vulnerability_sequence_forward",
                    "source": "415"
                  },
                  "peer_relationship": {
                    "path": [
                      [
                        "415",
                        "416",
                        "PEEROF"
                      ]
                    ],
                    "score": 0.9,
                    "type": "peer_relationship",
                    "source": "415"
                  }
                }
              },
              "is_explicit": true,
              "abstraction_level": "variant",
              "position": "after",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense",
                  "sparse",
                  "graph"
                ],
                "retriever_count": 3,
                "normalized_scores": {
                  "dense": 0.5564290782764135,
                  "sparse": 60.782740992322296,
                  "graph": 2.262891626614683
                }
              }
            },
            "similarity": 2.262891626614683
          },
          {
            "doc_id": "415",
            "text": "The product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.",
            "score": 0.5710550232704926,
            "metadata": {
              "doc_id": "415",
              "name": "Double Free",
              "type": "Variant",
              "extended_description": "When a program calls free() twice with the same argument, the program's memory management data structures become corrupted. This corruption can cause the program to crash or, in some circumstances, cause two later calls to malloc() to return the same pointer. If malloc() returns the same value twice and the program later gives the attacker control over the data that is written into this doubly-allocated memory, the program becomes vulnerable to a buffer overflow attack.",
              "alternate_terms": [
                "Double-free"
              ],
              "original_content": "The product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.",
              "relationships": [
                {
                  "source_id": "415",
                  "target_id": "364",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "415",
                  "target_id": "123",
                  "label": "PEEROF",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "415",
                  "target_id": "416",
                  "label": "PEEROF",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "415",
                  "target_id": "666",
                  "label": "CHILDOF",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "415",
                  "target_id": "672",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1340"
                  }
                },
                {
                  "source_id": "415",
                  "target_id": "672",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1305"
                  }
                },
                {
                  "source_id": "415",
                  "target_id": "672",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1003"
                  }
                },
                {
                  "source_id": "415",
                  "target_id": "1341",
                  "label": "CHILDOF",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "415",
                  "target_id": "825",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "825",
                  "target_id": "415",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "672",
                  "target_id": "415",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1003"
                  }
                },
                {
                  "source_id": "666",
                  "target_id": "415",
                  "label": "PARENTOF",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "364",
                  "target_id": "415",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "1341",
                  "target_id": "415",
                  "label": "PARENTOF",
                  "properties": {
                    "view_id": "1000"
                  }
                }
              ],
              "source": "graph",
              "sources": [
                "vector",
                "graph"
              ],
              "vector_score": 0.5710550232704926,
              "graph_score": 3.372,
              "score_components": {
                "explicit_mention": 1.0,
                "relationship_chain": 0.7,
                "sequence_path": 0.8,
                "peer_group": 0.9
              },
              "abstraction_factor": 1.2,
              "graph_path_info": {
                "path_types": [
                  "relationship_chain",
                  "vulnerability_sequence_forward",
                  "peer_relationship"
                ],
                "best_paths": {
                  "relationship_chain": {
                    "path": [
                      [
                        "415",
                        "416",
                        "PEEROF"
                      ]
                    ],
                    "score": 0.7,
                    "type": "relationship_chain",
                    "source": "416"
                  },
                  "vulnerability_sequence_forward": {
                    "path": [
                      [
                        "416",
                        "364",
                        "CANFOLLOW"
                      ],
                      [
                        "364",
                        "415",
                        "CANPRECEDE"
                      ]
                    ],
                    "score": 0.8,
                    "type": "vulnerability_sequence_forward",
                    "source": "416"
                  },
                  "peer_relationship": {
                    "path": [
                      [
                        "415",
                        "416",
                        "PEEROF"
                      ]
                    ],
                    "score": 0.9,
                    "type": "peer_relationship",
                    "source": "416"
                  }
                }
              },
              "is_explicit": true,
              "abstraction_level": "variant",
              "position": "after",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "sparse",
                  "graph"
                ],
                "retriever_count": 2,
                "normalized_scores": {
                  "sparse": 53.504177185489525,
                  "graph": 2.2516220093081967
                }
              }
            },
            "similarity": 2.2516220093081967
          },
          {
            "doc_id": "364",
            "text": "CWE-364: Signal Handler Race Condition",
            "score": 2.2100000000000004,
            "metadata": {
              "doc_id": "364",
              "name": "Signal Handler Race Condition",
              "type": "base",
              "original_content": "CWE-364: Signal Handler Race Condition",
              "relationships": [
                {
                  "source_id": "364",
                  "target_id": "831",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "364",
                  "target_id": "828",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "364",
                  "target_id": "432",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "364",
                  "target_id": "123",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "364",
                  "target_id": "416",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "364",
                  "target_id": "415",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "364",
                  "target_id": "362",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "831",
                  "target_id": "364",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "828",
                  "target_id": "364",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "432",
                  "target_id": "364",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "416",
                  "target_id": "364",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "415",
                  "target_id": "364",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "368",
                  "target_id": "364",
                  "label": "CANALSOBE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "362",
                  "target_id": "364",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "123",
                  "target_id": "364",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                }
              ],
              "score_components": {
                "relationship_chain": 1.0,
                "sequence_path": 1.0
              },
              "abstraction_factor": 1.3,
              "graph_path_info": {
                "path_types": [
                  "relationship_chain",
                  "vulnerability_sequence_forward",
                  "vulnerability_sequence_backward"
                ],
                "best_paths": {
                  "relationship_chain": {
                    "path": [
                      [
                        "415",
                        "364",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 1.0,
                    "type": "relationship_chain",
                    "source": "415"
                  },
                  "vulnerability_sequence_forward": {
                    "path": [
                      [
                        "415",
                        "364",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.9,
                    "type": "vulnerability_sequence_forward",
                    "source": "415"
                  },
                  "vulnerability_sequence_backward": {
                    "path": [
                      [
                        "364",
                        "415",
                        "CANPRECEDE"
                      ]
                    ],
                    "score": 1.0,
                    "type": "vulnerability_sequence_backward",
                    "source": "415"
                  }
                }
              },
              "position": "before",
              "sources": [
                "graph"
              ],
              "source": "graph",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "graph"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "graph": 2.2100000000000004
                }
              }
            },
            "similarity": 2.2100000000000004
          },
          {
            "doc_id": "825",
            "text": "CWE-825: Expired Pointer Dereference",
            "score": 2.2100000000000004,
            "metadata": {
              "doc_id": "825",
              "name": "Expired Pointer Dereference",
              "type": "base",
              "original_content": "CWE-825: Expired Pointer Dereference",
              "relationships": [
                {
                  "source_id": "825",
                  "target_id": "562",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "825",
                  "target_id": "416",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "825",
                  "target_id": "415",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "825",
                  "target_id": "787",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "825",
                  "target_id": "125",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "825",
                  "target_id": "672",
                  "label": "CHILDOF",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "825",
                  "target_id": "119",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1340"
                  }
                },
                {
                  "source_id": "825",
                  "target_id": "119",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1305"
                  }
                },
                {
                  "source_id": "825",
                  "target_id": "119",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "787",
                  "target_id": "825",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "672",
                  "target_id": "825",
                  "label": "PARENTOF",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "562",
                  "target_id": "825",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "416",
                  "target_id": "825",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "415",
                  "target_id": "825",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "125",
                  "target_id": "825",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "119",
                  "target_id": "825",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                }
              ],
              "score_components": {
                "relationship_chain": 1.0,
                "sequence_path": 1.0
              },
              "abstraction_factor": 1.3,
              "graph_path_info": {
                "path_types": [
                  "relationship_chain",
                  "vulnerability_sequence_forward",
                  "vulnerability_sequence_backward"
                ],
                "best_paths": {
                  "relationship_chain": {
                    "path": [
                      [
                        "787",
                        "825",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 1.0,
                    "type": "relationship_chain",
                    "source": "787"
                  },
                  "vulnerability_sequence_forward": {
                    "path": [
                      [
                        "787",
                        "825",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.9,
                    "type": "vulnerability_sequence_forward",
                    "source": "787"
                  },
                  "vulnerability_sequence_backward": {
                    "path": [
                      [
                        "825",
                        "787",
                        "CANPRECEDE"
                      ]
                    ],
                    "score": 1.0,
                    "type": "vulnerability_sequence_backward",
                    "source": "787"
                  }
                }
              },
              "position": "before",
              "sources": [
                "graph"
              ],
              "source": "graph",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "graph"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "graph": 2.2100000000000004
                }
              }
            },
            "similarity": 2.2100000000000004
          },
          {
            "doc_id": "120",
            "text": "CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
            "score": 2.2100000000000004,
            "metadata": {
              "doc_id": "120",
              "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
              "type": "base",
              "original_content": "CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
              "relationships": [
                {
                  "source_id": "120",
                  "target_id": "785",
                  "label": "PARENTOF",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "120",
                  "target_id": "456",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "120",
                  "target_id": "416",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "120",
                  "target_id": "231",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "120",
                  "target_id": "170",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "120",
                  "target_id": "20",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "700"
                  }
                },
                {
                  "source_id": "120",
                  "target_id": "123",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "120",
                  "target_id": "119",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1340"
                  }
                },
                {
                  "source_id": "120",
                  "target_id": "119",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1305"
                  }
                },
                {
                  "source_id": "120",
                  "target_id": "119",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1003"
                  }
                },
                {
                  "source_id": "120",
                  "target_id": "119",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "785",
                  "target_id": "120",
                  "label": "CHILDOF",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "456",
                  "target_id": "120",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "416",
                  "target_id": "120",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "231",
                  "target_id": "120",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "20",
                  "target_id": "120",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "700"
                  }
                },
                {
                  "source_id": "196",
                  "target_id": "120",
                  "label": "CANALSOBE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "170",
                  "target_id": "120",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "123",
                  "target_id": "120",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "119",
                  "target_id": "120",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                }
              ],
              "score_components": {
                "relationship_chain": 1.0,
                "sequence_path": 1.0
              },
              "abstraction_factor": 1.3,
              "graph_path_info": {
                "path_types": [
                  "relationship_chain",
                  "vulnerability_sequence_forward"
                ],
                "best_paths": {
                  "relationship_chain": {
                    "path": [
                      [
                        "416",
                        "120",
                        "CANPRECEDE"
                      ]
                    ],
                    "score": 1.0,
                    "type": "relationship_chain",
                    "source": "416"
                  },
                  "vulnerability_sequence_forward": {
                    "path": [
                      [
                        "416",
                        "120",
                        "CANPRECEDE"
                      ]
                    ],
                    "score": 1.0,
                    "type": "vulnerability_sequence_forward",
                    "source": "416"
                  }
                }
              },
              "position": "after",
              "sources": [
                "graph"
              ],
              "source": "graph",
              "mapping_notes": {
                "usage": "Allowed-with-Review",
                "rationale": "There are some indications that this CWE ID might be misused and selected simply because it mentions \"buffer overflow\" - an increasingly vague term. This CWE entry is only appropriate for \"Buffer Copy\" operations (not buffer reads), in which where there is no \"Checking [the] Size of Input\", and (by implication of the copy) writing past the end of the buffer.",
                "comments": "If the vulnerability being analyzed involves out-of-bounds reads, then consider CWE-125 or descendants. For root cause analysis: if there is any input validation, consider children of CWE-20 such as CWE-1284. If there is a calculation error for buffer sizes, consider CWE-131 or similar.",
                "reasons": [
                  "Frequent Misuse"
                ]
              },
              "score_info": {
                "retrievers": [
                  "graph"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "graph": 2.2100000000000004
                }
              }
            },
            "similarity": 2.2100000000000004
          },
          {
            "doc_id": "1265",
            "text": "CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
            "score": 2.2100000000000004,
            "metadata": {
              "doc_id": "1265",
              "name": "Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
              "type": "base",
              "original_content": "CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
              "relationships": [
                {
                  "source_id": "1265",
                  "target_id": "416",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "1265",
                  "target_id": "663",
                  "label": "PEEROF",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "1265",
                  "target_id": "691",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "691",
                  "target_id": "1265",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "416",
                  "target_id": "1265",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                }
              ],
              "score_components": {
                "relationship_chain": 1.0,
                "sequence_path": 1.0
              },
              "abstraction_factor": 1.3,
              "graph_path_info": {
                "path_types": [
                  "relationship_chain",
                  "vulnerability_sequence_forward",
                  "vulnerability_sequence_backward"
                ],
                "best_paths": {
                  "relationship_chain": {
                    "path": [
                      [
                        "416",
                        "1265",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 1.0,
                    "type": "relationship_chain",
                    "source": "416"
                  },
                  "vulnerability_sequence_forward": {
                    "path": [
                      [
                        "416",
                        "1265",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.9,
                    "type": "vulnerability_sequence_forward",
                    "source": "416"
                  },
                  "vulnerability_sequence_backward": {
                    "path": [
                      [
                        "1265",
                        "416",
                        "CANPRECEDE"
                      ]
                    ],
                    "score": 1.0,
                    "type": "vulnerability_sequence_backward",
                    "source": "416"
                  }
                }
              },
              "position": "before",
              "sources": [
                "graph"
              ],
              "source": "graph",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "graph"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "graph": 2.2100000000000004
                }
              }
            },
            "similarity": 2.2100000000000004
          },
          {
            "doc_id": "122",
            "text": "CWE-122: Heap-based Buffer Overflow",
            "score": 2.1624,
            "metadata": {
              "doc_id": "122",
              "name": "Heap-based Buffer Overflow",
              "type": "variant",
              "original_content": "CWE-122: Heap-based Buffer Overflow",
              "relationships": [
                {
                  "source_id": "122",
                  "target_id": "787",
                  "label": "CHILDOF",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "122",
                  "target_id": "788",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "788",
                  "target_id": "122",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "787",
                  "target_id": "122",
                  "label": "PARENTOF",
                  "properties": {
                    "view_id": "1000"
                  }
                }
              ],
              "score_components": {
                "relationship_chain": 0.3,
                "explicit_mention": 1.0,
                "abstraction_path": 0.76
              },
              "abstraction_factor": 1.2,
              "graph_path_info": {
                "path_types": [
                  "relationship_chain",
                  "abstraction_path_down"
                ],
                "best_paths": {
                  "relationship_chain": {
                    "path": [
                      [
                        "787",
                        "122",
                        "PARENTOF"
                      ]
                    ],
                    "score": 0.3,
                    "type": "relationship_chain",
                    "source": "787"
                  },
                  "abstraction_path_down": {
                    "path": [
                      [
                        "787",
                        "122",
                        "PARENTOF"
                      ]
                    ],
                    "score": 0.76,
                    "type": "abstraction_path_down",
                    "source": "787"
                  }
                }
              },
              "is_explicit": true,
              "abstraction_level": "variant",
              "sources": [
                "graph"
              ],
              "source": "graph",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense",
                  "sparse",
                  "graph"
                ],
                "retriever_count": 3,
                "normalized_scores": {
                  "dense": 0.5070551867766302,
                  "sparse": 59.76424520678538,
                  "graph": 2.1624
                }
              }
            },
            "similarity": 2.1624
          },
          {
            "doc_id": "787",
            "text": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "score": 0.6420077580310037,
            "metadata": {
              "doc_id": "787",
              "name": "Out-of-bounds Write",
              "type": "Base",
              "extended_description": null,
              "alternate_terms": [
                "Memory Corruption"
              ],
              "original_content": "The product writes data past the end, or before the beginning, of the intended buffer.",
              "relationships": [
                {
                  "source_id": "787",
                  "target_id": "825",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "787",
                  "target_id": "824",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "787",
                  "target_id": "823",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "787",
                  "target_id": "822",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "787",
                  "target_id": "124",
                  "label": "PARENTOF",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "787",
                  "target_id": "123",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "787",
                  "target_id": "122",
                  "label": "PARENTOF",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "787",
                  "target_id": "121",
                  "label": "PARENTOF",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "787",
                  "target_id": "119",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1340"
                  }
                },
                {
                  "source_id": "787",
                  "target_id": "119",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1305"
                  }
                },
                {
                  "source_id": "787",
                  "target_id": "119",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1003"
                  }
                },
                {
                  "source_id": "787",
                  "target_id": "119",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "825",
                  "target_id": "787",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "824",
                  "target_id": "787",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "823",
                  "target_id": "787",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "822",
                  "target_id": "787",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "124",
                  "target_id": "787",
                  "label": "CHILDOF",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "123",
                  "target_id": "787",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "122",
                  "target_id": "787",
                  "label": "CHILDOF",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "121",
                  "target_id": "787",
                  "label": "CHILDOF",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "119",
                  "target_id": "787",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                }
              ],
              "source": "graph",
              "sources": [
                "vector",
                "graph"
              ],
              "vector_score": 0.6420077580310037,
              "graph_score": 2.821,
              "score_components": {
                "relationship_chain": 0.6,
                "explicit_mention": 1.0,
                "abstraction_path": 0.9
              },
              "abstraction_factor": 1.3,
              "graph_path_info": {
                "path_types": [
                  "relationship_chain",
                  "abstraction_path_up"
                ],
                "best_paths": {
                  "relationship_chain": {
                    "path": [
                      [
                        "1260",
                        "119",
                        "CANPRECEDE"
                      ],
                      [
                        "119",
                        "822",
                        "PARENTOF"
                      ],
                      [
                        "822",
                        "787",
                        "CANPRECEDE"
                      ]
                    ],
                    "score": 0.6,
                    "type": "relationship_chain",
                    "source": "1260"
                  },
                  "abstraction_path_up": {
                    "path": [
                      [
                        "122",
                        "787",
                        "CHILDOF"
                      ]
                    ],
                    "score": 0.5599999999999999,
                    "type": "abstraction_path_up",
                    "source": "122"
                  }
                }
              },
              "is_explicit": true,
              "abstraction_level": "base",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense",
                  "sparse",
                  "graph"
                ],
                "retriever_count": 3,
                "normalized_scores": {
                  "dense": 0.6044956188779271,
                  "sparse": 1000.0,
                  "graph": 1.9494031032124015
                }
              }
            },
            "similarity": 1.9494031032124015
          },
          {
            "doc_id": "562",
            "text": "CWE-562: Return of Stack Variable Address",
            "score": 1.7680000000000005,
            "metadata": {
              "doc_id": "562",
              "name": "Return of Stack Variable Address",
              "type": "base",
              "original_content": "CWE-562: Return of Stack Variable Address",
              "relationships": [
                {
                  "source_id": "562",
                  "target_id": "825",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "562",
                  "target_id": "672",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "562",
                  "target_id": "758",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "825",
                  "target_id": "562",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "758",
                  "target_id": "562",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "672",
                  "target_id": "562",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                }
              ],
              "score_components": {
                "relationship_chain": 0.8,
                "sequence_path": 0.8
              },
              "abstraction_factor": 1.3,
              "graph_path_info": {
                "path_types": [
                  "relationship_chain",
                  "vulnerability_sequence_forward",
                  "vulnerability_sequence_backward"
                ],
                "best_paths": {
                  "relationship_chain": {
                    "path": [
                      [
                        "415",
                        "672",
                        "CHILDOF"
                      ],
                      [
                        "672",
                        "562",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.8,
                    "type": "relationship_chain",
                    "source": "415"
                  },
                  "vulnerability_sequence_forward": {
                    "path": [
                      [
                        "787",
                        "825",
                        "CANFOLLOW"
                      ],
                      [
                        "825",
                        "562",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.7200000000000001,
                    "type": "vulnerability_sequence_forward",
                    "source": "787"
                  },
                  "vulnerability_sequence_backward": {
                    "path": [
                      [
                        "825",
                        "787",
                        "CANPRECEDE"
                      ],
                      [
                        "562",
                        "825",
                        "CANPRECEDE"
                      ]
                    ],
                    "score": 0.8,
                    "type": "vulnerability_sequence_backward",
                    "source": "787"
                  }
                }
              },
              "position": "before",
              "sources": [
                "graph"
              ],
              "source": "graph",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "graph"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "graph": 1.7680000000000005
                }
              }
            },
            "similarity": 1.7680000000000005
          },
          {
            "doc_id": "134",
            "text": "CWE-134: Use of Externally-Controlled Format String",
            "score": 1.6848000000000003,
            "metadata": {
              "doc_id": "134",
              "name": "Use of Externally-Controlled Format String",
              "type": "base",
              "original_content": "CWE-134: Use of Externally-Controlled Format String",
              "relationships": [
                {
                  "source_id": "134",
                  "target_id": "20",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "700"
                  }
                },
                {
                  "source_id": "134",
                  "target_id": "123",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "134",
                  "target_id": "668",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1003"
                  }
                },
                {
                  "source_id": "134",
                  "target_id": "668",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "668",
                  "target_id": "134",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "20",
                  "target_id": "134",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "700"
                  }
                },
                {
                  "source_id": "123",
                  "target_id": "134",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                }
              ],
              "score_components": {
                "relationship_chain": 0.8,
                "sequence_path": 0.7200000000000001
              },
              "abstraction_factor": 1.3,
              "graph_path_info": {
                "path_types": [
                  "relationship_chain",
                  "vulnerability_sequence_forward"
                ],
                "best_paths": {
                  "relationship_chain": {
                    "path": [
                      [
                        "415",
                        "123",
                        "PEEROF"
                      ],
                      [
                        "123",
                        "134",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.8,
                    "type": "relationship_chain",
                    "source": "415"
                  },
                  "vulnerability_sequence_forward": {
                    "path": [
                      [
                        "416",
                        "123",
                        "CANPRECEDE"
                      ],
                      [
                        "123",
                        "134",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.7200000000000001,
                    "type": "vulnerability_sequence_forward",
                    "source": "416"
                  }
                }
              },
              "position": "after",
              "sources": [
                "graph"
              ],
              "source": "graph",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "graph"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "graph": 1.6848000000000003
                }
              }
            },
            "similarity": 1.6848000000000003
          },
          {
            "doc_id": "170",
            "text": "CWE-170: Improper Null Termination",
            "score": 1.6848000000000003,
            "metadata": {
              "doc_id": "170",
              "name": "Improper Null Termination",
              "type": "base",
              "original_content": "CWE-170: Improper Null Termination",
              "relationships": [
                {
                  "source_id": "170",
                  "target_id": "682",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "170",
                  "target_id": "193",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "170",
                  "target_id": "20",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "700"
                  }
                },
                {
                  "source_id": "170",
                  "target_id": "463",
                  "label": "PEEROF",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "170",
                  "target_id": "464",
                  "label": "PEEROF",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "170",
                  "target_id": "147",
                  "label": "CANALSOBE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "170",
                  "target_id": "126",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "170",
                  "target_id": "120",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "170",
                  "target_id": "707",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "707",
                  "target_id": "170",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "682",
                  "target_id": "170",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "20",
                  "target_id": "170",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "700"
                  }
                },
                {
                  "source_id": "193",
                  "target_id": "170",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "126",
                  "target_id": "170",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "120",
                  "target_id": "170",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                }
              ],
              "score_components": {
                "relationship_chain": 0.8,
                "sequence_path": 0.7200000000000001
              },
              "abstraction_factor": 1.3,
              "graph_path_info": {
                "path_types": [
                  "relationship_chain",
                  "vulnerability_sequence_forward"
                ],
                "best_paths": {
                  "relationship_chain": {
                    "path": [
                      [
                        "416",
                        "120",
                        "CANPRECEDE"
                      ],
                      [
                        "120",
                        "170",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.8,
                    "type": "relationship_chain",
                    "source": "416"
                  },
                  "vulnerability_sequence_forward": {
                    "path": [
                      [
                        "416",
                        "120",
                        "CANPRECEDE"
                      ],
                      [
                        "120",
                        "170",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.7200000000000001,
                    "type": "vulnerability_sequence_forward",
                    "source": "416"
                  }
                }
              },
              "position": "after",
              "sources": [
                "graph"
              ],
              "source": "graph",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "graph"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "graph": 1.6848000000000003
                }
              }
            },
            "similarity": 1.6848000000000003
          },
          {
            "doc_id": "1257",
            "text": "CWE-1257: Improper Access Control Applied to Mirrored or Aliased Memory Regions",
            "score": 1.6848000000000003,
            "metadata": {
              "doc_id": "1257",
              "name": "Improper Access Control Applied to Mirrored or Aliased Memory Regions",
              "type": "base",
              "original_content": "CWE-1257: Improper Access Control Applied to Mirrored or Aliased Memory Regions",
              "relationships": [
                {
                  "source_id": "1257",
                  "target_id": "119",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "1257",
                  "target_id": "284",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "284",
                  "target_id": "1257",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "119",
                  "target_id": "1257",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                }
              ],
              "score_components": {
                "relationship_chain": 0.8,
                "sequence_path": 0.7200000000000001
              },
              "abstraction_factor": 1.3,
              "graph_path_info": {
                "path_types": [
                  "relationship_chain",
                  "vulnerability_sequence_forward"
                ],
                "best_paths": {
                  "relationship_chain": {
                    "path": [
                      [
                        "1260",
                        "119",
                        "CANPRECEDE"
                      ],
                      [
                        "119",
                        "1257",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.8,
                    "type": "relationship_chain",
                    "source": "1260"
                  },
                  "vulnerability_sequence_forward": {
                    "path": [
                      [
                        "1260",
                        "119",
                        "CANPRECEDE"
                      ],
                      [
                        "119",
                        "1257",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.7200000000000001,
                    "type": "vulnerability_sequence_forward",
                    "source": "1260"
                  }
                }
              },
              "position": "after",
              "sources": [
                "graph"
              ],
              "source": "graph",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "graph"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "graph": 1.6848000000000003
                }
              }
            },
            "similarity": 1.6848000000000003
          },
          {
            "doc_id": "128",
            "text": "CWE-128: Wrap-around Error",
            "score": 1.6848000000000003,
            "metadata": {
              "doc_id": "128",
              "name": "Wrap-around Error",
              "type": "base",
              "original_content": "CWE-128: Wrap-around Error",
              "relationships": [
                {
                  "source_id": "128",
                  "target_id": "190",
                  "label": "PEEROF",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "128",
                  "target_id": "119",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "128",
                  "target_id": "682",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "682",
                  "target_id": "128",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "119",
                  "target_id": "128",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                }
              ],
              "score_components": {
                "relationship_chain": 0.8,
                "sequence_path": 0.7200000000000001
              },
              "abstraction_factor": 1.3,
              "graph_path_info": {
                "path_types": [
                  "relationship_chain",
                  "vulnerability_sequence_forward"
                ],
                "best_paths": {
                  "relationship_chain": {
                    "path": [
                      [
                        "1260",
                        "119",
                        "CANPRECEDE"
                      ],
                      [
                        "119",
                        "128",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.8,
                    "type": "relationship_chain",
                    "source": "1260"
                  },
                  "vulnerability_sequence_forward": {
                    "path": [
                      [
                        "1260",
                        "119",
                        "CANPRECEDE"
                      ],
                      [
                        "119",
                        "128",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.7200000000000001,
                    "type": "vulnerability_sequence_forward",
                    "source": "1260"
                  }
                }
              },
              "position": "after",
              "sources": [
                "graph"
              ],
              "source": "graph",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "graph"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "graph": 1.6848000000000003
                }
              }
            },
            "similarity": 1.6848000000000003
          },
          {
            "doc_id": "131",
            "text": "CWE-131: Incorrect Calculation of Buffer Size",
            "score": 1.6848000000000003,
            "metadata": {
              "doc_id": "131",
              "name": "Incorrect Calculation of Buffer Size",
              "type": "base",
              "original_content": "CWE-131: Incorrect Calculation of Buffer Size",
              "relationships": [
                {
                  "source_id": "131",
                  "target_id": "467",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "131",
                  "target_id": "119",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "131",
                  "target_id": "682",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1340"
                  }
                },
                {
                  "source_id": "131",
                  "target_id": "682",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1305"
                  }
                },
                {
                  "source_id": "131",
                  "target_id": "682",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1003"
                  }
                },
                {
                  "source_id": "131",
                  "target_id": "682",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "682",
                  "target_id": "131",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "467",
                  "target_id": "131",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "119",
                  "target_id": "131",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                }
              ],
              "score_components": {
                "relationship_chain": 0.8,
                "sequence_path": 0.7200000000000001
              },
              "abstraction_factor": 1.3,
              "graph_path_info": {
                "path_types": [
                  "relationship_chain",
                  "vulnerability_sequence_forward"
                ],
                "best_paths": {
                  "relationship_chain": {
                    "path": [
                      [
                        "1260",
                        "119",
                        "CANPRECEDE"
                      ],
                      [
                        "119",
                        "131",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.8,
                    "type": "relationship_chain",
                    "source": "1260"
                  },
                  "vulnerability_sequence_forward": {
                    "path": [
                      [
                        "1260",
                        "119",
                        "CANPRECEDE"
                      ],
                      [
                        "119",
                        "131",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.7200000000000001,
                    "type": "vulnerability_sequence_forward",
                    "source": "1260"
                  }
                }
              },
              "position": "after",
              "sources": [
                "graph"
              ],
              "source": "graph",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "graph"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "graph": 1.6848000000000003
                }
              }
            },
            "similarity": 1.6848000000000003
          },
          {
            "doc_id": "1339",
            "text": "CWE-1339: Insufficient Precision or Accuracy of a Real Number",
            "score": 1.6848000000000003,
            "metadata": {
              "doc_id": "1339",
              "name": "Insufficient Precision or Accuracy of a Real Number",
              "type": "base",
              "original_content": "CWE-1339: Insufficient Precision or Accuracy of a Real Number",
              "relationships": [
                {
                  "source_id": "1339",
                  "target_id": "119",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "1339",
                  "target_id": "834",
                  "label": "CANPRECEDE",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "1339",
                  "target_id": "190",
                  "label": "PEEROF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "1339",
                  "target_id": "682",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "834",
                  "target_id": "1339",
                  "label": "CANFOLLOW",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "682",
                  "target_id": "1339",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "119",
                  "target_id": "1339",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                }
              ],
              "score_components": {
                "relationship_chain": 0.8,
                "sequence_path": 0.7200000000000001
              },
              "abstraction_factor": 1.3,
              "graph_path_info": {
                "path_types": [
                  "relationship_chain",
                  "vulnerability_sequence_forward"
                ],
                "best_paths": {
                  "relationship_chain": {
                    "path": [
                      [
                        "1260",
                        "119",
                        "CANPRECEDE"
                      ],
                      [
                        "119",
                        "1339",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.8,
                    "type": "relationship_chain",
                    "source": "1260"
                  },
                  "vulnerability_sequence_forward": {
                    "path": [
                      [
                        "1260",
                        "119",
                        "CANPRECEDE"
                      ],
                      [
                        "119",
                        "1339",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.7200000000000001,
                    "type": "vulnerability_sequence_forward",
                    "source": "1260"
                  }
                }
              },
              "position": "after",
              "sources": [
                "graph"
              ],
              "source": "graph",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "graph"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "graph": 1.6848000000000003
                }
              }
            },
            "similarity": 1.6848000000000003
          },
          {
            "doc_id": "190",
            "text": "CWE-190: Integer Overflow or Wraparound",
            "score": 1.6848000000000003,
            "metadata": {
              "doc_id": "190",
              "name": "Integer Overflow or Wraparound",
              "type": "base",
              "original_content": "CWE-190: Integer Overflow or Wraparound",
              "relationships": [
                {
                  "source_id": "190",
                  "target_id": "680",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "190",
                  "target_id": "119",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "190",
                  "target_id": "20",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "700"
                  }
                },
                {
                  "source_id": "190",
                  "target_id": "682",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1003"
                  }
                },
                {
                  "source_id": "190",
                  "target_id": "682",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "682",
                  "target_id": "190",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "680",
                  "target_id": "190",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "680",
                  "target_id": "190",
                  "label": "STARTSWITH",
                  "properties": {
                    "view_id": "709"
                  }
                },
                {
                  "source_id": "20",
                  "target_id": "190",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "700"
                  }
                },
                {
                  "source_id": "1339",
                  "target_id": "190",
                  "label": "PEEROF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "128",
                  "target_id": "190",
                  "label": "PEEROF",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "119",
                  "target_id": "190",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                }
              ],
              "score_components": {
                "relationship_chain": 0.8,
                "sequence_path": 0.7200000000000001
              },
              "abstraction_factor": 1.3,
              "graph_path_info": {
                "path_types": [
                  "relationship_chain",
                  "vulnerability_sequence_forward"
                ],
                "best_paths": {
                  "relationship_chain": {
                    "path": [
                      [
                        "1260",
                        "119",
                        "CANPRECEDE"
                      ],
                      [
                        "119",
                        "190",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.8,
                    "type": "relationship_chain",
                    "source": "1260"
                  },
                  "vulnerability_sequence_forward": {
                    "path": [
                      [
                        "1260",
                        "119",
                        "CANPRECEDE"
                      ],
                      [
                        "119",
                        "190",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.7200000000000001,
                    "type": "vulnerability_sequence_forward",
                    "source": "1260"
                  }
                }
              },
              "position": "after",
              "sources": [
                "graph"
              ],
              "source": "graph",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Be careful of terminology problems with \"overflow,\" \"underflow,\" and \"wraparound\" - see Terminology Notes. Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ],
                "suggestions": [
                  {
                    "CweID": "191",
                    "Comment": "Integer Underflow (Wrap or Wraparound). Consider CWE-191 when the result is less than the minimum value that can be represented (sometimes called \"underflows\")."
                  }
                ]
              },
              "score_info": {
                "retrievers": [
                  "sparse",
                  "graph"
                ],
                "retriever_count": 2,
                "normalized_scores": {
                  "sparse": 51.530627528621274,
                  "graph": 1.6848000000000003
                }
              }
            },
            "similarity": 1.6848000000000003
          },
          {
            "doc_id": "193",
            "text": "CWE-193: Off-by-one Error",
            "score": 1.6848000000000003,
            "metadata": {
              "doc_id": "193",
              "name": "Off-by-one Error",
              "type": "base",
              "original_content": "CWE-193: Off-by-one Error",
              "relationships": [
                {
                  "source_id": "193",
                  "target_id": "119",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "193",
                  "target_id": "170",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "193",
                  "target_id": "617",
                  "label": "CANPRECEDE",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "193",
                  "target_id": "682",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1003"
                  }
                },
                {
                  "source_id": "193",
                  "target_id": "682",
                  "label": "CHILDOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "682",
                  "target_id": "193",
                  "label": "PARENTOF",
                  "properties": {
                    "ordinal": "Primary",
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "617",
                  "target_id": "193",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "170",
                  "target_id": "193",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                },
                {
                  "source_id": "119",
                  "target_id": "193",
                  "label": "CANFOLLOW",
                  "properties": {
                    "view_id": "1000"
                  }
                }
              ],
              "score_components": {
                "relationship_chain": 0.8,
                "sequence_path": 0.7200000000000001
              },
              "abstraction_factor": 1.3,
              "graph_path_info": {
                "path_types": [
                  "relationship_chain",
                  "vulnerability_sequence_forward"
                ],
                "best_paths": {
                  "relationship_chain": {
                    "path": [
                      [
                        "1260",
                        "119",
                        "CANPRECEDE"
                      ],
                      [
                        "119",
                        "193",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.8,
                    "type": "relationship_chain",
                    "source": "1260"
                  },
                  "vulnerability_sequence_forward": {
                    "path": [
                      [
                        "1260",
                        "119",
                        "CANPRECEDE"
                      ],
                      [
                        "119",
                        "193",
                        "CANFOLLOW"
                      ]
                    ],
                    "score": 0.7200000000000001,
                    "type": "vulnerability_sequence_forward",
                    "source": "1260"
                  }
                }
              },
              "position": "after",
              "sources": [
                "graph"
              ],
              "source": "graph",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "graph"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "graph": 1.6848000000000003
                }
              }
            },
            "similarity": 1.6848000000000003
          }
        ],
        "dense": [
          {
            "metadata": {
              "doc_id": "787",
              "name": "Out-of-bounds Write",
              "type": "Base",
              "original_content": "The product writes data past the end, or before the beginning, of the intended buffer.",
              "keyphrase_source": "weakness:memory corruption",
              "source": "dense",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense",
                  "sparse",
                  "graph"
                ],
                "retriever_count": 3,
                "normalized_scores": {
                  "dense": 0.6044956188779271,
                  "sparse": 1000.0,
                  "graph": 1.9494031032124015
                }
              }
            },
            "similarity": 0.6044956188779271
          },
          {
            "metadata": {
              "doc_id": "416",
              "name": "Use After Free",
              "type": "Variant",
              "original_content": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
              "source": "dense",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense",
                  "sparse",
                  "graph"
                ],
                "retriever_count": 3,
                "normalized_scores": {
                  "dense": 0.5564290782764135,
                  "sparse": 60.782740992322296,
                  "graph": 2.262891626614683
                }
              }
            },
            "similarity": 0.5564290782764135
          },
          {
            "metadata": {
              "doc_id": "843",
              "name": "Access of Resource Using Incompatible Type ('Type Confusion')",
              "type": "Base",
              "original_content": "The product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.",
              "keyphrase_source": "weakness:memory corruption",
              "source": "dense",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense",
                  "sparse",
                  "graph"
                ],
                "retriever_count": 3,
                "normalized_scores": {
                  "dense": 0.5532373381039504,
                  "sparse": 67.60603023958426,
                  "graph": 2.5257713361350778
                }
              }
            },
            "similarity": 0.5532373381039504
          },
          {
            "metadata": {
              "doc_id": "316",
              "name": "Cleartext Storage of Sensitive Information in Memory",
              "type": "Variant",
              "original_content": "The product stores sensitive information in cleartext in memory.",
              "keyphrase_source": "weakness:memory corruption",
              "source": "dense",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "dense": 0.5530907529031421
                }
              }
            },
            "similarity": 0.5530907529031421
          },
          {
            "metadata": {
              "doc_id": "1260",
              "name": "Improper Handling of Overlap Between Protected Memory Ranges",
              "type": "Base",
              "original_content": "The product allows address regions to overlap, which can result in the bypassing of intended memory protection.",
              "keyphrase_source": "weakness:memory corruption",
              "source": "dense",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense",
                  "graph"
                ],
                "retriever_count": 2,
                "normalized_scores": {
                  "dense": 0.5423218496153519,
                  "graph": 2.372747119777513
                }
              }
            },
            "similarity": 0.5423218496153519
          },
          {
            "metadata": {
              "doc_id": "788",
              "name": "Access of Memory Location After End of Buffer",
              "type": "Base",
              "original_content": "The product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.",
              "keyphrase_source": "weakness:memory corruption",
              "source": "dense",
              "mapping_notes": {
                "usage": "Discouraged",
                "rationale": "The CWE entry might be misused when lower-level CWE entries might be available. It also overlaps existing CWE entries and might be deprecated in the future.",
                "comments": "If the \"Access\" operation is known to be a read or a write, then investigate children of entries such as CWE-787: Out-of-bounds Write and CWE-125: Out-of-bounds Read.",
                "reasons": [
                  "Potential Deprecation",
                  "Frequent Misuse"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense",
                  "sparse"
                ],
                "retriever_count": 2,
                "normalized_scores": {
                  "dense": 0.5413483969451229,
                  "sparse": 51.05905723022035
                }
              }
            },
            "similarity": 0.5413483969451229
          },
          {
            "metadata": {
              "doc_id": "127",
              "name": "Buffer Under-read",
              "type": "Variant",
              "original_content": "The product reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations prior to the targeted buffer.",
              "keyphrase_source": "weakness:memory corruption",
              "source": "dense",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "dense": 0.5349246760880122
                }
              }
            },
            "similarity": 0.5349246760880122
          },
          {
            "metadata": {
              "doc_id": "822",
              "name": "Untrusted Pointer Dereference",
              "type": "Base",
              "original_content": "The product obtains a value from an untrusted source, converts this value to a pointer, and dereferences the resulting pointer.",
              "keyphrase_source": "weakness:memory corruption",
              "source": "dense",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense",
                  "sparse"
                ],
                "retriever_count": 2,
                "normalized_scores": {
                  "dense": 0.5331898988837035,
                  "sparse": 48.46614763081808
                }
              }
            },
            "similarity": 0.5331898988837035
          },
          {
            "metadata": {
              "doc_id": "124",
              "name": "Buffer Underwrite ('Buffer Underflow')",
              "type": "Base",
              "original_content": "The product writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.",
              "keyphrase_source": "weakness:memory corruption",
              "source": "dense",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "dense": 0.5304708044548463
                }
              }
            },
            "similarity": 0.5304708044548463
          },
          {
            "metadata": {
              "doc_id": "704",
              "name": "Incorrect Type Conversion or Cast",
              "type": "Class",
              "original_content": "The product does not correctly convert an object, resource, or structure from one type to a different type.",
              "keyphrase_source": "weakness:memory corruption",
              "source": "dense",
              "mapping_notes": {
                "usage": "Allowed-with-Review",
                "rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
                "comments": "Examine children of this entry to see if there is a better fit",
                "reasons": [
                  "Abstraction"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "dense": 0.5272079352444721
                }
              }
            },
            "similarity": 0.5272079352444721
          },
          {
            "metadata": {
              "doc_id": "789",
              "name": "Memory Allocation with Excessive Size Value",
              "type": "Variant",
              "original_content": "The product allocates memory based on an untrusted, large size value, but it does not ensure that the size is within expected limits, allowing arbitrary amounts of memory to be allocated.",
              "source": "dense",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "dense": 0.509625927918915
                }
              }
            },
            "similarity": 0.509625927918915
          },
          {
            "metadata": {
              "doc_id": "366",
              "name": "Race Condition within a Thread",
              "type": "Base",
              "original_content": "If two threads of execution use a resource simultaneously, there exists the possibility that resources may be used while invalid, in turn making the state of execution undefined.",
              "source": "dense",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense",
                  "sparse"
                ],
                "retriever_count": 2,
                "normalized_scores": {
                  "dense": 0.5095764723959488,
                  "sparse": 50.5279456484442
                }
              }
            },
            "similarity": 0.5095764723959488
          },
          {
            "metadata": {
              "doc_id": "401",
              "name": "Missing Release of Memory after Effective Lifetime",
              "type": "Variant",
              "original_content": "The product does not sufficiently track and release allocated memory after it has been used, which slowly consumes remaining memory.",
              "source": "dense",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "dense": 0.5090974239680022
                }
              }
            },
            "similarity": 0.5090974239680022
          },
          {
            "metadata": {
              "doc_id": "80",
              "name": "Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS)",
              "type": "Variant",
              "original_content": "The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special characters such as \"<\", \">\", and \"&\" that could be interpreted as web-scripting elements when they are sent to a downstream component that processes web pages.",
              "source": "dense",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "dense": 0.5070815204945177
                }
              }
            },
            "similarity": 0.5070815204945177
          },
          {
            "metadata": {
              "doc_id": "122",
              "name": "Heap-based Buffer Overflow",
              "type": "Variant",
              "original_content": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
              "source": "dense",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense",
                  "sparse",
                  "graph"
                ],
                "retriever_count": 3,
                "normalized_scores": {
                  "dense": 0.5070551867766302,
                  "sparse": 59.76424520678538,
                  "graph": 2.1624
                }
              }
            },
            "similarity": 0.5070551867766302
          },
          {
            "metadata": {
              "doc_id": "823",
              "name": "Use of Out-of-range Pointer Offset",
              "type": "Base",
              "original_content": "The product performs pointer arithmetic on a valid pointer, but it uses an offset that can point outside of the intended range of valid memory locations for the resulting pointer.",
              "source": "dense",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "dense": 0.5056866376391194
                }
              }
            },
            "similarity": 0.5056866376391194
          },
          {
            "metadata": {
              "doc_id": "119",
              "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
              "type": "Class",
              "original_content": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
              "source": "dense",
              "mapping_notes": {
                "usage": "Discouraged",
                "rationale": "CWE-119 is commonly misused in low-information vulnerability reports when lower-level CWEs could be used instead, or when more details about the vulnerability are available.",
                "comments": "Look at CWE-119's children and consider mapping to CWEs such as CWE-787: Out-of-bounds Write, CWE-125: Out-of-bounds Read, or others.",
                "reasons": [
                  "Frequent Misuse"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "dense": 0.504740424629194
                }
              }
            },
            "similarity": 0.504740424629194
          },
          {
            "metadata": {
              "doc_id": "125",
              "name": "Out-of-bounds Read",
              "type": "Base",
              "original_content": "The product reads data past the end, or before the beginning, of the intended buffer.",
              "source": "dense",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "dense": 0.5042019323869635
                }
              }
            },
            "similarity": 0.5042019323869635
          },
          {
            "metadata": {
              "doc_id": "126",
              "name": "Buffer Over-read",
              "type": "Variant",
              "original_content": "The product reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations after the targeted buffer.",
              "source": "dense",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "dense": 0.502493536294006
                }
              }
            },
            "similarity": 0.502493536294006
          },
          {
            "metadata": {
              "doc_id": "1342",
              "name": "Information Exposure through Microarchitectural State after Transient Execution",
              "type": "Base",
              "original_content": "The processor does not properly clear microarchitectural state after incorrect microcode assists or speculative execution, resulting in transient execution.",
              "source": "dense",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              },
              "score_info": {
                "retrievers": [
                  "dense"
                ],
                "retriever_count": 1,
                "normalized_scores": {
                  "dense": 0.5024177349997196
                }
              }
            },
            "similarity": 0.5024177349997196
          }
        ],
        "sparse": [
          {
            "cwe_id": "787",
            "name": "Out-of-bounds Write",
            "description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "score": 1000.0,
            "matched_text": "AlternateTerms: Memory Corruption",
            "matched_phrase": "memory corruption",
            "matched_term": "memory corruption",
            "type": "Base",
            "source": "sparse",
            "search_source": "alternate_term_match",
            "match_reason": "exact_match_whole_phrase",
            "metadata": {
              "source": "sparse",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              }
            }
          },
          {
            "cwe_id": "843",
            "name": "Access of Resource Using Incompatible Type ('Type Confusion')",
            "description": "The product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.",
            "score": 67.60603023958426,
            "matched_text": "CWE-843: Access of Resource Using Incompatible Type ('Type Confusion')\n\nType: Base\n\nStatus: Incomplete\n\nAlternative Terms:\n\nObject Type Confusion\n\nObject Type Confusion\n\nObject Type Confusion\n\nDescription:\n\nThe product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.\n\nExtended Details:\n\n\n\nWhen the product accesses the resource using an incompatible type, this could trigger logical errors because the resource does not have expected properties. In languages without memory safety, such as C and C++, type confusion can lead to out-of-bounds memory access.\n\n\nWhile this weakness is frequently associated with unions when parsing data with many different embedded object types in C, it can be present in any application that can interpret the same variable or memory location in multiple ways.\n\n\nThis weakness is not unique to C and C++. For example, errors in PHP applications can be triggered by providing array parameters when scalars are expected, or vice versa. Languages such as Perl, which perform automatic conversion of a variable of one type when it is accessed as if it were another type, can also contain these issues.\n\n\nReal-World Examples:\n\n- CVE-2010-4577: Type confusion in CSS sequence leads to out-of-bounds read.\n\n- CVE-2011-0611: Size inconsistency allows code execution, first discovered when it was actively exploited in-the-wild.\n\n- CVE-2010-0258: Improperly-parsed file containing records of different types leads to code execution when a memory location is interpreted as a different object than intended.\n\nTop 25 CWE Examples:\n\n- CVE-2021-0352: In RT regmap driver, there is a possible memory corruption due to type confusion. This could lead to local denial of service with System execution privileges needed. User interaction is not needed for exploitation. Product: Android; Versions: Android-10, Android-11; Patch ID: ALPS05453809.\n\n- CVE-2021-21230: Type confusion in V8 in Google Chrome prior to 90.0.4430.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-23954: Using the new logical assignment operators in a JavaScript switch statement could have caused a type confusion, leading to a memory corruption and a potentially exploitable crash. This vulnerability affects Firefox < 85, Thunderbird < 78.7, and Firefox ESR < 78.7.\n\n- CVE-2021-30513: Type confusion in V8 in Google Chrome prior to 90.0.4430.212 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30517: Type confusion in V8 in Google Chrome prior to 90.0.4430.212 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30551: Type confusion in V8 in Google Chrome prior to 91.0.4472.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30561: Type Confusion in V8 in Google Chrome prior to 91.0.4472.164 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30563: Type Confusion in V8 in Google Chrome prior to 91.0.4472.164 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30588: Type confusion in V8 in Google Chrome prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30627: Type confusion in Blink layout in Google Chrome prior to 93.0.4577.82 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-38001: Type confusion in V8 in Google Chrome prior to 95.0.4638.69 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-23443: This affects the package edge.js before 5.3.2. A type confusion vulnerability can be used to bypass input sanitization when the input to be rendered is an array (instead of a string or a SafeValue), even if {{ }} are used.\n\n- CVE-2021-23447: This affects the package teddy before 0.5.9. A type confusion vulnerability can be used to bypass input sanitization when the model content is an array (instead of a string).\n\n- CVE-2021-32696: The npm package \"striptags\" is an implementation of PHP's strip_tags in Typescript. In striptags before version 3.2.0, a type-confusion vulnerability can cause `striptags` to concatenate unsanitized strings when an array-like object is passed in as the `html` parameter. This can be abused by an attacker who can control the shape of their input, e.g. if query parameters are passed directly into the function. This can lead to a XSS.\n\n- CVE-2021-23807: This affects the package jsonpointer before 5.0.0. A type confusion vulnerability can lead to a bypass of a previous Prototype Pollution fix when the pointer components are arrays.\n\n- CVE-2020-16103: Type confusion in Gallagher Command Centre Server allows a remote attacker to crash the server or possibly cause remote code execution. This issue affects: Gallagher Command Centre 8.30 versions prior to 8.30.1236(MR1); 8.20 versions prior to 8.20.1166(MR3); 8.10 versions prior to 8.10.1211(MR5); version 8.00 and prior versions.\n\n- CVE-2020-7081: A type confusion vulnerability in the Autodesk FBX-SDK versions 2019.0 and earlier may lead to arbitary code read/write on the system running it.\n\n- CVE-2021-26600: ImpressCMS before 1.4.3 has plugins/preloads/autologin.php type confusion with resultant Authentication Bypass (!= instead of !==).\n\n- CVE-2020-16009: Inappropriate implementation in V8 in Google Chrome prior to 86.0.4240.183 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2020-27932: A type confusion issue was addressed with improved state handling. This issue is fixed in macOS Big Sur 11.0.1, watchOS 7.1, iOS 12.4.9, watchOS 6.2.9, Security Update 2020-006 High Sierra, Security Update 2020-006 Mojave, iOS 14.2 and iPadOS 14.2, watchOS 5.3.9, macOS Catalina 10.15.7 Supplemental Update, macOS Catalina 10.15.7 Update. A malicious application may be able to execute arbitrary code with kernel privileges.\n\n- CVE-2020-6418: Type confusion in V8 in Google Chrome prior to 80.0.3987.122 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-1789: A type confusion issue was addressed with improved state handling. This issue is fixed in macOS Big Sur 11.2, Security Update 2021-001 Catalina, Security Update 2021-001 Mojave, tvOS 14.4, watchOS 7.3, iOS 14.4 and iPadOS 14.4, Safari 14.0.3. Processing maliciously crafted web content may lead to arbitrary code execution.\n\n- CVE-2021-21224: Type confusion in V8 in Google Chrome prior to 90.0.4430.85 allowed a remote attacker to execute arbitrary code inside a sandbox via a crafted HTML page.\n\n- CVE-2021-30869: A type confusion issue was addressed with improved state handling. This issue is fixed in iOS 12.5.5, iOS 14.4 and iPadOS 14.4, macOS Big Sur 11.2, Security Update 2021-001 Catalina, Security Update 2021-001 Mojave, Security Update 2021-006 Catalina. A malicious application may be able to execute arbitrary code with kernel privileges. Apple is aware of reports that an exploit for this issue exists in the wild.\n\n- CVE-2021-26635: In the code that verifies the file size in the ark library, it is possible to manipulate the offset read from the target file due to the wrong use of the data type. An attacker could use this vulnerability to cause a stack buffer overflow and as a result, perform an attack such as remote code execution.\n\n- CVE-2021-38007: Type confusion in V8 in Google Chrome prior to 96.0.4664.45 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-38012: Type confusion in V8 in Google Chrome prior to 96.0.4664.45 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4056: Type confusion in loader in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4061: Type confusion in V8 in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4078: Type confusion in V8 in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0102: Type confusion in V8 in Google Chrome prior to 97.0.4692.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0457: Type confusion in V8 in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0795: Type confusion in Blink Layout in Google Chrome prior to 99.0.4844.51 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1096: Type confusion in V8 in Google Chrome prior to 99.0.4844.84 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1134: Type confusion in V8 in Google Chrome prior to 100.0.4896.60 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1232: Type confusion in V8 in Google Chrome prior to 100.0.4896.75 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1314: Type confusion in V8 in Google Chrome prior to 100.0.4896.88 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1364: Type confusion in V8 Turbofan in Google Chrome prior to 100.0.4896.127 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1869: Type Confusion in V8 in Google Chrome prior to 102.0.5005.61 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-20461: In pinReplyNative of com_android_bluetooth_btservice_AdapterService.cpp, there is a possible out of bounds read due to type confusion. This could lead to local escalation of privilege of BLE with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-228602963\n\n- CVE-2022-26433: In mailbox, there is a possible out of bounds write due to type confusion. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07138400; Issue ID: ALPS07138400.\n\n- CVE-2022-3315: Type confusion in Blink in Google Chrome prior to 106.0.5249.62 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: Low)\n\n- CVE-2022-3889: Type confusion in V8 in Google Chrome prior to 107.0.5304.106 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4174: Type confusion in V8 in Google Chrome prior to 108.0.5359.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-25721: Memory corruption in video driver due to type confusion error during video playback\n\n- CVE-2022-2295: Type confusion in V8 in Google Chrome prior to 103.0.5060.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-34918: An issue was discovered in the Linux kernel through 5.18.9. A type confusion bug in nft_set_elem_init (leading to a buffer overflow) could be used by a local attacker to escalate privileges, a different vulnerability than CVE-2022-32250. (The attacker can obtain root access, but must start with an unprivileged user namespace to obtain CAP_NET_ADMIN access.) This can be fixed in nft_setelem_parse_data in net/netfilter/nf_tables_api.c.\n\n- CVE-2022-3652: Type confusion in V8 in Google Chrome prior to 107.0.5304.62 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-23583: Tensorflow is an Open Source Machine Learning Framework. A malicious user can cause a denial of service by altering a `SavedModel` such that any binary op would trigger `CHECK` failures. This occurs when the protobuf part corresponding to the tensor arguments is modified such that the `dtype` no longer matches the `dtype` expected by the op. In that case, calling the templated binary operator for the binary op would receive corrupted data, due to the type confusion involved. If `Tin` and `Tout` don't match the type of data in `out` and `input_*` tensors then `flat<*>` would interpret it wrongly. In most cases, this would be a silent failure, but we have noticed scenarios where this results in a `CHECK` crash, hence a denial of service. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.\n\n- CVE-2022-3723: Type confusion in V8 in Google Chrome prior to 107.0.5304.87 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4262: Type confusion in V8 in Google Chrome prior to 108.0.5359.94 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-41033: Windows COM+ Event System Service Elevation of Privilege Vulnerability\n\n- CVE-2022-42856: A type confusion issue was addressed with improved state handling. This issue is fixed in Safari 16.2, tvOS 16.2, macOS Ventura 13.1, iOS 15.7.2 and iPadOS 15.7.2, iOS 16.1.2. Processing maliciously crafted web content may lead to arbitrary code execution. Apple is aware of a report that this issue may have been actively exploited against versions of iOS released before iOS 15.1..\n\n- CVE-2022-21656: Envoy is an open source edge and service proxy, designed for cloud-native applications. The default_validator.cc implementation used to implement the default certificate validation routines has a \"type confusion\" bug when processing subjectAltNames. This processing allows, for example, an rfc822Name or uniformResourceIndicator to be authenticated as a domain name. This confusion allows for the bypassing of nameConstraints, as processed by the underlying OpenSSL/BoringSSL implementation, exposing the possibility of impersonation of arbitrary servers. As a result Envoy will trust upstream certificates that should not be trusted.\n\n- CVE-2021-33624: In kernel/bpf/verifier.c in the Linux kernel before 5.12.13, a branch can be mispredicted (e.g., because of type confusion) and consequently an unprivileged BPF program can read arbitrary memory locations via a side-channel attack, aka CID-9183671af6db.\n\nRelated Weaknesses:\n\n- CWE-704 (ChildOf)\n\n- CWE-704 (ChildOf)\n\n- CWE-119 (CanPrecede)",
            "type": "Base",
            "source": "sparse",
            "search_source": "weakness:memory corruption",
            "sources": [
              "base",
              "weakness"
            ],
            "boost_factor": 2.8,
            "boosted": true,
            "metadata": {
              "source": "sparse",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              }
            }
          },
          {
            "cwe_id": "416",
            "name": "Use After Free",
            "description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
            "score": 60.782740992322296,
            "matched_text": "CWE-416: Use After Free\n\nType: Variant\n\nStatus: Stable\n\nAlternative Terms:\n\nDangling pointer - a pointer that no longer points to valid memory, often after it has been freed\nUAF - commonly used acronym for Use After Free\nUse-After-Free\n\nDangling pointer - a pointer that no longer points to valid memory, often after it has been freed\nUAF - commonly used acronym for Use After Free\nUse-After-Free\n\nDangling pointer - a pointer that no longer points to valid memory, often after it has been freed\nUAF - commonly used acronym for Use After Free\nUse-After-Free\n\nDescription:\n\nThe product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.\n\nReal-World Examples:\n\n- CVE-2022-20141: Chain: an operating system kernel has insufficent resource locking (CWE-413) leading to a use after free (CWE-416).\n\n- CVE-2022-2621: Chain: two threads in a web browser use the same resource (CWE-366), but one of those threads can destroy the resource before the other has completed (CWE-416).\n\n- CVE-2021-0920: Chain: mobile platform race condition (CWE-362) leading to use-after-free (CWE-416), as exploited in the wild per CISA KEV.\n\n- CVE-2020-6819: Chain: race condition (CWE-362) leads to use-after-free (CWE-416), as exploited in the wild per CISA KEV.\n\n- CVE-2010-4168: Use-after-free triggered by closing a connection while data is still being transmitted.\n\n- CVE-2010-2941: Improper allocation for invalid data leads to use-after-free.\n\n- CVE-2010-2547: certificate with a large number of Subject Alternate Names not properly handled in realloc, leading to use-after-free\n\n- CVE-2010-1772: Timers are not disabled when a related object is deleted\n\n- CVE-2010-1437: Access to a \"dead\" object that is being cleaned up\n\n- CVE-2010-1208: object is deleted even with a non-zero reference count, and later accessed\n\n- CVE-2010-0629: use-after-free involving request containing an invalid version number\n\n- CVE-2010-0378: unload of an object that is currently being accessed by other functionality\n\n- CVE-2010-0302: incorrectly tracking a reference count leads to use-after-free\n\n- CVE-2010-0249: use-after-free related to use of uninitialized memory\n\n- CVE-2010-0050: HTML document with incorrectly-nested tags\n\n- CVE-2009-3658: Use after free in ActiveX object by providing a malformed argument to a method\n\n- CVE-2009-3616: use-after-free by disconnecting during data transfer, or a message containing incorrect data types\n\n- CVE-2009-3553: disconnect during a large data transfer causes incorrect reference count, leading to use-after-free\n\n- CVE-2009-2416: use-after-free found by fuzzing\n\n- CVE-2009-1837: Chain: race condition (CWE-362) from improper handling of a page transition in web client while an applet is loading (CWE-368) leads to use after free (CWE-416)\n\n- CVE-2009-0749: realloc generates new buffer and pointer, but previous pointer is still retained, leading to use after free\n\n- CVE-2010-3328: Use-after-free in web browser, probably resultant from not initializing memory.\n\n- CVE-2008-5038: use-after-free when one thread accessed memory that was freed by another thread\n\n- CVE-2008-0077: assignment of malformed values to certain properties triggers use after free\n\n- CVE-2006-4434: mail server does not properly handle a long header.\n\n- CVE-2010-2753: chain: integer overflow leads to use-after-free\n\n- CVE-2006-4997: freed pointer dereference\n\nTop 25 CWE Examples:\n\n- CVE-2021-0310: In LazyServiceRegistrar of LazyServiceRegistrar.cpp, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android; Versions: Android-11; Android ID: A-170212632.\n\n- CVE-2021-0332: In bootFinished of SurfaceFlinger.cpp, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with User execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11 Android-10Android ID: A-169256435\n\n- CVE-2021-0335: In process of C2SoftHevcDec.cpp, there is a possible out of bounds write due to a use after free. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-11Android ID: A-160346309\n\n- CVE-2021-0342: In tun_get_user of tun.c, there is possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges required. User interaction is not required for exploitation. Product: Android; Versions: Android kernel; Android ID: A-146554327.\n\n- CVE-2021-0349: In display driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Product: Android; Versions: Android-9, Android-10, Android-11; Patch ID: ALPS05362646.\n\n- CVE-2021-0365: In display driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Product: Android; Versions: Android-10, Android-11; Patch ID: ALPS05454782.\n\n- CVE-2021-0395: In StopServicesAndLogViolations of reboot.cpp, there is possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11Android ID: A-170315126\n\n- CVE-2021-0399: In qtaguid_untag of xt_qtaguid.c, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-176919394References: Upstream kernel\n\n- CVE-2021-0429: In pollOnce of ALooper.cpp, there is possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-9 Android-10 Android-11 Android-8.1Android ID: A-175074139\n\n- CVE-2021-0475: In on_l2cap_data_ind of btif_sock_l2cap.cc, there is possible memory corruption due to a use after free. This could lead to remote code execution over Bluetooth with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11 Android-10Android ID: A-175686168\n\n- CVE-2021-0482: In BinderDiedCallback of MediaCodec.cpp, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11Android ID: A-173791720\n\n- CVE-2021-0496: In memory management driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-183467912\n\n- CVE-2021-0497: In memory management driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-183461320\n\n- CVE-2021-0527: In memory management driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-185193931\n\n- CVE-2021-0531: In memory management driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-185195272\n\n- CVE-2021-0535: In wpas_ctrl_msg_queue_timeout of ctrl_iface_unix.c, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11Android ID: A-168314741\n\n- CVE-2021-0611: In m4u, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05403499; Issue ID: ALPS05425810.\n\n- CVE-2021-0612: In m4u, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05403499; Issue ID: ALPS05425834.\n\n- CVE-2021-0629: In mdlactl driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05776625; Issue ID: ALPS05776625.\n\n- CVE-2021-0656: In edma driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05709376; Issue ID: ALPS05709376.\n\n- CVE-2021-0664: In ccu, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05827158; Issue ID: ALPS05827158.\n\n- CVE-2021-0667: In apusys, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05670581; Issue ID: ALPS05670581.\n\n- CVE-2021-0669: In apusys, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05681550; Issue ID: ALPS05681550.\n\n- CVE-2021-0670: In apusys, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05654663; Issue ID: ALPS05654663.\n\n- CVE-2021-0684: In TouchInputMapper::sync of TouchInputMapper.cpp, there is a possible out of bounds write due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-8.1 Android-9Android ID: A-179839665\n\n- CVE-2021-0695: In get_sock_stat of xt_qtaguid.c, there is a possible out of bounds read due to a use after free. This could lead to local information disclosure with User execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-184018316References: Upstream kernel\n\n- CVE-2021-0936: In acc_read of f_accessory.c, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-173789633References: Upstream kernel\n\n- CVE-2021-20204: A heap memory corruption problem (use after free) can be triggered in libgetdata v0.10.0 when processing maliciously crafted dirfile databases. This degrades the confidentiality, integrity and availability of third-party software that uses libgetdata as a library. This vulnerability may lead to arbitrary code execution or privilege escalation depending on input/skills of attacker.\n\n- CVE-2021-20231: A flaw was found in gnutls. A use after free issue in client sending key_share extension may lead to memory corruption and other consequences.\n\n- CVE-2021-20232: A flaw was found in gnutls. A use after free issue in client_send_params in lib/ext/pre_shared_key.c may lead to memory corruption and other potential consequences.\n\n- CVE-2021-21112: Use after free in Blink in Google Chrome prior to 87.0.4280.141 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21114: Use after free in audio in Google Chrome prior to 87.0.4280.141 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21119: Use after free in Media in Google Chrome prior to 88.0.4324.96 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21120: Use after free in WebSQL in Google Chrome prior to 88.0.4324.96 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21122: Use after free in Blink in Google Chrome prior to 88.0.4324.96 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21145: Use after free in Fonts in Google Chrome prior to 88.0.4324.146 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21157: Use after free in Web Sockets in Google Chrome on Linux prior to 88.0.4324.182 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21159: Heap buffer overflow in TabStrip in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21162: Use after free in WebRTC in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21167: Use after free in bookmarks in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21179: Use after free in Network Internals in Google Chrome on Linux prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21180: Use after free in tab search in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21188: Use after free in Blink in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21191: Use after free in WebRTC in Google Chrome prior to 89.0.4389.90 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21193: Use after free in Blink in Google Chrome prior to 89.0.4389.90 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21194: Use after free in screen sharing in Google Chrome prior to 89.0.4389.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21195: Use after free in V8 in Google Chrome prior to 89.0.4389.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21199: Use after free in Aura in Google Chrome on Linux prior to 89.0.4389.114 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21203: Use after free in Blink in Google Chrome prior to 90.0.4430.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21204: Use after free in Blink in Google Chrome on OS X prior to 90.0.4430.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21206: Use after free in Blink in Google Chrome prior to 89.0.4389.128 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21213: Use after free in WebMIDI in Google Chrome prior to 90.0.4430.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21214: Use after free in Network API in Google Chrome prior to 90.0.4430.72 allowed a remote attacker to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2021-21232: Use after free in Dev Tools in Google Chrome prior to 90.0.4430.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21775: A use-after-free vulnerability exists in the way certain events are processed for ImageLoader objects of Webkit WebKitGTK 2.30.4. A specially crafted web page can lead to a potential information leak and further memory corruption. In order to trigger the vulnerability, a victim must be tricked into visiting a malicious webpage.\n\n- CVE-2021-21779: A use-after-free vulnerability exists in the way Webkit\u2019s GraphicsContext handles certain events in WebKitGTK 2.30.4. A specially crafted web page can lead to a potential information leak and further memory corruption. A victim must be tricked into visiting a malicious web page to trigger this vulnerability.\n\n- CVE-2021-22543: An issue was discovered in Linux: KVM through Improper handling of VM_IO|VM_PFNMAP vmas in KVM can bypass RO checks and can lead to pages being freed while still accessible by the VMM and guest. This allows users with the ability to start and control a VM to read/write random pages of memory and can result in local privilege escalation.\n\n- CVE-2021-22930: Node.js before 16.6.0, 14.17.4, and 12.22.4 is vulnerable to a use after free attack where an attacker might be able to exploit the memory corruption, to change process behavior.\n\n- CVE-2021-22940: Node.js before 16.6.1, 14.17.5, and 12.22.5 is vulnerable to a use after free attack where an attacker might be able to exploit the memory corruption, to change process behavior.\n\n- CVE-2021-28702: PCI devices with RMRRs not deassigned correctly Certain PCI devices in a system might be assigned Reserved Memory Regions (specified via Reserved Memory Region Reporting, \"RMRR\"). These are typically used for platform tasks such as legacy USB emulation. If such a device is passed through to a guest, then on guest shutdown the device is not properly deassigned. The IOMMU configuration for these devices which are not properly deassigned ends up pointing to a freed data structure, including the IO Pagetables. Subsequent DMA or interrupts from the device will have unpredictable behaviour, ranging from IOMMU faults to memory corruption.\n\n- CVE-2021-29970: A malicious webpage could have triggered a use-after-free, memory corruption, and a potentially exploitable crash. *This bug could only be triggered when accessibility was enabled.*. This vulnerability affects Thunderbird < 78.12, Firefox ESR < 78.12, and Firefox < 90.\n\n- CVE-2021-29985: A use-after-free vulnerability in media channels could have led to memory corruption and a potentially exploitable crash. This vulnerability affects Thunderbird < 78.13, Thunderbird < 91, Firefox ESR < 78.13, and Firefox < 91.\n\n- CVE-2021-30510: Use after free in Aura in Google Chrome prior to 90.0.4430.212 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30512: Use after free in Notifications in Google Chrome prior to 90.0.4430.212 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30514: Use after free in Autofill in Google Chrome prior to 90.0.4430.212 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30515: Use after free in File API in Google Chrome prior to 90.0.4430.212 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30519: Use after free in Payments in Google Chrome prior to 90.0.4430.212 allowed an attacker who convinced a user to install a malicious payments app to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30520: Use after free in Tab Strip in Google Chrome prior to 90.0.4430.212 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30522: Use after free in WebAudio in Google Chrome prior to 91.0.4472.77 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30523: Use after free in WebRTC in Google Chrome prior to 91.0.4472.77 allowed a remote attacker to potentially exploit heap corruption via a crafted SCTP packet.\n\n- CVE-2021-30524: Use after free in TabStrip in Google Chrome prior to 91.0.4472.77 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30525: Use after free in TabGroups in Google Chrome prior to 91.0.4472.77 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30527: Use after free in WebUI in Google Chrome prior to 91.0.4472.77 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30528: Use after free in WebAuthentication in Google Chrome on Android prior to 91.0.4472.77 allowed a remote attacker who had compromised the renderer process of a user who had saved a credit card in their Google account to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30529: Use after free in Bookmarks in Google Chrome prior to 91.0.4472.77 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30541: Use after free in V8 in Google Chrome prior to 91.0.4472.164 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30542: Use after free in Tab Strip in Google Chrome prior to 91.0.4472.77 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30543: Use after free in Tab Strip in Google Chrome prior to 91.0.4472.77 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30544: Use after free in BFCache in Google Chrome prior to 91.0.4472.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30545: Use after free in Extensions in Google Chrome prior to 91.0.4472.101 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30546: Use after free in Autofill in Google Chrome prior to 91.0.4472.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30548: Use after free in Loader in Google Chrome prior to 91.0.4472.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30549: Use after free in Spell check in Google Chrome prior to 91.0.4472.101 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30550: Use after free in Accessibility in Google Chrome prior to 91.0.4472.101 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30552: Use after free in Extensions in Google Chrome prior to 91.0.4472.101 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30553: Use after free in Network service in Google Chrome prior to 91.0.4472.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30554: Use after free in WebGL in Google Chrome prior to 91.0.4472.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30555: Use after free in Sharing in Google Chrome prior to 91.0.4472.114 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page and user gesture.\n\n- CVE-2021-30556: Use after free in WebAudio in Google Chrome prior to 91.0.4472.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30557: Use after free in TabGroups in Google Chrome prior to 91.0.4472.114 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30560: Use after free in Blink XSLT in Google Chrome prior to 91.0.4472.164 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30562: Use after free in WebSerial in Google Chrome prior to 91.0.4472.164 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30567: Use after free in DevTools in Google Chrome prior to 92.0.4515.107 allowed an attacker who convinced a user to open DevTools to potentially exploit heap corruption via specific user gesture.\n\n- CVE-2021-30569: Use after free in sqlite in Google Chrome prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30572: Use after free in Autofill in Google Chrome prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30573: Use after free in GPU in Google Chrome prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30574: Use after free in protocol handling in Google Chrome prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30576: Use after free in DevTools in Google Chrome prior to 92.0.4515.107 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30579: Use after free in UI framework in Google Chrome prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30581: Use after free in DevTools in Google Chrome prior to 92.0.4515.107 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30585: Use after free in sensor handling in Google Chrome on Windows prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30586: Use after free in dialog box handling in Windows in Google Chrome prior to 92.0.4515.107 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30591: Use after free in File System API in Google Chrome prior to 92.0.4515.131 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30594: Use after free in Page Info UI in Google Chrome prior to 92.0.4515.131 allowed a remote attacker to potentially exploit heap corruption via physical access to the device.\n\n- CVE-2021-30597: Use after free in Browser UI in Google Chrome on Chrome prior to 92.0.4515.131 allowed a remote attacker to potentially exploit heap corruption via physical access to the device.\n\n- CVE-2021-30600: Use after free in Printing in Google Chrome prior to 92.0.4515.159 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30601: Use after free in Extensions API in Google Chrome prior to 92.0.4515.159 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30602: Use after free in WebRTC in Google Chrome prior to 92.0.4515.159 allowed an attacker who convinced a user to visit a malicious website to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30604: Use after free in ANGLE in Google Chrome prior to 92.0.4515.159 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30625: Use after free in Selection API in Google Chrome prior to 93.0.4577.82 allowed a remote attacker who convinced the user the visit a malicious website to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30629: Use after free in Permissions in Google Chrome prior to 93.0.4577.82 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37956: Use after free in Offline use in Google Chrome on Android prior to 94.0.4606.54 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37957: Use after free in WebGPU in Google Chrome prior to 94.0.4606.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37959: Use after free in Task Manager in Google Chrome prior to 94.0.4606.54 allowed an attacker who convinced a user to enage in a series of user gestures to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37961: Use after free in Tab Strip in Google Chrome prior to 94.0.4606.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37962: Use after free in Performance Manager in Google Chrome prior to 94.0.4606.54 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37970: Use after free in File System API in Google Chrome prior to 94.0.4606.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37974: Use after free in Safebrowsing in Google Chrome prior to 94.0.4606.71 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37975: Use after free in V8 in Google Chrome prior to 94.0.4606.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37977: Use after free in Garbage Collection in Google Chrome prior to 94.0.4606.81 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37982: Use after free in Incognito in Google Chrome prior to 95.0.4638.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37983: Use after free in Dev Tools in Google Chrome prior to 95.0.4638.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37985: Use after free in V8 in Google Chrome prior to 95.0.4638.54 allowed a remote attacker who had convinced a user to allow for connection to debugger to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37987: Use after free in Network APIs in Google Chrome prior to 95.0.4638.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37988: Use after free in Profiles in Google Chrome prior to 95.0.4638.54 allowed a remote attacker who convinced a user to engage in specific gestures to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37993: Use after free in PDF Accessibility in Google Chrome prior to 95.0.4638.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37997: Use after free in Sign-In in Google Chrome prior to 95.0.4638.69 allowed a remote attacker who convinced a user to sign into Chrome to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37998: Use after free in Garbage Collection in Google Chrome prior to 95.0.4638.69 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-38496: During operations on MessageTasks, a task may have been removed while it was still scheduled, resulting in memory corruption and a potentially exploitable crash. This vulnerability affects Thunderbird < 78.15, Thunderbird < 91.2, Firefox ESR < 91.2, Firefox ESR < 78.15, and Firefox < 93.\n\n- CVE-2021-38498: During process shutdown, a document could have caused a use-after-free of a languages service object, leading to memory corruption and a potentially exploitable crash. This vulnerability affects Firefox < 93, Thunderbird < 91.2, and Firefox ESR < 91.2.\n\n- CVE-2021-43057: An issue was discovered in the Linux kernel before 5.14.8. A use-after-free in selinux_ptrace_traceme (aka the SELinux handler for PTRACE_TRACEME) could be used by local attackers to cause memory corruption and escalate privileges, aka CID-a3727a8bac0a. This occurs because of an attempt to access the subjective credentials of another task.\n\n- CVE-2021-43790: Lucet is a native WebAssembly compiler and runtime. There is a bug in the main branch of `lucet-runtime` affecting all versions published to crates.io that allows a use-after-free in an Instance object that could result in memory corruption, data race, or other related issues. This bug was introduced early in the development of Lucet and is present in all releases. As a result of this bug, and dependent on the memory backing for the Instance objects, it is possible to trigger a use-after-free when the Instance is dropped. Users should upgrade to the main branch of the Lucet repository. Lucet no longer provides versioned releases on crates.io. There is no way to remediate this vulnerability without upgrading.\n\n- CVE-2021-44047: A use-after-free vulnerability exists when reading a DWF/DWFX file using Open Design Alliance Drawings SDK before 2022.11. The specific issue exists with parsing DWF/DWFX files. Crafted data in a DWF/DWFX file and lack of proper validation of input data can trigger a write operation past the end of an allocated buffer. An attacker can leverage this vulnerability to execute code in the context of the current process.\n\n- CVE-2021-1651: Diagnostics Hub Standard Collector Elevation of Privilege Vulnerability\n\n- CVE-2021-26900: Windows Win32k Elevation of Privilege Vulnerability\n\n- CVE-2021-31170: Windows Graphics Component Elevation of Privilege Vulnerability\n\n- CVE-2021-31188: Windows Graphics Component Elevation of Privilege Vulnerability\n\n- CVE-2021-34486: Windows Event Tracing Elevation of Privilege Vulnerability\n\n- CVE-2021-40449: Win32k Elevation of Privilege Vulnerability\n\n- CVE-2021-40125: A vulnerability in the Internet Key Exchange Version 2 (IKEv2) implementation of Cisco Adaptive Security Appliance (ASA) Software and Cisco Firepower Threat Defense (FTD) Software could allow an authenticated, remote attacker to trigger a denial of service (DoS) condition on an affected device. This vulnerability is due to improper control of a resource. An attacker with the ability to spoof a trusted IKEv2 site-to-site VPN peer and in possession of valid IKEv2 credentials for that peer could exploit this vulnerability by sending malformed, authenticated IKEv2 messages to an affected device. A successful exploit could allow the attacker to trigger a reload of the device.\n\n- CVE-2021-34498: Windows GDI Elevation of Privilege Vulnerability\n\n- CVE-2021-22893: Pulse Connect Secure 9.0R3/9.1R1 and higher is vulnerable to an authentication bypass vulnerability exposed by the Windows File Share Browser and Pulse Secure Collaboration features of Pulse Connect Secure that can allow an unauthenticated user to perform remote arbitrary code execution on the Pulse Connect Secure gateway. This vulnerability has been exploited in the wild.\n\n- CVE-2021-22348: There is a Memory Buffer Improper Operation Limit Vulnerability in Huawei Smartphone. Successful exploitation of this vulnerability may cause code to execute.\n\n- CVE-2021-22350: There is a Memory Buffer Improper Operation Limit Vulnerability in Huawei Smartphone. Successful exploitation of this vulnerability may cause the device to crash and restart.\n\n- CVE-2021-22353: There is a Memory Buffer Improper Operation Limit Vulnerability in Huawei Smartphone. Successful exploitation of this vulnerability may cause the kernel to restart.\n\n- CVE-2021-22390: There is a Memory Buffer Improper Operation Limit Vulnerability in Huawei Smartphone.Successful exploitation of this vulnerability may cause certain codes to be executed.\n\n- CVE-2020-24349: njs through 0.4.3, used in NGINX, allows control-flow hijack in njs_value_property in njs_value.c. NOTE: the vendor considers the issue to be \"fluff\" in the NGINX use case because there is no remote attack surface.\n\n- CVE-2021-37045: There is an UAF vulnerability in Huawei Smartphone.Successful exploitation of this vulnerability may cause the device to restart unexpectedly and the kernel-mode code to be executed.\n\n- CVE-2021-39803: In ~Impl of C2AllocatorIon.cpp, there is a possible out of bounds read due to a use after free. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12LAndroid ID: A-193790350\n\n- CVE-2021-42612: A use after free in cleanup_index in index.c in Halibut 1.2 allows an attacker to cause a segmentation fault or possibly have other unspecified impact via a crafted text document.\n\n- CVE-2021-42614: A use after free in info_width_internal in bk_info.c in Halibut 1.2 allows an attacker to cause a segmentation fault or possibly have unspecified other impact via a crafted text document.\n\n- CVE-2020-0674: A remote code execution vulnerability exists in the way that the scripting engine handles objects in memory in Internet Explorer, aka 'Scripting Engine Memory Corruption Vulnerability'. This CVE ID is unique from CVE-2020-0673, CVE-2020-0710, CVE-2020-0711, CVE-2020-0712, CVE-2020-0713, CVE-2020-0767.\n\n- CVE-2020-16017: Use after free in site isolation in Google Chrome prior to 86.0.4240.198 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2020-3992: OpenSLP as used in VMware ESXi (7.0 before ESXi_7.0.1-0.0.16850804, 6.7 before ESXi670-202010401-SG, 6.5 before ESXi650-202010401-SG) has a use-after-free issue. A malicious actor residing in the management network who has access to port 427 on an ESXi machine may be able to trigger a use-after-free in the OpenSLP service resulting in remote code execution.\n\n- CVE-2020-6572: Use after free in Media in Google Chrome prior to 81.0.4044.92 allowed a remote attacker to execute arbitrary code via a crafted HTML page.\n\n- CVE-2021-1048: In ep_loop_check_proc of eventpoll.c, there is a possible way to corrupt memory due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-204573007References: Upstream kernel\n\n- CVE-2021-1905: Possible use after free due to improper handling of memory mapping of multiple processes simultaneously. in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2021-28550: Acrobat Reader DC versions versions 2021.001.20150 (and earlier), 2020.001.30020 (and earlier) and 2017.011.30194 (and earlier) are affected by a Use After Free vulnerability. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-28663: The Arm Mali GPU kernel driver allows privilege escalation or information disclosure because GPU memory operations are mishandled, leading to a use-after-free. This affects Bifrost r0p0 through r28p0 before r29p0, Valhall r19p0 through r28p0 before r29p0, and Midgard r4p0 through r30p0.\n\n- CVE-2021-30633: Use after free in Indexed DB API in Google Chrome prior to 93.0.4577.82 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2021-30661: A use after free issue was addressed with improved memory management. This issue is fixed in Safari 14.1, iOS 12.5.3, iOS 14.5 and iPadOS 14.5, watchOS 7.4, tvOS 14.5, macOS Big Sur 11.3. Processing maliciously crafted web content may lead to arbitrary code execution. Apple is aware of a report that this issue may have been actively exploited..\n\n- CVE-2021-30762: A use after free issue was addressed with improved memory management. This issue is fixed in iOS 12.5.4. Processing maliciously crafted web content may lead to arbitrary code execution. Apple is aware of a report that this issue may have been actively exploited..\n\n- CVE-2021-30858: A use after free issue was addressed with improved memory management. This issue is fixed in iOS 14.8 and iPadOS 14.8, macOS Big Sur 11.6. Processing maliciously crafted web content may lead to arbitrary code execution. Apple is aware of a report that this issue may have been actively exploited.\n\n- CVE-2021-31166: HTTP Protocol Stack Remote Code Execution Vulnerability\n\n- CVE-2021-37973: Use after free in Portals in Google Chrome prior to 94.0.4606.61 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2021-35120: Improper handling between export and release functions on the same handle from client can lead to use after free in Snapdragon Compute, Snapdragon Connectivity, Snapdragon Industrial IOT, Snapdragon Mobile\n\n- CVE-2021-3700: A use-after-free vulnerability was found in usbredir in versions prior to 0.11.0 in the usbredirparser_serialize() in usbredirparser/usbredirparser.c. This issue occurs when serializing large amounts of buffered write data in the case of a slow or blocked destination.\n\n- CVE-2021-38005: Use after free in loader in Google Chrome prior to 96.0.4664.45 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-38006: Use after free in storage foundation in Google Chrome prior to 96.0.4664.45 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-38008: Use after free in media in Google Chrome prior to 96.0.4664.45 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-38011: Use after free in storage foundation in Google Chrome prior to 96.0.4664.45 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-39812: In TBD of TBD, there is a possible out of bounds read due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-205522359References: N/A\n\n- CVE-2021-4052: Use after free in web apps in Google Chrome prior to 96.0.4664.93 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2021-4053: Use after free in UI in Google Chrome on Linux prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4057: Use after free in file API in Google Chrome prior to 96.0.4664.93 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4063: Use after free in developer tools in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4064: Use after free in screen capture in Google Chrome on ChromeOS prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4065: Use after free in autofill in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4067: Use after free in window manager in Google Chrome on ChromeOS prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4099: Use after free in Swiftshader in Google Chrome prior to 96.0.4664.110 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4102: Use after free in V8 in Google Chrome prior to 96.0.4664.110 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0096: Use after free in Storage in Google Chrome prior to 97.0.4692.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0098: Use after free in Screen Capture in Google Chrome on Chrome OS prior to 97.0.4692.71 allowed an attacker who convinced a user to perform specific user gestures to potentially exploit heap corruption via specific user gestures.\n\n- CVE-2022-0099: Use after free in Sign-in in Google Chrome prior to 97.0.4692.71 allowed a remote attacker who convinced a user to perform specific user gestures to potentially exploit heap corruption via specific user gesture.\n\n- CVE-2022-0103: Use after free in SwiftShader in Google Chrome prior to 97.0.4692.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0105: Use after free in PDF Accessibility in Google Chrome prior to 97.0.4692.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0106: Use after free in Autofill in Google Chrome prior to 97.0.4692.71 allowed a remote attacker who convinced a user to perform specific user gesture to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0107: Use after free in File Manager API in Google Chrome on Chrome OS prior to 97.0.4692.71 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0289: Use after free in Safe browsing in Google Chrome prior to 97.0.4692.99 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0293: Use after free in Web packaging in Google Chrome prior to 97.0.4692.99 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0295: Use after free in Omnibox in Google Chrome prior to 97.0.4692.99 allowed a remote attacker who convinced the user to engage is specific user interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0296: Use after free in Printing in Google Chrome prior to 97.0.4692.99 allowed a remote attacker who convinced the user to engage is specific user interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0297: Use after free in Vulkan in Google Chrome prior to 97.0.4692.99 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0298: Use after free in Scheduling in Google Chrome prior to 97.0.4692.99 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0300: Use after free in Text Input Method Editor in Google Chrome on Android prior to 97.0.4692.99 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0301: Heap buffer overflow in DevTools in Google Chrome prior to 97.0.4692.99 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0302: Use after free in Omnibox in Google Chrome prior to 97.0.4692.99 allowed an attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0304: Use after free in Bookmarks in Google Chrome prior to 97.0.4692.99 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0307: Use after free in Optimization Guide in Google Chrome prior to 97.0.4692.99 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0308: Use after free in Data Transfer in Google Chrome on Chrome OS prior to 97.0.4692.99 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0453: Use after free in Reader Mode in Google Chrome prior to 98.0.4758.80 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0456: Use after free in Web Search in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via profile destruction.\n\n- CVE-2022-0458: Use after free in Thumbnail Tab Strip in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0459: Use after free in Screen Capture in Google Chrome prior to 98.0.4758.80 allowed a remote attacker who had compromised the renderer process and convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0460: Use after free in Window Dialogue in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0463: Use after free in Accessibility in Google Chrome prior to 98.0.4758.80 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via user interaction.\n\n- CVE-2022-0464: Use after free in Accessibility in Google Chrome prior to 98.0.4758.80 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via user interaction.\n\n- CVE-2022-0465: Use after free in Extensions in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via user interaction.\n\n- CVE-2022-0468: Use after free in Payments in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0469: Use after free in Cast in Google Chrome prior to 98.0.4758.80 allowed a remote attacker who convinced a user to engage in specific interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0603: Use after free in File Manager in Google Chrome on Chrome OS prior to 98.0.4758.102 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0605: Use after free in Webstore API in Google Chrome prior to 98.0.4758.102 allowed an attacker who convinced a user to install a malicious extension and convinced a user to enage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0606: Use after free in ANGLE in Google Chrome prior to 98.0.4758.102 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0607: Use after free in GPU in Google Chrome prior to 98.0.4758.102 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0609: Use after free in Animation in Google Chrome prior to 98.0.4758.102 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0646: A flaw use after free in the Linux kernel Management Component Transport Protocol (MCTP) subsystem was found in the way user triggers cancel_work_sync after the unregister_netdev during removing device. A local user could use this flaw to crash the system or escalate their privileges on the system. It is actual from Linux Kernel 5.17-rc1 (when mctp-serial.c introduced) till 5.17-rc5.\n\n- CVE-2022-0791: Use after free in Omnibox in Google Chrome prior to 99.0.4844.51 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via user interactions.\n\n- CVE-2022-0793: Use after free in Cast in Google Chrome prior to 99.0.4844.51 allowed an attacker who convinced a user to install a malicious extension and engage in specific user interaction to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2022-0794: Use after free in WebShare in Google Chrome prior to 99.0.4844.51 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0796: Use after free in Media in Google Chrome prior to 99.0.4844.51 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0798: Use after free in MediaStream in Google Chrome prior to 99.0.4844.51 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2022-0805: Use after free in Browser Switcher in Google Chrome prior to 99.0.4844.51 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via user interaction.\n\n- CVE-2022-0808: Use after free in Chrome OS Shell in Google Chrome on Chrome OS prior to 99.0.4844.51 allowed a remote attacker who convinced a user to engage in a series of user interaction to potentially exploit heap corruption via user interactions.\n\n- CVE-2022-0971: Use after free in Blink Layout in Google Chrome on Android prior to 99.0.4844.74 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0972: Use after free in Extensions in Google Chrome prior to 99.0.4844.74 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0973: Use after free in Safe Browsing in Google Chrome prior to 99.0.4844.74 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0974: Use after free in Splitscreen in Google Chrome on Chrome OS prior to 99.0.4844.74 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0975: Use after free in ANGLE in Google Chrome prior to 99.0.4844.74 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0977: Use after free in Browser UI in Google Chrome on Chrome OS prior to 99.0.4844.74 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0978: Use after free in ANGLE in Google Chrome prior to 99.0.4844.74 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0979: Use after free in Safe Browsing in Google Chrome on Android prior to 99.0.4844.74 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0980: Use after free in New Tab Page in Google Chrome prior to 99.0.4844.74 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-1125: Use after free in Portals in Google Chrome prior to 100.0.4896.60 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via user interaction.\n\n- CVE-2022-1127: Use after free in QR Code Generator in Google Chrome prior to 100.0.4896.60 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via user interaction.\n\n- CVE-2022-1131: Use after free in Cast UI in Google Chrome prior to 100.0.4896.60 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1133: Use after free in WebRTC Perf in Google Chrome prior to 100.0.4896.60 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1135: Use after free in Shopping Cart in Google Chrome prior to 100.0.4896.60 allowed a remote attacker to potentially exploit heap corruption via standard feature user interaction.\n\n- CVE-2022-1136: Use after free in Tab Strip in Google Chrome prior to 100.0.4896.60 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via specific set of user gestures.\n\n- CVE-2022-1141: Use after free in File Manager in Google Chrome prior to 100.0.4896.60 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via specific user gesture.\n\n- CVE-2022-1144: Use after free in WebUI in Google Chrome prior to 100.0.4896.60 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via specific input into DevTools.\n\n- CVE-2022-1145: Use after free in Extensions in Google Chrome prior to 100.0.4896.60 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via specific user interaction and profile destruction.\n\n- CVE-2022-1305: Use after free in storage in Google Chrome prior to 100.0.4896.88 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1308: Use after free in BFCache in Google Chrome prior to 100.0.4896.88 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1310: Use after free in regular expressions in Google Chrome prior to 100.0.4896.88 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1311: Use after free in shell in Google Chrome on ChromeOS prior to 100.0.4896.88 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1313: Use after free in tab groups in Google Chrome prior to 100.0.4896.88 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1477: Use after free in Vulkan in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1478: Use after free in SwiftShader in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1479: Use after free in ANGLE in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1481: Use after free in Sharing in Google Chrome on Mac prior to 101.0.4951.41 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1485: Use after free in File System API in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1487: Use after free in Ozone in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via running a Wayland test.\n\n- CVE-2022-1490: Use after free in Browser Switcher in Google Chrome prior to 101.0.4951.41 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1491: Use after free in Bookmarks in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via specific and direct user interaction.\n\n- CVE-2022-1493: Use after free in Dev Tools in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via specific and direct user interaction.\n\n- CVE-2022-1496: Use after free in File Manager in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via specific and direct user interaction.\n\n- CVE-2022-1633: Use after free in Sharesheet in Google Chrome on Chrome OS prior to 101.0.4951.64 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-1634: Use after free in Browser UI in Google Chrome prior to 101.0.4951.64 allowed a remote attacker who had convinced a user to engage in specific UI interaction to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-1635: Use after free in Permission Prompts in Google Chrome prior to 101.0.4951.64 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-1636: Use after free in Performance APIs in Google Chrome prior to 101.0.4951.64 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1639: Use after free in ANGLE in Google Chrome prior to 101.0.4951.64 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1640: Use after free in Sharing in Google Chrome prior to 101.0.4951.64 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1641: Use after free in Web UI Diagnostics in Google Chrome on Chrome OS prior to 101.0.4951.64 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via specific user interaction.\n\n- CVE-2022-1734: A flaw in Linux Kernel found in nfcmrvl_nci_unregister_dev() in drivers/nfc/nfcmrvl/main.c can lead to use after free both read or write when non synchronized between cleanup routine and firmware download routine.\n\n- CVE-2022-1854: Use after free in ANGLE in Google Chrome prior to 102.0.5005.61 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1855: Use after free in Messaging in Google Chrome prior to 102.0.5005.61 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1856: Use after free in User Education in Google Chrome prior to 102.0.5005.61 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension or specific user interaction.\n\n- CVE-2022-1859: Use after free in Performance Manager in Google Chrome prior to 102.0.5005.61 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1860: Use after free in UI Foundations in Google Chrome on Chrome OS prior to 102.0.5005.61 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-1861: Use after free in Sharing in Google Chrome on Chrome OS prior to 102.0.5005.61 allowed a remote attacker who convinced a user to enage in specific user interactions to potentially exploit heap corruption via specific user interaction.\n\n- CVE-2022-1863: Use after free in Tab Groups in Google Chrome prior to 102.0.5005.61 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension and specific user interaction.\n\n- CVE-2022-1864: Use after free in WebApp Installs in Google Chrome prior to 102.0.5005.61 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension and specific user interaction.\n\n- CVE-2022-1865: Use after free in Bookmarks in Google Chrome prior to 102.0.5005.61 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension and specific user interaction.\n\n- CVE-2022-1866: Use after free in Tablet Mode in Google Chrome on Chrome OS prior to 102.0.5005.61 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-1870: Use after free in App Service in Google Chrome prior to 102.0.5005.61 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2022-1919: Use after free in Codecs in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2007: Use after free in WebGPU in Google Chrome prior to 102.0.5005.115 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2011: Use after free in ANGLE in Google Chrome prior to 102.0.5005.115 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-20447: In PAN_WriteBuf of pan_api.cc, there is a possible out of bounds read due to a use after free. This could lead to remote information disclosure over Bluetooth with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-233604485\n\n- CVE-2022-20552: In btif_a2dp_sink_command_ready of btif_a2dp_sink.cc, there is a possible out of bounds read due to a use after free. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-243922806\n\n- CVE-2022-20554: In removeEventHubDevice of InputDevice.cpp, there is a possible OOB read due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-245770596\n\n- CVE-2022-20581: In the Pixel camera driver, there is a possible use after free due to a logic error in the code. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-245916120References: N/A\n\n- CVE-2022-2156: Use after free in Core in Google Chrome prior to 103.0.5060.53 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2157: Use after free in Interest groups in Google Chrome prior to 103.0.5060.53 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2158: Type confusion in V8 in Google Chrome prior to 103.0.5060.53 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2161: Use after free in WebApp Provider in Google Chrome prior to 103.0.5060.53 allowed a remote attacker who convinced the user to engage in specific user interactions to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2163: Use after free in Cast UI and Toolbar in Google Chrome prior to 103.0.5060.134 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via UI interaction.\n\n- CVE-2022-2296: Use after free in Chrome OS Shell in Google Chrome on Chrome OS prior to 103.0.5060.114 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via direct UI interactions.\n\n- CVE-2022-23608: PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In versions up to and including 2.11.1 when in a dialog set (or forking) scenario, a hash key shared by multiple UAC dialogs can potentially be prematurely freed when one of the dialogs is destroyed . The issue may cause a dialog set to be registered in the hash table multiple times (with different hash keys) leading to undefined behavior such as dialog list collision which eventually leading to endless loop. A patch is available in commit db3235953baa56d2fb0e276ca510fefca751643f which will be included in the next release. There are no known workarounds for this issue.\n\n- CVE-2022-2399: Use after free in WebGPU in Google Chrome prior to 100.0.4896.88 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2477: Use after free in Guest View in Google Chrome prior to 103.0.5060.134 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2478: Use after free in PDF in Google Chrome prior to 103.0.5060.134 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2480: Use after free in Service Worker API in Google Chrome prior to 103.0.5060.134 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2481: Use after free in Views in Google Chrome prior to 103.0.5060.134 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via UI interaction.\n\n- CVE-2022-2603: Use after free in Omnibox in Google Chrome prior to 104.0.5112.79 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2604: Use after free in Safe Browsing in Google Chrome prior to 104.0.5112.79 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2606: Use after free in Managed devices API in Google Chrome prior to 104.0.5112.79 allowed a remote attacker who convinced a user to enable a specific Enterprise policy to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2613: Use after free in Input in Google Chrome on Chrome OS prior to 104.0.5112.79 allowed a remote attacker who convinced a user to enage in specific user interactions to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2614: Use after free in Sign-In Flow in Google Chrome prior to 104.0.5112.79 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-28269: Acrobat Reader DC versions 22.001.20085 (and earlier), 20.005.3031x (and earlier) and 17.012.30205 (and earlier) are affected by a use-after-free vulnerability in the processing of Annotation objects that could result in a memory leak in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2022-2852: Use after free in FedCM in Google Chrome prior to 104.0.5112.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2855: Use after free in ANGLE in Google Chrome prior to 104.0.5112.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2858: Use after free in Sign-In Flow in Google Chrome prior to 104.0.5112.101 allowed a remote attacker to potentially exploit heap corruption via specific UI interaction.\n\n- CVE-2022-2859: Use after free in Chrome OS Shell in Google Chrome prior to 104.0.5112.101 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2896: Measuresoft ScadaPro Server (All Versions) allows use after free while processing a specific project file.\n\n- CVE-2022-2998: Use after free in Browser Creation in Google Chrome prior to 104.0.5112.101 allowed a remote attacker who had convinced a user to engage in a specific UI interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3038: Use after free in Network Service in Google Chrome prior to 105.0.5195.52 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3039: Use after free in WebSQL in Google Chrome prior to 105.0.5195.52 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3041: Use after free in WebSQL in Google Chrome prior to 105.0.5195.52 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3046: Use after free in Browser Tag in Google Chrome prior to 105.0.5195.52 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3055: Use after free in Passwords in Google Chrome prior to 105.0.5195.52 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3058: Use after free in Sign-In Flow in Google Chrome prior to 105.0.5195.52 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via crafted UI interaction.\n\n- CVE-2022-3196: Use after free in PDF in Google Chrome prior to 105.0.5195.125 allowed a remote attacker to potentially exploit heap corruption via a crafted PDF file. (Chromium security severity: High)\n\n- CVE-2022-3197: Use after free in PDF in Google Chrome prior to 105.0.5195.125 allowed a remote attacker to potentially exploit heap corruption via a crafted PDF file. (Chromium security severity: High)\n\n- CVE-2022-3198: Use after free in PDF in Google Chrome prior to 105.0.5195.125 allowed a remote attacker to potentially exploit heap corruption via a crafted PDF file. (Chromium security severity: High)\n\n- CVE-2022-3199: Use after free in Frames in Google Chrome prior to 105.0.5195.125 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-32317: The MPlayer Project v1.5 was discovered to contain a heap use-after-free resulting in a double free in the preinit function at libvo/vo_v4l2.c. This vulnerability can lead to a Denial of Service (DoS) via a crafted file. The device=strdup statement is not executed on every call. Note: This has been disputed by third parties as invalid and not reproduceable.\n\n- CVE-2022-3445: Use after free in Skia in Google Chrome prior to 106.0.5249.119 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-3448: Use after free in Permissions API in Google Chrome prior to 106.0.5249.119 allowed a remote attacker who convinced a user to engage in specific UI gestures to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-34484: The Mozilla Fuzzing Team reported potential vulnerabilities present in Thunderbird 91.10. Some of these bugs showed evidence of memory corruption and we presume that with enough effort some of these could have been exploited to run arbitrary code. This vulnerability affects Firefox < 102, Firefox ESR < 91.11, Thunderbird < 102, and Thunderbird < 91.11.\n\n- CVE-2022-3449: Use after free in Safe Browsing in Google Chrome prior to 106.0.5249.119 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension. (Chromium security severity: High)\n\n- CVE-2022-34568: SDL v1.2 was discovered to contain a use-after-free via the XFree function at /src/video/x11/SDL_x11yuv.c.\n\n- CVE-2022-3654: Use after free in Layout in Google Chrome prior to 107.0.5304.62 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-3657: Use after free in Extensions in Google Chrome prior to 107.0.5304.62 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension. (Chromium security severity: Medium)\n\n- CVE-2022-3658: Use after free in Feedback service on Chrome OS in Google Chrome on Chrome OS prior to 107.0.5304.62 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via specific UI interaction. (Chromium security severity: Medium)\n\n- CVE-2022-3659: Use after free in Accessibility in Google Chrome on Chrome OS prior to 107.0.5304.62 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via specific UI interactions. (Chromium security severity: Medium)\n\n- CVE-2022-3842: Use after free in Passwords in Google Chrome prior to 105.0.5195.125 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-3863: Use after free in Browser History in Google Chrome prior to 100.0.4896.75 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chrome security severity: High)\n\n- CVE-2022-3885: Use after free in V8 in Google Chrome prior to 107.0.5304.106 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-3886: Use after free in Speech Recognition in Google Chrome prior to 107.0.5304.106 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-3887: Use after free in Web Workers in Google Chrome prior to 107.0.5304.106 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-3888: Use after free in WebCodecs in Google Chrome prior to 107.0.5304.106 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4175: Use after free in Camera Capture in Google Chrome prior to 108.0.5359.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4177: Use after free in Extensions in Google Chrome prior to 108.0.5359.71 allowed an attacker who convinced a user to install an extension to potentially exploit heap corruption via a crafted Chrome Extension and UI interaction. (Chromium security severity: High)\n\n- CVE-2022-4178: Use after free in Mojo in Google Chrome prior to 108.0.5359.71 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4179: Use after free in Audio in Google Chrome prior to 108.0.5359.71 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension. (Chromium security severity: High)\n\n- CVE-2022-4180: Use after free in Mojo in Google Chrome prior to 108.0.5359.71 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension. (Chromium security severity: High)\n\n- CVE-2022-4181: Use after free in Forms in Google Chrome prior to 108.0.5359.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4191: Use after free in Sign-In in Google Chrome prior to 108.0.5359.71 allowed a remote attacker who convinced a user to engage in specific UI interaction to potentially exploit heap corruption via profile destruction. (Chromium security severity: Medium)\n\n- CVE-2022-4192: Use after free in Live Caption in Google Chrome prior to 108.0.5359.71 allowed a remote attacker who convinced a user to engage in specific UI interaction to potentially exploit heap corruption via UI interaction. (Chromium security severity: Medium)\n\n- CVE-2022-4194: Use after free in Accessibility in Google Chrome prior to 108.0.5359.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: Medium)\n\n- CVE-2022-42332: x86 shadow plus log-dirty mode use-after-free In environments where host assisted address translation is necessary but Hardware Assisted Paging (HAP) is unavailable, Xen will run guests in so called shadow mode. Shadow mode maintains a pool of memory used for both shadow page tables as well as auxiliary data structures. To migrate or snapshot guests, Xen additionally runs them in so called log-dirty mode. The data structures needed by the log-dirty tracking are part of aformentioned auxiliary data. In order to keep error handling efforts within reasonable bounds, for operations which may require memory allocations shadow mode logic ensures up front that enough memory is available for the worst case requirements. Unfortunately, while page table memory is properly accounted for on the code path requiring the potential establishing of new shadows, demands by the log-dirty infrastructure were not taken into consideration. As a result, just established shadow page tables could be freed again immediately, while other code is still accessing them on the assumption that they would remain allocated.\n\n- CVE-2022-4436: Use after free in Blink Media in Google Chrome prior to 108.0.5359.124 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4437: Use after free in Mojo IPC in Google Chrome prior to 108.0.5359.124 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4438: Use after free in Blink Frames in Google Chrome prior to 108.0.5359.124 allowed a remote attacker who convinced the user to engage in specific UI interactions to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4439: Use after free in Aura in Google Chrome on Windows prior to 108.0.5359.124 allowed a remote attacker who convinced the user to engage in specific UI interactions to potentially exploit heap corruption via specific UI interactions. (Chromium security severity: High)\n\n- CVE-2022-4440: Use after free in Profiles in Google Chrome prior to 108.0.5359.124 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: Medium)\n\n- CVE-2022-44550: The graphics display module has a UAF vulnerability when traversing graphic layers. Successful exploitation of this vulnerability may affect system availability.\n\n- CVE-2022-45406: If an out-of-memory condition occurred when creating a JavaScript global, a JavaScript realm may be deleted while references to it lived on in a BaseShape. This could lead to a use-after-free causing a potentially exploitable crash. This vulnerability affects Firefox ESR < 102.5, Thunderbird < 102.5, and Firefox < 107.\n\n- CVE-2022-29228: Envoy is a cloud-native high-performance proxy. In versions prior to 1.22.1 the OAuth filter would try to invoke the remaining filters in the chain after emitting a local response, which triggers an ASSERT() in newer versions and corrupts memory on earlier versions. continueDecoding() shouldn\u2019t ever be called from filters after a local reply has been sent. Users are advised to upgrade. There are no known workarounds for this issue.\n\n- CVE-2022-23459: Jsonxx or Json++ is a JSON parser, writer and reader written in C++. In affected versions of jsonxx use of the Value class may lead to memory corruption via a double free or via a use after free. The value class has a default assignment operator which may be used with pointer types which may point to alterable data where the pointer itself is not updated. This issue exists on the current commit of the jsonxx project. The project itself has been archived and updates are not expected. Users are advised to find a replacement.\n\n- CVE-2022-3370: Use after free in Custom Elements in Google Chrome prior to 106.0.5249.91 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-43945: The Linux kernel NFSD implementation prior to versions 5.19.17 and 6.0.2 are vulnerable to buffer overflow. NFSD tracks the number of pages held by each NFSD thread by combining the receive and send buffers of a remote procedure call (RPC) into a single array of pages. A client can force the send buffer to shrink by sending an RPC message over TCP with garbage data added at the end of the message. The RPC message with garbage data is still correctly formed according to the specification and is passed forward to handlers. Vulnerable code in NFSD is not expecting the oversized request and writes beyond the allocated buffer space. CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H\n\n- CVE-2021-1048: In ep_loop_check_proc of eventpoll.c, there is a possible way to corrupt memory due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-204573007References: Upstream kernel\n\n- CVE-2021-21193: Use after free in Blink in Google Chrome prior to 89.0.4389.90 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21206: Use after free in Blink in Google Chrome prior to 89.0.4389.128 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30554: Use after free in WebGL in Google Chrome prior to 91.0.4472.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37975: Use after free in V8 in Google Chrome prior to 94.0.4606.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-22620: A use after free issue was addressed with improved memory management. This issue is fixed in macOS Monterey 12.2.1, iOS 15.3.1 and iPadOS 15.3.1, Safari 15.3 (v. 16612.4.9.1.8 and 15612.4.9.1.8). Processing maliciously crafted web content may lead to arbitrary code execution. Apple is aware of a report that this issue may have been actively exploited..\n\n- CVE-2022-26485: Removing an XSLT parameter during processing could have lead to an exploitable use-after-free. We have had reports of attacks in the wild abusing this flaw. This vulnerability affects Firefox < 97.0.2, Firefox ESR < 91.6.1, Firefox for Android < 97.3.0, Thunderbird < 91.6.2, and Focus < 97.3.0.\n\n- CVE-2022-26486: An unexpected message in the WebGPU IPC framework could lead to a use-after-free and exploitable sandbox escape. We have had reports of attacks in the wild abusing this flaw. This vulnerability affects Firefox < 97.0.2, Firefox ESR < 91.6.1, Firefox for Android < 97.3.0, Thunderbird < 91.6.2, and Focus < 97.3.0.\n\n- CVE-2022-38181: The Arm Mali GPU kernel driver allows unprivileged users to access freed memory because GPU memory operations are mishandled. This affects Bifrost r0p0 through r38p1, and r39p0; Valhall r19p0 through r38p1, and r39p0; and Midgard r4p0 through r32p0.\n\n- CVE-2022-0523: Use After Free in GitHub repository radareorg/radare2 prior to 5.6.2.\n\n- CVE-2022-22034: Windows Graphics Component Elevation of Privilege Vulnerability\n\n- CVE-2022-0581: Crash in the CMS protocol dissector in Wireshark 3.6.0 to 3.6.1 and 3.4.0 to 3.4.11 allows denial of service via packet injection or crafted capture file\n\n- CVE-2022-3541: A vulnerability classified as critical has been found in Linux Kernel. This affects the function spl2sw_nvmem_get_mac_address of the file drivers/net/ethernet/sunplus/spl2sw_driver.c of the component BPF. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier VDB-211041 was assigned to this vulnerability.\n\n- CVE-2022-3545: A vulnerability has been found in Linux Kernel and classified as critical. Affected by this vulnerability is the function area_cache_get of the file drivers/net/ethernet/netronome/nfp/nfpcore/nfp_cppcore.c of the component IPsec. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier VDB-211045 was assigned to this vulnerability.\n\n- CVE-2022-3559: A vulnerability was found in Exim and classified as problematic. This issue affects some unknown processing of the component Regex Handler. The manipulation leads to use after free. The name of the patch is 4e9ed49f8f12eb331b29bd5b6dc3693c520fddc2. It is recommended to apply a patch to fix this issue. The identifier VDB-211073 was assigned to this vulnerability.\n\n- CVE-2022-3620: A vulnerability was found in Exim and classified as problematic. This issue affects the function dmarc_dns_lookup of the file dmarc.c of the component DMARC Handler. The manipulation leads to use after free. The attack may be initiated remotely. The name of the patch is 12fb3842f81bcbd4a4519d5728f2d7e0e3ca1445. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211919.\n\n- CVE-2022-3625: A vulnerability was found in Linux Kernel. It has been classified as critical. This affects the function devlink_param_set/devlink_param_get of the file net/core/devlink.c of the component IPsec. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier VDB-211929 was assigned to this vulnerability.\n\n- CVE-2022-3636: A vulnerability, which was classified as critical, was found in Linux Kernel. This affects the function __mtk_ppe_check_skb of the file drivers/net/ethernet/mediatek/mtk_ppe.c of the component Ethernet Handler. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211935.\n\n- CVE-2022-3640: A vulnerability, which was classified as critical, was found in Linux Kernel. Affected is the function l2cap_conn_del of the file net/bluetooth/l2cap_core.c of the component Bluetooth. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211944.\n\n- CVE-2022-3649: A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is the function nilfs_new_inode of the file fs/nilfs2/inode.c of the component BPF. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211992.\n\n- CVE-2022-3705: A vulnerability was found in vim and classified as problematic. Affected by this issue is the function qf_update_buffer of the file quickfix.c of the component autocmd Handler. The manipulation leads to use after free. The attack may be launched remotely. Upgrading to version 9.0.0805 is able to address this issue. The name of the patch is d0fab10ed2a86698937e3c3fed2f10bd9bb5e731. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-212324.\n\n- CVE-2021-30262: Improper validation of a socket state when socket events are being sent to clients can lead to invalid access of memory in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2022-35254: An unauthenticated attacker can cause a denial-of-service to the following products: Ivanti Connect Secure (ICS) in versions prior to 9.1R14.3, 9.1R15.2, 9.1R16.2, and 22.2R4, Ivanti Policy Secure (IPS) in versions prior to 9.1R17 and 22.3R1, and Ivanti Neurons for Zero-Trust Access in versions prior to 22.3R1.\n\nRelated Weaknesses:\n\n- CWE-825 (ChildOf)\n\n- CWE-672 (ChildOf)\n\n- CWE-672 (ChildOf)\n\n- CWE-672 (ChildOf)\n\n- CWE-120 (CanPrecede)\n\n- CWE-123 (CanPrecede)",
            "type": "Variant",
            "source": "sparse",
            "search_source": "weakness:memory corruption",
            "sources": [
              "base",
              "weakness"
            ],
            "boost_factor": 2.8,
            "boosted": true,
            "metadata": {
              "source": "sparse",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              }
            }
          },
          {
            "cwe_id": "122",
            "name": "Heap-based Buffer Overflow",
            "description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
            "score": 59.76424520678538,
            "matched_text": "CWE-122: Heap-based Buffer Overflow\n\nType: Variant\n\nStatus: Draft\n\nDescription:\n\nA heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().\n\nReal-World Examples:\n\n- CVE-2021-43537: Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n\n- CVE-2007-4268: Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)\n\n- CVE-2009-2523: Chain: product does not handle when an input string is not NULL terminated (CWE-170), leading to buffer over-read (CWE-125) or heap-based buffer overflow (CWE-122).\n\n- CVE-2021-29529: Chain: machine-learning product can have a heap-based buffer overflow (CWE-122) when some integer-oriented bounds are calculated by using ceiling() and floor() on floating point values (CWE-1339)\n\n- CVE-2010-1866: Chain: integer overflow (CWE-190) causes a negative signed value, which later bypasses a maximum-only check (CWE-839), leading to heap-based buffer overflow (CWE-122).\n\nTop 25 CWE Examples:\n\n- CVE-2020-11176: While processing server certificate from IPSec server, certificate validation for subject alternative name API can cause heap overflow which can lead to memory corruption in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Mobile\n\n- CVE-2020-11182: Possible heap overflow while parsing NAL header due to lack of check of length of data received from user in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile\n\n- CVE-2020-18900: A heap-based buffer overflow in the libexe_io_handle_read_coff_optional_header function of libyal libexe before 20181128. NOTE: the vendor has disputed this as described in libyal/libexe issue 1 on GitHub\n\n- CVE-2020-21600: libde265 v1.0.4 contains a heap buffer overflow in the put_weighted_pred_avg_16_fallback function, which can be exploited via a crafted a file.\n\n- CVE-2020-21602: libde265 v1.0.4 contains a heap buffer overflow in the put_weighted_bipred_16_fallback function, which can be exploited via a crafted a file.\n\n- CVE-2020-21606: libde265 v1.0.4 contains a heap buffer overflow fault in the put_epel_16_fallback function, which can be exploited via a crafted a file.\n\n- CVE-2020-21677: A heap-based buffer overflow in the sixel_encoder_output_without_macro function in encoder.c of Libsixel 1.8.4 allows attackers to cause a denial of service (DOS) via converting a crafted PNG file into Sixel format.\n\n- CVE-2020-21814: A heap based buffer overflow issue exists in GNU LibreDWG 0.10.2641 via htmlwescape ../../programs/escape.c:97.\n\n- CVE-2020-21818: A heap based buffer overflow vulnerability exists in GNU LibreDWG 0.10.2641 via htmlescape ../../programs/escape.c:48.\n\n- CVE-2020-21819: A heap based buffer overflow vulnerability exists in GNU LibreDWG 0.10.2641via htmlescape ../../programs/escape.c:51.\n\n- CVE-2020-21827: A heap based buffer overflow vulnerability exists in GNU LibreDWG 0.10 via read_2004_compressed_section ../../src/decode.c:2379.\n\n- CVE-2020-21830: A heap based buffer overflow vulneraibility exists in GNU LibreDWG 0.10 via bit_calc_CRC ../../src/bits.c:2213.\n\n- CVE-2020-21831: A heap based buffer overflow vulnerability exists in GNU LibreDWG 0.10 via read_2004_section_handles ../../src/decode.c:2637.\n\n- CVE-2020-21832: A heap based buffer overflow vulnerability exists in GNU LibreDWG 0.10 via read_2004_compressed_section ../../src/decode.c:2417.\n\n- CVE-2020-21833: A heap based buffer overflow vulnerability exits in GNU LibreDWG 0.10 via: read_2004_section_classes ../../src/decode.c:2440.\n\n- CVE-2020-21838: A heap based buffer overflow vulnerability exits in GNU LibreDWG 0.10 via: read_2004_section_appinfo ../../src/decode.c:2842.\n\n- CVE-2020-21840: A heap based buffer overflow vulnerability exits in GNU LibreDWG 0.10 via bit_search_sentinel ../../src/bits.c:1985.\n\n- CVE-2020-21841: A heap based buffer overflow vulnerability exits in GNU LibreDWG 0.10 via bit_read_B ../../src/bits.c:135.\n\n- CVE-2020-21842: A heap based buffer overflow vulnerability exists in GNU LibreDWG 0.10 via read_2004_section_revhistory ../../src/decode.c:3051.\n\n- CVE-2020-21843: A heap based buffer overflow vulnerability exits in GNU LibreDWG 0.10 via bit_read_RC ../../src/bits.c:318.\n\n- CVE-2020-22016: A heap-based Buffer Overflow vulnerability in FFmpeg 4.2 at libavcodec/get_bits.h when writing .mov files, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22017: A heap-based Buffer Overflow vulnerability exists in FFmpeg 4.2 at ff_fill_rectangle in libavfilter/drawutils.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22022: A heap-based Buffer Overflow vulnerability exists in FFmpeg 4.2 in filter_frame at libavfilter/vf_fieldorder.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22023: A heap-based Buffer Overflow vulnerabililty exists in FFmpeg 4.2 in filter_frame at libavfilter/vf_bitplanenoise.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22025: A heap-based Buffer Overflow vulnerability exists in gaussian_blur at libavfilter/vf_edgedetect.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22027: A heap-based Buffer Overflow vulnerability exits in FFmpeg 4.2 in deflate16 at libavfilter/vf_neighbor.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22029: A heap-based Buffer Overflow vulnerability exists in FFmpeg 4.2 at libavfilter/vf_colorconstancy.c: in slice_get_derivative, which crossfade_samples_fltp, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22030: A heap-based Buffer Overflow vulnerability exists in FFmpeg 4.2 at libavfilter/af_afade.c in crossfade_samples_fltp, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22031: A Heap-based Buffer Overflow vulnerability exists in FFmpeg 4.2 at libavfilter/vf_w3fdif.c in filter16_complex_low, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22032: A heap-based Buffer Overflow vulnerability exists FFmpeg 4.2 at libavfilter/vf_edgedetect.c in gaussian_blur, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22033: A heap-based Buffer Overflow Vulnerability exists FFmpeg 4.2 at libavfilter/vf_vmafmotion.c in convolution_y_8bit, which could let a remote malicious user cause a Denial of Service.\n\n- CVE-2020-22034: A heap-based Buffer Overflow vulnerability exists FFmpeg 4.2 at libavfilter/vf_floodfill.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22035: A heap-based Buffer Overflow vulnerability exists in FFmpeg 4.2 in get_block_row at libavfilter/vf_bm3d.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22036: A heap-based Buffer Overflow vulnerability exists in FFmpeg 4.2 in filter_intra at libavfilter/vf_bwdif.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22675: An issue was discovered in gpac 0.8.0. The GetGhostNum function in stbl_read.c has a heap-based buffer overflow which can lead to a denial of service (DOS) via a crafted input.\n\n- CVE-2020-22677: An issue was discovered in gpac 0.8.0. The dump_data_hex function in box_dump.c has a heap-based buffer overflow which can lead to a denial of service (DOS) via a crafted input.\n\n- CVE-2020-22678: An issue was discovered in gpac 0.8.0. The gf_media_nalu_remove_emulation_bytes function in av_parsers.c has a heap-based buffer overflow which can lead to a denial of service (DOS) via a crafted input.\n\n- CVE-2020-23266: An issue was discovered in gpac 0.8.0. The OD_ReadUTF8String function in odf_code.c has a heap-based buffer overflow which can lead to a denial of service (DOS) via a crafted media file.\n\n- CVE-2020-23267: An issue was discovered in gpac 0.8.0. The gf_hinter_track_process function in isom_hinter_track_process.c has a heap-based buffer overflow which can lead to a denial of service (DOS) via a crafted media file\n\n- CVE-2020-23269: An issue was discovered in gpac 0.8.0. The stbl_GetSampleSize function in isomedia/stbl_read.c has a heap-based buffer overflow which can lead to a denial of service (DOS) via a crafted media file.\n\n- CVE-2020-23332: A heap-based buffer overflow exists in the AP4_StdcFileByteStream::ReadPartial component located in /StdC/Ap4StdCFileByteStream.cpp of Bento4 version 06c39d9. This issue can lead to a denial of service (DOS).\n\n- CVE-2020-23333: A heap-based buffer overflow exists in the AP4_CttsAtom::AP4_CttsAtom component located in /Core/Ap4Utils.h of Bento4 version 06c39d9. This can lead to a denial of service (DOS).\n\n- CVE-2020-23706: A heap-based buffer overflow vulnerability in the function ok_jpg_decode_block_subsequent_scan() ok_jpg.c:1102 of ok-file-formats through 2020-06-26 allows attackers to cause a Denial of Service (DOS) via a crafted jpeg file.\n\n- CVE-2020-23707: A heap-based buffer overflow vulnerability in the function ok_jpg_decode_block_progressive() at ok_jpg.c:1054 of ok-file-formats through 2020-06-26 allows attackers to cause a Denial of Service (DOS) via a crafted jpeg file.\n\n- CVE-2020-23852: A heap based buffer overflow vulnerability exists in ffjpeg through 2020-07-02 in the jfif_decode(void *ctxt, BMP *pb) function at ffjpeg/src/jfif.c (line 544 & line 545), which could cause a denial of service by submitting a malicious jpeg image.\n\n- CVE-2020-23861: A heap-based buffer overflow vulnerability exists in LibreDWG 0.10.1 via the read_system_page function at libredwg-0.10.1/src/decode_r2007.c:666:5, which causes a denial of service by submitting a dwg file.\n\n- CVE-2020-23886: XnView MP v0.96.4 was discovered to contain a heap overflow which allows attackers to cause a denial of service (DoS) via a crafted pict file. Related to a User Mode Write AV starting at ntdll!RtlpLowFragHeapFree.\n\n- CVE-2020-23887: XnView MP v0.96.4 was discovered to contain a heap overflow which allows attackers to cause a denial of service (DoS) via a crafted ico file. Related to a Read Access Violation starting at USER32!SmartStretchDIBits+0x33.\n\n- CVE-2020-23907: An issue was discovered in retdec v3.3. In function canSplitFunctionOn() of ir_modifications.cpp, there is a possible out of bounds read due to a heap buffer overflow. The impact is: Deny of Service, Memory Disclosure, and Possible Code Execution.\n\n- CVE-2020-24133: A heap buffer overflow vulnerability in the r_asm_swf_disass function of Radare2-extras before commit e74a93c allows attackers to execute arbitrary code or carry out denial of service (DOS) attacks.\n\n- CVE-2020-24829: An issue was discovered in GPAC v0.8.0, as demonstrated by MP4Box. It contains a heap-based buffer overflow in gf_m2ts_section_complete in media_tools/mpegts.c that can cause a denial of service (DOS) via a crafted MP4 file.\n\n- CVE-2020-26797: Mediainfo before version 20.08 has a heap buffer overflow vulnerability via MediaInfoLib::File_Gxf::ChooseParser_ChannelGrouping.\n\n- CVE-2020-28011: Exim 4 before 4.94.2 allows Heap-based Buffer Overflow in queue_run via two sender options: -R and -S. This may cause privilege escalation from exim to root.\n\n- CVE-2020-28013: Exim 4 before 4.94.2 allows Heap-based Buffer Overflow because it mishandles \"-F '.('\" on the command line, and thus may allow privilege escalation from any user to root. This occurs because of the interpretation of negative sizes in strncpy.\n\n- CVE-2020-28592: A heap-based buffer overflow vulnerability exists in the configuration server functionality of the Cosori Smart 5.8-Quart Air Fryer CS158-AF 1.1.0. A specially crafted JSON object can lead to remote code execution. An attacker can send a malicious packet to trigger this vulnerability.\n\n- CVE-2020-29614: This issue was addressed with improved checks. This issue is fixed in macOS Big Sur 11.2, Security Update 2021-001 Catalina, Security Update 2021-001 Mojave, macOS Big Sur 11.1, Security Update 2020-001 Catalina, Security Update 2020-007 Mojave, iOS 14.3 and iPadOS 14.3, tvOS 14.3. Processing a maliciously crafted file may lead to heap corruption.\n\n- CVE-2020-35979: An issue was discovered in GPAC version 0.8.0 and 1.0.1. There is heap-based buffer overflow in the function gp_rtp_builder_do_avc() in ietf/rtp_pck_mpeg4.c.\n\n- CVE-2020-36400: ZeroMQ libzmq 4.3.3 has a heap-based buffer overflow in zmq::tcp_read, a different vulnerability than CVE-2021-20235.\n\n- CVE-2020-36428: matio (aka MAT File I/O Library) 1.5.18 through 1.5.21 has a heap-based buffer overflow in ReadInt32DataDouble (called from ReadInt32Data and Mat_VarRead4).\n\n- CVE-2020-36430: libass 0.15.x before 0.15.1 has a heap-based buffer overflow in decode_chars (called from decode_font and process_text) because the wrong integer data type is used for subtraction.\n\n- CVE-2020-7461: In FreeBSD 12.1-STABLE before r365010, 11.4-STABLE before r365011, 12.1-RELEASE before p9, 11.4-RELEASE before p3, and 11.3-RELEASE before p13, dhclient(8) fails to handle certain malformed input related to handling of DHCP option 119 resulting a heap overflow. The heap overflow could in principle be exploited to achieve remote code execution. The affected process runs with reduced privileges in a Capsicum sandbox, limiting the immediate impact of an exploit.\n\n- CVE-2021-0325: In ih264d_parse_pslice of ih264d_parse_pslice.c, there is a possible out of bounds write due to a heap buffer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-8.1 Android-9 Android-10 Android-11Android ID: A-174238784\n\n- CVE-2021-0353: In kisd, there is a possible memory corruption due to a heap buffer overflow. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Product: Android; Versions: Android-11; Patch ID: ALPS05425247.\n\n- CVE-2021-0426: In parsePrimaryFieldFirstUidAnnotation of LogEvent.cpp, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11Android ID: A-174485572\n\n- CVE-2021-0427: In parseExclusiveStateAnnotation of LogEvent.cpp, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11Android ID: A-174488848\n\n- CVE-2021-0457: In the FingerTipS touch screen driver, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-157155375\n\n- CVE-2021-0464: In sound_trigger_event_alloc of platform.h, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-167663878\n\n- CVE-2021-0474: In avrc_msg_cback of avrc_api.cc, there is a possible out of bounds write due to a heap buffer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11 Android-8.1 Android-9 Android-10Android ID: A-177611958\n\n- CVE-2021-0512: In __hidinput_change_resolution_multipliers of hid-input.c, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-173843328References: Upstream kernel\n\n- CVE-2021-0519: In BITSTREAM_FLUSH of ih264e_bitstream.h, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-8.1 Android-9Android ID: A-176533109\n\n- CVE-2021-0577: In flv extractor, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-187161771\n\n- CVE-2021-0690: In ih264d_mark_err_slice_skip of ih264d_parse_pslice.c, there is a possible out of bounds write due to a heap buffer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-9 Android-10 Android-11 Android-8.1Android ID: A-182152757\n\n- CVE-2021-1767: This issue was addressed with improved checks. This issue is fixed in macOS Big Sur 11.2, Security Update 2021-001 Catalina, Security Update 2021-001 Mojave, iOS 14.4 and iPadOS 14.4. Processing a maliciously crafted image may lead to heap corruption.\n\n- CVE-2021-1883: This issue was addressed with improved checks. This issue is fixed in Security Update 2021-004 Mojave, iOS 14.5 and iPadOS 14.5, watchOS 7.4, Security Update 2021-003 Catalina, tvOS 14.5, macOS Big Sur 11.3. Processing maliciously crafted server messages may lead to heap corruption.\n\n- CVE-2021-1975: Possible heap overflow due to improper length check of domain while parsing the DNS response in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2021-20194: There is a vulnerability in the linux kernel versions higher than 5.2 (if kernel compiled with config params CONFIG_BPF_SYSCALL=y , CONFIG_BPF=y , CONFIG_CGROUPS=y , CONFIG_CGROUP_BPF=y , CONFIG_HARDENED_USERCOPY not set, and BPF hook to getsockopt is registered). As result of BPF execution, the local user can trigger bug in __cgroup_bpf_run_filter_getsockopt() function that can lead to heap overflow (because of non-hardened usercopy). The impact of attack could be deny of service or possibly privileges escalation.\n\n- CVE-2021-20284: A flaw was found in GNU Binutils 2.35.1, where there is a heap-based buffer overflow in _bfd_elf_slurp_secondary_reloc_section in elf.c due to the number of symbols not calculated correctly. The highest threat from this vulnerability is to system availability.\n\n- CVE-2021-20494: IBM Security Identity Manager Adapters 6.0 and 7.0 are vulnerable to a heap based buffer overflow, caused by improper bounds. An authenticared user could overflow the buffer and cause the service to crash. IBM X-Force ID: 197882.\n\n- CVE-2021-20573: IBM Security Identity Manager Adapters 6.0 and 7.0 are vulnerable to a heap-based buffer overflow, caused by improper bounds checking. A remote authenticated attacker could overflow the and cause the server to crash. IBM X-Force ID: 199249.\n\n- CVE-2021-20587: Heap-based buffer overflow vulnerability in Mitsubishi Electric FA Engineering Software (CPU Module Logging Configuration Tool versions 1.112R and prior, CW Configurator versions 1.011M and prior, Data Transfer versions 3.44W and prior, EZSocket versions 5.4 and prior, FR Configurator all versions, FR Configurator SW3 all versions, FR Configurator2 versions 1.24A and prior, GT Designer3 Version1(GOT1000) versions 1.250L and prior, GT Designer3 Version1(GOT2000) versions 1.250L and prior, GT SoftGOT1000 Version3 versions 3.245F and prior, GT SoftGOT2000 Version1 versions 1.250L and prior, GX Configurator-DP versions 7.14Q and prior, GX Configurator-QP all versions, GX Developer versions 8.506C and prior, GX Explorer all versions, GX IEC Developer all versions, GX LogViewer versions 1.115U and prior, GX RemoteService-I all versions, GX Works2 versions 1.597X and prior, GX Works3 versions 1.070Y and prior, iQ Monozukuri ANDON (Data Transfer) all versions, iQ Monozukuri Process Remote Monitoring (Data Transfer) all versions, M_CommDTM-HART all versions, M_CommDTM-IO-Link versions 1.03D and prior, MELFA-Works versions 4.4 and prior, MELSEC WinCPU Setting Utility all versions, MELSOFT EM Software Development Kit (EM Configurator) versions 1.015R and prior, MELSOFT Navigator versions 2.74C and prior, MH11 SettingTool Version2 versions 2.004E and prior, MI Configurator versions 1.004E and prior, MT Works2 versions 1.167Z and prior, MX Component versions 5.001B and prior, Network Interface Board CC IE Control utility versions 1.29F and prior, Network Interface Board CC IE Field Utility versions 1.16S and prior, Network Interface Board CC-Link Ver.2 Utility versions 1.23Z and prior, Network Interface Board MNETH utility versions 34L and prior, PX Developer versions 1.53F and prior, RT ToolBox2 versions 3.73B and prior, RT ToolBox3 versions 1.82L and prior, Setting/monitoring tools for the C Controller module (SW4PVC-CCPU) versions 4.12N and prior and SLMP Data Collector versions 1.04E and prior) allows a remote unauthenticated attacker to cause a DoS condition of the software products, and possibly to execute a malicious program on the personal computer running the software products although it has not been reproduced, by spoofing MELSEC, GOT or FREQROL and returning crafted reply packets.\n\n- CVE-2021-21017: Acrobat Reader DC versions versions 2020.013.20074 (and earlier), 2020.001.30018 (and earlier) and 2017.011.30188 (and earlier) are affected by a heap-based buffer overflow vulnerability. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-21077: Adobe Animate version 21.0.3 (and earlier) is affected by a Heap-based Buffer Overflow vulnerability. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-21113: Heap buffer overflow in Skia in Google Chrome prior to 87.0.4280.141 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21116: Heap buffer overflow in audio in Google Chrome prior to 87.0.4280.141 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21128: Heap buffer overflow in Blink in Google Chrome prior to 88.0.4324.96 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21143: Heap buffer overflow in Extensions in Google Chrome prior to 88.0.4324.146 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2021-21144: Heap buffer overflow in Tab Groups in Google Chrome prior to 88.0.4324.146 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2021-21148: Heap buffer overflow in V8 in Google Chrome prior to 88.0.4324.150 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21152: Heap buffer overflow in Media in Google Chrome on Linux prior to 88.0.4324.182 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21154: Heap buffer overflow in Tab Strip in Google Chrome prior to 88.0.4324.182 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2021-21155: Heap buffer overflow in Tab Strip in Google Chrome on Windows prior to 88.0.4324.182 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2021-21156: Heap buffer overflow in V8 in Google Chrome prior to 88.0.4324.182 allowed a remote attacker to potentially exploit heap corruption via a crafted script.\n\n- CVE-2021-21160: Heap buffer overflow in WebAudio in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21161: Heap buffer overflow in TabStrip in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21192: Heap buffer overflow in tab groups in Google Chrome prior to 89.0.4389.90 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21196: Heap buffer overflow in TabStrip in Google Chrome on Windows prior to 89.0.4389.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21197: Heap buffer overflow in TabStrip in Google Chrome prior to 89.0.4389.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21222: Heap buffer overflow in V8 in Google Chrome prior to 90.0.4430.85 allowed a remote attacker who had compromised the renderer process to bypass site isolation via a crafted HTML page.\n\n- CVE-2021-21225: Out of bounds memory access in V8 in Google Chrome prior to 90.0.4430.85 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21233: Heap buffer overflow in ANGLE in Google Chrome on Windows prior to 90.0.4430.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21555: Dell PowerEdge R640, R740, R740XD, R840, R940, R940xa, MX740c, MX840c, and T640 Server BIOS contain a heap-based buffer overflow vulnerability in systems with NVDIMM-N installed. A local malicious user with high privileges may potentially exploit this vulnerability, leading to a denial of Service, arbitrary code execution, or information disclosure in UEFI or BIOS Preboot Environment.\n\n- CVE-2021-21795: A heap-based buffer overflow vulnerability exists in the PSD read_icc_icCurve_data functionality of Accusoft ImageGear 19.9. A specially crafted malformed file can lead to an integer overflow that, in turn, leads to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21808: A memory corruption vulnerability exists in the PNG png_palette_process functionality of Accusoft ImageGear 19.9. A specially crafted malformed file can lead to a heap buffer overflow. An attacker can provide malicious inputs to trigger this vulnerability.\n\n- CVE-2021-21810: A memory corruption vulnerability exists in the XML-parsing ParseAttribs functionality of AT&T Labs\u2019 Xmill 0.7. A specially crafted XML file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21811: A memory corruption vulnerability exists in the XML-parsing CreateLabelOrAttrib functionality of AT&T Labs\u2019 Xmill 0.7. A specially crafted XML file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21825: A heap-based buffer overflow vulnerability exists in the XML Decompression PlainTextUncompressor::UncompressItem functionality of AT&T Labs\u2019 Xmill 0.7. A specially crafted XMI file can lead to remote code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21826: A heap-based buffer overflow vulnerability exists in the XML Decompression DecodeTreeBlock functionality of AT&T Labs Xmill 0.7. Within `DecodeTreeBlock` which is called during the decompression of an XMI file, a UINT32 is loaded from the file and used as trusted input as the length of a buffer. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21827: A heap-based buffer overflow vulnerability exists in the XML Decompression DecodeTreeBlock functionality of AT&T Labs Xmill 0.7. Within `DecodeTreeBlock` which is called during the decompression of an XMI file, a UINT32 is loaded from the file and used as trusted input as the length of a buffer. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21828: A heap-based buffer overflow vulnerability exists in the XML Decompression DecodeTreeBlock functionality of AT&T Labs Xmill 0.7. In the default case of DecodeTreeBlock a label is created via CurPath::AddLabel in order to track the label for later reference. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21829: A heap-based buffer overflow vulnerability exists in the XML Decompression EnumerationUncompressor::UncompressItem functionality of AT&T Labs\u2019 Xmill 0.7. A specially crafted XMI file can lead to remote code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21830: A heap-based buffer overflow vulnerability exists in the XML Decompression LabelDict::Load functionality of AT&T Labs\u2019 Xmill 0.7. A specially crafted XMI file can lead to remote code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21897: A code execution vulnerability exists in the DL_Dxf::handleLWPolylineData functionality of Ribbonsoft dxflib 3.17.0. A specially-crafted .dxf file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21899: A code execution vulnerability exists in the dwgCompressor::copyCompBytes21 functionality of LibreCad libdxfrw 2.2.0-rc2-19-ge02f3580. A specially-crafted .dwg file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21940: A heap-based buffer overflow vulnerability exists in the pushMuxer processRtspInfo functionality of Anker Eufy Homebase 2 2.1.6.9h. A specially-crafted network packet can lead to a heap buffer overflow. An attacker can send a malicious packet to trigger this vulnerability.\n\n- CVE-2021-22427: There is a Heap-based Buffer Overflow Vulnerability in Huawei Smartphone.Successful exploitation of this vulnerability may lead to authentication bypass.\n\n- CVE-2021-22465: A component of the HarmonyOS has a Heap-based Buffer Overflow vulnerability. Local attackers may exploit this vulnerability to cause Kernel System unavailable.\n\n- CVE-2021-22641: A heap-based buffer overflow issue has been identified in the way the application processes project files, allowing an attacker to craft a special project file that may allow arbitrary code execution on the Tellus Lite V-Simulator and V-Server Lite (versions prior to 4.0.10.0).\n\n- CVE-2021-25289: An issue was discovered in Pillow before 8.1.1. TiffDecode has a heap-based buffer overflow when decoding crafted YCbCr files because of certain interpretation conflicts with LibTIFF in RGBA mode. NOTE: this issue exists because of an incomplete fix for CVE-2020-35654.\n\n- CVE-2021-25475: A possible heap-based buffer overflow vulnerability in DSP kernel driver prior to SMR Oct-2021 Release 1 allows arbitrary memory write and code execution.\n\n- CVE-2021-25479: A possible heap-based buffer overflow vulnerability in Exynos CP Chipset prior to SMR Oct-2021 Release 1 allows arbitrary memory write and code execution.\n\n- CVE-2021-25495: A possible heap buffer overflow vulnerability in libSPenBase library of Samsung Notes prior to Samsung Note version 4.3.02.61 allows arbitrary code execution.\n\n- CVE-2021-25832: A heap buffer overflow vulnerability inside of BMP image processing was found at [core] module of ONLYOFFICE DocumentServer v4.0.0-9-v6.0.0. Using this vulnerability, an attacker is able to gain remote code executions on DocumentServer.\n\n- CVE-2021-25900: An issue was discovered in the smallvec crate before 0.6.14 and 1.x before 1.6.1 for Rust. There is a heap-based buffer overflow in SmallVec::insert_many.\n\n- CVE-2021-26096: Multiple instances of heap-based buffer overflow in the command shell of FortiSandbox before 4.0.0 may allow an authenticated attacker to manipulate memory and alter its content by means of specifically crafted command line arguments.\n\n- CVE-2021-26603: A heap overflow issue was found in ARK library of bandisoft Co., Ltd when the Ark_DigPathA function parsed a file path. This vulnerability is due to missing support for string length check.\n\n- CVE-2021-26691: In Apache HTTP Server versions 2.4.0 to 2.4.46 a specially crafted SessionHeader sent by an origin server could cause a heap overflow\n\n- CVE-2021-26951: An issue was discovered in the calamine crate before 0.17.0 for Rust. It allows attackers to overwrite heap-memory locations because Vec::set_len is used without proper memory claiming, and this uninitialized memory is used for a user-provided Read operation, as demonstrated by Sectors::get.\n\n- CVE-2021-27034: A heap-based buffer overflow could occur while parsing PICT, PCX, RCL or TIFF files in Autodesk Design Review 2018, 2017, 2013, 2012, 2011. This vulnerability can be exploited to execute arbitrary code.\n\n- CVE-2021-27954: A heap-based buffer overflow vulnerability exists on the ecobee3 lite 4.5.81.200 device in the HKProcessConfig function of the HomeKit Wireless Access Control setup process. A threat actor can exploit this vulnerability to force the device to connect to a SSID or cause a denial of service.\n\n- CVE-2021-28026: jpeg-xl v0.3.2 is affected by a heap buffer overflow in /lib/jxl/coeff_order.cc ReadPermutation. When decoding a malicous jxl file using djxl, an attacker can trigger arbitrary code execution or a denial of service.\n\n- CVE-2021-28211: A heap overflow in LzmaUefiDecompressGetInfo function in EDK II.\n\n- CVE-2021-28233: Heap-based Buffer Overflow vulnerability exists in ok-file-formats 1 via the ok_jpg_generate_huffman_table function in ok_jpg.c.\n\n- CVE-2021-28603: Adobe After Effects version 18.2 (and earlier) is affected by a Heap-based Buffer Overflow vulnerability when parsing a specially crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-28604: Adobe After Effects version 18.2 (and earlier) is affected by a Heap-based Buffer Overflow vulnerability when parsing a specially crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-28607: Adobe After Effects version 18.2 (and earlier) is affected by a heap corruption vulnerability when parsing a specially crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-28608: Adobe After Effects version 18.2 (and earlier) is affected by a Heap-based Buffer Overflow vulnerability when parsing a specially crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-28610: Adobe After Effects version 18.2 (and earlier) is affected by a Heap-based Buffer Overflow vulnerability when parsing a specially crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-29323: OpenSource Moddable v10.5.0 was discovered to contain a heap buffer overflow via the component /modules/network/wifi/esp/modwifi.c.\n\n- CVE-2021-29325: OpenSource Moddable v10.5.0 was discovered to contain a heap buffer overflow in the fx_String_prototype_repeat function at /moddable/xs/sources/xsString.c.\n\n- CVE-2021-29326: OpenSource Moddable v10.5.0 was discovered to contain a heap buffer overflow in the fxIDToString function at /moddable/xs/sources/xsSymbol.c.\n\n- CVE-2021-29327: OpenSource Moddable v10.5.0 was discovered to contain a heap buffer overflow in the fx_ArrayBuffer function at /moddable/xs/sources/xsDataView.c.\n\n- CVE-2021-29464: Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. A heap buffer overflow was found in Exiv2 versions v0.27.3 and earlier. The heap overflow is triggered when Exiv2 is used to write metadata into a crafted image file. An attacker could potentially exploit the vulnerability to gain code execution, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when writing the metadata, which is a less frequently used Exiv2 operation than reading the metadata. For example, to trigger the bug in the Exiv2 command-line application, you need to add an extra command-line argument such as `insert`. The bug is fixed in version v0.27.4.\n\n- CVE-2021-29512: TensorFlow is an end-to-end open source platform for machine learning. If the `splits` argument of `RaggedBincount` does not specify a valid `SparseTensor`(https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor), then an attacker can trigger a heap buffer overflow. This will cause a read from outside the bounds of the `splits` tensor buffer in the implementation of the `RaggedBincount` op(https://github.com/tensorflow/tensorflow/blob/8b677d79167799f71c42fd3fa074476e0295413a/tensorflow/core/kernels/bincount_op.cc#L430-L433). Before the `for` loop, `batch_idx` is set to 0. The user controls the `splits` array, making it contain only one element, 0. Thus, the code in the `while` loop would increment `batch_idx` and then try to read `splits(1)`, which is outside of bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3, as these are also affected.\n\n- CVE-2021-29514: TensorFlow is an end-to-end open source platform for machine learning. If the `splits` argument of `RaggedBincount` does not specify a valid `SparseTensor`(https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor), then an attacker can trigger a heap buffer overflow. This will cause a read from outside the bounds of the `splits` tensor buffer in the implementation of the `RaggedBincount` op(https://github.com/tensorflow/tensorflow/blob/8b677d79167799f71c42fd3fa074476e0295413a/tensorflow/core/kernels/bincount_op.cc#L430-L446). Before the `for` loop, `batch_idx` is set to 0. The attacker sets `splits(0)` to be 7, hence the `while` loop does not execute and `batch_idx` remains 0. This then results in writing to `out(-1, bin)`, which is before the heap allocated buffer for the output tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3, as these are also affected.\n\n- CVE-2021-29520: TensorFlow is an end-to-end open source platform for machine learning. Missing validation between arguments to `tf.raw_ops.Conv3DBackprop*` operations can result in heap buffer overflows. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/4814fafb0ca6b5ab58a09411523b2193fed23fed/tensorflow/core/kernels/conv_grad_shape_utils.cc#L94-L153) assumes that the `input`, `filter_sizes` and `out_backprop` tensors have the same shape, as they are accessed in parallel. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29535: TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedMul` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/87cf4d3ea9949051e50ca3f071fc909538a51cd0/tensorflow/core/kernels/quantized_mul_op.cc#L287-L290) assumes that the 4 arguments are always valid scalars and tries to access the numeric value directly. However, if any of these tensors is empty, then `.flat<T>()` is an empty buffer and accessing the element at position 0 results in overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29536: TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedReshape` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a324ac84e573fba362a5e53d4e74d5de6729933e/tensorflow/core/kernels/quantized_reshape_op.cc#L38-L55) assumes that the 2 arguments are always valid scalars and tries to access the numeric value directly. However, if any of these tensors is empty, then `.flat<T>()` is an empty buffer and accessing the element at position 0 results in overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29537: TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedResizeBilinear` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/50711818d2e61ccce012591eeb4fdf93a8496726/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L705-L706) assumes that the 2 arguments are always valid scalars and tries to access the numeric value directly. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29540: TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow to occur in `Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1b0296c3b8dd9bd948f924aa8cd62f87dbb7c3da/tensorflow/core/kernels/conv_grad_filter_ops.cc#L495-L497) computes the size of the filter tensor but does not validate that it matches the number of elements in `filter_sizes`. Later, when reading/writing to this buffer, code uses the value computed here, instead of the number of elements in the tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29542: TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow by passing crafted inputs to `tf.raw_ops.StringNGrams`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1cdd4da14282210cc759e468d9781741ac7d01bf/tensorflow/core/kernels/string_ngrams_op.cc#L171-L185) fails to consider corner cases where input would be split in such a way that the generated tokens should only contain padding elements. If input is such that `num_tokens` is 0, then, for `data_start_index=0` (when left padding is present), the marked line would result in reading `data[-1]`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29558: TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `tf.raw_ops.SparseSplit`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/699bff5d961f0abfde8fa3f876e6d241681fbef8/tensorflow/core/util/sparse/sparse_tensor.h#L528-L530) accesses an array element based on a user controlled offset. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29560: TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `tf.raw_ops.RaggedTensorToTensor`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/d94227d43aa125ad8b54115c03cece54f6a1977b/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L219-L222) uses the same index to access two arrays in parallel. Since the user controls the shape of the input arguments, an attacker could trigger a heap OOB access when `parent_output_index` is shorter than `row_split`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29576: TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPool3DGradGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/596c05a159b6fbb9e39ca10b3f7753b7244fa1e9/tensorflow/core/kernels/pooling_ops_3d.cc#L694-L696) does not check that the initialization of `Pool3dParameters` completes successfully. Since the constructor(https://github.com/tensorflow/tensorflow/blob/596c05a159b6fbb9e39ca10b3f7753b7244fa1e9/tensorflow/core/kernels/pooling_ops_3d.cc#L48-L88) uses `OP_REQUIRES` to validate conditions, the first assertion that fails interrupts the initialization of `params`, making it contain invalid data. In turn, this might cause a heap buffer overflow, depending on default initialized values. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29577: TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.AvgPool3DGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/d80ffba9702dc19d1fac74fc4b766b3fa1ee976b/tensorflow/core/kernels/pooling_ops_3d.cc#L376-L450) assumes that the `orig_input_shape` and `grad` tensors have similar first and last dimensions but does not check that this assumption is validated. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29578: TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.FractionalAvgPoolGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/dcba796a28364d6d7f003f6fe733d82726dda713/tensorflow/core/kernels/fractional_avg_pool_op.cc#L216) fails to validate that the pooling sequence arguments have enough elements as required by the `out_backprop` tensor shape. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29579: TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/ab1e644b48c82cb71493f4362b4dd38f4577a1cf/tensorflow/core/kernels/maxpooling_op.cc#L194-L203) fails to validate that indices used to access elements of input/output arrays are valid. Whereas accesses to `input_backprop_flat` are guarded by `FastBoundsCheck`, the indexing in `out_backprop_flat` can result in OOB access. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29998: An issue was discovered in Wind River VxWorks before 6.5. There is a possible heap overflow in dhcp client.\n\n- CVE-2021-30019: In the adts_dmx_process function in filters/reframe_adts.c in GPAC 1.0.1, a crafted file may cause ctx->hdr.frame_size to be smaller than ctx->hdr.hdr_size, resulting in size to be a negative number and a heap overflow in the memcpy.\n\n- CVE-2021-30020: In the function gf_hevc_read_pps_bs_internal function in media_tools/av_parsers.c in GPAC 1.0.1 there is a loop, which with crafted file, pps->num_tile_columns may be larger than sizeof(pps->column_width), which results in a heap overflow in the loop.\n\n- CVE-2021-30186: CODESYS V2 runtime system SP before 2.4.7.55 has a Heap-based Buffer Overflow.\n\n- CVE-2021-30498: A flaw was found in libcaca. A heap buffer overflow in export.c in function export_tga might lead to memory corruption and other potential consequences.\n\n- CVE-2021-30508: Heap buffer overflow in Media Feeds in Google Chrome prior to 90.0.4430.212 allowed an attacker who convinced a user to enable certain features in Chrome to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30516: Heap buffer overflow in History in Google Chrome prior to 90.0.4430.212 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30518: Heap buffer overflow in Reader Mode in Google Chrome prior to 90.0.4430.212 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30521: Heap buffer overflow in Autofill in Google Chrome on Android prior to 91.0.4472.77 allowed a remote attacker to perform out of bounds memory access via a crafted HTML page.\n\n- CVE-2021-30559: Out of bounds write in ANGLE in Google Chrome prior to 91.0.4472.164 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30564: Heap buffer overflow in WebXR in Google Chrome prior to 91.0.4472.164 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30568: Heap buffer overflow in WebGL in Google Chrome prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30575: Out of bounds write in Autofill in Google Chrome prior to 92.0.4515.107 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30590: Heap buffer overflow in Bookmarks in Google Chrome prior to 92.0.4515.131 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30614: Chromium: CVE-2021-30614 Heap buffer overflow in TabStrip\n\n- CVE-2021-30632: Out of bounds write in V8 in Google Chrome prior to 93.0.4577.82 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-31254: Buffer overflow in the tenc_box_read function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file, related invalid IV sizes.\n\n- CVE-2021-31320: Telegram Android <7.1.0 (2090), Telegram iOS <7.1, and Telegram macOS <7.1 are affected by a Heap Buffer Overflow in the VGradientCache::generateGradientColorTable function of their custom fork of the rlottie library. A remote attacker might be able to overwrite heap memory out-of-bounds on a victim device via a malicious animated sticker.\n\n- CVE-2021-31322: Telegram Android <7.1.0 (2090), Telegram iOS <7.1, and Telegram macOS <7.1 are affected by a Heap Buffer Overflow in the LOTGradient::populate function of their custom fork of the rlottie library. A remote attacker might be able to access heap memory out-of-bounds on a victim device via a malicious animated sticker.\n\n- CVE-2021-31323: Telegram Android <7.1.0 (2090), Telegram iOS <7.1, and Telegram macOS <7.1 are affected by a Heap Buffer Overflow in the LottieParserImpl::parseDashProperty function of their custom fork of the rlottie library. A remote attacker might be able to access heap memory out-of-bounds on a victim device via a malicious animated sticker.\n\n- CVE-2021-31598: An issue was discovered in libezxml.a in ezXML 0.8.6. The function ezxml_decode() performs incorrect memory handling while parsing crafted XML files, leading to a heap-based buffer overflow.\n\n- CVE-2021-32136: Heap buffer overflow in the print_udta function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.\n\n- CVE-2021-32137: Heap buffer overflow in the URL_GetProtocolType function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.\n\n- CVE-2021-32263: ok-file-formats through 2021-04-29 has a heap-based buffer overflow in the ok_csv_circular_buffer_read function in ok_csv.c.\n\n- CVE-2021-3246: A heap buffer overflow vulnerability in msadpcm_decode_block of libsndfile 1.0.30 allows attackers to execute arbitrary code via a crafted WAV file.\n\n- CVE-2021-32484: In modem 2G RRM, there is a possible system crash due to a heap buffer overflow. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: MOLY00500621; Issue ID: ALPS04964917.\n\n- CVE-2021-32485: In modem 2G RRM, there is a possible system crash due to a heap buffer overflow. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: MOLY00500621; Issue ID: ALPS04964926.\n\n- CVE-2021-32486: In modem 2G RRM, there is a possible system crash due to a heap buffer overflow. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: MOLY00500621; Issue ID: ALPS04964928.\n\n- CVE-2021-32487: In modem 2G RRM, there is a possible system crash due to a heap buffer overflow. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: MOLY00500736; Issue ID: ALPS04938456.\n\n- CVE-2021-32493: A flaw was found in djvulibre-3.5.28 and earlier. A heap buffer overflow in function DJVU::GBitmap::decode() via crafted djvu file may lead to application crash and other consequences.\n\n- CVE-2021-33000: Parsing a maliciously crafted project file may cause a heap-based buffer overflow, which may allow an attacker to perform arbitrary code execution. User interaction is required on the WebAccess HMI Designer (versions 2.1.9.95 and prior).\n\n- CVE-2021-33023: Advantech WebAccess versions 9.02 and prior are vulnerable to a heap-based buffer overflow, which may allow an attacker to remotely execute code.\n\n- CVE-2021-33285: In NTFS-3G versions < 2021.8.22, when a specially crafted NTFS attribute is supplied to the function ntfs_get_attribute_value, a heap buffer overflow can occur allowing for memory disclosure or denial of service. The vulnerability is caused by an out-of-bound buffer access which can be triggered by mounting a crafted ntfs partition. The root cause is a missing consistency check after reading an MFT record : the \"bytes_in_use\" field should be less than the \"bytes_allocated\" field. When it is not, the parsing of the records proceeds into the wild.\n\n- CVE-2021-33286: In NTFS-3G versions < 2021.8.22, when a specially crafted unicode string is supplied in an NTFS image a heap buffer overflow can occur and allow for code execution.\n\n- CVE-2021-33287: In NTFS-3G versions < 2021.8.22, when specially crafted NTFS attributes are read in the function ntfs_attr_pread_i, a heap buffer overflow can occur and allow for writing to arbitrary memory or denial of service of the application.\n\n- CVE-2021-33289: In NTFS-3G versions < 2021.8.22, when a specially crafted MFT section is supplied in an NTFS image a heap buffer overflow can occur and allow for code execution.\n\n- CVE-2021-3345: _gcry_md_block_write in cipher/hash-common.c in Libgcrypt version 1.9.0 has a heap-based buffer overflow when the digest final function sets a large count value. It is recommended to upgrade to 1.9.1 or later.\n\n- CVE-2021-33485: CODESYS Control Runtime system before 3.5.17.10 has a Heap-based Buffer Overflow.\n\n- CVE-2021-3404: In ytnef 1.9.3, the SwapWord function in lib/ytnef.c allows remote attackers to cause a denial-of-service (and potentially code execution) due to a heap buffer overflow which can be triggered via a crafted file.\n\n- CVE-2021-3405: A flaw was found in libebml before 1.4.2. A heap overflow bug exists in the implementation of EbmlString::ReadData and EbmlUnicodeString::ReadData in libebml.\n\n- CVE-2021-34067: Heap based buffer overflow in tsMuxer 2.6.16 allows attackers to cause a Denial of Service (DoS) by running the application with a crafted file.\n\n- CVE-2021-34068: Heap based buffer overflow in tsMuxer 2.6.16 allows attackers to cause a Denial of Service (DoS) by running the application with a crafted file.\n\n- CVE-2021-34071: Heap based buffer overflow in tsMuxer 2.6.16 allows attackers to cause a Denial of Service (DoS) by running the application with a crafted file.\n\n- CVE-2021-34373: Trusty trusted Linux kernel (TLK) contains a vulnerability in the NVIDIA TLK kernel where a lack of heap hardening could cause heap overflows, which might lead to information disclosure and denial of service.\n\n- CVE-2021-34380: Bootloader contains a vulnerability in NVIDIA MB2 where potential heap overflow might cause corruption of the heap metadata, which might lead to arbitrary code execution, denial of service, and information disclosure during secure boot.\n\n- CVE-2021-34383: Bootloader contains a vulnerability in NVIDIA MB2 where a potential heap overflow might lead to denial of service or escalation of privileges.\n\n- CVE-2021-34384: Bootloader contains a vulnerability in NVIDIA MB2 where a potential heap overflow could cause memory corruption, which might lead to denial of service or code execution.\n\n- CVE-2021-34388: Bootloader contains a vulnerability in NVIDIA TegraBoot where a potential heap overflow might allow an attacker to control all the RAM after the heap block, leading to denial of service or code execution.\n\n- CVE-2021-3470: A heap overflow issue was found in Redis in versions before 5.0.10, before 6.0.9 and before 6.2.0 when using a heap allocator other than jemalloc or glibc's malloc, leading to potential out of bound write or process crash. Effectively this flaw does not affect the vast majority of users, who use jemalloc or glibc malloc.\n\n- CVE-2021-3491: The io_uring subsystem in the Linux kernel allowed the MAX_RW_COUNT limit to be bypassed in the PROVIDE_BUFFERS operation, which led to negative values being usedin mem_rw when reading /proc/<PID>/mem. This could be used to create a heap overflow leading to arbitrary code execution in the kernel. It was addressed via commit d1f82808877b (\"io_uring: truncate lengths larger than MAX_RW_COUNT on provide buffers\") (v5.13-rc1) and backported to the stable kernels in v5.12.4, v5.11.21, and v5.10.37. It was introduced in ddf0322db79c (\"io_uring: add IORING_OP_PROVIDE_BUFFERS\") (v5.7-rc1).\n\n- CVE-2021-3496: A heap-based buffer overflow was found in jhead in version 3.06 in Get16u() in exif.c when processing a crafted file.\n\n- CVE-2021-3498: GStreamer before 1.18.4 might cause heap corruption when parsing certain malformed Matroska files.\n\n- CVE-2021-3507: A heap buffer overflow was found in the floppy disk emulator of QEMU up to 6.0.0 (including). It could occur in fdctrl_transfer_handler() in hw/block/fdc.c while processing DMA read data transfers from the floppy drive to the guest system. A privileged guest user could use this flaw to crash the QEMU process on the host resulting in DoS scenario, or potential information leakage from the host memory.\n\n- CVE-2021-35266: In NTFS-3G versions < 2021.8.22, when a specially crafted NTFS inode pathname is supplied in an NTFS image a heap buffer overflow can occur resulting in memory disclosure, denial of service and even code execution.\n\n- CVE-2021-35268: In NTFS-3G versions < 2021.8.22, when a specially crafted NTFS inode is loaded in the function ntfs_inode_real_open, a heap buffer overflow can occur allowing for code execution and escalation of privileges.\n\n- CVE-2021-35269: NTFS-3G versions < 2021.8.22, when a specially crafted NTFS attribute from the MFT is setup in the function ntfs_attr_setup_flag, a heap buffer overflow can occur allowing for code execution and escalation of privileges.\n\n- CVE-2021-35344: tsMuxer v2.6.16 was discovered to contain a heap-based buffer overflow via the function BitStreamReader::getCurVal in bitStream.h.\n\n- CVE-2021-35346: tsMuxer v2.6.16 was discovered to contain a heap-based buffer overflow via the function HevcSpsUnit::short_term_ref_pic_set(int) in hevc.cpp.\n\n- CVE-2021-35392: Realtek Jungle SDK version v2.x up to v3.4.14B provides a 'WiFi Simple Config' server that implements both UPnP and SSDP protocols. The binary is usually named wscd or mini_upnpd and is the successor to miniigd. The server is vulnerable to a heap buffer overflow that is present due to unsafe crafting of SSDP NOTIFY messages from received M-SEARCH messages ST header.\n\n- CVE-2021-36065: Adobe Photoshop versions 21.2.10 (and earlier) and 22.4.3 (and earlier) are affected by a heap-based buffer overflow vulnerability that could result in arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-36073: Adobe Bridge version 11.1 (and earlier) is affected by a heap-based buffer overflow vulnerability when parsing a crafted .SGI file. An attacker could leverage this vulnerability to execute code in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-36089: Grok 7.6.6 through 9.2.0 has a heap-based buffer overflow in grk::FileFormatDecompress::apply_palette_clr (called from grk::FileFormatDecompress::applyColour).\n\n- CVE-2021-3625: Buffer overflow in Zephyr USB DFU DNLOAD. Zephyr versions >= v2.5.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-c3gr-hgvr-f363\n\n- CVE-2021-3634: A flaw has been found in libssh in versions prior to 0.9.6. The SSH protocol keeps track of two shared secrets during the lifetime of the session. One of them is called secret_hash and the other session_id. Initially, both of them are the same, but after key re-exchange, previous session_id is kept and used as an input to new secret_hash. Historically, both of these buffers had shared length variable, which worked as long as these buffers were same. But the key re-exchange operation can also change the key exchange method, which can be based on hash of different size, eventually creating \"secret_hash\" of different size than the session_id has. This becomes an issue when the session_id memory is zeroed or when it is used again during second key re-exchange.\n\n- CVE-2021-36530: ngiflib 0.4 has a heap overflow in GetByteStr() at ngiflib.c:108 in NGIFLIB_NO_FILE mode, GetByteStr() copy memory buffer without checking the boundary.\n\n- CVE-2021-36531: ngiflib 0.4 has a heap overflow in GetByte() at ngiflib.c:70 in NGIFLIB_NO_FILE mode, GetByte() reads memory buffer without checking the boundary.\n\n- CVE-2021-36584: An issue was discovered in GPAC 1.0.1. There is a heap-based buffer overflow in the function gp_rtp_builder_do_tx3g function in ietf/rtp_pck_3gpp.c, as demonstrated by MP4Box. This can cause a denial of service (DOS).\n\n- CVE-2021-36977: matio (aka MAT File I/O Library) 1.5.20 and 1.5.21 has a heap-based buffer overflow in H5MM_memcpy (called from H5MM_malloc and H5C_load_entry), related to use of HDF5 1.12.0.\n\n- CVE-2021-36978: QPDF 9.x through 9.1.1 and 10.x through 10.0.4 has a heap-based buffer overflow in Pl_ASCII85Decoder::write (called from Pl_AES_PDF::flush and Pl_AES_PDF::finish) when a certain downstream write fails.\n\n- CVE-2021-37022: There is a Heap-based Buffer Overflow vulnerability in Huawei Smartphone.Successful exploitation of this vulnerability will cause root permission which can be escalated.\n\n- CVE-2021-3756: libmysofa is vulnerable to Heap-based Buffer Overflow\n\n- CVE-2021-37650: TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.ExperimentalDatasetToTFRecord` and `tf.raw_ops.DatasetToTFRecord` can trigger heap buffer overflow and segmentation fault. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/data/experimental/to_tf_record_op.cc#L93-L102) assumes that all records in the dataset are of string type. However, there is no check for that, and the example given above uses numeric types. We have patched the issue in GitHub commit e0b6e58c328059829c3eb968136f17aa72b6c876. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.\n\n- CVE-2021-3770: vim is vulnerable to Heap-based Buffer Overflow\n\n- CVE-2021-37978: Heap buffer overflow in Blink in Google Chrome prior to 94.0.4606.81 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37979: heap buffer overflow in WebRTC in Google Chrome prior to 94.0.4606.81 allowed a remote attacker who convinced a user to browse to a malicious website to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37981: Heap buffer overflow in Skia in Google Chrome prior to 95.0.4638.54 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2021-37984: Heap buffer overflow in PDFium in Google Chrome prior to 95.0.4638.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-38098: Corel PDF Fusion 2.6.2.0 is affected by a Heap Corruption vulnerability when parsing a crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious PDF file.\n\n- CVE-2021-38592: Wasm3 0.5.0 has a heap-based buffer overflow in op_Const64 (called from EvaluateExpression and m3_LoadModule).\n\n- CVE-2021-38614: Polipo through 1.1.1, when NDEBUG is used, allows a heap-based buffer overflow during parsing of a Range header. NOTE: This vulnerability only affects products that are no longer supported by the maintainer\n\n- CVE-2021-39256: A crafted NTFS image can cause a heap-based buffer overflow in ntfs_inode_lookup_by_name in NTFS-3G < 2021.8.22.\n\n- CVE-2021-39261: A crafted NTFS image can cause a heap-based buffer overflow in ntfs_compressed_pwrite in NTFS-3G < 2021.8.22.\n\n- CVE-2021-39518: An issue was discovered in libjpeg through 2020021. LineBuffer::FetchRegion() in linebuffer.cpp has a heap-based buffer overflow.\n\n- CVE-2021-39522: An issue was discovered in libredwg through v0.10.1.3751. bit_wcs2len() in bits.c has a heap-based buffer overflow.\n\n- CVE-2021-39525: An issue was discovered in libredwg through v0.10.1.3751. bit_read_fixed() in bits.c has a heap-based buffer overflow.\n\n- CVE-2021-39527: An issue was discovered in libredwg through v0.10.1.3751. appinfo_private() in decode.c has a heap-based buffer overflow.\n\n- CVE-2021-39530: An issue was discovered in libredwg through v0.10.1.3751. bit_wcs2nlen() in bits.c has a heap-based buffer overflow.\n\n- CVE-2021-39533: An issue was discovered in libslax through v0.22.1. slaxLexer() in slaxlexer.c has a heap-based buffer overflow.\n\n- CVE-2021-39534: An issue was discovered in libslax through v0.22.1. slaxIsCommentStart() in slaxlexer.c has a heap-based buffer overflow.\n\n- CVE-2021-39536: An issue was discovered in libxsmm through v1.16.1-93. The JIT code has a heap-based buffer overflow.\n\n- CVE-2021-39537: An issue was discovered in ncurses through v6.2-1. _nc_captoinfo in captoinfo.c has a heap-based buffer overflow.\n\n- CVE-2021-39544: An issue was discovered in sela through 20200412. file::WavFile::writeToFile() in wav_file.c has a heap-based buffer overflow.\n\n- CVE-2021-39546: An issue was discovered in sela through 20200412. rice::RiceDecoder::process() in rice_decoder.cpp has a heap-based buffer overflow.\n\n- CVE-2021-39550: An issue was discovered in sela through 20200412. file::SelaFile::readFromFile() in sela_file.cpp has a heap-based buffer overflow.\n\n- CVE-2021-39551: An issue was discovered in sela through 20200412. file::SelaFile::readFromFile() in sela_file.c has a heap-based buffer overflow.\n\n- CVE-2021-39552: An issue was discovered in sela through 20200412. file::WavFile::readFromFile() in wav_file.c has a heap-based buffer overflow.\n\n- CVE-2021-3968: vim is vulnerable to Heap-based Buffer Overflow\n\n- CVE-2021-3973: vim is vulnerable to Heap-based Buffer Overflow\n\n- CVE-2020-12895: Pool/Heap Overflow in AMD Graphics Driver for Windows 10 in Escape 0x110037 may lead to escalation of privilege, information disclosure or denial of service.\n\n- CVE-2020-13600: Malformed SPI in response for eswifi can corrupt kernel memory. Zephyr versions >= 1.14.2, >= 2.3.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-hx4p-j86p-2mhr\n\n- CVE-2020-18735: A heap buffer overflow in /src/dds_stream.c of Eclipse IOT Cyclone DDS Project v0.1.0 causes the DDS subscriber server to crash.\n\n- CVE-2020-19721: A heap buffer overflow vulnerability in Ap4TrunAtom.cpp of Bento 1.5.1-628 may lead to an out-of-bounds write while running mp42aac, leading to system crashes and a denial of service (DOS).\n\n- CVE-2020-21547: Libsixel 1.8.2 contains a heap-based buffer overflow in the dither_func_fs function in tosixel.c.\n\n- CVE-2020-21548: Libsixel 1.8.3 contains a heap-based buffer overflow in the sixel_encode_highcolor function in tosixel.c.\n\n- CVE-2020-21594: libde265 v1.0.4 contains a heap buffer overflow in the put_epel_hv_fallback function, which can be exploited via a crafted a file.\n\n- CVE-2020-21595: libde265 v1.0.4 contains a heap buffer overflow in the mc_luma function, which can be exploited via a crafted a file.\n\n- CVE-2020-21597: libde265 v1.0.4 contains a heap buffer overflow in the mc_chroma function, which can be exploited via a crafted a file.\n\n- CVE-2020-21598: libde265 v1.0.4 contains a heap buffer overflow in the ff_hevc_put_unweighted_pred_8_sse function, which can be exploited via a crafted a file.\n\n- CVE-2020-21599: libde265 v1.0.4 contains a heap buffer overflow in the de265_image::available_zscan function, which can be exploited via a crafted a file.\n\n- CVE-2020-21603: libde265 v1.0.4 contains a heap buffer overflow in the put_qpel_0_0_fallback_16 function, which can be exploited via a crafted a file.\n\n- CVE-2020-21604: libde265 v1.0.4 contains a heap buffer overflow fault in the _mm_loadl_epi64 function, which can be exploited via a crafted a file.\n\n- CVE-2020-21813: A heap based buffer overflow issue exists in GNU LibreDWG 0.10.2641 via output_TEXT ../../programs/dwg2SVG.c:114.\n\n- CVE-2020-21836: A heap based buffer overflow vulnerability exists in GNU LibreDWG 0.10 via read_2004_section_preview ../../src/decode.c:3175.\n\n- CVE-2021-44143: A flaw was found in mbsync in isync 1.4.0 through 1.4.3. Due to an unchecked condition, a malicious or compromised IMAP server could use a crafted mail message that lacks headers (i.e., one that starts with an empty line) to provoke a heap overflow, which could conceivably be exploited for remote code execution.\n\n- CVE-2021-42327: dp_link_settings_write in drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c in the Linux kernel through 5.14.14 allows a heap-based buffer overflow by an attacker who can write a string to the AMD GPU display drivers debug filesystem. There are no checks on size within parse_write_buffer_into_params when it uses the size of copy_from_user to copy a userspace buffer into a 40-byte heap buffer.\n\n- CVE-2021-31610: The Bluetooth Classic implementation on AB32VG1 devices does not properly handle the reception of continuous unsolicited LMP responses, allowing attackers in radio range to trigger a denial of service (either restart or deadlock the device) by flooding a device with LMP_AU_rand data.\n\n- CVE-2021-34143: The Bluetooth Classic implementation in the Zhuhai Jieli AC6366C_DEMO_V1.0 does not properly handle the reception of continuous unsolicited LMP responses, allowing attackers in radio range to trigger a denial of service (deadlock) of the device by flooding it with LMP_AU_Rand packets after paging procedure. User intervention is required to restart the device.\n\n- CVE-2021-34149: The Bluetooth Classic implementation on the Texas Instruments CC256XCQFN-EM does not properly handle the reception of continuous LMP_AU_Rand packets, allowing attackers in radio range to trigger a denial of service (deadlock) of the device by flooding it with LMP_AU_Rand packets after the paging procedure.\n\n- CVE-2020-28022: Exim 4 before 4.94.2 has Improper Restriction of Write Operations within the Bounds of a Memory Buffer. This occurs when processing name=value pairs within MAIL FROM and RCPT TO commands.\n\n- CVE-2021-22335: There is a Memory Buffer Improper Operation Limit vulnerability in Huawei Smartphone. Successful exploitation of this vulnerability may cause exceptions in image processing.\n\n- CVE-2021-32020: The kernel in Amazon Web Services FreeRTOS before 10.4.3 has insufficient bounds checking during management of heap memory.\n\n- CVE-2021-34326: A vulnerability has been identified in JT2Go (All versions < V13.2), Solid Edge SE2021 (All Versions < SE2021MP5), Teamcenter Visualization (All versions < V13.2). The plmxmlAdapterSE70.dll library in affected applications lacks proper validation of user-supplied data when parsing PAR files. This could result in an out of bounds write past the fixed-length heap-based buffer. An attacker could leverage this vulnerability to execute code in the context of the current process. (ZDI-CAN-13422)\n\n- CVE-2021-43247: Windows TCP/IP Driver Elevation of Privilege Vulnerability\n\n- CVE-2020-23273: Heap-buffer overflow in the randomize_iparp function in edit_packet.c. of Tcpreplay v4.3.2 allows attackers to cause a denial of service (DOS) via a crafted pcap.\n\n- CVE-2020-23873: pdf2xml v2.0 was discovered to contain a heap-buffer overflow in the function TextPage::dump.\n\n- CVE-2020-23874: pdf2xml v2.0 was discovered to contain a heap-buffer overflow in the function TextPage::addAttributsNode.\n\n- CVE-2021-46790: ntfsck in NTFS-3G through 2021.8.22 has a heap-based buffer overflow involving buffer+512*3-2. NOTE: the upstream position is that ntfsck is deprecated; however, it is shipped by some Linux distributions.\n\n- CVE-2020-15999: Heap buffer overflow in Freetype in Google Chrome prior to 86.0.4240.111 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2020-16010: Heap buffer overflow in UI in Google Chrome on Android prior to 86.0.4240.185 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2020-16013: Inappropriate implementation in V8 in Google Chrome prior to 86.0.4240.198 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2020-9819: A memory consumption issue was addressed with improved memory handling. This issue is fixed in iOS 13.5 and iPadOS 13.5, iOS 12.4.7, watchOS 6.2.5, watchOS 5.3.7. Processing a maliciously crafted mail message may lead to heap corruption.\n\n- CVE-2020-1027: An elevation of privilege vulnerability exists in the way that the Windows Kernel handles objects in memory, aka 'Windows Kernel Elevation of Privilege Vulnerability'. This CVE ID is unique from CVE-2020-0913, CVE-2020-1000, CVE-2020-1003.\n\n- CVE-2021-20043: A Heap-based buffer overflow vulnerability in SonicWall SMA100 getBookmarks method allows a remote authenticated attacker to potentially execute code as the nobody user in the appliance. This vulnerability affected SMA 200, 210, 400, 410 and 500v appliances.\n\n- CVE-2021-21793: An out-of-bounds write vulnerability exists in the JPG sof_nb_comp header processing functionality of Accusoft ImageGear 19.8 and 19.9. A specially crafted malformed file can lead to memory corruption. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21962: A heap-based buffer overflow vulnerability exists in the OTA Update u-download functionality of Sealevel Systems, Inc. SeaConnect 370W v1.3.34. A series of specially-crafted MQTT payloads can lead to remote code execution. An attacker must perform a man-in-the-middle attack in order to trigger this vulnerability.\n\n- CVE-2021-23157: WECON LeviStudioU Versions 2019-09-21 and prior are vulnerable to a heap-based buffer overflow, which may allow an attacker to remotely execute code.\n\n- CVE-2021-23165: A flaw was found in htmldoc before v1.9.12. Heap buffer overflow in pspdf_prepare_outpages(), in ps-pdf.cxx may lead to execute arbitrary code and denial of service.\n\n- CVE-2021-23169: A heap-buffer overflow was found in the copyIntoFrameBuffer function of OpenEXR in versions before 3.0.1. An attacker could use this flaw to execute arbitrary code with the permissions of the user running the application compiled against OpenEXR.\n\n- CVE-2021-26252: A flaw was found in htmldoc in v1.9.12. Heap buffer overflow in pspdf_prepare_page(),in ps-pdf.cxx may lead to execute arbitrary code and denial of service.\n\n- CVE-2021-26259: A flaw was found in htmldoc in v1.9.12. Heap buffer overflow in render_table_row(),in ps-pdf.cxx may lead to arbitrary code execution and denial of service.\n\n- CVE-2021-28237: LibreDWG v0.12.3 was discovered to contain a heap-buffer overflow via decode_preR13.\n\n- CVE-2021-28277: A Heap-based Buffer Overflow vulnerabilty exists in jhead 3.04 and 3.05 is affected by: Buffer Overflow via the RemoveUnknownSections function in jpgfile.c.\n\n- CVE-2021-28278: A Heap-based Buffer Overflow vulnerability exists in jhead 3.04 and 3.05 via the RemoveSectionType function in jpgfile.c.\n\n- CVE-2021-33657: There is a heap overflow problem in video/SDL_pixels.c in SDL (Simple DirectMedia Layer) 2.x to 2.0.18 versions. By crafting a malicious .BMP file, an attacker can cause the application using this library to crash, denial of service or Code execution.\n\n- CVE-2021-33912: libspf2 before 1.2.11 has a four-byte heap-based buffer overflow that might allow remote attackers to execute arbitrary code (via an unauthenticated e-mail message from anywhere on the Internet) with a crafted SPF DNS record, because of incorrect sprintf usage in SPF_record_expand_data in spf_expand.c. The vulnerable code may be part of the supply chain of a site's e-mail infrastructure (e.g., with additional configuration, Exim can use libspf2; the Postfix web site links to unofficial patches for use of libspf2 with Postfix; older versions of spfquery relied on libspf2) but most often is not.\n\n- CVE-2021-33913: libspf2 before 1.2.11 has a heap-based buffer overflow that might allow remote attackers to execute arbitrary code (via an unauthenticated e-mail message from anywhere on the Internet) with a crafted SPF DNS record, because of SPF_record_expand_data in spf_expand.c. The amount of overflowed data depends on the relationship between the length of an entire domain name and the length of its leftmost label. The vulnerable code may be part of the supply chain of a site's e-mail infrastructure (e.g., with additional configuration, Exim can use libspf2; the Postfix web site links to unofficial patches for use of libspf2 with Postfix; older versions of spfquery relied on libspf2) but most often is not.\n\n- CVE-2021-34583: Crafted web server requests may cause a heap-based buffer overflow and could therefore trigger a denial-of- service condition due to a crash in the CODESYS V2 web server prior to V1.1.9.22.\n\n- CVE-2021-3575: A heap-based buffer overflow was found in openjpeg in color.c:379:42 in sycc420_to_rgb when decompressing a crafted .j2k file. An attacker could use this to execute arbitrary code with the permissions of the application compiled against openjpeg.\n\n- CVE-2021-3610: A heap-based buffer overflow vulnerability was found in ImageMagick in versions prior to 7.0.11-14 in ReadTIFFImage() in coders/tiff.c. This issue is due to an incorrect setting of the pixel array size, which can lead to a crash and segmentation fault.\n\n- CVE-2021-36173: A heap-based buffer overflow in the firmware signature verification function of FortiOS versions 7.0.1, 7.0.0, 6.4.0 through 6.4.6, 6.2.0 through 6.2.9, and 6.0.0 through 6.0.13 may allow an attacker to execute arbitrary code via specially crafted installation images.\n\n- CVE-2021-36412: A heap-based buffer overflow vulnerability exists in MP4Box in GPAC 1.0.1 via the gp_rtp_builder_do_mpeg12_video function, which allows attackers to possibly have unspecified other impact via a crafted file in the MP4Box command,\n\n- CVE-2021-36417: A heap-based buffer overflow vulnerability exists in GPAC v1.0.1 in the gf_isom_dovi_config_get function in MP4Box, which causes a denial of service or execute arbitrary code via a crafted file.\n\n- CVE-2021-37049: There is a Heap-based buffer overflow vulnerability in Huawei Smartphone.Successful exploitation of this vulnerability may rewrite the memory of adjacent objects.\n\n- CVE-2021-38013: Heap buffer overflow in fingerprint recognition in Google Chrome on ChromeOS prior to 96.0.4664.45 allowed a remote attacker who had compromised a WebUI renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2021-3835: Buffer overflow in usb device class. Zephyr versions >= v2.6.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-fm6v-8625-99jf\n\n- CVE-2021-3861: The RNDIS USB device class includes a buffer overflow vulnerability. Zephyr versions >= v2.6.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-hvfp-w4h8-gxvj\n\n- CVE-2021-39665: In checkSpsUpdated of AAVCAssembler.cpp, there is a possible out of bounds read due to a heap buffer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-12Android ID: A-204077881\n\n- CVE-2021-39667: In ih264d_parse_decode_slice of ih264d_parse_slice.c, there is a possible out of bounds write due to a heap buffer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12Android ID: A-205702093\n\n- CVE-2021-39675: In GKI_getbuf of gki_buffer.cc, there is a possible out of bounds write due to a heap buffer overflow. This could lead to remote escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-12Android ID: A-205729183\n\n- CVE-2021-39996: There is a Heap-based buffer overflow vulnerability with the NFC module in smartphones. Successful exploitation of this vulnerability may cause memory overflow.\n\n- CVE-2021-40010: The bone voice ID TA has a heap overflow vulnerability.Successful exploitation of this vulnerability may result in malicious code execution.\n\n- CVE-2021-40014: The bone voice ID trusted application (TA) has a heap overflow vulnerability. Successful exploitation of this vulnerability may affect data confidentiality. \n\n- CVE-2021-40026: There is a Heap-based buffer overflow vulnerability in the AOD module in smartphones. Successful exploitation of this vulnerability may affect service integrity.\n\n- CVE-2021-40058: There is a heap-based buffer overflow vulnerability in the video framework. Successful exploitation of this vulnerability may affect availability.\n\n- CVE-2021-40060: There is a heap-based buffer overflow vulnerability in the video framework. Successful exploitation of this vulnerability may affect availability.\n\n- CVE-2021-40064: There is a heap-based buffer overflow vulnerability in system components. Successful exploitation of this vulnerability may affect system stability.\n\n- CVE-2021-40164: A heap-based buffer overflow could occur while parsing TIFF, PICT, TGA, or RLC files. This vulnerability may be exploited to execute arbitrary code.\n\n- CVE-2021-4055: Heap buffer overflow in extensions in Google Chrome prior to 96.0.4664.93 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2021-4058: Heap buffer overflow in ANGLE in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4062: Heap buffer overflow in BFCache in Google Chrome prior to 96.0.4664.93 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4079: Out of bounds write in WebRTC in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via crafted WebRTC packets.\n\n- CVE-2021-4101: Heap buffer overflow in Swiftshader in Google Chrome prior to 96.0.4664.110 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-41017: Multiple heap-based buffer overflow vulnerabilities in some web API controllers of FortiWeb 6.4.1, 6.4.0, and 6.3.0 through 6.3.15 may allow a remote authenticated attacker to execute arbitrary code or commands via specifically crafted HTTP requests.\n\n- CVE-2021-41396: Live555 through 1.08 does not handle socket connections properly. A huge number of incoming socket connections in a short time invokes the error-handling module, in which a heap-based buffer overflow happens. An attacker can leverage this to launch a DoS attack.\n\n- CVE-2021-41736: Faust v2.35.0 was discovered to contain a heap-buffer overflow in the function realPropagate() at propagate.cpp.\n\n- CVE-2021-41987: In the SCEP Server of RouterOS in certain Mikrotik products, an attacker can trigger a heap-based buffer overflow that leads to remote code execution. The attacker must know the scep_server_name value. This affects RouterOS 6.46.8, 6.47.9, and 6.47.10.\n\n- CVE-2021-4214: A heap overflow flaw was found in libpngs' pngimage.c program. This flaw allows an attacker with local network access to pass a specially crafted PNG file to the pngimage utility, causing an application to crash, leading to a denial of service.\n\n- CVE-2021-42199: An issue was discovered in swftools through 20201222. A heap buffer overflow exists in the function swf_FontExtract_DefineTextCallback() located in swftext.c. It allows an attacker to cause code execution.\n\n- CVE-2021-42585: A heap buffer overflow was discovered in copy_compressed_bytes in decode_r2007.c in dwgread before 0.12.4 via a crafted dwg file.\n\n- CVE-2021-42586: A heap buffer overflow was discovered in copy_bytes in decode_r2007.c in dwgread before 0.12.4 via a crafted dwg file.\n\n- CVE-2021-42739: The firewire subsystem in the Linux kernel through 5.14.13 has a buffer overflow related to drivers/media/firewire/firedtv-avc.c and drivers/media/firewire/firedtv-ci.c, because avc_ca_pmt mishandles bounds checking.\n\n- CVE-2021-42781: Heap buffer overflow issues were found in Opensc before version 0.22.0 in pkcs15-oberthur.c that could potentially crash programs using the library.\n\n- CVE-2021-43071: A heap-based buffer overflow in Fortinet FortiWeb version 6.4.1 and 6.4.0, version 6.3.15 and below, version 6.2.6 and below allows attacker to execute unauthorized code or commands via crafted HTTP requests to the LogReport API controller.\n\n- CVE-2021-43304: Heap buffer overflow in Clickhouse's LZ4 compression codec when parsing a malicious query. There is no verification that the copy operations in the LZ4::decompressImpl loop and especially the arbitrary copy operation wildCopy<copy_amount>(op, ip, copy_end), don\u2019t exceed the destination buffer\u2019s limits.\n\n- CVE-2021-43305: Heap buffer overflow in Clickhouse's LZ4 compression codec when parsing a malicious query. There is no verification that the copy operations in the LZ4::decompressImpl loop and especially the arbitrary copy operation wildCopy<copy_amount>(op, ip, copy_end), don\u2019t exceed the destination buffer\u2019s limits. This issue is very similar to CVE-2021-43304, but the vulnerable copy operation is in a different wildCopy call.\n\n- CVE-2021-43311: A heap-based buffer overflow was discovered in upx, during the generic pointer 'p' points to an inaccessible address in func get_le32(). The problem is essentially caused in PackLinuxElf32::elf_lookup() at p_lx_elf.cpp:5382.\n\n- CVE-2021-43312: A heap-based buffer overflow was discovered in upx, during the variable 'bucket' points to an inaccessible address. The issue is being triggered in the function PackLinuxElf64::invert_pt_dynamic at p_lx_elf.cpp:5239.\n\n- CVE-2021-43313: A heap-based buffer overflow was discovered in upx, during the variable 'bucket' points to an inaccessible address. The issue is being triggered in the function PackLinuxElf32::invert_pt_dynamic at p_lx_elf.cpp:1688.\n\n- CVE-2021-43314: A heap-based buffer overflows was discovered in upx, during the generic pointer 'p' points to an inaccessible address in func get_le32(). The problem is essentially caused in PackLinuxElf32::elf_lookup() at p_lx_elf.cpp:5368\n\n- CVE-2021-43315: A heap-based buffer overflows was discovered in upx, during the generic pointer 'p' points to an inaccessible address in func get_le32(). The problem is essentially caused in PackLinuxElf32::elf_lookup() at p_lx_elf.cpp:5349\n\n- CVE-2021-43316: A heap-based buffer overflow was discovered in upx, during the generic pointer 'p' points to an inaccessible address in func get_le64().\n\n- CVE-2021-43317: A heap-based buffer overflows was discovered in upx, during the generic pointer 'p' points to an inaccessible address in func get_le32(). The problem is essentially caused in PackLinuxElf64::elf_lookup() at p_lx_elf.cpp:5404\n\n- CVE-2021-43527: NSS (Network Security Services) versions prior to 3.73 or 3.68.1 ESR are vulnerable to a heap overflow when handling DER-encoded DSA or RSA-PSS signatures. Applications using NSS for handling signatures encoded within CMS, S/MIME, PKCS \\\\#7, or PKCS \\\\#12 are likely to be impacted. Applications using NSS for certificate validation or other TLS, X.509, OCSP or CRL functionality may be impacted, depending on how they configure NSS. *Note: This vulnerability does NOT impact Mozilla Firefox.* However, email clients and PDF viewers that use NSS for signature verification, such as Thunderbird, LibreOffice, Evolution and Evince are believed to be impacted. This vulnerability affects NSS < 3.73 and NSS < 3.68.1.\n\n- CVE-2021-43529: Thunderbird versions prior to 91.3.0 are vulnerable to the heap overflow described in CVE-2021-43527 when processing S/MIME messages. Thunderbird versions 91.3.0 and later will not call the vulnerable code when processing S/MIME messages that contain certificates with DER-encoded DSA or RSA-PSS signatures.\n\n- CVE-2021-44648: GNOME gdk-pixbuf 2.42.6 is vulnerable to a heap-buffer overflow vulnerability when decoding the lzw compressed stream of image data in GIF files with lzw minimum code size equals to 12.\n\n- CVE-2021-44708: Acrobat Reader DC version 21.007.20099 (and earlier), 20.004.30017 (and earlier) and 17.011.30204 (and earlier) are affected by a heap overflow vulnerability due to insecure handling of a crafted file, potentially resulting in arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-44709: Acrobat Reader DC version 21.007.20099 (and earlier), 20.004.30017 (and earlier) and 17.011.30204 (and earlier) are affected by a heap overflow vulnerability due to insecure handling of a crafted file, potentially resulting in arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-44956: Two Heap based buffer overflow vulnerabilities exist in ffjpeg through 01.01.2021. It is similar to CVE-2020-23852. Issues that are in the jfif_decode function at ffjpeg/src/jfif.c (line 552) could cause a Denial of Service by using a crafted jpeg file.\n\n- CVE-2021-45005: Artifex MuJS v1.1.3 was discovered to contain a heap buffer overflow which is caused by conflicting JumpList of nested try/finally statements.\n\n- CVE-2021-45078: stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact, as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.\n\n- CVE-2021-45417: AIDE before 0.17.4 allows local users to obtain root privileges via crafted file metadata (such as XFS extended attributes or tmpfs ACLs), because of a heap-based buffer overflow.\n\n- CVE-2021-45830: A heap-based buffer overflow vulnerability exists in HDF5 1.13.1-1 via H5F_addr_decode_len in /hdf5/src/H5Fint.c, which could cause a Denial of Service.\n\n- CVE-2021-45863: tsMuxer git-2678966 was discovered to contain a heap-based buffer overflow via the function HevcUnit::updateBits in hevc.cpp.\n\n- CVE-2021-45909: An issue was discovered in gif2apng 1.9. There is a heap-based buffer overflow vulnerability in the DecodeLZW function. It allows an attacker to write a large amount of arbitrary data outside the boundaries of a buffer.\n\n- CVE-2021-45910: An issue was discovered in gif2apng 1.9. There is a heap-based buffer overflow within the main function. It allows an attacker to write data outside of the allocated buffer. The attacker has control over a part of the address that data is written to, control over the written data, and (to some extent) control over the amount of data that is written.\n\n- CVE-2021-45911: An issue was discovered in gif2apng 1.9. There is a heap-based buffer overflow in the main function. It allows an attacker to write 2 bytes outside the boundaries of the buffer.\n\n- CVE-2021-45932: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow (4 bytes) in MqttDecode_Publish (called from MqttClient_DecodePacket and MqttClient_HandlePacket).\n\n- CVE-2021-45933: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow (8 bytes) in MqttDecode_Publish (called from MqttClient_DecodePacket and MqttClient_HandlePacket).\n\n- CVE-2021-45934: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttClient_DecodePacket (called from MqttClient_HandlePacket and MqttClient_WaitType).\n\n- CVE-2021-45935: Grok 9.5.0 has a heap-based buffer overflow in openhtj2k::T1OpenHTJ2K::decompress (called from std::__1::__packaged_task_func<std::__1::__bind<grk::T1DecompressScheduler::deco and std::__1::packaged_task<int).\n\n- CVE-2021-45936: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttDecode_Disconnect (called from MqttClient_DecodePacket and MqttClient_WaitType).\n\n- CVE-2021-45937: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttClient_DecodePacket (called from MqttClient_WaitType and MqttClient_Connect).\n\n- CVE-2021-45938: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttClient_DecodePacket (called from MqttClient_WaitType and MqttClient_Unsubscribe).\n\n- CVE-2021-45939: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttClient_DecodePacket (called from MqttClient_WaitType and MqttClient_Subscribe).\n\n- CVE-2021-45940: libbpf 0.6.0 and 0.6.1 has a heap-based buffer overflow (4 bytes) in __bpf_object__open (called from bpf_object__open_mem and bpf-object-fuzzer.c).\n\n- CVE-2021-45941: libbpf 0.6.0 and 0.6.1 has a heap-based buffer overflow (8 bytes) in __bpf_object__open (called from bpf_object__open_mem and bpf-object-fuzzer.c).\n\n- CVE-2021-45942: OpenEXR 3.1.x before 3.1.4 has a heap-based buffer overflow in Imf_3_1::LineCompositeTask::execute (called from IlmThread_3_1::NullThreadPoolProvider::addTask and IlmThread_3_1::ThreadPool::addGlobalTask). NOTE: db217f2 may be inapplicable.\n\n- CVE-2021-45943: GDAL 3.3.0 through 3.4.0 has a heap-based buffer overflow in PCIDSK::CPCIDSKFile::ReadFromFile (called from PCIDSK::CPCIDSKSegment::ReadFromFile and PCIDSK::CPCIDSKBinarySegment::CPCIDSKBinarySegment).\n\n- CVE-2021-45948: Open Asset Import Library (aka assimp) 5.1.0 and 5.1.1 has a heap-based buffer overflow in _m3d_safestr (called from m3d_load and Assimp::M3DWrapper::M3DWrapper).\n\n- CVE-2021-45949: Ghostscript GhostPDL 9.50 through 9.54.0 has a heap-based buffer overflow in sampled_data_finish (called from sampled_data_continue and interp).\n\n- CVE-2021-46474: Jsish v3.5.0 was discovered to contain a heap buffer overflow via jsiEvalCodeSub in src/jsiEval.c. This vulnerability can lead to a Denial of Service (DoS).\n\n- CVE-2021-46475: Jsish v3.5.0 was discovered to contain a heap buffer overflow via jsi_ArraySliceCmd in src/jsiArray.c. This vulnerability can lead to a Denial of Service (DoS).\n\n- CVE-2021-46477: Jsish v3.5.0 was discovered to contain a heap buffer overflow via RegExp_constructor in src/jsiRegexp.c. This vulnerability can lead to a Denial of Service (DoS).\n\n- CVE-2021-46478: Jsish v3.5.0 was discovered to contain a heap buffer overflow via jsiClearStack in src/jsiEval.c. This vulnerability can lead to a Denial of Service (DoS).\n\n- CVE-2021-46480: Jsish v3.5.0 was discovered to contain a heap buffer overflow via jsiValueObjDelete in src/jsiEval.c. This vulnerability can lead to a Denial of Service (DoS).\n\n- CVE-2021-46482: Jsish v3.5.0 was discovered to contain a heap buffer overflow via NumberConstructor at src/jsiNumber.c.\n\n- CVE-2021-46483: Jsish v3.5.0 was discovered to contain a heap buffer overflow via BooleanConstructor at src/jsiBool.c.\n\n- CVE-2021-46518: Cesanta MJS v2.20.0 was discovered to contain a heap buffer overflow via mjs_disown at src/mjs_core.c.\n\n- CVE-2021-46519: Cesanta MJS v2.20.0 was discovered to contain a heap buffer overflow via mjs_array_length at src/mjs_array.c.\n\n- CVE-2021-46520: Cesanta MJS v2.20.0 was discovered to contain a heap buffer overflow via mjs_jprintf at src/mjs_util.c.\n\n- CVE-2021-46522: Cesanta MJS v2.20.0 was discovered to contain a heap buffer overflow via /usr/lib/x86_64-linux-gnu/libasan.so.4+0xaff53.\n\n- CVE-2021-46523: Cesanta MJS v2.20.0 was discovered to contain a heap buffer overflow via to_json_or_debug at mjs/src/mjs_json.c.\n\n- CVE-2021-46524: Cesanta MJS v2.20.0 was discovered to contain a heap buffer overflow via snquote at mjs/src/mjs_json.c.\n\n- CVE-2021-46527: Cesanta MJS v2.20.0 was discovered to contain a heap buffer overflow via mjs_get_cstring at src/mjs_string.c.\n\n- CVE-2021-46822: The PPM reader in libjpeg-turbo through 2.0.90 mishandles use of tjLoadImage for loading a 16-bit binary PPM file into a grayscale buffer and loading a 16-bit binary PGM file into an RGB buffer. This is related to a heap-based buffer overflow in the get_word_rgb_row function in rdppm.c.\n\n- CVE-2022-0100: Heap buffer overflow in Media streams API in Google Chrome prior to 97.0.4692.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0101: Heap buffer overflow in Bookmarks in Google Chrome prior to 97.0.4692.71 allowed a remote attacker who convinced a user to perform specific user gesture to potentially exploit heap corruption via specific user gesture.\n\n- CVE-2022-0104: Heap buffer overflow in ANGLE in Google Chrome prior to 97.0.4692.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0137: A heap buffer overflow in image_set_mask function of HTMLDOC before 1.9.15 allows an attacker to write outside the buffer boundaries.\n\n- CVE-2022-0261: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.\n\n- CVE-2022-0306: Heap buffer overflow in PDFium in Google Chrome prior to 97.0.4692.99 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0310: Heap buffer overflow in Task Manager in Google Chrome prior to 97.0.4692.99 allowed a remote attacker to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-0311: Heap buffer overflow in Task Manager in Google Chrome prior to 97.0.4692.99 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0318: Heap-based Buffer Overflow in vim/vim prior to 8.2.\n\n- CVE-2022-0367: A heap-based buffer overflow flaw was found in libmodbus in function modbus_reply() in src/modbus.c.\n\n- CVE-2022-0454: Heap buffer overflow in ANGLE in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0470: Out of bounds memory access in V8 in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0518: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.6.2.\n\n- CVE-2022-0572: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.\n\n- CVE-2022-0604: Heap buffer overflow in Tab Groups in Google Chrome prior to 98.0.4758.102 allowed an attacker who convinced a user to install a malicious extension and engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0610: Inappropriate implementation in Gamepad API in Google Chrome prior to 98.0.4758.102 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0676: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.6.4.\n\n- CVE-2022-0713: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.6.4.\n\n- CVE-2022-0789: Heap buffer overflow in ANGLE in Google Chrome prior to 99.0.4844.51 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0800: Heap buffer overflow in Cast UI in Google Chrome prior to 99.0.4844.51 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0809: Out of bounds memory access in WebXR in Google Chrome prior to 99.0.4844.51 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0891: A heap buffer overflow in ExtractImageSection function in tiffcrop.c in libtiff library Version 4.3.0 allows attacker to trigger unsafe or out of bounds memory access via crafted TIFF image file which could result into application crash, potential information disclosure or any other context-dependent impact\n\n- CVE-2022-0976: Heap buffer overflow in GPU in Google Chrome prior to 99.0.4844.74 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1052: Heap Buffer Overflow in iterate_chained_fixups in GitHub repository radareorg/radare2 prior to 5.6.6.\n\n- CVE-2022-1061: Heap Buffer Overflow in parseDragons in GitHub repository radareorg/radare2 prior to 5.6.8.\n\n- CVE-2022-1142: Heap buffer overflow in WebUI in Google Chrome prior to 100.0.4896.60 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via specific input into DevTools.\n\n- CVE-2022-1143: Heap buffer overflow in WebUI in Google Chrome prior to 100.0.4896.60 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via specific input into DevTools.\n\n- CVE-2022-1238: Out-of-bounds Write in libr/bin/format/ne/ne.c in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability is heap overflow and may be exploitable. For more general description of heap buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/122.html).\n\n- CVE-2022-1240: Heap buffer overflow in libr/bin/format/mach0/mach0.c in GitHub repository radareorg/radare2 prior to 5.8.6. If address sanitizer is disabled during the compiling, the program should executes into the `r_str_ncpy` function. Therefore I think it is very likely to be exploitable. For more general description of heap buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/122.html).\n\n- CVE-2022-1270: In GraphicsMagick, a heap buffer overflow was found when parsing MIFF.\n\n- CVE-2022-1354: A heap buffer overflow flaw was found in Libtiffs' tiffinfo.c in TIFFReadRawDataStriped() function. This flaw allows an attacker to pass a crafted TIFF file to the tiffinfo tool, triggering a heap buffer overflow issue and causing a crash that leads to a denial of service.\n\n- CVE-2022-1383: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.6.8. The bug causes the program reads data past the end of the intented buffer. Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash.\n\n- CVE-2022-1437: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.7.0. The bug causes the program reads data past the end of the intented buffer. Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash.\n\n- CVE-2022-1482: Inappropriate implementation in WebGL in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1483: Heap buffer overflow in WebGPU in Google Chrome prior to 101.0.4951.41 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1484: Heap buffer overflow in Web UI Settings in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1489: Out of bounds memory access in UI Shelf in Google Chrome on Chrome OS, Lacros prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-1621: Heap buffer overflow in vim_strncpy find_word in GitHub repository vim/vim prior to 8.2.4919. This vulnerability is capable of crashing software, Bypass Protection Mechanism, Modify Memory, and possible remote execution\n\n- CVE-2022-1638: Heap buffer overflow in V8 Internationalization in Google Chrome prior to 101.0.4951.64 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1876: Heap buffer overflow in DevTools in Google Chrome prior to 102.0.5005.61 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-20106: In MM service, there is a possible out of bounds write due to a heap-based buffer overflow. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: DTV03330460; Issue ID: DTV03330460.\n\n- CVE-2022-20166: In various methods of kernel base drivers, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-182388481References: Upstream kernel\n\n- CVE-2022-20202: In ih264_resi_trans_quant_4x4_sse42 of ih264_resi_trans_quant_sse42.c, there is a possible out of bounds read due to a heap buffer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-12LAndroid ID: A-204704614\n\n- CVE-2022-20209: In hme_add_new_node_to_a_sorted_array of hme_utils.c, there is a possible out of bounds read due to a heap buffer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-12LAndroid ID: A-207502397\n\n- CVE-2022-20247: In Media, there is a possible out of bounds read due to a heap buffer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-229858836\n\n- CVE-2022-20273: In Bluetooth, there is a possible out of bounds read due to a heap buffer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-206478022\n\n- CVE-2022-29210: TensorFlow is an open source platform for machine learning. In version 2.8.0, the `TensorKey` hash function used total estimated `AllocatedBytes()`, which (a) is an estimate per tensor, and (b) is a very poor hash function for constants (e.g. `int32_t`). It also tried to access individual tensor bytes through `tensor.data()` of size `AllocatedBytes()`. This led to ASAN failures because the `AllocatedBytes()` is an estimate of total bytes allocated by a tensor, including any pointed-to constructs (e.g. strings), and does not refer to contiguous bytes in the `.data()` buffer. The discoverers could not use this byte vector anyway because types such as `tstring` include pointers, whereas they needed to hash the string values themselves. This issue is patched in Tensorflow versions 2.9.0 and 2.8.1.\n\n- CVE-2022-2991: A heap-based buffer overflow was found in the Linux kernel's LightNVM subsystem. The issue results from the lack of proper validation of the length of user-supplied data prior to copying it to a fixed-length heap-based buffer. This vulnerability allows a local attacker to escalate privileges and execute arbitrary code in the context of the kernel. The attacker must first obtain the ability to execute high-privileged code on the target system to exploit this vulnerability.\n\n- CVE-2022-29917: Mozilla developers Andrew McCreight, Gabriele Svelto, Tom Ritter and the Mozilla Fuzzing Team reported memory safety bugs present in Firefox 99 and Firefox ESR 91.8. Some of these bugs showed evidence of memory corruption and we presume that with enough effort some of these could have been exploited to run arbitrary code. This vulnerability affects Thunderbird < 91.9, Firefox ESR < 91.9, and Firefox < 100.\n\n- CVE-2022-30292: Heap-based buffer overflow in sqbaselib.cpp in SQUIRREL 3.2 due to lack of a certain sq_reservestack call.\n\n- CVE-2022-30293: In WebKitGTK through 2.36.0 (and WPE WebKit), there is a heap-based buffer overflow in WebCore::TextureMapperLayer::setContentsLayer in WebCore/platform/graphics/texmap/TextureMapperLayer.cpp.\n\n- CVE-2022-3040: Use after free in Layout in Google Chrome prior to 105.0.5195.52 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3043: Heap buffer overflow in Screen Capture in Google Chrome on Chrome OS prior to 105.0.5195.52 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-30474: Tenda AC Series Router AC18_V15.03.05.19(6318) was discovered to contain a heap overflow in the httpd module when handling /goform/saveParentControlInfo request.\n\n- CVE-2022-3437: A heap-based buffer overflow vulnerability was found in Samba within the GSSAPI unwrap_des() and unwrap_des3() routines of Heimdal. The DES and Triple-DES decryption routines in the Heimdal GSSAPI library allow a length-limited write buffer overflow on malloc() allocated memory when presented with a maliciously small packet. This flaw allows a remote user to send specially crafted malicious data to the application, possibly resulting in a denial of service (DoS) attack.\n\n- CVE-2022-34502: Radare2 v5.7.0 was discovered to contain a heap buffer overflow via the function consume_encoded_name_new at format/wasm/wasm.c. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted binary file.\n\n- CVE-2022-34503: QPDF v8.4.2 was discovered to contain a heap buffer overflow via the function QPDF::processXRefStream. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted PDF file.\n\n- CVE-2022-35104: SWFTools commit 772e55a2 was discovered to contain a heap-buffer overflow via DCTStream::reset() at /xpdf/Stream.cc.\n\n- CVE-2022-35105: SWFTools commit 772e55a2 was discovered to contain a heap-buffer overflow via /bin/png2swf+0x552cea.\n\n- CVE-2022-35109: SWFTools commit 772e55a2 was discovered to contain a heap-buffer overflow via draw_stroke at /gfxpoly/stroke.c.\n\n- CVE-2022-35113: SWFTools commit 772e55a2 was discovered to contain a heap-buffer overflow via swf_DefineLosslessBitsTagToImage at /modules/swfbits.c.\n\n- CVE-2022-35447: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b04de.\n\n- CVE-2022-35448: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b55af.\n\n- CVE-2022-35449: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b0466.\n\n- CVE-2022-35450: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b84b1.\n\n- CVE-2022-35451: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b03b5.\n\n- CVE-2022-35452: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b0b2c.\n\n- CVE-2022-35453: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6c08a6.\n\n- CVE-2022-35454: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b05aa.\n\n- CVE-2022-35455: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b0d63.\n\n- CVE-2022-35456: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x617087.\n\n- CVE-2022-35458: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b05ce.\n\n- CVE-2022-35459: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6e412a.\n\n- CVE-2022-35460: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x61731f.\n\n- CVE-2022-35461: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6c0a32.\n\n- CVE-2022-35462: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6c0bc3.\n\n- CVE-2022-35463: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b0478.\n\n- CVE-2022-35464: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6171b2.\n\n- CVE-2022-35465: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6c0414.\n\n- CVE-2022-35466: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6c0473.\n\n- CVE-2022-35467: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6e41b8.\n\n- CVE-2022-35468: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6e420d.\n\n- CVE-2022-35470: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x65fc97.\n\n- CVE-2022-35471: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6e41b0.\n\n- CVE-2022-35474: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b544e.\n\n- CVE-2022-35475: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6e41a8.\n\n- CVE-2022-35623: In Nordic nRF5 SDK for Mesh 5.0, a heap overflow vulnerability can be triggered by sending a series of segmented control packets and access packets with the same SeqAuth\n\n- CVE-2022-35624: In Nordic nRF5 SDK for Mesh 5.0, a heap overflow vulnerability can be triggered by sending a series of segmented packets with SegO > SegN\n\n- CVE-2022-3570: Multiple heap buffer overflows in tiffcrop.c utility in libtiff library Version 4.4.0 allows attacker to trigger unsafe or out of bounds memory access via crafted TIFF image file which could result into application crash, potential information disclosure or any other context-dependent impact\n\n- CVE-2022-35711: Adobe ColdFusion versions Update 14 (and earlier) and Update 4 (and earlier) are affected by a Heap-based Buffer Overflow vulnerability that could result in arbitrary code execution in the context of the current user. Exploitation of this issue does not require user interaction, the vulnerability is triggered when a crafted network packet is sent to the server.\n\n- CVE-2022-35712: Adobe ColdFusion versions Update 14 (and earlier) and Update 4 (and earlier) are affected by a Heap-based Buffer Overflow vulnerability that could result in arbitrary code execution in the context of the current user. Exploitation of this issue does not require user interaction, the vulnerability is triggered when a crafted network packet is sent to the server.\n\n- CVE-2022-36150: tifig v0.2.2 was discovered to contain a heap-buffer overflow via __asan_memmove at /asan/asan_interceptors_memintrinsics.cpp.\n\n- CVE-2022-4135: Heap buffer overflow in GPU in Google Chrome prior to 107.0.5304.121 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4141: Heap based buffer overflow in vim/vim 9.0.0946 and below by allowing an attacker to CTRL-W gf in the expression used in the RHS of the substitute command.\n\n- CVE-2022-41428: Bento4 v1.6.0-639 was discovered to contain a heap overflow via the AP4_BitReader::ReadBits function in mp4mux.\n\n- CVE-2022-41429: Bento4 v1.6.0-639 was discovered to contain a heap overflow via the AP4_Atom::TypeFromString function in mp4tag.\n\n- CVE-2022-41430: Bento4 v1.6.0-639 was discovered to contain a heap overflow via the AP4_BitReader::ReadBit function in mp4mux.\n\n- CVE-2022-41595: The phones have the heap overflow, out-of-bounds read, and null pointer vulnerabilities in the fingerprint trusted application (TA).Successful exploitation of this vulnerability may affect the fingerprint service.\n\n- CVE-2022-42499: In sms_SendMmCpErrMsg of sms_MmConManagement.c, there is a possible out of bounds write due to a heap buffer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-242001391References: N/A\n\n- CVE-2022-4291: The aswjsflt.dll library from Avast Antivirus windows contained a potentially exploitable heap corruption vulnerability that could enable an attacker to bypass the sandbox of the application it was loaded into, if applicable. This issue was fixed in version 18.0.1478 of the Script Shield Component. \n\n- CVE-2021-21958: A heap-based buffer overflow vulnerability exists in the Hword HwordApp.dll functionality of Hancom Office 2020 11.0.0.2353. A specially-crafted malformed file can lead to memory corruption and potential arbitrary code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2022-37434: zlib through 1.2.12 has a heap-based buffer over-read or buffer overflow in inflate in inflate.c via a large gzip header extra field. NOTE: only applications that call inflateGetHeader are affected. Some common applications bundle the affected zlib source code but may be unable to call inflateGetHeader (e.g., see the nodejs/node reference).\n\n- CVE-2022-46393: An issue was discovered in Mbed TLS before 2.28.2 and 3.x before 3.3.0. There is a potential heap-based buffer overflow and heap-based buffer over-read in DTLS if MBEDTLS_SSL_DTLS_CONNECTION_ID is enabled and MBEDTLS_SSL_CID_IN_LEN_MAX > 2 * MBEDTLS_SSL_CID_OUT_LEN_MAX.\n\n- CVE-2022-22612: A memory consumption issue was addressed with improved memory handling. This issue is fixed in tvOS 15.4, iOS 15.4 and iPadOS 15.4, iTunes 12.12.3 for Windows, watchOS 8.5, macOS Monterey 12.3. Processing a maliciously crafted image may lead to heap corruption.\n\n- CVE-2022-23318: A heap-buffer-overflow in pcf2bdf, versions >= 1.05 allows an attacker to trigger unsafe memory access via a specially crafted PCF font file. This out-of-bound read may lead to an application crash, information disclosure via program memory or other context-dependent impact.\n\n- CVE-2022-35557: A stack overflow vulnerability exists in /goform/wifiSSIDget in Tenda W6 V1.0.0.9(4122) version, which can be exploited by attackers to cause a denial of service (DoS) via the index parameter.\n\n- CVE-2022-4498: In TP-Link routers, Archer C5 and WR710N-V1, running the latest available code, when receiving HTTP Basic Authentication the httpd service can be sent a crafted packet that causes a heap overflow. This can result in either a DoS (by crashing the httpd process) or an arbitrary code execution.\n\n- CVE-2022-42475: A heap-based buffer overflow vulnerability [CWE-122] in FortiOS SSL-VPN 7.2.0 through 7.2.2, 7.0.0 through 7.0.8, 6.4.0 through 6.4.10, 6.2.0 through 6.2.11, 6.0.15 and earlier and FortiProxy SSL-VPN 7.2.0 through 7.2.1, 7.0.7 and earlier may allow a remote unauthenticated attacker to execute arbitrary code or commands via specifically crafted requests.\n\n- CVE-2022-2294: Heap buffer overflow in WebRTC in Google Chrome prior to 103.0.5060.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-26318: On WatchGuard Firebox and XTM appliances, an unauthenticated user can execute arbitrary code, aka FBX-22786. This vulnerability impacts Fireware OS before 12.7.2_U2, 12.x before 12.1.3_U8, and 12.2.x through 12.5.x before 12.5.9_U2.\n\n- CVE-2022-2598: Out-of-bounds Write to API in GitHub repository vim/vim prior to 9.0.0100. \n\n- CVE-2022-25363: WatchGuard Firebox and XTM appliances allow an authenticated remote attacker with unprivileged credentials to modify privileged management user credentials. This vulnerability impacts Fireware OS before 12.7.2_U2, 12.x before 12.1.3_U8, and 12.2.x through 12.5.x before 12.5.9_U2.\n\n- CVE-2022-3974: A vulnerability classified as critical was found in Axiomatic Bento4. Affected by this vulnerability is the function AP4_StdcFileByteStream::ReadPartial of the file Ap4StdCFileByteStream.cpp of the component mp4info. The manipulation leads to heap-based buffer overflow. The attack can be launched remotely. The exploit has been disclosed to the public and may be used. The identifier VDB-213553 was assigned to this vulnerability.\n\n- CVE-2021-40647: In man2html 1.6g, a specific string being read in from a file will overwrite the size parameter in the top chunk of the heap. This at least causes the program to segmentation abort if the heap size parameter isn't aligned correctly. In version before GLIBC version 2.29 and aligned correctly, it allows arbitrary write anywhere in the programs memory.\n\n- CVE-2021-3567: A flaw was found in Caribou due to a regression of CVE-2020-25712 fix. An attacker could use this flaw to bypass screen-locking applications that leverage Caribou as an input mechanism. The highest threat from this vulnerability is to system availability.\n\nRelated Weaknesses:\n\n- CWE-788 (ChildOf)\n\n- CWE-787 (ChildOf)",
            "type": "Variant",
            "source": "sparse",
            "search_source": "weakness:memory corruption",
            "sources": [
              "base",
              "weakness"
            ],
            "boost_factor": 2.8,
            "boosted": true,
            "metadata": {
              "source": "sparse",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              }
            }
          },
          {
            "cwe_id": "415",
            "name": "Double Free",
            "description": "The product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.",
            "score": 53.504177185489525,
            "matched_text": "CWE-415: Double Free\n\nType: Variant\n\nStatus: Draft\n\nAlternative Terms:\n\nDouble-free\n\nDouble-free\n\nDouble-free\n\nDescription:\n\nThe product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.\n\nExtended Details:\n\nWhen a program calls free() twice with the same argument, the program's memory management data structures become corrupted. This corruption can cause the program to crash or, in some circumstances, cause two later calls to malloc() to return the same pointer. If malloc() returns the same value twice and the program later gives the attacker control over the data that is written into this doubly-allocated memory, the program becomes vulnerable to a buffer overflow attack.\n\nReal-World Examples:\n\n- CVE-2006-5051: Chain: Signal handler contains too much functionality (CWE-828), introducing a race condition (CWE-362) that leads to a double free (CWE-415).\n\n- CVE-2004-0642: Double free resultant from certain error conditions.\n\n- CVE-2004-0772: Double free resultant from certain error conditions.\n\n- CVE-2005-1689: Double free resultant from certain error conditions.\n\n- CVE-2003-0545: Double free from invalid ASN.1 encoding.\n\n- CVE-2003-1048: Double free from malformed GIF.\n\n- CVE-2005-0891: Double free from malformed GIF.\n\n- CVE-2002-0059: Double free from malformed compressed data.\n\nTop 25 CWE Examples:\n\n- CVE-2020-11231: Two threads call one or both functions concurrently leading to corruption of pointers and reference counters which in turn can lead to heap corruption in Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile\n\n- CVE-2020-14354: A possible use-after-free and double-free in c-ares lib version 1.16.0 if ares_destroy() is called prior to ares_getaddrinfo() completing. This flaw possibly allows an attacker to crash the service that uses c-ares lib. The highest threat from this vulnerability is to this service availability.\n\n- CVE-2021-0392: In main of main.cpp, there is a possible memory corruption due to a double free. This could lead to local escalation of privilege with User execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-9Android ID: A-175124730\n\n- CVE-2021-0498: In memory management driver, there is a possible memory corruption due to a double free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-183461321\n\n- CVE-2021-0528: In memory management driver, there is a possible memory corruption due to a double free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-185195266\n\n- CVE-2021-1119: NVIDIA vGPU software contains a vulnerability in the Virtual GPU Manager (vGPU plugin), where it can double-free a pointer, which may lead to denial of service. This flaw may result in a write-what-where condition, allowing an attacker to execute arbitrary code impacting integrity and availability.\n\n- CVE-2021-1875: A double free issue was addressed with improved memory management. This issue is fixed in Security Update 2021-002 Catalina, Security Update 2021-003 Mojave, iOS 14.5 and iPadOS 14.5, watchOS 7.4, tvOS 14.5, macOS Big Sur 11.3. Processing a maliciously crafted file may lead to heap corruption.\n\n- CVE-2021-1888: Memory corruption in key parsing and import function due to double freeing the same heap allocation in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2021-1934: Possible memory corruption due to improper check when application loader object is explicitly destructed while application is unloading in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT\n\n- CVE-2021-30535: Double free in ICU in Google Chrome prior to 91.0.4472.77 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-32613: In radare2 through 5.3.0 there is a double free vulnerability in the pyc parse via a crafted file which can lead to DoS.\n\n- CVE-2021-3403: In ytnef 1.9.3, the TNEFSubjectHandler function in lib/ytnef.c allows remote attackers to cause a denial-of-service (and potentially code execution) due to a double free which can be triggered via a crafted file.\n\n- CVE-2021-3407: A flaw was found in mupdf 1.18.0. Double free of object during linearization may lead to memory corruption and other potential consequences.\n\n- CVE-2021-3564: A flaw double-free memory corruption in the Linux kernel HCI device initialization subsystem was found in the way user attach malicious HCI TTY Bluetooth device. A local user could use this flaw to crash the system. This flaw affects all the Linux kernel versions starting from 3.13.\n\n- CVE-2021-37652: TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.BoostedTreesCreateEnsemble` can result in a use after free error if an attacker supplies specially crafted arguments. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/boosted_trees/resource_ops.cc#L55) uses a reference counted resource and decrements the refcount if the initialization fails, as it should. However, when the code was written, the resource was represented as a naked pointer but later refactoring has changed it to be a smart pointer. Thus, when the pointer leaves the scope, a subsequent `free`-ing of the resource occurs, but this fails to take into account that the refcount has already reached 0, thus the resource has been already freed. During this double-free process, members of the resource object are accessed for cleanup but they are invalid as the entire resource has been freed. We have patched the issue in GitHub commit 5ecec9c6fbdbc6be03295685190a45e7eee726ab. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.\n\n- CVE-2020-14123: There is a pointer double free vulnerability in Some MIUI Services. When a function is called, the memory pointer is copied to two function modules, and an attacker can cause the pointer to be repeatedly released through malicious operations, resulting in the affected module crashing and affecting normal functionality, and if successfully exploited the vulnerability can cause elevation of privileges.\n\n- CVE-2021-42778: A heap double free issue was found in Opensc before version 0.22.0 in sc_pkcs15_free_tokeninfo.\n\n- CVE-2021-42613: A double free in cleanup_index in index.c in Halibut 1.2 allows an attacker to cause a denial of service or possibly have other unspecified impact via a crafted text document.\n\n- CVE-2021-22600: A double free bug in packet_set_ring() in net/packet/af_packet.c can be exploited by a local user through crafted syscalls to escalate privileges or deny service. We recommend upgrading kernel past the effected versions or rebuilding past ec6af094ea28f0f2dda1a6a33b14cd57e36a9755\n\n- CVE-2020-9859: A memory consumption issue was addressed with improved memory handling. This issue is fixed in iOS 13.5.1 and iPadOS 13.5.1, macOS Catalina 10.15.5 Supplemental Update, tvOS 13.4.6, watchOS 6.2.6. An application may be able to execute arbitrary code with kernel privileges.\n\n- CVE-2021-23158: A flaw was found in htmldoc in v1.9.12. Double-free in function pspdf_export(),in ps-pdf.cxx may result in a write-what-where condition, allowing an attacker to execute arbitrary code and denial of service.\n\n- CVE-2022-2008: Double free in WebGL in Google Chrome prior to 102.0.5005.115 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-40304: An issue was discovered in libxml2 before 2.10.3. Certain invalid XML entity definitions can corrupt a hash table key, potentially leading to subsequent logic errors. In one case, a double-free can be provoked.\n\nRelated Weaknesses:\n\n- CWE-825 (ChildOf)\n\n- CWE-1341 (ChildOf)\n\n- CWE-672 (ChildOf)\n\n- CWE-672 (ChildOf)\n\n- CWE-672 (ChildOf)\n\n- CWE-666 (ChildOf)\n\n- CWE-416 (PeerOf)\n\n- CWE-123 (PeerOf)",
            "type": "Variant",
            "source": "sparse",
            "search_source": "weakness:memory corruption",
            "sources": [
              "base",
              "weakness"
            ],
            "boost_factor": 2.8,
            "boosted": true,
            "metadata": {
              "source": "sparse",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              }
            }
          },
          {
            "cwe_id": "190",
            "name": "Integer Overflow or Wraparound",
            "description": "The product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.",
            "score": 51.530627528621274,
            "matched_text": "CWE-190: Integer Overflow or Wraparound\n\nType: Base\n\nStatus: Stable\n\nAlternative Terms:\n\nOverflow - The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nWraparound - The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nwrap, wrap-around, wrap around - Alternate spellings of \"wraparound\"\n\nOverflow - The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nWraparound - The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nwrap, wrap-around, wrap around - Alternate spellings of \"wraparound\"\n\nOverflow - The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nWraparound - The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nwrap, wrap-around, wrap around - Alternate spellings of \"wraparound\"\n\nDescription:\n\nThe product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.\n\nReal-World Examples:\n\n- CVE-2021-43537: Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n\n- CVE-2022-21668: Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n\n- CVE-2022-0545: Chain: 3D renderer has an integer overflow (CWE-190) leading to write-what-where condition (CWE-123) using a crafted image.\n\n- CVE-2021-30860: Chain: improper input validation (CWE-20) leads to integer overflow (CWE-190) in mobile OS, as exploited in the wild per CISA KEV.\n\n- CVE-2021-30663: Chain: improper input validation (CWE-20) leads to integer overflow (CWE-190) in mobile OS, as exploited in the wild per CISA KEV.\n\n- CVE-2018-10887: Chain: unexpected sign extension (CWE-194) leads to integer overflow (CWE-190), causing an out-of-bounds read (CWE-125)\n\n- CVE-2019-1010006: Chain: compiler optimization (CWE-733) removes or modifies code used to detect integer overflow (CWE-190), allowing out-of-bounds write (CWE-787).\n\n- CVE-2010-1866: Chain: integer overflow (CWE-190) causes a negative signed value, which later bypasses a maximum-only check (CWE-839), leading to heap-based buffer overflow (CWE-122).\n\n- CVE-2010-2753: Chain: integer overflow leads to use-after-free\n\n- CVE-2005-1513: Chain: integer overflow in securely-coded mail program leads to buffer overflow. In 2005, this was regarded as unrealistic to exploit, but in 2020, it was rediscovered to be easier to exploit due to evolutions of the technology.\n\n- CVE-2002-0391: Integer overflow via a large number of arguments.\n\n- CVE-2002-0639: Integer overflow in OpenSSH as listed in the demonstrative examples.\n\n- CVE-2005-1141: Image with large width and height leads to integer overflow.\n\n- CVE-2005-0102: Length value of -1 leads to allocation of 0 bytes and resultant heap overflow.\n\n- CVE-2004-2013: Length value of -1 leads to allocation of 0 bytes and resultant heap overflow.\n\n- CVE-2017-1000121: chain: unchecked message size metadata allows integer overflow (CWE-190) leading to buffer overflow (CWE-119).\n\n- CVE-2013-1591: Chain: an integer overflow (CWE-190) in the image size calculation causes an infinite loop (CWE-835) which sequentially allocates buffers without limits (CWE-1325) until the stack is full.\n\nTop 25 CWE Examples:\n\n- CVE-2020-11279: Memory corruption while processing crafted SDES packets due to improper length check in sdes packets recieved in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2020-28020: Exim 4 before 4.92 allows Integer Overflow to Buffer Overflow, in which an unauthenticated remote attacker can execute arbitrary code by leveraging the mishandling of continuation lines during header-length restriction.\n\n- CVE-2020-35198: An issue was discovered in Wind River VxWorks 7. The memory allocator has a possible integer overflow in calculating a memory block's size to be allocated by calloc(). As a result, the actual memory allocated is smaller than the buffer size specified by the arguments, leading to memory corruption.\n\n- CVE-2021-0355: In kisd, there is a possible out of bounds write due to an integer overflow. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Product: Android; Versions: Android-11; Patch ID: ALPS05425581.\n\n- CVE-2021-0436: In CryptoPlugin::decrypt of CryptoPlugin.cpp, there is a possible out of bounds read due to integer overflow. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-8.1 Android-9 Android-10 Android-11Android ID: A-176496160\n\n- CVE-2021-0458: In the FingerTipS touch screen driver, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-157156744\n\n- CVE-2021-0460: In the FingerTipS touch screen driver, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-156739245\n\n- CVE-2021-0494: In memory management driver, there is a possible out of bounds write due to an integer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-183461318\n\n- CVE-2021-0610: In memory management driver, there is a possible memory corruption due to an integer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05403499; Issue ID: ALPS05411456.\n\n- CVE-2021-0621: In asf extractor, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05489178; Issue ID: ALPS05561383.\n\n- CVE-2021-0623: In asf extractor, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05489178; Issue ID: ALPS05585817.\n\n- CVE-2021-0627: In OMA DRM, there is a possible memory corruption due to an integer overflow. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05722434; Issue ID: ALPS05722434.\n\n- CVE-2021-21309: Redis is an open-source, in-memory database that persists on disk. In affected versions of Redis an integer overflow bug in 32-bit Redis version 4.0 or newer could be exploited to corrupt the heap and potentially result with remote code execution. Redis 4.0 or newer uses a configurable limit for the maximum supported bulk input size. By default, it is 512MB which is a safe value for all platforms. If the limit is significantly increased, receiving a large request from a client may trigger several integer overflow scenarios, which would result with buffer overflow and heap corruption. We believe this could in certain conditions be exploited for remote code execution. By default, authenticated Redis users have access to all configuration parameters and can therefore use the \u201cCONFIG SET proto-max-bulk-len\u201d to change the safe default, making the system vulnerable. **This problem only affects 32-bit Redis (on a 32-bit system, or as a 32-bit executable running on a 64-bit system).** The problem is fixed in version 6.2, and the fix is back ported to 6.0.11 and 5.0.11. Make sure you use one of these versions if you are running 32-bit Redis. An additional workaround to mitigate the problem without patching the redis-server executable is to prevent clients from directly executing `CONFIG SET`: Using Redis 6.0 or newer, ACL configuration can be used to block the command. Using older versions, the `rename-command` configuration directive can be used to rename the command to a random string unknown to users, rendering it inaccessible. Please note that this workaround may have an additional impact on users or operational systems that expect `CONFIG SET` to behave in certain ways.\n\n- CVE-2021-21807: An integer overflow vulnerability exists in the DICOM parse_dicom_meta_info functionality of Accusoft ImageGear 19.9. A specially crafted malformed file can lead to a stack-based buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21834: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input when decoding the atom for the \u201cco64\u201d FOURCC can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21835: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input when decoding the atom associated with the \u201ccsgp\u201d FOURCC can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21836: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input using the \u201cctts\u201d FOURCC code can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21837: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21838: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21839: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21840: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input used to process an atom using the \u201csaio\u201d FOURCC code cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21841: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input when reading an atom using the 'sbgp' FOURCC code can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21842: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow when processing an atom using the 'ssix' FOURCC code, due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21843: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. After validating the number of ranges, at [41] the library will multiply the count by the size of the GF_SubsegmentRangeInfo structure. On a 32-bit platform, this multiplication can result in an integer overflow causing the space of the array being allocated to be less than expected. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21844: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input when encountering an atom using the \u201cstco\u201d FOURCC code, can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21845: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input in \u201cstsc\u201d decoder can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21846: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input in \u201cstsz\u201d decoder can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21847: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input in \u201cstts\u201d decoder can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21848: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. The library will actually reuse the parser for atoms with the \u201cstsz\u201d FOURCC code when parsing atoms that use the \u201cstz2\u201d FOURCC code and can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21849: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow when the library encounters an atom using the \u201ctfra\u201d FOURCC code due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21850: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow when the library encounters an atom using the \u201ctrun\u201d FOURCC code due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21851: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input at \u201ccsgp\u201d decoder sample group description indices can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21852: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input at \u201cstss\u201d decoder can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21853: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked addition arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21854: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked addition arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21855: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked addition arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21856: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked addition arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21857: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked addition arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21858: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked addition arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-22412: There is an Integer Overflow Vulnerability in Huawei Smartphone.Successful exploitation of this vulnerability may cause random kernel address access.\n\n- CVE-2021-22413: There is an Integer Overflow Vulnerability in Huawei Smartphone.Successful exploitation of this vulnerability may cause the system to reset.\n\n- CVE-2021-23215: An integer overflow leading to a heap-buffer overflow was found in the DwaCompressor of OpenEXR in versions before 3.0.1. An attacker could use this flaw to crash an application compiled with OpenEXR.\n\n- CVE-2021-24025: Due to incorrect string size calculations inside the preg_quote function, a large input string passed to the function can trigger an integer overflow leading to a heap overflow. This issue affects HHVM versions prior to 4.56.3, all versions between 4.57.0 and 4.80.1, all versions between 4.81.0 and 4.93.1, and versions 4.94.0, 4.95.0, 4.96.0, 4.97.0, 4.98.0.\n\n- CVE-2021-24036: Passing an attacker controlled size when creating an IOBuf could cause integer overflow, leading to an out of bounds write on the heap with the possibility of remote code execution. This issue affects versions of folly prior to v2021.07.22.00. This issue affects HHVM versions prior to 4.80.5, all versions between 4.81.0 and 4.102.1, all versions between 4.103.0 and 4.113.0, and versions 4.114.0, 4.115.0, 4.116.0, 4.117.0, 4.118.0 and 4.118.1.\n\n- CVE-2021-25803: A buffer overflow vulnerability in the vlc_input_attachment_New component of VideoLAN VLC Media Player 3.0.11 allows attackers to cause an out-of-bounds read via a crafted .avi file.\n\n- CVE-2021-26260: An integer overflow leading to a heap-buffer overflow was found in the DwaCompressor of OpenEXR in versions before 3.0.1. An attacker could use this flaw to crash an application compiled with OpenEXR. This is a different flaw from CVE-2021-23215.\n\n- CVE-2021-26461: Apache Nuttx Versions prior to 10.1.0 are vulnerable to integer wrap-around in functions malloc, realloc and memalign. This improper memory assignment can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-26825: An integer overflow issue exists in Godot Engine up to v3.2 that can be triggered when loading specially crafted.TGA image files. The vulnerability exists in ImageLoaderTGA::load_image() function at line: const size_t buffer_size = (tga_header.image_width * tga_header.image_height) * pixel_size; The bug leads to Dynamic stack buffer overflow. Depending on the context of the application, attack vector can be local or remote, and can lead to code execution and/or system crash.\n\n- CVE-2021-26945: An integer overflow leading to a heap-buffer overflow was found in OpenEXR in versions before 3.0.1. An attacker could use this flaw to crash an application compiled with OpenEXR.\n\n- CVE-2021-30354: Amazon Kindle e-reader prior to and including version 5.13.4 contains an Integer Overflow that leads to a Heap-Based Buffer Overflow in function CJBig2Image::expand() and results in a memory corruption that leads to code execution when parsing a crafted PDF book.\n\n- CVE-2021-31292: An integer overflow in CrwMap::encode0x1810 of Exiv2 0.27.3 allows attackers to trigger a heap-based buffer overflow and cause a denial of service (DOS) via crafted metadata.\n\n- CVE-2021-31870: An issue was discovered in klibc before 2.0.9. Multiplication in the calloc() function may result in an integer overflow and a subsequent heap buffer overflow.\n\n- CVE-2021-31871: An issue was discovered in klibc before 2.0.9. An integer overflow in the cpio command may result in a NULL pointer dereference on 64-bit systems.\n\n- CVE-2021-31873: An issue was discovered in klibc before 2.0.9. Additions in the malloc() function may result in an integer overflow and a subsequent heap buffer overflow.\n\n- CVE-2021-32625: Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker. An integer overflow bug in Redis version 6.0 or newer, could be exploited using the STRALGO LCS command to corrupt the heap and potentially result with remote code execution. This is a result of an incomplete fix by CVE-2021-29477. The problem is fixed in version 6.2.4 and 6.0.14. An additional workaround to mitigate the problem without patching the redis-server executable is to use ACL configuration to prevent clients from using the STRALGO LCS command. On 64 bit systems which have the fixes of CVE-2021-29477 (6.2.3 or 6.0.13), it is sufficient to make sure that the proto-max-bulk-len config parameter is smaller than 2GB (default is 512MB).\n\n- CVE-2021-32628: Redis is an open source, in-memory database that persists on disk. An integer overflow bug in the ziplist data structure used by all versions of Redis can be exploited to corrupt the heap and potentially result with remote code execution. The vulnerability involves modifying the default ziplist configuration parameters (hash-max-ziplist-entries, hash-max-ziplist-value, zset-max-ziplist-entries or zset-max-ziplist-value) to a very large value, and then constructing specially crafted commands to create very large ziplists. The problem is fixed in Redis versions 6.2.6, 6.0.16, 5.0.14. An additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from modifying the above configuration parameters. This can be done using ACL to restrict unprivileged users from using the CONFIG SET command.\n\n- CVE-2021-34385: Trusty TLK contains a vulnerability in the NVIDIA TLK kernel where an integer overflow in the calculation of a length could lead to a heap overflow.\n\n- CVE-2021-34386: Trusty TLK contains a vulnerability in the NVIDIA TLK kernel where an integer overflow in the calloc size calculation can cause the multiplication of count and size can overflow, which might lead to heap overflows.\n\n- CVE-2021-39254: A crafted NTFS image can cause an integer overflow in memmove, leading to a heap-based buffer overflow in the function ntfs_attr_record_resize, in NTFS-3G < 2021.8.22.\n\n- CVE-2021-40346: An integer overflow exists in HAProxy 2.0 through 2.5 in htx_add_header that can be exploited to perform an HTTP request smuggling attack, allowing an attacker to bypass all configured http-request HAProxy ACLs and possibly other ACLs.\n\n- CVE-2021-41864: prealloc_elems_and_freelist in kernel/bpf/stackmap.c in the Linux kernel before 5.14.12 allows unprivileged users to trigger an eBPF multiplication integer overflow with a resultant out-of-bounds write.\n\n- CVE-2021-41991: The in-memory certificate cache in strongSwan before 5.9.4 has a remote integer overflow upon receiving many requests with different certificates to fill the cache and later trigger the replacement of cache entries. The code attempts to select a less-often-used cache entry by means of a random number generator, but this is not done correctly. Remote code execution might be a slight possibility.\n\n- CVE-2021-43784: runc is a CLI tool for spawning and running containers on Linux according to the OCI specification. In runc, netlink is used internally as a serialization system for specifying the relevant container configuration to the `C` portion of the code (responsible for the based namespace setup of containers). In all versions of runc prior to 1.0.3, the encoder did not handle the possibility of an integer overflow in the 16-bit length field for the byte array attribute type, meaning that a large enough malicious byte array attribute could result in the length overflowing and the attribute contents being parsed as netlink messages for container configuration. This vulnerability requires the attacker to have some control over the configuration of the container and would allow the attacker to bypass the namespace restrictions of the container by simply adding their own netlink payload which disables all namespaces. The main users impacted are those who allow untrusted images with untrusted configurations to run on their machines (such as with shared cloud infrastructure). runc version 1.0.3 contains a fix for this bug. As a workaround, one may try disallowing untrusted namespace paths from your container. It should be noted that untrusted namespace paths would allow the attacker to disable namespace protections entirely even in the absence of this bug.\n\n- CVE-2021-36155: LengthPrefixedMessageReader in gRPC Swift 1.1.0 and earlier allocates buffers of arbitrary length, which allows remote attackers to cause uncontrolled resource consumption and deny service.\n\n- CVE-2020-28009: Exim 4 before 4.94.2 allows Integer Overflow to Buffer Overflow because get_stdinput allows unbounded reads that are accompanied by unbounded increases in a certain size variable. NOTE: exploitation may be impractical because of the execution time needed to overflow (multiple days).\n\n- CVE-2020-28017: Exim 4 before 4.94.2 allows Integer Overflow to Buffer Overflow in receive_add_recipient via an e-mail message with fifty million recipients. NOTE: remote exploitation may be difficult because of resource consumption.\n\n- CVE-2021-22323: There is an Integer Overflow Vulnerability in Huawei Smartphone. Successful exploitation of these vulnerabilities may escalate the permission to that of the root user.\n\n- CVE-2021-32027: A flaw was found in postgresql in versions before 13.3, before 12.7, before 11.12, before 10.17 and before 9.6.22. While modifying certain SQL array values, missing bounds checks let authenticated database users write arbitrary bytes to a wide area of server memory. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.\n\n- CVE-2021-3410: A flaw was found in libcaca v0.99.beta19. A buffer overflow issue in caca_resize function in libcaca/caca/canvas.c may lead to local execution of arbitrary code in the user context.\n\n- CVE-2020-14344: An integer overflow leading to a heap-buffer overflow was found in The X Input Method (XIM) client was implemented in libX11 before version 1.6.10. As per upstream this is security relevant when setuid programs call XIM client functions while running with elevated privileges. No such programs are shipped with Red Hat Enterprise Linux.\n\n- CVE-2020-6059: An exploitable out of bounds read vulnerability exists in the way MiniSNMPD version 1.4 parses incoming SNMP packets. A specially crafted SNMP request can trigger an out of bounds memory read which can result in sensitive information disclosure and Denial Of Service. In order to trigger this vulnerability, an attacker needs to send a specially crafted packet to the vulnerable server.\n\n- CVE-2020-6099: An exploitable code execution vulnerability exists in the file format parsing functionality of Graphisoft BIMx Desktop Viewer 2019.2.2328. A specially crafted file can cause a heap buffer overflow resulting in a code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-22680: NXP MQX Versions 5.1 and prior are vulnerable to integer overflow in mem_alloc, _lwmem_alloc and _partition functions. This unverified memory assignment can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-27419: uClibc-ng versions prior to 1.0.37 are vulnerable to integer wrap-around in functions malloc-simple. This improper memory assignment can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-27425: Cesanta Software Mongoose-OS v2.17.0 is vulnerable to integer wrap-around in function mm_malloc. This improper memory assignment can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-27427: RIOT OS version 2020.01.1 is vulnerable to integer wrap-around in its implementation of calloc function, which can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-27433: ARM mbed-ualloc memory library version 1.3.0 is vulnerable to integer wrap-around in function mbed_krbs, which can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-27435: ARM mbed product Version 6.3.0 is vulnerable to integer wrap-around in malloc_wrapper function, which can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-27439: TencentOS-tiny version 3.1.0 is vulnerable to integer wrap-around in function 'tos_mmheap_alloc incorrect calculation of effective memory allocation size. This improper memory assignment can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-27417: eCosCentric eCosPro RTOS Versions 2.0.1 through 4.5.3 are vulnerable to integer wraparound in function calloc (an implementation of malloc). The unverified memory assignment can lead to arbitrary memory allocation, resulting in a heap-based buffer overflow.\n\n- CVE-2021-30663: An integer overflow was addressed with improved input validation. This issue is fixed in iOS 14.5.1 and iPadOS 14.5.1, tvOS 14.6, iOS 12.5.3, Safari 14.1.1, macOS Big Sur 11.3.1. Processing maliciously crafted web content may lead to arbitrary code execution.\n\n- CVE-2021-30860: An integer overflow was addressed with improved input validation. This issue is fixed in Security Update 2021-005 Catalina, iOS 14.8 and iPadOS 14.8, macOS Big Sur 11.6, watchOS 7.6.2. Processing a maliciously crafted PDF may lead to arbitrary code execution. Apple is aware of a report that this issue may have been actively exploited.\n\n- CVE-2021-0677: In ccu driver, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05827154; Issue ID: ALPS05827154.\n\n- CVE-2021-1047: In valid_ipc_dram_addr of cm_access_control.c, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-197966306References: N/A\n\n- CVE-2021-21832: A memory corruption vulnerability exists in the ISO Parsing functionality of Disc Soft Ltd Deamon Tools Pro 8.3.0.0767. A specially crafted malformed file can lead to an out-of-bounds write. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21914: A heap-based buffer overflow vulnerability exists in the DecoderStream::Append functionality of Accusoft ImageGear 19.10. A specially-crafted file can lead to code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21948: A heap-based buffer overflow vulnerability exists in the readDatHeadVec functionality of AnyCubic Chitubox AnyCubic Plugin 1.0.0. A specially-crafted GF file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-22437: There is a software integer overflow leading to a TOCTOU condition in smartphones. Successful exploitation of this vulnerability may cause random address access.\n\n- CVE-2021-3782: An internal reference count is held on the buffer pool, incremented every time a new buffer is created from the pool. The reference count is maintained as an int; on LP64 systems this can cause the reference count to overflow if the client creates a large number of wl_shm buffer objects, or if it can coerce the server to create a large number of external references to the buffer storage. With the reference count overflowing, a use-after-free can be constructed on the wl_shm_pool tracking structure, where values may be incremented or decremented; it may also be possible to construct a limited oracle to leak 4 bytes of server-side memory to the attacking client at a time.\n\n- CVE-2021-39762: In tremolo, there is a possible out of bounds read due to an integer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-12LAndroid ID: A-210625816\n\n- CVE-2021-40417: When parsing a file that is submitted to the DPDecoder service as a job, the service will use the combination of decoding parameters that were submitted with the job along with fields that were parsed for the submitted video by the R3D SDK to calculate the size of a heap buffer. Due to an integer overflow with regards to this calculation, this can result in an undersized heap buffer being allocated. When this heap buffer is written to, a heap-based buffer overflow will occur. This can result in code execution under the context of the application.\n\n- CVE-2021-4206: A flaw was found in the QXL display device emulation in QEMU. An integer overflow in the cursor_alloc() function can lead to the allocation of a small cursor object followed by a subsequent heap-based buffer overflow. This flaw allows a malicious privileged guest user to crash the QEMU process on the host or potentially execute arbitrary code within the context of the QEMU process.\n\n- CVE-2021-46829: GNOME GdkPixbuf (aka GDK-PixBuf) before 2.42.8 allows a heap-based buffer overflow when compositing or clearing frames in GIF files, as demonstrated by io-gif-animation.c composite_frame. This overflow is controllable and could be abused for code execution, especially on 32-bit systems.\n\n- CVE-2022-0204: A heap overflow vulnerability was found in bluez in versions prior to 5.63. An attacker with local network access could pass specially crafted files causing an application to halt or crash, leading to a denial of service.\n\n- CVE-2022-0545: An integer overflow in the processing of loaded 2D images leads to a write-what-where vulnerability and an out-of-bounds read vulnerability, allowing an attacker to leak sensitive information or achieve code execution in the context of the Blender process when a specially crafted image file is loaded. This flaw affects Blender versions prior to 2.83.19, 2.93.8 and 3.1.\n\n- CVE-2022-0608: Integer overflow in Mojo in Google Chrome prior to 98.0.4758.102 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1922: DOS / potential heap overwrite in mkv demuxing using zlib decompression. Integer overflow in matroskademux element in gst_matroska_decompress_data function which causes a segfault, or could cause a heap overwrite, depending on libc and OS. Depending on the libc used, and the underlying OS capabilities, it could be just a segfault or a heap overwrite. If the libc uses mmap for large chunks, and the OS supports mmap, then it is just a segfault (because the realloc before the integer overflow will use mremap to reduce the size of the chunk, and it will start to write to unmapped memory). However, if using a libc implementation that does not use mmap, or if the OS does not support mmap while using libc, then this could result in a heap overwrite.\n\n- CVE-2022-1923: DOS / potential heap overwrite in mkv demuxing using bzip decompression. Integer overflow in matroskademux element in bzip decompression function which causes a segfault, or could cause a heap overwrite, depending on libc and OS. Depending on the libc used, and the underlying OS capabilities, it could be just a segfault or a heap overwrite. If the libc uses mmap for large chunks, and the OS supports mmap, then it is just a segfault (because the realloc before the integer overflow will use mremap to reduce the size of the chunk, and it will start to write to unmapped memory). However, if using a libc implementation that does not use mmap, or if the OS does not support mmap while using libc, then this could result in a heap overwrite.\n\n- CVE-2022-1924: DOS / potential heap overwrite in mkv demuxing using lzo decompression. Integer overflow in matroskademux element in lzo decompression function which causes a segfault, or could cause a heap overwrite, depending on libc and OS. Depending on the libc used, and the underlying OS capabilities, it could be just a segfault or a heap overwrite. If the libc uses mmap for large chunks, and the OS supports mmap, then it is just a segfault (because the realloc before the integer overflow will use mremap to reduce the size of the chunk, and it will start to write to unmapped memory). However, if using a libc implementation that does not use mmap, or if the OS does not support mmap while using libc, then this could result in a heap overwrite.\n\n- CVE-2022-1925: DOS / potential heap overwrite in mkv demuxing using HEADERSTRIP decompression. Integer overflow in matroskaparse element in gst_matroska_decompress_data function which causes a heap overflow. Due to restrictions on chunk sizes in the matroskademux element, the overflow can't be triggered, however the matroskaparse element has no size checks.\n\n- CVE-2022-21729: Tensorflow is an Open Source Machine Learning Framework. The implementation of `UnravelIndex` is vulnerable to a division by zero caused by an integer overflow bug. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.\n\n- CVE-2022-21743: In ion, there is a possible use after free due to an integer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS06371108; Issue ID: ALPS06371108.\n\n- CVE-2022-22074: Memory Corruption during wma file playback due to integer overflow in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2022-22081: Memory corruption in audio module due to integer overflow in Snapdragon Auto, Snapdragon Connectivity, Snapdragon Mobile, Snapdragon Wearables\n\n- CVE-2022-22106: Memory corruption in multimedia due to improper length check while copying the data in Snapdragon Auto\n\n- CVE-2022-2329: A CWE-190: Integer Overflow or Wraparound vulnerability exists that could cause heap-based buffer overflow, leading to denial of service and potentially remote code execution when an attacker sends multiple specially crafted messages. Affected Products: IGSS Data Server - IGSSdataServer.exe (Versions prior to V15.0.0.22073)\n\n- CVE-2022-23559: Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would cause an integer overflow in embedding lookup operations. Both `embedding_size` and `lookup_size` are products of values provided by the user. Hence, a malicious user could trigger overflows in the multiplication. In certain scenarios, this can then result in heap OOB read/write. Users are advised to upgrade to a patched version.\n\n- CVE-2022-24310: A CWE-190: Integer Overflow or Wraparound vulnerability exists that could cause heap-based buffer overflow, leading to denial of service and potentially remote code execution when an attacker sends multiple specially crafted messages. Affected Product: Interactive Graphical SCADA System Data Server (V15.0.0.22020 and prior)\n\n- CVE-2022-24724: cmark-gfm is GitHub's extended version of the C reference implementation of CommonMark. Prior to versions 0.29.0.gfm.3 and 0.28.3.gfm.21, an integer overflow in cmark-gfm's table row parsing `table.c:row_from_string` may lead to heap memory corruption when parsing tables who's marker rows contain more than UINT16_MAX columns. The impact of this heap corruption ranges from Information Leak to Arbitrary Code Execution depending on how and where `cmark-gfm` is used. If `cmark-gfm` is used for rendering remote user controlled markdown, this vulnerability may lead to Remote Code Execution (RCE) in applications employing affected versions of the `cmark-gfm` library. This vulnerability has been patched in the following cmark-gfm versions 0.29.0.gfm.3 and 0.28.3.gfm.21. A workaround is available. The vulnerability exists in the table markdown extensions of cmark-gfm. Disabling the table extension will prevent this vulnerability from being triggered.\n\n- CVE-2022-24795: yajl-ruby is a C binding to the YAJL JSON parsing and generation library. The 1.x branch and the 2.x branch of `yajl` contain an integer overflow which leads to subsequent heap memory corruption when dealing with large (~2GB) inputs. The reallocation logic at `yajl_buf.c#L64` may result in the `need` 32bit integer wrapping to 0 when `need` approaches a value of 0x80000000 (i.e. ~2GB of data), which results in a reallocation of buf->alloc into a small heap chunk. These integers are declared as `size_t` in the 2.x branch of `yajl`, which practically prevents the issue from triggering on 64bit platforms, however this does not preclude this issue triggering on 32bit builds on which `size_t` is a 32bit integer. Subsequent population of this under-allocated heap chunk is based on the original buffer size, leading to heap memory corruption. This vulnerability mostly impacts process availability. Maintainers believe exploitation for arbitrary code execution is unlikely. A patch is available and anticipated to be part of yajl-ruby version 1.4.2. As a workaround, avoid passing large inputs to YAJL.\n\n- CVE-2022-25291: An integer overflow in WatchGuard Firebox and XTM appliances allows an authenticated remote attacker to trigger a heap-based buffer overflow and potentially execute arbitrary code by initiating a firmware update with a malicious upgrade image. This vulnerability impacts Fireware OS before 12.7.2_U2, 12.x before 12.1.3_U8, and 12.2.x through 12.5.x before 12.5.9_U2.\n\n- CVE-2022-2566: A heap out-of-bounds memory write exists in FFMPEG since version 5.1. The size calculation in `build_open_gop_key_points()` goes through all entries in the loop and adds `sc->ctts_data[i].count` to `sc->sample_offsets_count`. This can lead to an integer overflow resulting in a small allocation with `av_calloc()`. An attacker can cause remote code execution via a malicious mp4 file. We recommend upgrading past commit c953baa084607dd1d84c3bfcce3cf6a87c3e6e05\n\n- CVE-2022-26459: In vow, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07032634; Issue ID: ALPS07032634.\n\n- CVE-2022-26495: In nbd-server in nbd before 3.24, there is an integer overflow with a resultant heap-based buffer overflow. A value of 0xffffffff in the name length field will cause a zero-sized buffer to be allocated for the name, resulting in a write to a dangling pointer. This issue exists for the NBD_OPT_INFO, NBD_OPT_GO, and NBD_OPT_EXPORT_NAME messages.\n\n- CVE-2022-28331: On Windows, Apache Portable Runtime 1.7.0 and earlier may write beyond the end of a stack based buffer in apr_socket_sendv(). This is a result of integer overflow.\n\n- CVE-2022-28471: In ffjpeg (commit hash: caade60), the function bmp_load() in bmp.c contains an integer overflow vulnerability, which eventually results in the heap overflow in jfif_encode() in jfif.c. This is due to the incomplete patch for issue 38\n\n- CVE-2022-29203: TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.SpaceToBatchND` (in all backends such as XLA and handwritten kernels) is vulnerable to an integer overflow: The result of this integer overflow is used to allocate the output tensor, hence we get a denial of service via a `CHECK`-failure (assertion failure), as in TFSA-2021-198. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue.\n\n- CVE-2022-29886: An integer overflow vulnerability exists in the way ESTsoft Alyac 2.5.8.544 parses OLE files. A specially-crafted OLE file can lead to a heap buffer overflow, which can result in arbitrary code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2022-32543: An integer overflow vulnerability exists in the way ESTsoft Alyac 2.5.8.544 parses OLE files. A specially-crafted OLE file can lead to a heap buffer overflow which can result in arbitrary code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2022-33266: Memory corruption in Audio due to integer overflow to buffer overflow while music playback of clips like amr,evrc,qcelp with modified content.\n\n- CVE-2022-35289: A write-what-where condition in hermes caused by an integer overflow, prior to commit 5b6255ae049fa4641791e47fad994e8e8c4da374 allows attackers to potentially execute arbitrary code via crafted JavaScript. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected.\n\n- CVE-2022-35951: Redis is an in-memory database that persists on disk. Versions 7.0.0 and above, prior to 7.0.5 are vulnerable to an Integer Overflow. Executing an `XAUTOCLAIM` command on a stream key in a specific state, with a specially crafted `COUNT` argument may cause an integer overflow, a subsequent heap overflow, and potentially lead to remote code execution. This has been patched in Redis version 7.0.5. No known workarounds exist.\n\n- CVE-2022-39343: Azure RTOS FileX is a FAT-compatible file system that\u2019s fully integrated with Azure RTOS ThreadX. In versions before 6.2.0, the Fault Tolerant feature of Azure RTOS FileX includes integer under and overflows which may be exploited to achieve buffer overflow and modify memory contents. When a valid log file with correct ID and checksum is detected by the `_fx_fault_tolerant_enable` function an attempt to recover the previous failed write operation is taken by call of `_fx_fault_tolerant_apply_logs`. This function iterates through the log entries and performs required recovery operations. When properly crafted a log including entries of type `FX_FAULT_TOLERANT_DIR_LOG_TYPE` may be utilized to introduce unexpected behavior. This issue has been patched in version 6.2.0. A workaround to fix line 218 in fx_fault_tolerant_apply_logs.c is documented in the GHSA.\n\n- CVE-2022-41318: A buffer over-read was discovered in libntlmauth in Squid 2.5 through 5.6. Due to incorrect integer-overflow protection, the SSPI and SMB authentication helpers are vulnerable to reading unintended memory locations. In some configurations, cleartext credentials from these locations are sent to a client. This is fixed in 5.7.\n\n- CVE-2022-4172: An integer overflow and buffer overflow issues were found in the ACPI Error Record Serialization Table (ERST) device of QEMU in the read_erst_record() and write_erst_record() functions. Both issues may allow the guest to overrun the host buffer allocated for the ERST memory device. A malicious guest could use these flaws to crash the QEMU process on the host.\n\n- CVE-2022-42898: PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has \"a similar bug.\"\n\n- CVE-2022-44638: In libpixman in Pixman before 0.42.2, there is an out-of-bounds write (aka heap-based buffer overflow) in rasterize_edges_8 due to an integer overflow in pixman_sample_floor_y.\n\n- CVE-2022-3970: A vulnerability was found in LibTIFF. It has been classified as critical. This affects the function TIFFReadRGBATileExt of the file libtiff/tif_getimage.c. The manipulation leads to integer overflow. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used. The name of the patch is 227500897dfb07fb7d27f7aa570050e62617e3be. It is recommended to apply a patch to fix this issue. The identifier VDB-213549 was assigned to this vulnerability.\n\n- CVE-2022-4202: A vulnerability, which was classified as problematic, was found in GPAC 2.1-DEV-rev490-g68064e101-master. Affected is the function lsr_translate_coords of the file laser/lsr_dec.c. The manipulation leads to integer overflow. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used. The name of the patch is b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908. It is recommended to apply a patch to fix this issue. VDB-214518 is the identifier assigned to this vulnerability.\n\n- CVE-2022-25705: Memory corruption in modem due to integer overflow to buffer overflow while handling APDU response\n\n- CVE-2022-25748: Memory corruption in WLAN due to integer overflow to buffer overflow while parsing GTK frames. in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer Electronics Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables, Snapdragon Wired Infrastructure and Networking\n\n- CVE-2022-33219: Memory corruption in Automotive due to integer overflow to buffer overflow while registering a new listener with shared buffer.\n\n- CVE-2022-39907: Integer overflow vulnerability in Samsung decoding library for video thumbnails prior to SMR Dec-2022 Release 1 allows local attacker to perform Out-Of-Bounds Write.\n\n- CVE-2022-40530: Memory corruption in WLAN due to integer overflow to buffer overflow in WLAN during initialization phase.\n\n- CVE-2021-20268: An out-of-bounds access flaw was found in the Linux kernel's implementation of the eBPF code verifier in the way a user running the eBPF script calls dev_map_init_map or sock_map_alloc. This flaw allows a local user to crash the system or possibly escalate their privileges. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.\n\n- CVE-2022-28937: FISCO-BCOS release-3.0.0-rc2 was discovered to contain an issue where a malicious node, via an invalid proposal with an invalid header, will cause normal nodes to stop producing new blocks and processing new clients' requests.\n\n- CVE-2022-1699: Uncontrolled Resource Consumption in GitHub repository causefx/organizr prior to 2.1.2000. This vulnerability can be abused by doing a DDoS attack for which genuine users will not able to access resources/applications.\n\nRelated Weaknesses:\n\n- CWE-682 (ChildOf)\n\n- CWE-682 (ChildOf)\n\n- CWE-20 (ChildOf)\n\n- CWE-119 (CanPrecede)",
            "type": "Base",
            "source": "sparse",
            "search_source": "weakness:memory corruption",
            "sources": [
              "base",
              "weakness"
            ],
            "boost_factor": 2.8,
            "boosted": true,
            "metadata": {
              "source": "sparse",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Be careful of terminology problems with \"overflow,\" \"underflow,\" and \"wraparound\" - see Terminology Notes. Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ],
                "suggestions": [
                  {
                    "CweID": "191",
                    "Comment": "Integer Underflow (Wrap or Wraparound). Consider CWE-191 when the result is less than the minimum value that can be represented (sometimes called \"underflows\")."
                  }
                ]
              }
            }
          },
          {
            "cwe_id": "788",
            "name": "Access of Memory Location After End of Buffer",
            "description": "The product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.",
            "score": 51.05905723022035,
            "matched_text": "CWE-788: Access of Memory Location After End of Buffer\n\nType: Base\n\nStatus: Incomplete\n\nDescription:\n\nThe product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.\n\nExtended Details:\n\nThis typically occurs when a pointer or its index is incremented to a position after the buffer; or when pointer arithmetic results in a position after the buffer.\n\nReal-World Examples:\n\n- CVE-2009-2550: Classic stack-based buffer overflow in media player using a long entry in a playlist\n\n- CVE-2009-2403: Heap-based buffer overflow in media player using a long entry in a playlist\n\n- CVE-2009-0689: large precision value in a format string triggers overflow\n\n- CVE-2009-0558: attacker-controlled array index leads to code execution\n\n- CVE-2008-4113: OS kernel trusts userland-supplied length value, allowing reading of sensitive information\n\n- CVE-2007-4268: Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)\n\nTop 25 CWE Examples:\n\n- CVE-2021-28602: Adobe After Effects version 18.2 (and earlier) is affected by a memory corruption vulnerability when parsing a specially crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-28605: Adobe After Effects version 18.2 (and earlier) is affected by a memory corruption vulnerability when parsing a specially crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-36059: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-36067: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-36068: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-36069: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-36076: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-36077: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious SVG file, potentially resulting in local application denial of service in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-36078: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-39816: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-39817: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-39818: Adobe InCopy version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious TIFF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-39819: Adobe InCopy version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious XML file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-39824: Adobe Premiere Elements version 2021.2235820 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious png file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-39830: Adobe Framemaker versions 2019 Update 8 (and earlier) and 2020 Release Update 2 (and earlier) are affected by a memory corruption vulnerability due to insecure handling of a malicious PDF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-39832: Adobe Framemaker versions 2019 Update 8 (and earlier) and 2020 Release Update 2 (and earlier) are affected by a memory corruption vulnerability due to insecure handling of a malicious PDF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40700: Adobe Premiere Elements version 2021.2235820 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious TIFF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40701: Adobe Premiere Elements version 2021.2235820 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious m4a file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40702: Adobe Premiere Elements version 2021.2235820 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious psd file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40703: Adobe Premiere Elements version 2021.2235820 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious m4a file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40710: Adobe Premiere Pro version 15.4 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious .svg file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40715: Adobe Premiere Pro version 15.4 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious .exr file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40733: Adobe Animate version 21.0.9 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious .psd file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40751: Adobe After Effects version 18.4 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious .m4a file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40752: Adobe After Effects version 18.4 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious .m4a file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40753: Adobe After Effects version 18.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious SVG file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40754: Adobe After Effects version 18.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40755: Adobe After Effects version 18.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious SGI file in the DoReadContinue function, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40757: Adobe After Effects version 18.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious MXF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40758: Adobe After Effects version 18.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40759: Adobe After Effects version 18.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious .m4a file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40760: Adobe After Effects version 18.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious .m4a file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40770: Adobe Prelude version 10.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40771: Adobe Prelude version 10.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40772: Adobe Prelude version 10.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40775: Adobe Prelude version 10.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious SVG file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-42266: Adobe Animate version 21.0.9 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious FLA file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42723: Adobe Bridge version 11.1.1 (and earlier) is affected by an out-of-bounds read vulnerability when parsing a crafted SGI file, which could result in a read past the end of an allocated memory structure. An attacker could leverage this vulnerability to execute code in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-42726: Adobe Bridge version 11.1.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42737: Adobe Prelude version 10.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-42738: Adobe Prelude version 10.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious MXF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-43011: Adobe Prelude version 10.1 (and earlier) are affected by a memory corruption vulnerability. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious M4A file.\n\n- CVE-2021-43012: Adobe Prelude version 10.1 (and earlier) are affected by a memory corruption vulnerability. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious M4A file.\n\n- CVE-2021-43013: Adobe Media Encoder version 15.4.1 (and earlier) are affected by a memory corruption vulnerability. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-43015: Adobe InCopy version 16.4 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious GIF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-42721: Acrobat Bridge versions 11.1.1 and earlier are affected by a use-after-free vulnerability in the processing of Format event actions that could result in arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-42267: Adobe Animate version 21.0.9 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious FLA file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-36070: Adobe Media Encoder version 15.1 (and earlier) is affected by an improper memory access vulnerability when parsing a crafted .SVG file. An attacker could leverage this vulnerability to execute code in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-40142: In OPC Foundation Local Discovery Server (LDS) before 1.04.402.463, remote attackers can cause a denial of service (DoS) by sending carefully crafted messages that lead to Access of a Memory Location After the End of a Buffer.\n\n- CVE-2021-41771: ImportedSymbols in debug/macho (for Open or OpenFat) in Go before 1.16.10 and 1.17.x before 1.17.3 Accesses a Memory Location After the End of a Buffer, aka an out-of-bounds slice situation.\n\n- CVE-2021-45067: Acrobat Reader DC version 21.007.20099 (and earlier), 20.004.30017 (and earlier) and 17.011.30204 (and earlier) are affected by an Access of Memory Location After End of Buffer vulnerability that could lead to disclosure of sensitive memory. An attacker could leverage this vulnerability to bypass mitigations such as ASLR. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-44712: Acrobat Reader DC version 21.007.20099 (and earlier), 20.004.30017 (and earlier) and 17.011.30204 (and earlier) are affected by an Access of Memory Location After End of Buffer vulnerability that could lead to application denial-of-service. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-39820: Adobe InDesign versions 16.3 (and earlier), and 16.3.1 (and earlier) is affected by an Out-of-bounds Write vulnerability due to insecure handling of a malicious TIFF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40734: Adobe Audition version 14.4 (and earlier) is affected by a memory corruption vulnerability when parsing a SVG file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40735: Adobe Audition version 14.4 (and earlier) is affected by a memory corruption vulnerability, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40736: Adobe Audition version 14.4 (and earlier) is affected by a memory corruption vulnerability, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40738: Adobe Audition version 14.4 (and earlier) is affected by a memory corruption vulnerability when parsing a WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40739: Adobe Audition version 14.4 (and earlier) is affected by a memory corruption vulnerability when parsing a M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40740: Adobe Audition version 14.4 (and earlier) is affected by a memory corruption vulnerability when parsing a M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40763: Adobe Character Animator version 4.4 (and earlier) is affected by a memory corruption vulnerability when parsing a WAF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40764: Adobe Character Animator version 4.4 (and earlier) is affected by a memory corruption vulnerability when parsing a M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40765: Adobe Character Animator version 4.4 (and earlier) is affected by a memory corruption vulnerability when parsing a M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40777: Adobe Media Encoder version 15.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40779: Adobe Media Encoder version 15.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40780: Adobe Media Encoder version 15.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40783: Adobe Premiere Rush version 1.5.16 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40784: Adobe Premiere Rush version 1.5.16 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40786: Adobe Premiere Elements 20210809.daily.2242976 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40787: Adobe Premiere Elements 20210809.daily.2242976 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40792: Adobe Premiere Pro version 15.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40793: Adobe Premiere Pro version 15.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40794: Adobe Premiere Pro version 15.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42526: Adobe Premiere Elements 20210809.daily.2242976 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42527: Adobe Premiere Elements 20210809.daily.2242976 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42724: Adobe Bridge version 11.1.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42725: Adobe Bridge version 11.1.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42729: Adobe Bridge version 11.1.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42730: Adobe Bridge version 11.1.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious PSD file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-43754: Adobe Prelude version 22.1.1 (and earlier) is affected by an Out-of-bounds Write vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-43755: Adobe After Effects versions 22.0 (and earlier) and 18.4.2 (and earlier) are affected by an Out-of-bounds Write vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-43756: Adobe Media Encoder versions 22.0, 15.4.2 (and earlier) are affected by an Out-of-bounds Write vulnerability. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2022-0521: Access of Memory Location After End of Buffer in GitHub repository radareorg/radare2 prior to 5.6.2.\n\nRelated Weaknesses:\n\n- CWE-119 (ChildOf)\n\n- CWE-119 (ChildOf)\n\n- CWE-119 (ChildOf)",
            "type": "Base",
            "source": "sparse",
            "search_source": "weakness:memory corruption",
            "sources": [
              "base",
              "weakness"
            ],
            "boost_factor": 2.8,
            "boosted": true,
            "metadata": {
              "source": "sparse",
              "mapping_notes": {
                "usage": "Discouraged",
                "rationale": "The CWE entry might be misused when lower-level CWE entries might be available. It also overlaps existing CWE entries and might be deprecated in the future.",
                "comments": "If the \"Access\" operation is known to be a read or a write, then investigate children of entries such as CWE-787: Out-of-bounds Write and CWE-125: Out-of-bounds Read.",
                "reasons": [
                  "Potential Deprecation",
                  "Frequent Misuse"
                ]
              }
            }
          },
          {
            "cwe_id": "366",
            "name": "Race Condition within a Thread",
            "description": "If two threads of execution use a resource simultaneously, there exists the possibility that resources may be used while invalid, in turn making the state of execution undefined.",
            "score": 50.5279456484442,
            "matched_text": "CWE-366: Race Condition within a Thread\n\nType: Base\n\nStatus: Draft\n\nDescription:\n\nIf two threads of execution use a resource simultaneously, there exists the possibility that resources may be used while invalid, in turn making the state of execution undefined.\n\nReal-World Examples:\n\n- CVE-2022-2621: Chain: two threads in a web browser use the same resource (CWE-366), but one of those threads can destroy the resource before the other has completed (CWE-416).\n\nTop 25 CWE Examples:\n\n- CVE-2021-0652: In VectorDrawable::VectorDrawable of VectorDrawable.java, there is a possible way to introduce a memory corruption due to sharing of not thread-safe objects. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-8.1 Android-9 Android-10 Android-11Android ID: A-185178568\n\n- CVE-2021-21165: Data race in audio in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21166: Data race in audio in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-26569: Race Condition within a Thread vulnerability in iscsi_snapshot_comm_core in Synology DiskStation Manager (DSM) before 6.2.3-25426-3 allows remote attackers to execute arbitrary code via crafted web requests.\n\n- CVE-2020-36447: An issue was discovered in the v9 crate through 2020-12-18 for Rust. There is an unconditional implementation of Sync for SyncRef<T>.\n\n- CVE-2020-36448: An issue was discovered in the cache crate through 2020-11-24 for Rust. There are unconditional implementations of Send and Sync for Cache<K>.\n\n- CVE-2020-36449: An issue was discovered in the kekbit crate before 0.3.4 for Rust. For ShmWriter<H>, Send is implemented without requiring H: Send.\n\n- CVE-2020-36450: An issue was discovered in the bunch crate through 2020-11-12 for Rust. There are unconditional implementations of Send and Sync for Bunch<T>.\n\n- CVE-2020-36451: An issue was discovered in the rcu_cell crate through 2020-11-14 for Rust. There are unconditional implementations of Send and Sync for RcuCell<T>.\n\n- CVE-2020-36455: An issue was discovered in the slock crate through 2020-11-17 for Rust. Slock<T> unconditionally implements Send and Sync.\n\n- CVE-2020-36456: An issue was discovered in the toolshed crate through 2020-11-15 for Rust. In CopyCell<T>, the Send trait lacks bounds on the contained type.\n\n- CVE-2020-36457: An issue was discovered in the lever crate before 0.1.1 for Rust. AtomicBox<T> implements the Send and Sync traits for all types T.\n\n- CVE-2020-36458: An issue was discovered in the lexer crate through 2020-11-10 for Rust. For ReaderResult<T, E>, there is an implementation of Sync with a trait bound of T: Send, E: Send.\n\n- CVE-2020-36459: An issue was discovered in the dces crate through 2020-12-09 for Rust. The World type is marked as Send but lacks bounds on its EntityStore and ComponentStore.\n\n- CVE-2020-36461: An issue was discovered in the noise_search crate through 2020-12-10 for Rust. There are unconditional implementations of Send and Sync for MvccRwLock.\n\n- CVE-2020-36462: An issue was discovered in the syncpool crate before 0.1.6 for Rust. There is an unconditional implementation of Send for Bucket2.\n\n- CVE-2020-36463: An issue was discovered in the multiqueue crate through 2020-12-25 for Rust. There are unconditional implementations of Send for InnerSend<RW, T>, InnerRecv<RW, T>, FutInnerSend<RW, T>, and FutInnerRecv<RW, T>.\n\n- CVE-2021-33078: Race condition within a thread in firmware for some Intel(R) Optane(TM) SSD and Intel(R) SSD DC Products may allow a privileged user to potentially enable denial of service via local access.\n\n- CVE-2021-44733: A use-after-free exists in drivers/tee/tee_shm.c in the TEE subsystem in the Linux kernel through 5.15.11. This occurs because of a race condition in tee_shm_get_from_id during an attempt to free a shared memory object.\n\n- CVE-2022-20148: In TBD of TBD, there is a possible use-after-free due to a race condition. This could lead to local escalation of privilege in the kernel with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-219513976References: Upstream kernel\n\n- CVE-2022-2607: Use after free in Tab Strip in Google Chrome on Chrome OS prior to 104.0.5112.79 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2608: Use after free in Overview Mode in Google Chrome on Chrome OS prior to 104.0.5112.79 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2609: Use after free in Nearby Share in Google Chrome on Chrome OS prior to 104.0.5112.79 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2617: Use after free in Extensions API in Google Chrome prior to 104.0.5112.79 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2621: Use after free in Extensions in Google Chrome prior to 104.0.5112.79 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2857: Use after free in Blink in Google Chrome prior to 104.0.5112.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2742: Use after free in Exosphere in Google Chrome on Chrome OS and Lacros prior to 104.0.5112.79 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via crafted UI interactions. (Chrome security severity: High)\n\n- CVE-2022-2854: Use after free in SwiftShader in Google Chrome prior to 104.0.5112.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3049: Use after free in SplitScreen in Google Chrome on Chrome OS, Lacros prior to 105.0.5195.52 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3071: Use after free in Tab Strip in Google Chrome on Chrome OS, Lacros prior to 105.0.5195.52 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via crafted UI interaction.\n\nRelated Weaknesses:\n\n- CWE-362 (ChildOf)\n\n- CWE-662 (ChildOf)\n\n- CWE-662 (ChildOf)",
            "type": "Base",
            "source": "sparse",
            "search_source": "weakness:memory corruption",
            "sources": [
              "base",
              "weakness"
            ],
            "boost_factor": 2.8,
            "boosted": true,
            "metadata": {
              "source": "sparse",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              }
            }
          },
          {
            "cwe_id": "822",
            "name": "Untrusted Pointer Dereference",
            "description": "The product obtains a value from an untrusted source, converts this value to a pointer, and dereferences the resulting pointer.",
            "score": 48.46614763081808,
            "matched_text": "CWE-822: Untrusted Pointer Dereference\n\nType: Base\n\nStatus: Incomplete\n\nDescription:\n\nThe product obtains a value from an untrusted source, converts this value to a pointer, and dereferences the resulting pointer.\n\nExtended Details:\n\n\n\nAn attacker can supply a pointer for memory locations that the product is not expecting. If the pointer is dereferenced for a write operation, the attack might allow modification of critical state variables, cause a crash, or execute code. If the dereferencing operation is for a read, then the attack might allow reading of sensitive data, cause a crash, or set a variable to an unexpected value (since the value will be read from an unexpected memory location).\n\n\nThere are several variants of this weakness, including but not necessarily limited to:\n\n\n  - The untrusted value is directly invoked as a function call.\n\n  - In OS kernels or drivers where there is a boundary between \"userland\" and privileged memory spaces, an untrusted pointer might enter through an API or system call (see CWE-781 for one such example).\n\n  - Inadvertently accepting the value from an untrusted control sphere when it did not have to be accepted as input at all. This might occur when the code was originally developed to be run by a single user in a non-networked environment, and the code is then ported to or otherwise exposed to a networked environment.\n\n\n\nReal-World Examples:\n\n- CVE-2007-5655: message-passing framework interprets values in packets as pointers, causing a crash.\n\n- CVE-2010-2299: labeled as a \"type confusion\" issue, also referred to as a \"stale pointer.\" However, the bug ID says \"contents are simply interpreted as a pointer... renderer ordinarily doesn't supply this pointer directly\". The \"handle\" in the untrusted area is replaced in one function, but not another - thus also, effectively, exposure to wrong sphere (CWE-668).\n\n- CVE-2009-1719: Untrusted dereference using undocumented constructor.\n\n- CVE-2009-1250: An error code is incorrectly checked and interpreted as a pointer, leading to a crash.\n\n- CVE-2009-0311: An untrusted value is obtained from a packet and directly called as a function pointer, leading to code execution.\n\n- CVE-2010-1818: Undocumented attribute in multimedia software allows \"unmarshaling\" of an untrusted pointer.\n\n- CVE-2010-3189: ActiveX control for security software accepts a parameter that is assumed to be an initialized pointer.\n\n- CVE-2010-1253: Spreadsheet software treats certain record values that lead to \"user-controlled pointer\" (might be untrusted offset, not untrusted pointer).\n\nTop 25 CWE Examples:\n\n- CVE-2021-22649: Luxion KeyShot versions prior to 10.1, Luxion KeyShot Viewer versions prior to 10.1, Luxion KeyShot Network Rendering versions prior to 10.1, and Luxion KeyVR versions prior to 10.1 have multiple NULL pointer dereference issues while processing project files, which may allow an attacker to execute arbitrary code.\n\n- CVE-2021-40157: A user may be tricked into opening a malicious FBX file which may exploit an Untrusted Pointer Dereference vulnerability in FBX\u2019s Review version 1.5.0 and prior causing it to run arbitrary code on the system.\n\n- CVE-2021-1973: A FTM Diag command can allow an arbitrary write into modem OS space in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2021-20239: A flaw was found in the Linux kernel in versions before 5.4.92 in the BPF protocol. This flaw allows an attacker with a local account to leak information about kernel internal addresses. The highest threat from this vulnerability is to confidentiality.\n\n- CVE-2020-7452: In FreeBSD 12.1-STABLE before r357490, 12.1-RELEASE before 12.1-RELEASE-p3, 11.3-STABLE before r357489, and 11.3-RELEASE before 11.3-RELEASE-p7, incorrect use of a user-controlled pointer in the epair virtual network module allowed vnet jailed privileged users to panic the host system and potentially execute arbitrary code in the kernel.\n\n- CVE-2021-46019: An untrusted pointer dereference in rec_db_destroy() at rec-db.c of GNU Recutils v1.8.90 can lead to a segmentation fault or application crash.\n\n- CVE-2021-46237: An untrusted pointer dereference vulnerability exists in GPAC v1.1.0 via the function gf_node_unregister () at scenegraph/base_scenegraph.c. This vulnerability can lead to a Denial of Service (DoS).\n\n- CVE-2021-46243: An untrusted pointer dereference vulnerability exists in HDF5 v1.13.1-1 via the function H5O__dtype_decode_helper () at hdf5/src/H5Odtype.c. This vulnerability can lead to a Denial of Service (DoS).\n\n- CVE-2021-46020: An untrusted pointer dereference in mrb_vm_exec() of mruby v3.0.0 can lead to a segmentation fault or application crash.\n\n- CVE-2021-46023: An Untrusted Pointer Dereference was discovered in function mrb_vm_exec in mruby before 3.1.0-rc. The vulnerability causes a segmentation fault and application crash.\n\n- CVE-2022-22098: Memory corruption in multimedia driver due to untrusted pointer dereference while reading data from socket in Snapdragon Auto\n\n- CVE-2022-25661: Memory corruption due to untrusted pointer dereference in kernel in Snapdragon Auto, Snapdragon Compute, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile\n\n- CVE-2022-25658: Memory corruption due to incorrect pointer arithmetic when attempting to change the endianness in video parser function in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2021-41837: An issue was discovered in AhciBusDxe in the kernel 5.0 through 5.5 in Insyde InsydeH2O. Because of an Untrusted Pointer Dereference that causes SMM memory corruption, an attacker may be able to write fixed or predictable data to SMRAM. Exploiting this issue could lead to escalating privileges to SMM.\n\n- CVE-2021-41839: An issue was discovered in NvmExpressDxe in the kernel 5.0 through 5.5 in Insyde InsydeH2O. Because of an Untrusted Pointer Dereference that causes SMM memory corruption, an attacker may be able to write fixed or predictable data to SMRAM. Exploiting this issue could lead to escalating privileges to SMM.\n\n- CVE-2022-25662: Information disclosure due to untrusted pointer dereference in kernel in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile, Snapdragon Wearables\n\n- CVE-2022-22716: Microsoft Excel Information Disclosure Vulnerability\n\n- CVE-2022-29275: In UsbCoreDxe, untrusted input may allow SMRAM or OS memory tampering Use of untrusted pointers could allow OS or SMRAM memory tampering leading to escalation of privileges. This issue was discovered by Insyde during security review. It was fixed in: Kernel 5.0: version 05.09.21 Kernel 5.1: version 05.17.21 Kernel 5.2: version 05.27.21 Kernel 5.3: version 05.36.21 Kernel 5.4: version 05.44.21 Kernel 5.5: version 05.52.21 https://www.insyde.com/security-pledge/SA-2022058\n\n- CVE-2022-29279: Use of a untrusted pointer allows tampering with SMRAM and OS memory in SdHostDriver and SdMmcDevice Use of a untrusted pointer allows tampering with SMRAM and OS memory in SdHostDriver and SdMmcDevice. This issue was discovered by Insyde during security review. It was fixed in: Kernel 5.0: version 05.09.17 Kernel 5.1: version 05.17.17 Kernel 5.2: version 05.27.17 Kernel 5.3: version 05.36.17 Kernel 5.4: version 05.44.17 Kernel 5.5: version 05.52.17 https://www.insyde.com/security-pledge/SA-2022062\n\nRelated Weaknesses:\n\n- CWE-119 (ChildOf)\n\n- CWE-119 (ChildOf)\n\n- CWE-119 (ChildOf)\n\n- CWE-125 (CanPrecede)\n\n- CWE-787 (CanPrecede)",
            "type": "Base",
            "source": "sparse",
            "search_source": "weakness:memory corruption",
            "sources": [
              "base",
              "weakness"
            ],
            "boost_factor": 2.8,
            "boosted": true,
            "metadata": {
              "source": "sparse",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              }
            }
          },
          {
            "cwe_id": "908",
            "name": "Use of Uninitialized Resource",
            "description": "The product uses or accesses a resource that has not been initialized.",
            "score": 47.42449593239558,
            "matched_text": "CWE-908: Use of Uninitialized Resource\n\nType: Base\n\nStatus: Incomplete\n\nDescription:\n\nThe product uses or accesses a resource that has not been initialized.\n\nExtended Details:\n\nWhen a resource has not been properly initialized, the product may behave unexpectedly. This may lead to a crash or invalid memory access, but the consequences vary depending on the type of resource and how it is used within the product.\n\nReal-World Examples:\n\n- CVE-2019-9805: Chain: Creation of the packet client occurs before initialization is complete (CWE-696) resulting in a read from uninitialized memory (CWE-908), causing memory corruption.\n\n- CVE-2008-4197: Use of uninitialized memory may allow code execution.\n\n- CVE-2008-2934: Free of an uninitialized pointer leads to crash and possible code execution.\n\n- CVE-2008-0063: Product does not clear memory contents when generating an error message, leading to information leak.\n\n- CVE-2008-0062: Lack of initialization triggers NULL pointer dereference or double-free.\n\n- CVE-2008-0081: Uninitialized variable leads to code execution in popular desktop application.\n\n- CVE-2008-3688: Chain: Uninitialized variable leads to infinite loop.\n\n- CVE-2008-3475: Chain: Improper initialization leads to memory corruption.\n\n- CVE-2005-1036: Chain: Bypass of access restrictions due to improper authorization (CWE-862) of a user results from an improperly initialized (CWE-909) I/O permission bitmap\n\n- CVE-2008-3597: Chain: game server can access player data structures before initialization has happened leading to NULL dereference\n\n- CVE-2009-2692: Chain: uninitialized function pointers can be dereferenced allowing code execution\n\n- CVE-2009-0949: Chain: improper initialization of memory can lead to NULL dereference\n\n- CVE-2009-3620: Chain: some unprivileged ioctls do not verify that a structure has been initialized before invocation, leading to NULL dereference\n\nTop 25 CWE Examples:\n\n- CVE-2021-0473: In rw_t3t_process_error of rw_t3t.cc, there is a possible double free due to uninitialized data. This could lead to remote code execution over NFC with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-9 Android-10 Android-11 Android-8.1Android ID: A-179687208\n\n- CVE-2021-0495: In memory management driver, there is a possible out of bounds write due to uninitialized data. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-183459083\n\n- CVE-2021-0526: In memory management driver, there is a possible out of bounds write due to uninitialized data. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-185195264\n\n- CVE-2021-0530: In memory management driver, there is a possible out of bounds write due to uninitialized data. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-185196175\n\n- CVE-2021-0634: In display driver, there is a possible memory corruption due to uninitialized data. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05594994; Issue ID: ALPS05594994.\n\n- CVE-2021-25905: An issue was discovered in the bra crate before 0.1.1 for Rust. It lacks soundness because it can read uninitialized memory.\n\n- CVE-2021-28033: An issue was discovered in the byte_struct crate before 0.6.1 for Rust. There can be a drop of uninitialized memory if a certain deserialization method panics.\n\n- CVE-2021-29631: In FreeBSD 13.0-STABLE before n246941-20f96f215562, 12.2-STABLE before r370400, 11.4-STABLE before r370399, 13.0-RELEASE before p4, 12.2-RELEASE before p10, and 11.4-RELEASE before p13, certain VirtIO-based device models in bhyve failed to handle errors when fetching I/O descriptors. A malicious guest may cause the device model to operate on uninitialized I/O vectors leading to memory corruption, crashing of the bhyve process, and possibly arbitrary code execution in the bhyve process.\n\n- CVE-2021-29930: An issue was discovered in the arenavec crate through 2021-01-12 for Rust. A drop of uninitialized memory can sometimes occur upon a panic in T::default().\n\n- CVE-2021-29934: An issue was discovered in PartialReader in the uu_od crate before 0.0.4 for Rust. Attackers can read the contents of uninitialized memory locations via a user-provided Read operation.\n\n- CVE-2021-29980: Uninitialized memory in a canvas object could have caused an incorrect free() leading to memory corruption and a potentially exploitable crash. This vulnerability affects Thunderbird < 78.13, Thunderbird < 91, Firefox ESR < 78.13, and Firefox < 91.\n\n- CVE-2021-30454: An issue was discovered in the outer_cgi crate before 0.2.1 for Rust. A user-provided Read instance receives an uninitialized memory buffer from KeyValueReader.\n\n- CVE-2021-29937: An issue was discovered in the telemetry crate through 2021-02-17 for Rust. There is a drop of uninitialized memory if a value.clone() call panics within misc::vec_with_size().\n\n- CVE-2021-3545: An information disclosure vulnerability was found in the virtio vhost-user GPU device (vhost-user-gpu) of QEMU in versions up to and including 6.0. The flaw exists in virgl_cmd_get_capset_info() in contrib/vhost-user-gpu/virgl.c and could occur due to the read of uninitialized memory. A malicious guest could exploit this issue to leak memory from the host.\n\n- CVE-2020-36432: An issue was discovered in the alg_ds crate through 2020-08-25 for Rust. There is a drop of uninitialized memory in Matrix::new().\n\n- CVE-2020-36452: An issue was discovered in the array-tools crate before 0.3.2 for Rust. FixedCapacityDequeLike::clone() has a drop of uninitialized memory.\n\n- CVE-2021-28035: An issue was discovered in the stack_dst crate before 0.6.1 for Rust. Because of the push_inner behavior, a drop of uninitialized memory can occur upon a val.clone() panic.\n\n- CVE-2021-28029: An issue was discovered in the toodee crate before 0.3.0 for Rust. The row-insertion feature allows attackers to read the contents of uninitialized memory locations.\n\n- CVE-2021-36282: Dell EMC PowerScale OneFS versions 8.2.x - 9.1.0.x contain a use of uninitialized resource vulnerability. This can potentially allow an authenticated user with ISI_PRIV_LOGIN_CONSOLE or ISI_PRIV_LOGIN_SSH privileges to gain access up to 24 bytes of data within the /ifs kernel stack under certain conditions.\n\n- CVE-2021-43848: h2o is an open source http server. In code prior to the `8c0eca3` commit h2o may attempt to access uninitialized memory. When receiving QUIC frames in certain order, HTTP/3 server-side implementation of h2o can be misguided to treat uninitialized memory as HTTP/3 frames that have been received. When h2o is used as a reverse proxy, an attacker can abuse this vulnerability to send internal state of h2o to backend servers controlled by the attacker or third party. Also, if there is an HTTP endpoint that reflects the traffic sent from the client, an attacker can use that reflector to obtain internal state of h2o. This internal state includes traffic of other connections in unencrypted form and TLS session tickets. This vulnerability exists in h2o server with HTTP/3 support, between commit 93af138 and d1f0f65. None of the released versions of h2o are affected by this vulnerability. There are no known workarounds. Users of unreleased versions of h2o using HTTP/3 are advised to upgrade immediately.\n\n- CVE-2021-39671: In code generated by aidl_const_expressions.cpp, there is a possible out of bounds read due to uninitialized data. This could lead to information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-12Android ID: A-206718630\n\n- CVE-2022-26437: In httpclient, there is a possible out of bounds write due to uninitialized data. This could lead to remote escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: WSAP00103831; Issue ID: WSAP00103831.\n\n- CVE-2022-2949:  Altair HyperView Player versions 2021.1.0.27 and prior are vulnerable to the use of uninitialized memory vulnerability during parsing of H3D files. A DWORD is extracted from an uninitialized buffer and, after sign extension, is used as an index into a stack variable to increment a counter leading to memory corruption. \n\n- CVE-2022-2950:  Altair HyperView Player versions 2021.1.0.27 and prior are vulnerable to the use of uninitialized memory vulnerability during parsing of H3D files. A DWORD is extracted from an uninitialized buffer and, after sign extension, is used as an index into a stack variable to increment a counter leading to memory corruption. \n\n- CVE-2022-32615: In ccd, there is a possible out of bounds write due to uninitialized data. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07326559; Issue ID: ALPS07326559.\n\n- CVE-2022-32616: In isp, there is a possible out of bounds write due to uninitialized data. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07341258; Issue ID: ALPS07341258.\n\n- CVE-2022-39283: FreeRDP is a free remote desktop protocol library and clients. All FreeRDP based clients when using the `/video` command line switch might read uninitialized data, decode it as audio/video and display the result. FreeRDP based server implementations are not affected. This issue has been patched in version 2.8.1. If you cannot upgrade do not use the `/video` switch.\n\n- CVE-2022-20015: In kd_camera_hw driver, there is a possible information disclosure due to uninitialized data. This could lead to local information disclosure with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05862966; Issue ID: ALPS05862966.\n\n- CVE-2022-20357: In writeToParcel of SurfaceControl.cpp, there is a possible information disclosure due to uninitialized data. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-12 Android-12LAndroid ID: A-214999987\n\n- CVE-2022-38668: HTTP applications (servers) based on Crow through 1.0+4 may reveal potentially sensitive uninitialized data from stack memory when fulfilling a request for a static file smaller than 16 KB.\n\n- CVE-2022-0494: A kernel information leak flaw was identified in the scsi_ioctl function in drivers/scsi/scsi_ioctl.c in the Linux kernel. This flaw allows a local attacker with a special user privilege (CAP_SYS_ADMIN or CAP_SYS_RAWIO) to create issues with confidentiality.\n\nRelated Weaknesses:\n\n- CWE-665 (ChildOf)\n\n- CWE-665 (ChildOf)",
            "type": "Base",
            "source": "sparse",
            "search_source": "weakness:memory corruption",
            "sources": [
              "base",
              "weakness"
            ],
            "boost_factor": 2.8,
            "boosted": true,
            "metadata": {
              "source": "sparse",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              }
            }
          },
          {
            "cwe_id": "191",
            "name": "Integer Underflow (Wrap or Wraparound)",
            "description": "The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.",
            "score": 10.227986494513978,
            "matched_text": "CWE-191: Integer Underflow (Wrap or Wraparound)\n\nType: Base\n\nStatus: Draft\n\nAlternative Terms:\n\nInteger underflow - \n\n\"Integer underflow\" is sometimes used to identify signedness errors in which an originally positive number becomes negative as a result of subtraction. However, there are cases of bad subtraction in which unsigned integers are involved, so it's not always a signedness issue.\n\n\n\"Integer underflow\" is occasionally used to describe array index errors in which the index is negative.\n\n\nInteger underflow - \n\n\"Integer underflow\" is sometimes used to identify signedness errors in which an originally positive number becomes negative as a result of subtraction. However, there are cases of bad subtraction in which unsigned integers are involved, so it's not always a signedness issue.\n\n\n\"Integer underflow\" is occasionally used to describe array index errors in which the index is negative.\n\n\nInteger underflow - \n\n\"Integer underflow\" is sometimes used to identify signedness errors in which an originally positive number becomes negative as a result of subtraction. However, there are cases of bad subtraction in which unsigned integers are involved, so it's not always a signedness issue.\n\n\n\"Integer underflow\" is occasionally used to describe array index errors in which the index is negative.\n\n\nDescription:\n\nThe product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.\n\nExtended Details:\n\nThis can happen in signed and unsigned cases.\n\nReal-World Examples:\n\n- CVE-2004-0816: Integer underflow in firewall via malformed packet.\n\n- CVE-2004-1002: Integer underflow by packet with invalid length.\n\n- CVE-2005-0199: Long input causes incorrect length calculation.\n\n- CVE-2005-1891: Malformed icon causes integer underflow in loop counter variable.\n\nTop 25 CWE Examples:\n\n- CVE-2021-27486: FATEK Automation WinProladder Versions 3.30 and prior is vulnerable to an integer underflow, which may cause an out-of-bounds write and allow an attacker to execute arbitrary code.\n\n- CVE-2021-28027: An issue was discovered in the bam crate before 0.1.3 for Rust. There is an integer underflow and out-of-bounds write during the loading of a bgzip block.\n\n- CVE-2021-28362: An issue was discovered in Contiki through 3.0. When sending an ICMPv6 error message because of invalid extension header options in an incoming IPv6 packet, there is an attempt to remove the RPL extension headers. Because the packet length and the extension header length are unchecked (with respect to the available data) at this stage, and these variables are susceptible to integer underflow, it is possible to construct an invalid extension header that will cause memory corruption issues and lead to a Denial-of-Service condition. This is related to rpl-ext-header.c.\n\n- CVE-2021-3321: Integer Underflow in Zephyr in IEEE 802154 Fragment Reassembly Header Removal. Zephyr versions >= >=2.4.0 contain Integer Overflow to Buffer Overflow (CWE-680). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-w44j-66g7-xw99\n\n- CVE-2021-31178: Microsoft Office Information Disclosure Vulnerability\n\n- CVE-2021-4066: Integer underflow in ANGLE in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0185: A heap-based buffer overflow flaw was found in the way the legacy_parse_param function in the Filesystem Context functionality of the Linux kernel verified the supplied parameters length. An unprivileged (in case of unprivileged user namespaces enabled, otherwise needs namespaced CAP_SYS_ADMIN privilege) local user able to open a filesystem that does not support the Filesystem Context API (and thus fallbacks to legacy handling) could use this flaw to escalate their privileges on the system.\n\n- CVE-2022-0544: An integer underflow in the DDS loader of Blender leads to an out-of-bounds read, possibly allowing an attacker to read sensitive data using a crafted DDS image file. This flaw affects Blender versions prior to 2.83.19, 2.93.8 and 3.1.\n\n- CVE-2022-20073: In preloader (usb), there is a possible out of bounds write due to a integer underflow. This could lead to local escalation of privilege, for an attacker who has physical access to the device, with no additional execution privileges needed. User interaction is needed for exploitation. Patch ID: ALPS06160841; Issue ID: ALPS06160841.\n\n- CVE-2022-20393: In extract3GPPGlobalDescriptions of TextDescriptions.cpp, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure from the media server with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11 Android-12 Android-12LAndroid ID: A-233735886\n\n- CVE-2022-20483: In several functions that parse avrc response in avrc_pars_ct.cc and related files, there are possible out of bounds reads due to integer overflows. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-242459126\n\n- CVE-2022-20516: In rw_t3t_act_handle_check_ndef_rsp of rw_t3t.cc, there is a possible out of bounds read due to an integer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-224002331\n\n- CVE-2022-23613: xrdp is an open source remote desktop protocol (RDP) server. In affected versions an integer underflow leading to a heap overflow in the sesman server allows any unauthenticated attacker which is able to locally access a sesman server to execute code as root. This vulnerability has been patched in version 0.9.18.1 and above. Users are advised to upgrade. There are no known workarounds.\n\n- CVE-2022-39293: Azure RTOS USBX is a high-performance USB host, device, and on-the-go (OTG) embedded stack, that is fully integrated with Azure RTOS ThreadX. The case is, in [_ux_host_class_pima_read](https://github.com/azure-rtos/usbx/blob/master/common/usbx_host_classes/src/ux_host_class_pima_read.c), there is data length from device response, returned in the very first packet, and read by [L165 code](https://github.com/azure-rtos/usbx/blob/082fd9db09a3669eca3358f10b8837a5c1635c0b/common/usbx_host_classes/src/ux_host_class_pima_read.c#L165), as header_length. Then in [L178 code](https://github.com/azure-rtos/usbx/blob/082fd9db09a3669eca3358f10b8837a5c1635c0b/common/usbx_host_classes/src/ux_host_class_pima_read.c#L178), there is a \u201cif\u201d branch, which check the expression of \u201c(header_length - UX_HOST_CLASS_PIMA_DATA_HEADER_SIZE) > data_length\u201d where if header_length is smaller than UX_HOST_CLASS_PIMA_DATA_HEADER_SIZE, calculation could overflow and then [L182 code](https://github.com/azure-rtos/usbx/blob/082fd9db09a3669eca3358f10b8837a5c1635c0b/common/usbx_host_classes/src/ux_host_class_pima_read.c#L182) the calculation of data_length is also overflow, this way the later [while loop start from L192](https://github.com/azure-rtos/usbx/blob/082fd9db09a3669eca3358f10b8837a5c1635c0b/common/usbx_host_classes/src/ux_host_class_pima_read.c#L192) can move data_pointer to unexpected address and cause write buffer overflow. The fix has been included in USBX release [6.1.12](https://github.com/azure-rtos/usbx/releases/tag/v6.1.12_rel). The following can be used as a workaround: Add check of `header_length`: 1. It must be greater than `UX_HOST_CLASS_PIMA_DATA_HEADER_SIZE`. 1. It should be greater or equal to the current returned data length (`transfer_request -> ux_transfer_request_actual_length`).\n\n- CVE-2022-4338: An integer underflow in Organization Specific TLV was found in various versions of OpenvSwitch.\n\n- CVE-2021-31956: Windows NTFS Elevation of Privilege Vulnerability\n\n- CVE-2022-22715: Named Pipe File System Elevation of Privilege Vulnerability\n\nRelated Weaknesses:\n\n- CWE-682 (ChildOf)\n\n- CWE-682 (ChildOf)",
            "type": "Base",
            "search_source": "base_query",
            "metadata": {
              "source": "sparse",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              }
            }
          },
          {
            "cwe_id": "770",
            "name": "Allocation of Resources Without Limits or Throttling",
            "description": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
            "score": 9.972354828241215,
            "matched_text": "CWE-770: Allocation of Resources Without Limits or Throttling\n\nType: Base\n\nStatus: Incomplete\n\nDescription:\n\nThe product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.\n\nExtended Details:\n\n\n\nCode frequently has to work with limited resources, so programmers must be careful to ensure that resources are not consumed too quickly, or too easily. Without use of quotas, resource limits, or other protection mechanisms, it can be easy for an attacker to consume many resources by rapidly making many requests, or causing larger resources to be used than is needed. When too many resources are allocated, or if a single resource is too large, then it can prevent the code from working correctly, possibly leading to a denial of service.\n\n\nReal-World Examples:\n\n- CVE-2022-21668: Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n\n- CVE-2009-4017: Language interpreter does not restrict the number of temporary files being created when handling a MIME request with a large number of parts..\n\n- CVE-2009-2726: Driver does not use a maximum width when invoking sscanf style functions, causing stack consumption.\n\n- CVE-2009-2540: Large integer value for a length property in an object causes a large amount of memory allocation.\n\n- CVE-2009-2054: Product allows exhaustion of file descriptors when processing a large number of TCP packets.\n\n- CVE-2008-5180: Communication product allows memory consumption with a large number of SIP requests, which cause many sessions to be created.\n\n- CVE-2008-1700: Product allows attackers to cause a denial of service via a large number of directives, each of which opens a separate window.\n\n- CVE-2005-4650: CMS does not restrict the number of searches that can occur simultaneously, leading to resource exhaustion.\n\n- CVE-2020-15100: web application scanner attempts to read an excessively large file created by a user, causing process termination\n\n- CVE-2020-7218: Go-based workload orchestrator does not limit resource usage with unauthenticated connections, allowing a DoS by flooding the service\n\nTop 25 CWE Examples:\n\n- CVE-2020-19463: An issue has been found in function vfprintf in PDF2JSON 0.70 that allows attackers to cause a Denial of Service due to a stack overflow.\n\n- CVE-2020-19464: An issue has been found in function XRef::fetch in PDF2JSON 0.70 that allows attackers to cause a Denial of Service due to a stack overflow .\n\n- CVE-2021-29324: OpenSource Moddable v10.5.0 was discovered to contain a stack overflow via the component /moddable/xs/sources/xsScript.c.\n\n- CVE-2021-29329: OpenSource Moddable v10.5.0 was discovered to contain a stack overflow in the fxBinaryExpressionNodeDistribute function at /moddable/xs/sources/xsTree.c.\n\n- CVE-2021-41800: MediaWiki before 1.36.2 allows a denial of service (resource consumption because of lengthy query processing time). Visiting Special:Contributions can sometimes result in a long running SQL query because PoolCounter protection is mishandled.\n\n- CVE-2021-35492: Wowza Streaming Engine through 4.8.11+5 could allow an authenticated, remote attacker to exhaust filesystem resources via the /enginemanager/server/vhost/historical.jsdata vhost parameter. This is due to the insufficient management of available filesystem resources. An attacker could exploit this vulnerability through the Virtual Host Monitoring section by requesting random virtual-host historical data and exhausting available filesystem resources. A successful exploit could allow the attacker to cause database errors and cause the device to become unresponsive to web-based management. (Manual intervention is required to free filesystem resources and return the application to an operational state.)\n\n- CVE-2021-22174: Crash in USB HID dissector in Wireshark 3.4.0 to 3.4.2 allows denial of service via packet injection or crafted capture file\n\n- CVE-2020-22785: Etherpad < 1.8.3 is affected by a missing lock check which could cause a denial of service. Aggressively targeting random pad import endpoints with empty data would flatten all pads due to lack of rate limiting and missing ownership check.\n\n- CVE-2021-33831: api/account/register in the TH Wildau COVID-19 Contact Tracing application through 2021-09-01 has Incorrect Access Control. An attacker can interfere with tracing of infection chains by creating 500 random users within 2500 seconds.\n\n- CVE-2020-28200: The Sieve engine in Dovecot before 2.3.15 allows Uncontrolled Resource Consumption, as demonstrated by a situation with a complex regular expression for the regex extension.\n\n- CVE-2021-41591: ACINQ Eclair before 0.6.3 allows loss of funds because of dust HTLC exposure.\n\n- CVE-2021-41592: Blockstream c-lightning through 0.10.1 allows loss of funds because of dust HTLC exposure.\n\n- CVE-2021-41593: Lightning Labs lnd before 0.13.3-beta allows loss of funds because of dust HTLC exposure.\n\n- CVE-2020-24821: A vulnerability in the dwarf::cursor::skip_form function of Libelfin v0.3 allows attackers to cause a denial of service (DOS) through a segmentation fault via a crafted ELF file.\n\n- CVE-2020-24822: A vulnerability in the dwarf::cursor::uleb function of Libelfin v0.3 allows attackers to cause a denial of service (DOS) through a segmentation fault via a crafted ELF file.\n\n- CVE-2020-24823: A vulnerability in the dwarf::to_string function of Libelfin v0.3 allows attackers to cause a denial of service (DOS) through a segmentation fault via a crafted ELF file.\n\n- CVE-2020-24825: A vulnerability in the line_table::line_table function of Libelfin v0.3 allows attackers to cause a denial of service (DOS) through a segmentation fault via a crafted ELF file.\n\n- CVE-2020-24826: A vulnerability in the elf::section::as_strtab function of Libelfin v0.3 allows attackers to cause a denial of service (DOS) through a segmentation fault via a crafted ELF file.\n\n- CVE-2021-0217: A vulnerability in processing of certain DHCP packets from adjacent clients on EX Series and QFX Series switches running Juniper Networks Junos OS with DHCP local/relay server configured may lead to exhaustion of DMA memory causing a Denial of Service (DoS). Over time, exploitation of this vulnerability may cause traffic to stop being forwarded, or to crashing of the fxpc process. When Packet DMA heap utilization reaches 99%, the system will become unstable. Packet DMA heap utilization can be monitored through the following command: user@junos# request pfe execute target fpc0 timeout 30 command \"show heap\" ID Base Total(b) Free(b) Used(b) % Name -- ---------- ----------- ----------- ----------- --- ----------- 0 213301a8 536870488 387228840 149641648 27 Kernel 1 91800000 8388608 3735120 4653488 55 DMA 2 92000000 75497472 74452192 1045280 1 PKT DMA DESC 3 d330000 335544320 257091400 78452920 23 Bcm_sdk 4 96800000 184549376 2408 184546968 99 Packet DMA <--- 5 903fffe0 20971504 20971504 0 0 Blob An indication of the issue occurring may be observed through the following log messages: Dec 10 08:07:00.124 2020 hostname fpc0 brcm_pkt_buf_alloc:523 (buf alloc) failed allocating packet buffer Dec 10 08:07:00.126 2020 hostname fpc0 (buf alloc) failed allocating packet buffer Dec 10 08:07:00.128 2020 hostname fpc0 brcm_pkt_buf_alloc:523 (buf alloc) failed allocating packet buffer Dec 10 08:07:00.130 2020 hostnameC fpc0 (buf alloc) failed allocating packet buffer This issue affects Juniper Networks Junos OS on EX Series and QFX Series: 17.4R3 versions prior to 17.4R3-S3; 18.1R3 versions between 18.1R3-S6 and 18.1R3-S11; 18.2R3 versions prior to 18.2R3-S6; 18.3R3 versions prior to 18.3R3-S4; 18.4R2 versions prior to 18.4R2-S5; 18.4R3 versions prior to 18.4R3-S6; 19.1 versions between 19.1R2 and 19.1R3-S3; 19.2 versions prior to 19.2R3-S1; 19.3 versions prior to 19.3R2-S5, 19.3R3; 19.4 versions prior to 19.4R2-S2, 19.4R3; 20.1 versions prior to 20.1R2; 20.2 versions prior to 20.2R1-S2, 20.2R2. Junos OS versions prior to 17.4R3 are unaffected by this vulnerability.\n\n- CVE-2021-0242: A vulnerability due to the improper handling of direct memory access (DMA) buffers on EX4300 switches on Juniper Networks Junos OS allows an attacker sending specific unicast frames to trigger a Denial of Service (DoS) condition by exhausting DMA buffers, causing the FPC to crash and the device to restart. The DMA buffer leak is seen when receiving these specific, valid unicast frames on an interface without Layer 2 Protocol Tunneling (L2PT) or dot1x configured. Interfaces with either L2PT or dot1x configured are not vulnerable to this issue. When this issue occurs, DMA buffer usage keeps increasing and the following error log messages may be observed: Apr 14 14:29:34.360 /kernel: pid 64476 (pfex_junos), uid 0: exited on signal 11 (core dumped) Apr 14 14:29:33.790 init: pfe-manager (PID 64476) terminated by signal number 11. Core dumped! The DMA buffers on the FPC can be monitored by the executing vty command 'show heap': ID Base Total(b) Free(b) Used(b) % Name -- ---------- ----------- ----------- ----------- --- ----------- 0 4a46000 268435456 238230496 30204960 11 Kernel 1 18a46000 67108864 17618536 49490328 73 Bcm_sdk 2 23737000 117440512 18414552 99025960 84 DMA buf <<<<< keeps increasing 3 2a737000 16777216 16777216 0 0 DMA desc This issue affects Juniper Networks Junos OS on the EX4300: 17.3 versions prior to 17.3R3-S11; 17.4 versions prior to 17.4R2-S13, 17.4R3-S4; 18.1 versions prior to 18.1R3-S12; 18.2 versions prior to 18.2R2-S8, 18.2R3-S7; 18.3 versions prior to 18.3R3-S4; 18.4 versions prior to 18.4R1-S8, 18.4R2-S7, 18.4R3-S7; 19.1 versions prior to 19.1R1-S6, 19.1R2-S2, 19.1R3-S4; 19.2 versions prior to 19.2R1-S6, 19.2R3-S2; 19.3 versions prior to 19.3R3-S2; 19.4 versions prior to 19.4R2-S3, 19.4R3-S1; 20.1 versions prior to 20.1R2; 20.2 versions prior to 20.2R2-S1, 20.2R3; 20.3 versions prior to 20.3R1-S1, 20.3R2.\n\n- CVE-2021-0338: In SystemSettingsValidators, there is a possible permanent denial of service due to missing bounds checks on UI settings. This could lead to local denial of service with User execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11Android ID: A-156260178\n\n- CVE-2021-0420: In memory management driver, there is a possible system crash due to a missing bounds check. This could lead to local denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05403499; Issue ID: ALPS05381065.\n\n- CVE-2021-0422: In memory management driver, there is a possible system crash due to a missing bounds check. This could lead to local denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05403499; Issue ID: ALPS05381071.\n\n- CVE-2021-0424: In memory management driver, there is a possible system crash due to a missing bounds check. This could lead to local denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05403499; Issue ID: ALPS05393787.\n\n- CVE-2021-20185: It was found in Moodle before version 3.10.1, 3.9.4, 3.8.7 and 3.5.16 that messaging did not impose a character limit when sending messages, which could result in client-side (browser) denial of service for users receiving very large messages.\n\n- CVE-2021-29430: Sydent is a reference Matrix identity server. Sydent does not limit the size of requests it receives from HTTP clients. A malicious user could send an HTTP request with a very large body, leading to memory exhaustion and denial of service. Sydent also does not limit response size for requests it makes to remote Matrix homeservers. A malicious homeserver could return a very large response, again leading to memory exhaustion and denial of service. This affects any server which accepts registration requests from untrusted clients. This issue has been patched by releases 89071a1, 0523511, f56eee3. As a workaround request sizes can be limited in an HTTP reverse-proxy. There are no known workarounds for the problem with overlarge responses.\n\n- CVE-2021-29932: An issue was discovered in the parse_duration crate through 2021-03-18 for Rust. It allows attackers to cause a denial of service (CPU and memory consumption) via a duration string with a large exponent.\n\n- CVE-2021-32699: Wings is the control plane software for the open source Pterodactyl game management system. All versions of Pterodactyl Wings prior to `1.4.4` are vulnerable to system resource exhaustion due to improper container process limits being defined. A malicious user can consume more resources than intended and cause downstream impacts to other clients on the same hardware, eventually causing the physical server to stop responding. Users should upgrade to `1.4.4` to mitigate the issue. There is no non-code based workaround for impacted versions of the software. Users running customized versions of this software can manually set a PID limit for containers created.\n\n- CVE-2021-3478: There's a flaw in OpenEXR's scanline input file functionality in versions before 3.0.0-beta. An attacker able to submit a crafted file to be processed by OpenEXR could consume excessive system memory. The greatest impact of this flaw is to system availability.\n\n- CVE-2021-38463: The affected product does not properly control the allocation of resources. A user may be able to allocate unlimited memory buffers using API functions.\n\n- CVE-2021-38465: The webinstaller is a Golang web server executable that enables the generation of an Auvesy image agent. Resource consumption can be achieved by generating large amounts of installations, which are then saved without limitation in the temp folder of the webinstaller executable.\n\n- CVE-2021-3912: OctoRPKI tries to load the entire contents of a repository in memory, and in the case of a GZIP bomb, unzip it in memory, making it possible to create a repository that makes OctoRPKI run out of memory (and thus crash).\n\n- CVE-2021-41546: A vulnerability has been identified in RUGGEDCOM ROX MX5000 (All versions < V2.14.1), RUGGEDCOM ROX RX1400 (All versions < V2.14.1), RUGGEDCOM ROX RX1500 (All versions < V2.14.1), RUGGEDCOM ROX RX1501 (All versions < V2.14.1), RUGGEDCOM ROX RX1510 (All versions < V2.14.1), RUGGEDCOM ROX RX1511 (All versions < V2.14.1), RUGGEDCOM ROX RX1512 (All versions < V2.14.1), RUGGEDCOM ROX RX1524 (All versions < V2.14.1), RUGGEDCOM ROX RX1536 (All versions < V2.14.1), RUGGEDCOM ROX RX5000 (All versions < V2.14.1). Affected devices write crashdumps without checking if enough space is available on the filesystem. Once the crashdump fills the entire root filesystem, affected devices fail to boot successfully. An attacker can leverage this vulnerability to cause a permanent Denial-of-Service.\n\n- CVE-2021-21274: Synapse is a Matrix reference homeserver written in python (pypi package matrix-synapse). Matrix is an ecosystem for open federated Instant Messaging and VoIP. In Synapse before version 1.25.0, a malicious homeserver could redirect requests to their .well-known file to a large file. This can lead to a denial of service attack where homeservers will consume significantly more resources when requesting the .well-known file of a malicious homeserver. This affects any server which accepts federation requests from untrusted servers. Issue is resolved in version 1.25.0. As a workaround the `federation_domain_whitelist` setting can be used to restrict the homeservers communicated with over federation.\n\n- CVE-2021-21294: Http4s (http4s-blaze-server) is a minimal, idiomatic Scala interface for HTTP services. Http4s before versions 0.21.17, 0.22.0-M2, and 1.0.0-M14 have a vulnerability which can lead to a denial-of-service. Blaze-core, a library underlying http4s-blaze-server, accepts connections unboundedly on its selector pool. This has the net effect of amplifying degradation in services that are unable to handle their current request load, since incoming connections are still accepted and added to an unbounded queue. Each connection allocates a socket handle, which drains a scarce OS resource. This can also confound higher level circuit breakers which work based on detecting failed connections. http4s provides a general \"MaxActiveRequests\" middleware mechanism for limiting open connections, but it is enforced inside the Blaze accept loop, after the connection is accepted and the socket opened. Thus, the limit only prevents the number of connections which can be simultaneously processed, not the number of connections which can be held open. In 0.21.17, 0.22.0-M2, and 1.0.0-M14, a new \"maxConnections\" property, with a default value of 1024, has been added to the `BlazeServerBuilder`. Setting the value to a negative number restores unbounded behavior, but is strongly disrecommended. The NIO2 backend does not respect `maxConnections`. Its use is now deprecated in http4s-0.21, and the option is removed altogether starting in http4s-0.22. There are several possible workarounds described in the refrenced GitHub Advisory GHSA-xhv5-w9c5-2r2w.\n\n- CVE-2021-23053: On version 15.1.x before 15.1.3, 14.1.x before 14.1.3.1, and 13.1.x before 13.1.3.6, when the brute force protection feature of BIG-IP Advanced WAF or BIG-IP ASM is enabled on a virtual server and the virtual server is under brute force attack, the MySQL database may run out of disk space due to lack of row limit on undisclosed tables in the MYSQL database. Note: Software versions which have reached End of Technical Support (EoTS) are not evaluated.\n\n- CVE-2021-41167: modern-async is an open source JavaScript tooling library for asynchronous operations using async/await and promises. In affected versions a bug affecting two of the functions in this library: forEachSeries and forEachLimit. They should limit the concurrency of some actions but, in practice, they don't. Any code calling these functions will be written thinking they would limit the concurrency but they won't. This could lead to potential security issues in other projects. The problem has been patched in 1.0.4. There is no workaround.\n\n- CVE-2021-42262: An issue was discovered in Softing OPC UA C++ SDK before 5.70. An invalid XML element in the type dictionary makes the OPC/UA client crash due to an out-of-memory condition.\n\n- CVE-2020-35210: A vulnerability in Atomix v3.1.5 allows attackers to cause a denial of service (DoS) via a Raft session flooding attack using Raft OpenSessionRequest messages.\n\n- CVE-2021-32476: A denial-of-service risk was identified in the draft files area, due to it not respecting user file upload limits. Moodle versions 3.10 to 3.10.3, 3.9 to 3.9.6, 3.8 to 3.8.8, 3.5 to 3.5.17 and earlier unsupported versions are affected.\n\n- CVE-2021-43662: totolink EX300_v2, ver V4.0.3c.140_B20210429 and A720R ,ver V4.1.5cu.470_B20200911 have an issue which causes uncontrolled resource consumption.\n\n- CVE-2020-3566: A vulnerability in the Distance Vector Multicast Routing Protocol (DVMRP) feature of Cisco IOS XR Software could allow an unauthenticated, remote attacker to exhaust process memory of an affected device. The vulnerability is due to insufficient queue management for Internet Group Management Protocol (IGMP) packets. An attacker could exploit this vulnerability by sending crafted IGMP traffic to an affected device. A successful exploit could allow the attacker to cause memory exhaustion, resulting in instability of other processes. These processes may include, but are not limited to, interior and exterior routing protocols. Cisco will release software updates that address this vulnerability.\n\n- CVE-2020-3569: Multiple vulnerabilities in the Distance Vector Multicast Routing Protocol (DVMRP) feature of Cisco IOS XR Software could allow an unauthenticated, remote attacker to either immediately crash the Internet Group Management Protocol (IGMP) process or make it consume available memory and eventually crash. The memory consumption may negatively impact other processes that are running on the device. These vulnerabilities are due to the incorrect handling of IGMP packets. An attacker could exploit these vulnerabilities by sending crafted IGMP traffic to an affected device. A successful exploit could allow the attacker to immediately crash the IGMP process or cause memory exhaustion, resulting in other processes becoming unstable. These processes may include, but are not limited to, interior and exterior routing protocols. Cisco will release software updates that address these vulnerabilities.\n\n- CVE-2021-44988: Jerryscript v3.0.0 and below was discovered to contain a stack overflow via ecma_find_named_property in ecma-helpers.c.\n\n- CVE-2021-46050: A Stack Overflow vulnerability exists in Binaryen 103 via the printf_common function.\n\n- CVE-2022-29503: A memory corruption vulnerability exists in the libpthread linuxthreads functionality of uClibC 0.9.33.2 and uClibC-ng 1.0.40. Thread allocation can lead to memory corruption. An attacker can create threads to trigger this vulnerability.\n\n- CVE-2022-35107: SWFTools commit 772e55a2 was discovered to contain a stack overflow via vfprintf at /stdio-common/vfprintf.c.\n\n- CVE-2022-35111: SWFTools commit 772e55a2 was discovered to contain a stack overflow via __sanitizer::StackDepotNode::hash(__sanitizer::StackTrace const&) at /sanitizer_common/sanitizer_stackdepot.cpp.\n\n- CVE-2022-21716: Twisted is an event-based framework for internet applications, supporting Python 3.6+. Prior to 22.2.0, Twisted SSH client and server implement is able to accept an infinite amount of data for the peer's SSH version identifier. This ends up with a buffer using all the available memory. The attach is a simple as `nc -rv localhost 22 < /dev/zero`. A patch is available in version 22.2.0. There are currently no known workarounds.\n\n- CVE-2022-41288: A vulnerability has been identified in JT2Go (All versions < V14.1.0.6), Teamcenter Visualization V13.2 (All versions < V13.2.0.12), Teamcenter Visualization V13.3 (All versions < V13.3.0.8), Teamcenter Visualization V14.0 (All versions < V14.0.0.4), Teamcenter Visualization V14.1 (All versions < V14.1.0.6). The CGM_NIST_Loader.dll contains stack exhaustion vulnerability when parsing a CGM file. An attacker could leverage this vulnerability to crash the application causing denial of service condition.\n\n- CVE-2022-32559: An issue was discovered in Couchbase Server before 7.0.4. Random HTTP requests lead to leaked metrics.\n\n- CVE-2022-3273: Allocation of Resources Without Limits or Throttling in GitHub repository ikus060/rdiffweb prior to 2.5.0a4.\n\n- CVE-2021-3669: A flaw was found in the Linux kernel. Measuring usage of the shared memory does not scale with large shared memory segment counts which could lead to resource exhaustion and DoS.\n\n- CVE-2021-3759: A memory overflow vulnerability was found in the Linux kernel\u2019s ipc functionality of the memcg subsystem, in the way a user calls the semget function multiple times, creating semaphores. This flaw allows a local user to starve the resources, causing a denial of service. The highest threat from this vulnerability is to system availability.\n\n- CVE-2022-1708: A vulnerability was found in CRI-O that causes memory or disk space exhaustion on the node for anyone with access to the Kube API. The ExecSync request runs commands in a container and logs the output of the command. This output is then read by CRI-O after command execution, and it is read in a manner where the entire file corresponding to the output of the command is read in. Thus, if the output of the command is large it is possible to exhaust the memory or the disk space of the node when CRI-O reads the output of the command. The highest threat from this vulnerability is system availability.\n\n- CVE-2022-20143: In addAutomaticZenRule of ZenModeHelper.java, there is a possible permanent denial of service due to resource exhaustion. This could lead to local denial of service with User execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12LAndroid ID: A-220735360\n\n- CVE-2022-20478: In NotificationChannel of NotificationChannel.java, there is a possible failure to persist permissions settings due to resource exhaustion. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-241764135\n\n- CVE-2022-20479: In NotificationChannel of NotificationChannel.java, there is a possible failure to persist permissions settings due to resource exhaustion. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-241764340\n\n- CVE-2022-20480: In NotificationChannel of NotificationChannel.java, there is a possible failure to persist permissions settings due to resource exhaustion. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-241764350\n\n- CVE-2022-20484: In NotificationChannel of NotificationChannel.java, there is a possible failure to persist permissions settings due to resource exhaustion. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-242702851\n\n- CVE-2022-20485: In NotificationChannel of NotificationChannel.java, there is a possible failure to persist permissions settings due to resource exhaustion. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-242702935\n\n- CVE-2022-20486: In NotificationChannel of NotificationChannel.java, there is a possible failure to persist permissions settings due to resource exhaustion. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-242703118\n\n- CVE-2022-20487: In NotificationChannel of NotificationChannel.java, there is a possible failure to persist permissions settings due to resource exhaustion. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-242703202\n\n- CVE-2022-21952: A Missing Authentication for Critical Function vulnerability in spacewalk-java of SUSE Manager Server 4.1, SUSE Manager Server 4.2 allows remote attackers to easily exhaust available disk resources leading to DoS. This issue affects: SUSE Manager Server 4.1 spacewalk-java versions prior to 4.1.46. SUSE Manager Server 4.2 spacewalk-java versions prior to 4.2.37. \n\n- CVE-2022-23487: js-libp2p is the official javascript Implementation of libp2p networking stack. Versions older than `v0.38.0` of js-libp2p are vulnerable to targeted resource exhaustion attacks. These attacks target libp2p\u2019s connection, stream, peer, and memory management. An attacker can cause the allocation of large amounts of memory, ultimately leading to the process getting killed by the host\u2019s operating system. While a connection manager tasked with keeping the number of connections within manageable limits has been part of js-libp2p, this component was designed to handle the regular churn of peers, not a targeted resource exhaustion attack. Users are advised to update their js-libp2p dependency to `v0.38.0` or greater. There are no known workarounds for this vulnerability.\n\n- CVE-2022-23492: go-libp2p is the offical libp2p implementation in the Go programming language. Version `0.18.0` and older of go-libp2p are vulnerable to targeted resource exhaustion attacks. These attacks target libp2p\u2019s connection, stream, peer, and memory management. An attacker can cause the allocation of large amounts of memory, ultimately leading to the process getting killed by the host\u2019s operating system. While a connection manager tasked with keeping the number of connections within manageable limits has been part of go-libp2p, this component was designed to handle the regular churn of peers, not a targeted resource exhaustion attack. Users are advised to upgrade their version of go-libp2p to version `0.18.1` or newer. Users unable to upgrade may consult the denial of service (dos) mitigation page for more information on how to incorporate mitigation strategies, monitor your application, and respond to attacks.\n\n- CVE-2022-23913: In Apache ActiveMQ Artemis prior to 2.20.0 or 2.19.1, an attacker could partially disrupt availability (DoS) through uncontrolled resource consumption of memory.\n\n- CVE-2022-2406: The legacy Slack import feature in Mattermost version 6.7.0 and earlier fails to properly limit the sizes of imported files, which allows an authenticated attacker to crash the server by importing large files via the Slack import REST API.\n\n- CVE-2022-28871: A Denial-of-Service (DoS) vulnerability was discovered in F-Secure Atlant whereby the fsicapd component used in certain F-Secure products while scanning larger packages/fuzzed files consume too much memory eventually can crash the scanning engine. The exploit can be triggered remotely by an attacker.\n\n- CVE-2022-31075: KubeEdge is an open source system for extending native containerized application orchestration capabilities to hosts at Edge. Prior to versions 1.11.1, 1.10.2, and 1.9.4, EdgeCore may be susceptible to a DoS attack on CloudHub if an attacker was to send a well-crafted HTTP request to `/edge.crt`. If an attacker can send a well-crafted HTTP request to CloudHub, and that request has a very large body, that request can crash the HTTP service through a memory exhaustion vector. The request body is being read into memory, and a body that is larger than the available memory can lead to a successful attack. Because the request would have to make it through authorization, only authorized users may perform this attack. The consequence of the exhaustion is that CloudHub will be in denial of service. KubeEdge is affected only when users enable the CloudHub module in the file `cloudcore.yaml`. This bug has been fixed in Kubeedge 1.11.1, 1.10.2, and 1.9.4. As a workaround, disable the CloudHub switch in the config file `cloudcore.yaml`.\n\n- CVE-2022-31078: KubeEdge is an open source system for extending native containerized application orchestration capabilities to hosts at Edge. Prior to versions 1.11.1, 1.10.2, and 1.9.4, the CloudCore Router does not impose a limit on the size of responses to requests made by the REST handler. An attacker could use this weakness to make a request that will return an HTTP response with a large body and cause DoS of CloudCore. In the HTTP Handler API, the rest handler makes a request to a pre-specified handle. The handle will return an HTTP response that is then read into memory. The consequence of the exhaustion is that CloudCore will be in a denial of service. Only an authenticated user of the cloud can make an attack. It will be affected only when users enable `router` module in the config file `cloudcore.yaml`. This bug has been fixed in Kubeedge 1.11.1, 1.10.2, and 1.9.4. As a workaround, disable the router switch in the config file `cloudcore.yaml`.\n\n- CVE-2022-31079: KubeEdge is an open source system for extending native containerized application orchestration capabilities to hosts at Edge. Prior to versions 1.11.1, 1.10.2, and 1.9.4, the Cloud Stream server and the Edge Stream server reads the entire message into memory without imposing a limit on the size of this message. An attacker can exploit this by sending a large message to exhaust memory and cause a DoS. The Cloud Stream server and the Edge Stream server are under DoS attack in this case. The consequence of the exhaustion is that the CloudCore and EdgeCore will be in a denial of service. Only an authenticated user can cause this issue. It will be affected only when users enable `cloudStream` module in the config file `cloudcore.yaml` and enable `edgeStream` module in the config file `edgecore.yaml`. This bug has been fixed in Kubeedge 1.11.1, 1.10.2, and 1.9.4. As a workaround, disable cloudStream module in the config file `cloudcore.yaml` and disable edgeStream module in the config file `edgecore.yaml`.\n\n- CVE-2022-3147: Mattermost version 7.0.x and earlier fails to sufficiently limit the in-memory sizes of concurrently uploaded JPEG images, which allows authenticated users to cause resource exhaustion on specific system configurations, resulting in server-side Denial of Service.\n\n- CVE-2022-33749: XAPI open file limit DoS It is possible for an unauthenticated client on the network to cause XAPI to hit its file-descriptor limit. This causes XAPI to be unable to accept new requests for other (trusted) clients, and blocks XAPI from carrying out any tasks that require the opening of file descriptors.\n\n- CVE-2022-3423: Allocation of Resources Without Limits or Throttling in GitHub repository nocodb/nocodb prior to 0.92.0. \n\n- CVE-2022-35915: OpenZeppelin Contracts is a library for secure smart contract development. The target contract of an EIP-165 `supportsInterface` query can cause unbounded gas consumption by returning a lot of data, while it is generally assumed that this operation has a bounded cost. The issue has been fixed in v4.7.2. Users are advised to upgrade. There are no known workarounds for this issue.\n\n- CVE-2022-41932: XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. It's possible to make XWiki create many new schemas and fill them with tables just by using a crafted user identifier in the login form. This may lead to degraded database performance. The problem has been patched in XWiki 13.10.8, 14.6RC1 and 14.4.2. Users are advised to upgrade. There are no known workarounds for this issue.\n\n- CVE-2022-2134: Allocation of Resources Without Limits or Throttling in GitHub repository inventree/inventree prior to 0.8.0.\n\n- CVE-2022-43686: In Concrete CMS (formerly concrete5) below 8.5.10 and between 9.0.0 and 9.1.2, the authTypeConcreteCookieMap table can be filled up causing a denial of service (high load).\n\n- CVE-2022-41725: A denial of service is possible from excessive resource consumption in net/http and mime/multipart. Multipart form parsing with mime/multipart.Reader.ReadForm can consume largely unlimited amounts of memory and disk files. This also affects form parsing in the net/http package with the Request methods FormFile, FormValue, ParseMultipartForm, and PostFormValue. ReadForm takes a maxMemory parameter, and is documented as storing \"up to maxMemory bytes +10MB (reserved for non-file parts) in memory\". File parts which cannot be stored in memory are stored on disk in temporary files. The unconfigurable 10MB reserved for non-file parts is excessively large and can potentially open a denial of service vector on its own. However, ReadForm did not properly account for all memory consumed by a parsed form, such as map entry overhead, part names, and MIME headers, permitting a maliciously crafted form to consume well over 10MB. In addition, ReadForm contained no limit on the number of disk files created, permitting a relatively small request body to create a large number of disk temporary files. With fix, ReadForm now properly accounts for various forms of memory overhead, and should now stay within its documented limit of 10MB + maxMemory bytes of memory consumption. Users should still be aware that this limit is high and may still be hazardous. In addition, ReadForm now creates at most one on-disk temporary file, combining multiple form parts into a single temporary file. The mime/multipart.File interface type's documentation states, \"If stored on disk, the File's underlying concrete type will be an *os.File.\". This is no longer the case when a form contains more than one file part, due to this coalescing of parts into a single file. The previous behavior of using distinct files for each form part may be reenabled with the environment variable GODEBUG=multipartfiles=distinct. Users should be aware that multipart.ReadForm and the http.Request methods that call it do not limit the amount of disk consumed by temporary files. Callers can limit the size of form data with http.MaxBytesReader.\n\nRelated Weaknesses:\n\n- CWE-400 (ChildOf)\n\n- CWE-665 (ChildOf)\n\n- CWE-400 (ChildOf)",
            "type": "Base",
            "search_source": "base_query",
            "metadata": {
              "source": "sparse",
              "mapping_notes": {
                "usage": "Allowed",
                "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
                "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
                "reasons": [
                  "Acceptable-Use"
                ]
              }
            }
          }
        ]
      },
      "search_metadata": {
        "query": "Microsoft Edge (HTML-based) Memory Corruption Vulnerability",
        "keyphrases": {
          "weakness": [
            "memory corruption"
          ]
        },
        "cve_id": "CVE-2024-38218",
        "retrievers_used": {
          "graph": true,
          "dense": true,
          "sparse": true
        },
        "search_time": 1752283939.6349826,
        "retriever_counts": {
          "graph": 20,
          "dense": 20,
          "sparse": 12
        }
      }
    },
    "relevant_cwes": [
      {
        "metadata": {
          "doc_id": "787",
          "name": "Out-of-bounds Write",
          "source": "alternate_terms",
          "original_match": "AlternateTerms: Memory Corruption",
          "match_reason": "exact_match_whole_phrase"
        },
        "similarity": 1000.0,
        "alternate_term_match": true
      },
      {
        "metadata": {
          "doc_id": "843",
          "name": "Access of Resource Using Incompatible Type ('Type Confusion')",
          "source": "sparse"
        },
        "similarity": 67.60603023958426
      },
      {
        "metadata": {
          "doc_id": "416",
          "name": "Use After Free",
          "source": "sparse"
        },
        "similarity": 60.782740992322296
      },
      {
        "metadata": {
          "doc_id": "122",
          "name": "Heap-based Buffer Overflow",
          "source": "sparse"
        },
        "similarity": 59.76424520678538
      },
      {
        "metadata": {
          "doc_id": "415",
          "name": "Double Free",
          "source": "sparse"
        },
        "similarity": 53.504177185489525
      },
      {
        "metadata": {
          "doc_id": "316",
          "name": "Cleartext Storage of Sensitive Information in Memory",
          "type": "Variant",
          "original_content": "The product stores sensitive information in cleartext in memory.",
          "keyphrase_source": "weakness:memory corruption",
          "source": "dense",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "dense": 0.5530907529031421
            }
          }
        },
        "similarity": 0.5530907529031421
      },
      {
        "doc_id": "123",
        "text": "CWE-123: Write-what-where Condition",
        "score": 3.5671999999999997,
        "metadata": {
          "doc_id": "123",
          "name": "Write-what-where Condition",
          "type": "base",
          "original_content": "CWE-123: Write-what-where Condition",
          "relationships": [
            {
              "source_id": "123",
              "target_id": "590",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "123",
              "target_id": "479",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "123",
              "target_id": "416",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "123",
              "target_id": "364",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "123",
              "target_id": "134",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "123",
              "target_id": "120",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "123",
              "target_id": "119",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1340"
              }
            },
            {
              "source_id": "123",
              "target_id": "119",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1305"
              }
            },
            {
              "source_id": "123",
              "target_id": "787",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "787",
              "target_id": "123",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "590",
              "target_id": "123",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "479",
              "target_id": "123",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "416",
              "target_id": "123",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "415",
              "target_id": "123",
              "label": "PEEROF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "364",
              "target_id": "123",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "134",
              "target_id": "123",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "120",
              "target_id": "123",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "119",
              "target_id": "123",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1305"
              }
            }
          ],
          "score_components": {
            "relationship_chain": 1.0,
            "abstraction_path": 0.7200000000000001,
            "sequence_path": 1.0,
            "peer_group": 0.9
          },
          "abstraction_factor": 1.3,
          "graph_path_info": {
            "path_types": [
              "relationship_chain",
              "abstraction_path_down",
              "vulnerability_sequence_forward",
              "peer_relationship"
            ],
            "best_paths": {
              "relationship_chain": {
                "path": [
                  [
                    "416",
                    "123",
                    "CANPRECEDE"
                  ]
                ],
                "score": 1.0,
                "type": "relationship_chain",
                "source": "416"
              },
              "abstraction_path_down": {
                "path": [
                  [
                    "787",
                    "123",
                    "PARENTOF"
                  ]
                ],
                "score": 0.7200000000000001,
                "type": "abstraction_path_down",
                "source": "787"
              },
              "vulnerability_sequence_forward": {
                "path": [
                  [
                    "416",
                    "123",
                    "CANPRECEDE"
                  ]
                ],
                "score": 1.0,
                "type": "vulnerability_sequence_forward",
                "source": "416"
              },
              "peer_relationship": {
                "path": [
                  [
                    "415",
                    "123",
                    "PEEROF"
                  ]
                ],
                "score": 0.9,
                "type": "peer_relationship",
                "source": "415"
              }
            }
          },
          "abstraction_level": "base",
          "position": "after",
          "sources": [
            "graph"
          ],
          "source": "graph",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "graph"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "graph": 3.5671999999999997
            }
          }
        },
        "similarity": 3.5671999999999997
      },
      {
        "metadata": {
          "doc_id": "190",
          "name": "Integer Overflow or Wraparound",
          "source": "sparse"
        },
        "similarity": 51.530627528621274
      },
      {
        "metadata": {
          "doc_id": "788",
          "name": "Access of Memory Location After End of Buffer",
          "source": "sparse"
        },
        "similarity": 51.05905723022035
      },
      {
        "metadata": {
          "doc_id": "366",
          "name": "Race Condition within a Thread",
          "source": "sparse"
        },
        "similarity": 50.5279456484442
      }
    ],
    "enhanced_query": "## Vulnerability Description\nMicrosoft Edge (HTML-based) Memory Corruption Vulnerability\n\n### Vulnerability Description Key Phrases\n- **weakness:** **memory corruption**\n- **product:** Microsoft Edge\n- **component:** HTML-based\n\n### CWE for similar CVE Descriptions\n### Primary CWE Match\nCWE-787\n\n#### Top CWEs\n- CWE-787 (Count: 9)\n- CWE-NVD-noinfo (Count: 6)\n\n## CVE Reference Links Content Summary\nUNRELATED\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 787 | Out-of-bounds Write | Base | Allowed | alternate_terms | 1.000 |\n| 2 | 843 | Access of Resource Using Incompatible Type ('Type Confusion') | Base | Allowed | sparse | 0.068 |\n| 3 | 416 | Use After Free | Variant | Allowed | sparse | 0.061 |\n| 4 | 122 | Heap-based Buffer Overflow | Variant | Allowed | sparse | 0.060 |\n| 5 | 415 | Double Free | Variant | Allowed | sparse | 0.054 |\n| 6 | 316 | Cleartext Storage of Sensitive Information in Memory | Variant | Allowed | dense | 0.553 |\n| 7 | 123 | Write-what-where Condition | Base | Allowed | graph | 0.004 |\n| 8 | 190 | Integer Overflow or Wraparound | Base | Allowed | sparse | 0.052 |\n| 9 | 788 | Access of Memory Location After End of Buffer | Base | Discouraged | sparse | 0.051 |\n| 10 | 366 | Race Condition within a Thread | Base | Allowed | sparse | 0.051 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-787: Out-of-bounds Write\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product writes data past the end, or before the beginning, of the intended buffer.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nMemory Corruption: Often used to describe the consequences of writing to memory outside the bounds of a buffer, or to memory that is otherwise invalid.\n\n### Relationships\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2023-1017:** The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to write 2 bytes past the end of a buffer.\n- **CVE-2021-21220:** Chain: insufficient input validation (CWE-20) in browser allows heap corruption (CWE-787), as exploited in the wild per CISA KEV.\n- **CVE-2021-28664:** GPU kernel driver allows memory corruption because a user can obtain read/write access to read-only pages, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-843: Access of Resource Using Incompatible Type ('Type Confusion')\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.\n\n### Extended Description\n\n\nWhen the product accesses the resource using an incompatible type, this could trigger logical errors because the resource does not have expected properties. In languages without memory safety, such as C and C++, type confusion can lead to out-of-bounds memory access.\n\n\nWhile this weakness is frequently associated with unions when parsing data with many different embedded object types in C, it can be present in any application that can interpret the same variable or memory location in multiple ways.\n\n\nThis weakness is not unique to C and C++. For example, errors in PHP applications can be triggered by providing array parameters when scalars are expected, or vice versa. Languages such as Perl, which perform automatic conversion of a variable of one type when it is accessed as if it were another type, can also contain these issues.\n\n\n### Alternative Terms\nObject Type Confusion\n\n### Relationships\nChildOf -> CWE-704\nChildOf -> CWE-704\nCanPrecede -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Applicable Platform]** \n\nThis weakness is possible in any type-unsafe programming language.\n\n\n**[Research Gap]** \n\nType confusion weaknesses have received some attention by applied researchers and major software vendors for C and C++ code. Some publicly-reported vulnerabilities probably have type confusion as a root-cause weakness, but these may be described as \"memory corruption\" instead.\n\n\nFor other languages, there are very few public reports of type confusion weaknesses. These are probably under-studied. Since many programs rely directly or indirectly on loose typing, a potential \"type confusion\" behavior might be intentional, possibly requiring more manual analysis.\n\n\n\n\n### Observed Examples\n- **CVE-2010-4577:** Type confusion in CSS sequence leads to out-of-bounds read.\n- **CVE-2011-0611:** Size inconsistency allows code execution, first discovered when it was actively exploited in-the-wild.\n- **CVE-2010-0258:** Improperly-parsed file containing records of different types leads to code execution when a memory location is interpreted as a different object than intended.\n\n\n\n\n## CWE-416: Use After Free\n**Abstraction:** Variant\n**Status:** Stable\n\n### Description\nThe product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nDangling pointer: a pointer that no longer points to valid memory, often after it has been freed\nUAF: commonly used acronym for Use After Free\nUse-After-Free\n\n### Relationships\nChildOf -> CWE-825\nChildOf -> CWE-672\nChildOf -> CWE-672\nChildOf -> CWE-672\nCanPrecede -> CWE-120\nCanPrecede -> CWE-123\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2022-20141:** Chain: an operating system kernel has insufficent resource locking (CWE-413) leading to a use after free (CWE-416).\n- **CVE-2022-2621:** Chain: two threads in a web browser use the same resource (CWE-366), but one of those threads can destroy the resource before the other has completed (CWE-416).\n- **CVE-2021-0920:** Chain: mobile platform race condition (CWE-362) leading to use-after-free (CWE-416), as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-122: Heap-based Buffer Overflow\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nA heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-788\nChildOf -> CWE-787\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** Heap-based buffer overflows are usually just as dangerous as stack-based buffer overflows.\n\n\n\n### Observed Examples\n- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n- **CVE-2007-4268:** Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)\n- **CVE-2009-2523:** Chain: product does not handle when an input string is not NULL terminated (CWE-170), leading to buffer over-read (CWE-125) or heap-based buffer overflow (CWE-122).\n\n\n\n\n## CWE-415: Double Free\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.\n\n### Extended Description\nWhen a program calls free() twice with the same argument, the program's memory management data structures become corrupted. This corruption can cause the program to crash or, in some circumstances, cause two later calls to malloc() to return the same pointer. If malloc() returns the same value twice and the program later gives the attacker control over the data that is written into this doubly-allocated memory, the program becomes vulnerable to a buffer overflow attack.\n\n### Alternative Terms\nDouble-free\n\n### Relationships\nChildOf -> CWE-825\nChildOf -> CWE-1341\nChildOf -> CWE-672\nChildOf -> CWE-672\nChildOf -> CWE-672\nChildOf -> CWE-666\nPeerOf -> CWE-416\nPeerOf -> CWE-123\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This is usually resultant from another weakness, such as an unhandled error or race condition between threads. It could also be primary to weaknesses such as buffer overflows.\n\n**[Theoretical]** It could be argued that Double Free would be most appropriately located as a child of \"Use after Free\", but \"Use\" and \"Release\" are considered to be distinct operations within vulnerability theory, therefore this is more accurately \"Release of a Resource after Expiration or Release\", which doesn't exist yet.\n\n\n\n### Observed Examples\n- **CVE-2006-5051:** Chain: Signal handler contains too much functionality (CWE-828), introducing a race condition (CWE-362) that leads to a double free (CWE-415).\n- **CVE-2004-0642:** Double free resultant from certain error conditions.\n- **CVE-2004-0772:** Double free resultant from certain error conditions.\n\n\n\n\n## CWE-316: Cleartext Storage of Sensitive Information in Memory\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product stores sensitive information in cleartext in memory.\n\n### Extended Description\n\n\nThe sensitive memory might be saved to disk, stored in a core dump, or remain uncleared if the product crashes, or if the programmer does not properly clear the memory before freeing it.\n\n\nIt could be argued that such problems are usually only exploitable by those with administrator privileges. However, swapping could cause the memory to be written to disk and leave it accessible to physical attack afterwards. Core dump files might have insecure permissions or be stored in archive files that are accessible to untrusted people. Or, uncleared sensitive memory might be inadvertently exposed to attackers due to another weakness.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-312\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This could be a resultant weakness, e.g. if the compiler removes code that was intended to wipe memory.\n\n**[Terminology]** Different people use \"cleartext\" and \"plaintext\" to mean the same thing: the lack of encryption. However, within cryptography, these have more precise meanings. Plaintext is the information just before it is fed into a cryptographic algorithm, including already-encrypted text. Cleartext is any information that is unencrypted, although it might be in an encoded form that is not easily human-readable (such as base64 encoding).\n\n\n\n### Observed Examples\n- **CVE-2001-1517:** Sensitive authentication information in cleartext in memory.\n- **CVE-2001-0984:** Password protector leaves passwords in memory when window is minimized, even when \"clear password when minimized\" is set.\n- **CVE-2003-0291:** SSH client does not clear credentials from memory.\n\n\n\n\n## CWE-123: Write-what-where Condition\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nAny condition where the attacker has the ability to write an arbitrary value to an arbitrary location, often as the result of a buffer overflow.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-787\nChildOf -> CWE-119\nChildOf -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2022-0545:** Chain: 3D renderer has an integer overflow (CWE-190) leading to write-what-where condition (CWE-123) using a crafted image.\n\n\n\n\n## CWE-190: Integer Overflow or Wraparound\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nOverflow: The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nWraparound: The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nwrap, wrap-around, wrap around: Alternate spellings of \"wraparound\"\n\n### Relationships\nChildOf -> CWE-682\nChildOf -> CWE-682\nChildOf -> CWE-20\nCanPrecede -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Be careful of terminology problems with \"overflow,\" \"underflow,\" and \"wraparound\" - see Terminology Notes. Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n**Suggested Alternatives:**\n- CWE-191: Integer Underflow (Wrap or Wraparound). Consider CWE-191 when the result is less than the minimum value that can be represented (sometimes called \"underflows\").\n\n\n### Additional Notes\n**[Relationship]** Integer overflows can be primary to buffer overflows when they cause less memory to be allocated than expected.\n\n**[Terminology]** \n\n\"Integer overflow\" is sometimes used to cover several types of errors, including signedness errors, or buffer overflows that involve manipulation of integer data types instead of characters. Part of the confusion results from the fact that 0xffffffff is -1 in a signed context. Other confusion also arises because of the role that integer overflows have in chains.\n\n\nA \"wraparound\" is a well-defined, standard behavior that follows specific rules for how to handle situations when the intended numeric value is too large or too small to be represented, as specified in standards such as C11.\n\n\n\"Overflow\" is sometimes conflated with \"wraparound\" but typically indicates a non-standard or undefined behavior.\n\n\nThe \"overflow\" term is sometimes used to indicate cases where either the maximum or the minimum is exceeded, but others might only use \"overflow\" to indicate exceeding the maximum while using \"underflow\" for exceeding the minimum.\n\n\nSome people use \"overflow\" to mean any value outside the representable range - whether greater than the maximum, or less than the minimum - but CWE uses \"underflow\" for cases in which the intended result is less than the minimum.\n\n\nSee [REF-1440] for additional explanation of the ambiguity of terminology.\n\n\n**[Other]** While there may be circumstances in which the logic intentionally relies on wrapping - such as with modular arithmetic in timers or counters - it can have security consequences if the wrap is unexpected. This is especially the case if the integer overflow can be triggered using user-supplied inputs.\n\n\n\n### Observed Examples\n- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2022-0545:** Chain: 3D renderer has an integer overflow (CWE-190) leading to write-what-where condition (CWE-123) using a crafted image.\n\n\n\n\n## CWE-788: Access of Memory Location After End of Buffer\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.\n\n### Extended Description\nThis typically occurs when a pointer or its index is incremented to a position after the buffer; or when pointer arithmetic results in a position after the buffer.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** The CWE entry might be misused when lower-level CWE entries might be available. It also overlaps existing CWE entries and might be deprecated in the future.\n**Comments:** If the \"Access\" operation is known to be a read or a write, then investigate children of entries such as CWE-787: Out-of-bounds Write and CWE-125: Out-of-bounds Read.\n**Reasons:**\n- Potential Deprecation\n- Frequent Misuse\n\n\n\n### Observed Examples\n- **CVE-2009-2550:** Classic stack-based buffer overflow in media player using a long entry in a playlist\n- **CVE-2009-2403:** Heap-based buffer overflow in media player using a long entry in a playlist\n- **CVE-2009-0689:** large precision value in a format string triggers overflow\n\n\n\n\n## CWE-366: Race Condition within a Thread\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nIf two threads of execution use a resource simultaneously, there exists the possibility that resources may be used while invalid, in turn making the state of execution undefined.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-362\nChildOf -> CWE-662\nChildOf -> CWE-662\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2022-2621:** Chain: two threads in a web browser use the same resource (CWE-366), but one of those threads can destroy the resource before the other has completed (CWE-416).\n\n",
    "dense_results": [
      {
        "metadata": {
          "doc_id": "787",
          "name": "Out-of-bounds Write",
          "type": "Base",
          "original_content": "The product writes data past the end, or before the beginning, of the intended buffer.",
          "keyphrase_source": "weakness:memory corruption",
          "source": "dense",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense",
              "sparse",
              "graph"
            ],
            "retriever_count": 3,
            "normalized_scores": {
              "dense": 0.6044956188779271,
              "sparse": 1000.0,
              "graph": 1.9494031032124015
            }
          }
        },
        "similarity": 0.6044956188779271
      },
      {
        "metadata": {
          "doc_id": "416",
          "name": "Use After Free",
          "type": "Variant",
          "original_content": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
          "source": "dense",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense",
              "sparse",
              "graph"
            ],
            "retriever_count": 3,
            "normalized_scores": {
              "dense": 0.5564290782764135,
              "sparse": 60.782740992322296,
              "graph": 2.262891626614683
            }
          }
        },
        "similarity": 0.5564290782764135
      },
      {
        "metadata": {
          "doc_id": "843",
          "name": "Access of Resource Using Incompatible Type ('Type Confusion')",
          "type": "Base",
          "original_content": "The product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.",
          "keyphrase_source": "weakness:memory corruption",
          "source": "dense",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense",
              "sparse",
              "graph"
            ],
            "retriever_count": 3,
            "normalized_scores": {
              "dense": 0.5532373381039504,
              "sparse": 67.60603023958426,
              "graph": 2.5257713361350778
            }
          }
        },
        "similarity": 0.5532373381039504
      },
      {
        "metadata": {
          "doc_id": "316",
          "name": "Cleartext Storage of Sensitive Information in Memory",
          "type": "Variant",
          "original_content": "The product stores sensitive information in cleartext in memory.",
          "keyphrase_source": "weakness:memory corruption",
          "source": "dense",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "dense": 0.5530907529031421
            }
          }
        },
        "similarity": 0.5530907529031421
      },
      {
        "metadata": {
          "doc_id": "1260",
          "name": "Improper Handling of Overlap Between Protected Memory Ranges",
          "type": "Base",
          "original_content": "The product allows address regions to overlap, which can result in the bypassing of intended memory protection.",
          "keyphrase_source": "weakness:memory corruption",
          "source": "dense",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense",
              "graph"
            ],
            "retriever_count": 2,
            "normalized_scores": {
              "dense": 0.5423218496153519,
              "graph": 2.372747119777513
            }
          }
        },
        "similarity": 0.5423218496153519
      },
      {
        "metadata": {
          "doc_id": "788",
          "name": "Access of Memory Location After End of Buffer",
          "type": "Base",
          "original_content": "The product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.",
          "keyphrase_source": "weakness:memory corruption",
          "source": "dense",
          "mapping_notes": {
            "usage": "Discouraged",
            "rationale": "The CWE entry might be misused when lower-level CWE entries might be available. It also overlaps existing CWE entries and might be deprecated in the future.",
            "comments": "If the \"Access\" operation is known to be a read or a write, then investigate children of entries such as CWE-787: Out-of-bounds Write and CWE-125: Out-of-bounds Read.",
            "reasons": [
              "Potential Deprecation",
              "Frequent Misuse"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense",
              "sparse"
            ],
            "retriever_count": 2,
            "normalized_scores": {
              "dense": 0.5413483969451229,
              "sparse": 51.05905723022035
            }
          }
        },
        "similarity": 0.5413483969451229
      },
      {
        "metadata": {
          "doc_id": "127",
          "name": "Buffer Under-read",
          "type": "Variant",
          "original_content": "The product reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations prior to the targeted buffer.",
          "keyphrase_source": "weakness:memory corruption",
          "source": "dense",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "dense": 0.5349246760880122
            }
          }
        },
        "similarity": 0.5349246760880122
      },
      {
        "metadata": {
          "doc_id": "822",
          "name": "Untrusted Pointer Dereference",
          "type": "Base",
          "original_content": "The product obtains a value from an untrusted source, converts this value to a pointer, and dereferences the resulting pointer.",
          "keyphrase_source": "weakness:memory corruption",
          "source": "dense",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense",
              "sparse"
            ],
            "retriever_count": 2,
            "normalized_scores": {
              "dense": 0.5331898988837035,
              "sparse": 48.46614763081808
            }
          }
        },
        "similarity": 0.5331898988837035
      },
      {
        "metadata": {
          "doc_id": "124",
          "name": "Buffer Underwrite ('Buffer Underflow')",
          "type": "Base",
          "original_content": "The product writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.",
          "keyphrase_source": "weakness:memory corruption",
          "source": "dense",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "dense": 0.5304708044548463
            }
          }
        },
        "similarity": 0.5304708044548463
      },
      {
        "metadata": {
          "doc_id": "704",
          "name": "Incorrect Type Conversion or Cast",
          "type": "Class",
          "original_content": "The product does not correctly convert an object, resource, or structure from one type to a different type.",
          "keyphrase_source": "weakness:memory corruption",
          "source": "dense",
          "mapping_notes": {
            "usage": "Allowed-with-Review",
            "rationale": "This CWE entry is a Class and might have Base-level children that would be more appropriate",
            "comments": "Examine children of this entry to see if there is a better fit",
            "reasons": [
              "Abstraction"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "dense": 0.5272079352444721
            }
          }
        },
        "similarity": 0.5272079352444721
      },
      {
        "metadata": {
          "doc_id": "789",
          "name": "Memory Allocation with Excessive Size Value",
          "type": "Variant",
          "original_content": "The product allocates memory based on an untrusted, large size value, but it does not ensure that the size is within expected limits, allowing arbitrary amounts of memory to be allocated.",
          "source": "dense",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "dense": 0.509625927918915
            }
          }
        },
        "similarity": 0.509625927918915
      },
      {
        "metadata": {
          "doc_id": "366",
          "name": "Race Condition within a Thread",
          "type": "Base",
          "original_content": "If two threads of execution use a resource simultaneously, there exists the possibility that resources may be used while invalid, in turn making the state of execution undefined.",
          "source": "dense",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense",
              "sparse"
            ],
            "retriever_count": 2,
            "normalized_scores": {
              "dense": 0.5095764723959488,
              "sparse": 50.5279456484442
            }
          }
        },
        "similarity": 0.5095764723959488
      },
      {
        "metadata": {
          "doc_id": "401",
          "name": "Missing Release of Memory after Effective Lifetime",
          "type": "Variant",
          "original_content": "The product does not sufficiently track and release allocated memory after it has been used, which slowly consumes remaining memory.",
          "source": "dense",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "dense": 0.5090974239680022
            }
          }
        },
        "similarity": 0.5090974239680022
      },
      {
        "metadata": {
          "doc_id": "80",
          "name": "Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS)",
          "type": "Variant",
          "original_content": "The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special characters such as \"<\", \">\", and \"&\" that could be interpreted as web-scripting elements when they are sent to a downstream component that processes web pages.",
          "source": "dense",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "dense": 0.5070815204945177
            }
          }
        },
        "similarity": 0.5070815204945177
      },
      {
        "metadata": {
          "doc_id": "122",
          "name": "Heap-based Buffer Overflow",
          "type": "Variant",
          "original_content": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
          "source": "dense",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense",
              "sparse",
              "graph"
            ],
            "retriever_count": 3,
            "normalized_scores": {
              "dense": 0.5070551867766302,
              "sparse": 59.76424520678538,
              "graph": 2.1624
            }
          }
        },
        "similarity": 0.5070551867766302
      },
      {
        "metadata": {
          "doc_id": "823",
          "name": "Use of Out-of-range Pointer Offset",
          "type": "Base",
          "original_content": "The product performs pointer arithmetic on a valid pointer, but it uses an offset that can point outside of the intended range of valid memory locations for the resulting pointer.",
          "source": "dense",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "dense": 0.5056866376391194
            }
          }
        },
        "similarity": 0.5056866376391194
      },
      {
        "metadata": {
          "doc_id": "119",
          "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
          "type": "Class",
          "original_content": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
          "source": "dense",
          "mapping_notes": {
            "usage": "Discouraged",
            "rationale": "CWE-119 is commonly misused in low-information vulnerability reports when lower-level CWEs could be used instead, or when more details about the vulnerability are available.",
            "comments": "Look at CWE-119's children and consider mapping to CWEs such as CWE-787: Out-of-bounds Write, CWE-125: Out-of-bounds Read, or others.",
            "reasons": [
              "Frequent Misuse"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "dense": 0.504740424629194
            }
          }
        },
        "similarity": 0.504740424629194
      },
      {
        "metadata": {
          "doc_id": "125",
          "name": "Out-of-bounds Read",
          "type": "Base",
          "original_content": "The product reads data past the end, or before the beginning, of the intended buffer.",
          "source": "dense",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "dense": 0.5042019323869635
            }
          }
        },
        "similarity": 0.5042019323869635
      },
      {
        "metadata": {
          "doc_id": "126",
          "name": "Buffer Over-read",
          "type": "Variant",
          "original_content": "The product reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations after the targeted buffer.",
          "source": "dense",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "dense": 0.502493536294006
            }
          }
        },
        "similarity": 0.502493536294006
      },
      {
        "metadata": {
          "doc_id": "1342",
          "name": "Information Exposure through Microarchitectural State after Transient Execution",
          "type": "Base",
          "original_content": "The processor does not properly clear microarchitectural state after incorrect microcode assists or speculative execution, resulting in transient execution.",
          "source": "dense",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "dense": 0.5024177349997196
            }
          }
        },
        "similarity": 0.5024177349997196
      }
    ],
    "sparse_results": [
      {
        "cwe_id": "787",
        "name": "Out-of-bounds Write",
        "description": "The product writes data past the end, or before the beginning, of the intended buffer.",
        "score": 1000.0,
        "matched_text": "AlternateTerms: Memory Corruption",
        "matched_phrase": "memory corruption",
        "matched_term": "memory corruption",
        "type": "Base",
        "source": "sparse",
        "search_source": "alternate_term_match",
        "match_reason": "exact_match_whole_phrase",
        "metadata": {
          "source": "sparse",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          }
        }
      },
      {
        "cwe_id": "843",
        "name": "Access of Resource Using Incompatible Type ('Type Confusion')",
        "description": "The product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.",
        "score": 67.60603023958426,
        "matched_text": "CWE-843: Access of Resource Using Incompatible Type ('Type Confusion')\n\nType: Base\n\nStatus: Incomplete\n\nAlternative Terms:\n\nObject Type Confusion\n\nObject Type Confusion\n\nObject Type Confusion\n\nDescription:\n\nThe product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.\n\nExtended Details:\n\n\n\nWhen the product accesses the resource using an incompatible type, this could trigger logical errors because the resource does not have expected properties. In languages without memory safety, such as C and C++, type confusion can lead to out-of-bounds memory access.\n\n\nWhile this weakness is frequently associated with unions when parsing data with many different embedded object types in C, it can be present in any application that can interpret the same variable or memory location in multiple ways.\n\n\nThis weakness is not unique to C and C++. For example, errors in PHP applications can be triggered by providing array parameters when scalars are expected, or vice versa. Languages such as Perl, which perform automatic conversion of a variable of one type when it is accessed as if it were another type, can also contain these issues.\n\n\nReal-World Examples:\n\n- CVE-2010-4577: Type confusion in CSS sequence leads to out-of-bounds read.\n\n- CVE-2011-0611: Size inconsistency allows code execution, first discovered when it was actively exploited in-the-wild.\n\n- CVE-2010-0258: Improperly-parsed file containing records of different types leads to code execution when a memory location is interpreted as a different object than intended.\n\nTop 25 CWE Examples:\n\n- CVE-2021-0352: In RT regmap driver, there is a possible memory corruption due to type confusion. This could lead to local denial of service with System execution privileges needed. User interaction is not needed for exploitation. Product: Android; Versions: Android-10, Android-11; Patch ID: ALPS05453809.\n\n- CVE-2021-21230: Type confusion in V8 in Google Chrome prior to 90.0.4430.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-23954: Using the new logical assignment operators in a JavaScript switch statement could have caused a type confusion, leading to a memory corruption and a potentially exploitable crash. This vulnerability affects Firefox < 85, Thunderbird < 78.7, and Firefox ESR < 78.7.\n\n- CVE-2021-30513: Type confusion in V8 in Google Chrome prior to 90.0.4430.212 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30517: Type confusion in V8 in Google Chrome prior to 90.0.4430.212 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30551: Type confusion in V8 in Google Chrome prior to 91.0.4472.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30561: Type Confusion in V8 in Google Chrome prior to 91.0.4472.164 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30563: Type Confusion in V8 in Google Chrome prior to 91.0.4472.164 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30588: Type confusion in V8 in Google Chrome prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30627: Type confusion in Blink layout in Google Chrome prior to 93.0.4577.82 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-38001: Type confusion in V8 in Google Chrome prior to 95.0.4638.69 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-23443: This affects the package edge.js before 5.3.2. A type confusion vulnerability can be used to bypass input sanitization when the input to be rendered is an array (instead of a string or a SafeValue), even if {{ }} are used.\n\n- CVE-2021-23447: This affects the package teddy before 0.5.9. A type confusion vulnerability can be used to bypass input sanitization when the model content is an array (instead of a string).\n\n- CVE-2021-32696: The npm package \"striptags\" is an implementation of PHP's strip_tags in Typescript. In striptags before version 3.2.0, a type-confusion vulnerability can cause `striptags` to concatenate unsanitized strings when an array-like object is passed in as the `html` parameter. This can be abused by an attacker who can control the shape of their input, e.g. if query parameters are passed directly into the function. This can lead to a XSS.\n\n- CVE-2021-23807: This affects the package jsonpointer before 5.0.0. A type confusion vulnerability can lead to a bypass of a previous Prototype Pollution fix when the pointer components are arrays.\n\n- CVE-2020-16103: Type confusion in Gallagher Command Centre Server allows a remote attacker to crash the server or possibly cause remote code execution. This issue affects: Gallagher Command Centre 8.30 versions prior to 8.30.1236(MR1); 8.20 versions prior to 8.20.1166(MR3); 8.10 versions prior to 8.10.1211(MR5); version 8.00 and prior versions.\n\n- CVE-2020-7081: A type confusion vulnerability in the Autodesk FBX-SDK versions 2019.0 and earlier may lead to arbitary code read/write on the system running it.\n\n- CVE-2021-26600: ImpressCMS before 1.4.3 has plugins/preloads/autologin.php type confusion with resultant Authentication Bypass (!= instead of !==).\n\n- CVE-2020-16009: Inappropriate implementation in V8 in Google Chrome prior to 86.0.4240.183 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2020-27932: A type confusion issue was addressed with improved state handling. This issue is fixed in macOS Big Sur 11.0.1, watchOS 7.1, iOS 12.4.9, watchOS 6.2.9, Security Update 2020-006 High Sierra, Security Update 2020-006 Mojave, iOS 14.2 and iPadOS 14.2, watchOS 5.3.9, macOS Catalina 10.15.7 Supplemental Update, macOS Catalina 10.15.7 Update. A malicious application may be able to execute arbitrary code with kernel privileges.\n\n- CVE-2020-6418: Type confusion in V8 in Google Chrome prior to 80.0.3987.122 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-1789: A type confusion issue was addressed with improved state handling. This issue is fixed in macOS Big Sur 11.2, Security Update 2021-001 Catalina, Security Update 2021-001 Mojave, tvOS 14.4, watchOS 7.3, iOS 14.4 and iPadOS 14.4, Safari 14.0.3. Processing maliciously crafted web content may lead to arbitrary code execution.\n\n- CVE-2021-21224: Type confusion in V8 in Google Chrome prior to 90.0.4430.85 allowed a remote attacker to execute arbitrary code inside a sandbox via a crafted HTML page.\n\n- CVE-2021-30869: A type confusion issue was addressed with improved state handling. This issue is fixed in iOS 12.5.5, iOS 14.4 and iPadOS 14.4, macOS Big Sur 11.2, Security Update 2021-001 Catalina, Security Update 2021-001 Mojave, Security Update 2021-006 Catalina. A malicious application may be able to execute arbitrary code with kernel privileges. Apple is aware of reports that an exploit for this issue exists in the wild.\n\n- CVE-2021-26635: In the code that verifies the file size in the ark library, it is possible to manipulate the offset read from the target file due to the wrong use of the data type. An attacker could use this vulnerability to cause a stack buffer overflow and as a result, perform an attack such as remote code execution.\n\n- CVE-2021-38007: Type confusion in V8 in Google Chrome prior to 96.0.4664.45 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-38012: Type confusion in V8 in Google Chrome prior to 96.0.4664.45 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4056: Type confusion in loader in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4061: Type confusion in V8 in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4078: Type confusion in V8 in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0102: Type confusion in V8 in Google Chrome prior to 97.0.4692.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0457: Type confusion in V8 in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0795: Type confusion in Blink Layout in Google Chrome prior to 99.0.4844.51 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1096: Type confusion in V8 in Google Chrome prior to 99.0.4844.84 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1134: Type confusion in V8 in Google Chrome prior to 100.0.4896.60 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1232: Type confusion in V8 in Google Chrome prior to 100.0.4896.75 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1314: Type confusion in V8 in Google Chrome prior to 100.0.4896.88 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1364: Type confusion in V8 Turbofan in Google Chrome prior to 100.0.4896.127 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1869: Type Confusion in V8 in Google Chrome prior to 102.0.5005.61 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-20461: In pinReplyNative of com_android_bluetooth_btservice_AdapterService.cpp, there is a possible out of bounds read due to type confusion. This could lead to local escalation of privilege of BLE with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-228602963\n\n- CVE-2022-26433: In mailbox, there is a possible out of bounds write due to type confusion. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07138400; Issue ID: ALPS07138400.\n\n- CVE-2022-3315: Type confusion in Blink in Google Chrome prior to 106.0.5249.62 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: Low)\n\n- CVE-2022-3889: Type confusion in V8 in Google Chrome prior to 107.0.5304.106 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4174: Type confusion in V8 in Google Chrome prior to 108.0.5359.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-25721: Memory corruption in video driver due to type confusion error during video playback\n\n- CVE-2022-2295: Type confusion in V8 in Google Chrome prior to 103.0.5060.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-34918: An issue was discovered in the Linux kernel through 5.18.9. A type confusion bug in nft_set_elem_init (leading to a buffer overflow) could be used by a local attacker to escalate privileges, a different vulnerability than CVE-2022-32250. (The attacker can obtain root access, but must start with an unprivileged user namespace to obtain CAP_NET_ADMIN access.) This can be fixed in nft_setelem_parse_data in net/netfilter/nf_tables_api.c.\n\n- CVE-2022-3652: Type confusion in V8 in Google Chrome prior to 107.0.5304.62 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-23583: Tensorflow is an Open Source Machine Learning Framework. A malicious user can cause a denial of service by altering a `SavedModel` such that any binary op would trigger `CHECK` failures. This occurs when the protobuf part corresponding to the tensor arguments is modified such that the `dtype` no longer matches the `dtype` expected by the op. In that case, calling the templated binary operator for the binary op would receive corrupted data, due to the type confusion involved. If `Tin` and `Tout` don't match the type of data in `out` and `input_*` tensors then `flat<*>` would interpret it wrongly. In most cases, this would be a silent failure, but we have noticed scenarios where this results in a `CHECK` crash, hence a denial of service. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.\n\n- CVE-2022-3723: Type confusion in V8 in Google Chrome prior to 107.0.5304.87 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4262: Type confusion in V8 in Google Chrome prior to 108.0.5359.94 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-41033: Windows COM+ Event System Service Elevation of Privilege Vulnerability\n\n- CVE-2022-42856: A type confusion issue was addressed with improved state handling. This issue is fixed in Safari 16.2, tvOS 16.2, macOS Ventura 13.1, iOS 15.7.2 and iPadOS 15.7.2, iOS 16.1.2. Processing maliciously crafted web content may lead to arbitrary code execution. Apple is aware of a report that this issue may have been actively exploited against versions of iOS released before iOS 15.1..\n\n- CVE-2022-21656: Envoy is an open source edge and service proxy, designed for cloud-native applications. The default_validator.cc implementation used to implement the default certificate validation routines has a \"type confusion\" bug when processing subjectAltNames. This processing allows, for example, an rfc822Name or uniformResourceIndicator to be authenticated as a domain name. This confusion allows for the bypassing of nameConstraints, as processed by the underlying OpenSSL/BoringSSL implementation, exposing the possibility of impersonation of arbitrary servers. As a result Envoy will trust upstream certificates that should not be trusted.\n\n- CVE-2021-33624: In kernel/bpf/verifier.c in the Linux kernel before 5.12.13, a branch can be mispredicted (e.g., because of type confusion) and consequently an unprivileged BPF program can read arbitrary memory locations via a side-channel attack, aka CID-9183671af6db.\n\nRelated Weaknesses:\n\n- CWE-704 (ChildOf)\n\n- CWE-704 (ChildOf)\n\n- CWE-119 (CanPrecede)",
        "type": "Base",
        "source": "sparse",
        "search_source": "weakness:memory corruption",
        "sources": [
          "base",
          "weakness"
        ],
        "boost_factor": 2.8,
        "boosted": true,
        "metadata": {
          "source": "sparse",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          }
        }
      },
      {
        "cwe_id": "416",
        "name": "Use After Free",
        "description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
        "score": 60.782740992322296,
        "matched_text": "CWE-416: Use After Free\n\nType: Variant\n\nStatus: Stable\n\nAlternative Terms:\n\nDangling pointer - a pointer that no longer points to valid memory, often after it has been freed\nUAF - commonly used acronym for Use After Free\nUse-After-Free\n\nDangling pointer - a pointer that no longer points to valid memory, often after it has been freed\nUAF - commonly used acronym for Use After Free\nUse-After-Free\n\nDangling pointer - a pointer that no longer points to valid memory, often after it has been freed\nUAF - commonly used acronym for Use After Free\nUse-After-Free\n\nDescription:\n\nThe product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.\n\nReal-World Examples:\n\n- CVE-2022-20141: Chain: an operating system kernel has insufficent resource locking (CWE-413) leading to a use after free (CWE-416).\n\n- CVE-2022-2621: Chain: two threads in a web browser use the same resource (CWE-366), but one of those threads can destroy the resource before the other has completed (CWE-416).\n\n- CVE-2021-0920: Chain: mobile platform race condition (CWE-362) leading to use-after-free (CWE-416), as exploited in the wild per CISA KEV.\n\n- CVE-2020-6819: Chain: race condition (CWE-362) leads to use-after-free (CWE-416), as exploited in the wild per CISA KEV.\n\n- CVE-2010-4168: Use-after-free triggered by closing a connection while data is still being transmitted.\n\n- CVE-2010-2941: Improper allocation for invalid data leads to use-after-free.\n\n- CVE-2010-2547: certificate with a large number of Subject Alternate Names not properly handled in realloc, leading to use-after-free\n\n- CVE-2010-1772: Timers are not disabled when a related object is deleted\n\n- CVE-2010-1437: Access to a \"dead\" object that is being cleaned up\n\n- CVE-2010-1208: object is deleted even with a non-zero reference count, and later accessed\n\n- CVE-2010-0629: use-after-free involving request containing an invalid version number\n\n- CVE-2010-0378: unload of an object that is currently being accessed by other functionality\n\n- CVE-2010-0302: incorrectly tracking a reference count leads to use-after-free\n\n- CVE-2010-0249: use-after-free related to use of uninitialized memory\n\n- CVE-2010-0050: HTML document with incorrectly-nested tags\n\n- CVE-2009-3658: Use after free in ActiveX object by providing a malformed argument to a method\n\n- CVE-2009-3616: use-after-free by disconnecting during data transfer, or a message containing incorrect data types\n\n- CVE-2009-3553: disconnect during a large data transfer causes incorrect reference count, leading to use-after-free\n\n- CVE-2009-2416: use-after-free found by fuzzing\n\n- CVE-2009-1837: Chain: race condition (CWE-362) from improper handling of a page transition in web client while an applet is loading (CWE-368) leads to use after free (CWE-416)\n\n- CVE-2009-0749: realloc generates new buffer and pointer, but previous pointer is still retained, leading to use after free\n\n- CVE-2010-3328: Use-after-free in web browser, probably resultant from not initializing memory.\n\n- CVE-2008-5038: use-after-free when one thread accessed memory that was freed by another thread\n\n- CVE-2008-0077: assignment of malformed values to certain properties triggers use after free\n\n- CVE-2006-4434: mail server does not properly handle a long header.\n\n- CVE-2010-2753: chain: integer overflow leads to use-after-free\n\n- CVE-2006-4997: freed pointer dereference\n\nTop 25 CWE Examples:\n\n- CVE-2021-0310: In LazyServiceRegistrar of LazyServiceRegistrar.cpp, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android; Versions: Android-11; Android ID: A-170212632.\n\n- CVE-2021-0332: In bootFinished of SurfaceFlinger.cpp, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with User execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11 Android-10Android ID: A-169256435\n\n- CVE-2021-0335: In process of C2SoftHevcDec.cpp, there is a possible out of bounds write due to a use after free. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-11Android ID: A-160346309\n\n- CVE-2021-0342: In tun_get_user of tun.c, there is possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges required. User interaction is not required for exploitation. Product: Android; Versions: Android kernel; Android ID: A-146554327.\n\n- CVE-2021-0349: In display driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Product: Android; Versions: Android-9, Android-10, Android-11; Patch ID: ALPS05362646.\n\n- CVE-2021-0365: In display driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Product: Android; Versions: Android-10, Android-11; Patch ID: ALPS05454782.\n\n- CVE-2021-0395: In StopServicesAndLogViolations of reboot.cpp, there is possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11Android ID: A-170315126\n\n- CVE-2021-0399: In qtaguid_untag of xt_qtaguid.c, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-176919394References: Upstream kernel\n\n- CVE-2021-0429: In pollOnce of ALooper.cpp, there is possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-9 Android-10 Android-11 Android-8.1Android ID: A-175074139\n\n- CVE-2021-0475: In on_l2cap_data_ind of btif_sock_l2cap.cc, there is possible memory corruption due to a use after free. This could lead to remote code execution over Bluetooth with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11 Android-10Android ID: A-175686168\n\n- CVE-2021-0482: In BinderDiedCallback of MediaCodec.cpp, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11Android ID: A-173791720\n\n- CVE-2021-0496: In memory management driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-183467912\n\n- CVE-2021-0497: In memory management driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-183461320\n\n- CVE-2021-0527: In memory management driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-185193931\n\n- CVE-2021-0531: In memory management driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-185195272\n\n- CVE-2021-0535: In wpas_ctrl_msg_queue_timeout of ctrl_iface_unix.c, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11Android ID: A-168314741\n\n- CVE-2021-0611: In m4u, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05403499; Issue ID: ALPS05425810.\n\n- CVE-2021-0612: In m4u, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05403499; Issue ID: ALPS05425834.\n\n- CVE-2021-0629: In mdlactl driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05776625; Issue ID: ALPS05776625.\n\n- CVE-2021-0656: In edma driver, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05709376; Issue ID: ALPS05709376.\n\n- CVE-2021-0664: In ccu, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05827158; Issue ID: ALPS05827158.\n\n- CVE-2021-0667: In apusys, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05670581; Issue ID: ALPS05670581.\n\n- CVE-2021-0669: In apusys, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05681550; Issue ID: ALPS05681550.\n\n- CVE-2021-0670: In apusys, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05654663; Issue ID: ALPS05654663.\n\n- CVE-2021-0684: In TouchInputMapper::sync of TouchInputMapper.cpp, there is a possible out of bounds write due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-8.1 Android-9Android ID: A-179839665\n\n- CVE-2021-0695: In get_sock_stat of xt_qtaguid.c, there is a possible out of bounds read due to a use after free. This could lead to local information disclosure with User execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-184018316References: Upstream kernel\n\n- CVE-2021-0936: In acc_read of f_accessory.c, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-173789633References: Upstream kernel\n\n- CVE-2021-20204: A heap memory corruption problem (use after free) can be triggered in libgetdata v0.10.0 when processing maliciously crafted dirfile databases. This degrades the confidentiality, integrity and availability of third-party software that uses libgetdata as a library. This vulnerability may lead to arbitrary code execution or privilege escalation depending on input/skills of attacker.\n\n- CVE-2021-20231: A flaw was found in gnutls. A use after free issue in client sending key_share extension may lead to memory corruption and other consequences.\n\n- CVE-2021-20232: A flaw was found in gnutls. A use after free issue in client_send_params in lib/ext/pre_shared_key.c may lead to memory corruption and other potential consequences.\n\n- CVE-2021-21112: Use after free in Blink in Google Chrome prior to 87.0.4280.141 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21114: Use after free in audio in Google Chrome prior to 87.0.4280.141 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21119: Use after free in Media in Google Chrome prior to 88.0.4324.96 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21120: Use after free in WebSQL in Google Chrome prior to 88.0.4324.96 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21122: Use after free in Blink in Google Chrome prior to 88.0.4324.96 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21145: Use after free in Fonts in Google Chrome prior to 88.0.4324.146 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21157: Use after free in Web Sockets in Google Chrome on Linux prior to 88.0.4324.182 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21159: Heap buffer overflow in TabStrip in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21162: Use after free in WebRTC in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21167: Use after free in bookmarks in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21179: Use after free in Network Internals in Google Chrome on Linux prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21180: Use after free in tab search in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21188: Use after free in Blink in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21191: Use after free in WebRTC in Google Chrome prior to 89.0.4389.90 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21193: Use after free in Blink in Google Chrome prior to 89.0.4389.90 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21194: Use after free in screen sharing in Google Chrome prior to 89.0.4389.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21195: Use after free in V8 in Google Chrome prior to 89.0.4389.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21199: Use after free in Aura in Google Chrome on Linux prior to 89.0.4389.114 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21203: Use after free in Blink in Google Chrome prior to 90.0.4430.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21204: Use after free in Blink in Google Chrome on OS X prior to 90.0.4430.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21206: Use after free in Blink in Google Chrome prior to 89.0.4389.128 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21213: Use after free in WebMIDI in Google Chrome prior to 90.0.4430.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21214: Use after free in Network API in Google Chrome prior to 90.0.4430.72 allowed a remote attacker to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2021-21232: Use after free in Dev Tools in Google Chrome prior to 90.0.4430.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21775: A use-after-free vulnerability exists in the way certain events are processed for ImageLoader objects of Webkit WebKitGTK 2.30.4. A specially crafted web page can lead to a potential information leak and further memory corruption. In order to trigger the vulnerability, a victim must be tricked into visiting a malicious webpage.\n\n- CVE-2021-21779: A use-after-free vulnerability exists in the way Webkit\u2019s GraphicsContext handles certain events in WebKitGTK 2.30.4. A specially crafted web page can lead to a potential information leak and further memory corruption. A victim must be tricked into visiting a malicious web page to trigger this vulnerability.\n\n- CVE-2021-22543: An issue was discovered in Linux: KVM through Improper handling of VM_IO|VM_PFNMAP vmas in KVM can bypass RO checks and can lead to pages being freed while still accessible by the VMM and guest. This allows users with the ability to start and control a VM to read/write random pages of memory and can result in local privilege escalation.\n\n- CVE-2021-22930: Node.js before 16.6.0, 14.17.4, and 12.22.4 is vulnerable to a use after free attack where an attacker might be able to exploit the memory corruption, to change process behavior.\n\n- CVE-2021-22940: Node.js before 16.6.1, 14.17.5, and 12.22.5 is vulnerable to a use after free attack where an attacker might be able to exploit the memory corruption, to change process behavior.\n\n- CVE-2021-28702: PCI devices with RMRRs not deassigned correctly Certain PCI devices in a system might be assigned Reserved Memory Regions (specified via Reserved Memory Region Reporting, \"RMRR\"). These are typically used for platform tasks such as legacy USB emulation. If such a device is passed through to a guest, then on guest shutdown the device is not properly deassigned. The IOMMU configuration for these devices which are not properly deassigned ends up pointing to a freed data structure, including the IO Pagetables. Subsequent DMA or interrupts from the device will have unpredictable behaviour, ranging from IOMMU faults to memory corruption.\n\n- CVE-2021-29970: A malicious webpage could have triggered a use-after-free, memory corruption, and a potentially exploitable crash. *This bug could only be triggered when accessibility was enabled.*. This vulnerability affects Thunderbird < 78.12, Firefox ESR < 78.12, and Firefox < 90.\n\n- CVE-2021-29985: A use-after-free vulnerability in media channels could have led to memory corruption and a potentially exploitable crash. This vulnerability affects Thunderbird < 78.13, Thunderbird < 91, Firefox ESR < 78.13, and Firefox < 91.\n\n- CVE-2021-30510: Use after free in Aura in Google Chrome prior to 90.0.4430.212 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30512: Use after free in Notifications in Google Chrome prior to 90.0.4430.212 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30514: Use after free in Autofill in Google Chrome prior to 90.0.4430.212 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30515: Use after free in File API in Google Chrome prior to 90.0.4430.212 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30519: Use after free in Payments in Google Chrome prior to 90.0.4430.212 allowed an attacker who convinced a user to install a malicious payments app to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30520: Use after free in Tab Strip in Google Chrome prior to 90.0.4430.212 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30522: Use after free in WebAudio in Google Chrome prior to 91.0.4472.77 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30523: Use after free in WebRTC in Google Chrome prior to 91.0.4472.77 allowed a remote attacker to potentially exploit heap corruption via a crafted SCTP packet.\n\n- CVE-2021-30524: Use after free in TabStrip in Google Chrome prior to 91.0.4472.77 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30525: Use after free in TabGroups in Google Chrome prior to 91.0.4472.77 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30527: Use after free in WebUI in Google Chrome prior to 91.0.4472.77 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30528: Use after free in WebAuthentication in Google Chrome on Android prior to 91.0.4472.77 allowed a remote attacker who had compromised the renderer process of a user who had saved a credit card in their Google account to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30529: Use after free in Bookmarks in Google Chrome prior to 91.0.4472.77 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30541: Use after free in V8 in Google Chrome prior to 91.0.4472.164 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30542: Use after free in Tab Strip in Google Chrome prior to 91.0.4472.77 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30543: Use after free in Tab Strip in Google Chrome prior to 91.0.4472.77 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30544: Use after free in BFCache in Google Chrome prior to 91.0.4472.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30545: Use after free in Extensions in Google Chrome prior to 91.0.4472.101 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30546: Use after free in Autofill in Google Chrome prior to 91.0.4472.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30548: Use after free in Loader in Google Chrome prior to 91.0.4472.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30549: Use after free in Spell check in Google Chrome prior to 91.0.4472.101 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30550: Use after free in Accessibility in Google Chrome prior to 91.0.4472.101 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30552: Use after free in Extensions in Google Chrome prior to 91.0.4472.101 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30553: Use after free in Network service in Google Chrome prior to 91.0.4472.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30554: Use after free in WebGL in Google Chrome prior to 91.0.4472.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30555: Use after free in Sharing in Google Chrome prior to 91.0.4472.114 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page and user gesture.\n\n- CVE-2021-30556: Use after free in WebAudio in Google Chrome prior to 91.0.4472.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30557: Use after free in TabGroups in Google Chrome prior to 91.0.4472.114 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30560: Use after free in Blink XSLT in Google Chrome prior to 91.0.4472.164 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30562: Use after free in WebSerial in Google Chrome prior to 91.0.4472.164 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30567: Use after free in DevTools in Google Chrome prior to 92.0.4515.107 allowed an attacker who convinced a user to open DevTools to potentially exploit heap corruption via specific user gesture.\n\n- CVE-2021-30569: Use after free in sqlite in Google Chrome prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30572: Use after free in Autofill in Google Chrome prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30573: Use after free in GPU in Google Chrome prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30574: Use after free in protocol handling in Google Chrome prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30576: Use after free in DevTools in Google Chrome prior to 92.0.4515.107 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30579: Use after free in UI framework in Google Chrome prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30581: Use after free in DevTools in Google Chrome prior to 92.0.4515.107 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30585: Use after free in sensor handling in Google Chrome on Windows prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30586: Use after free in dialog box handling in Windows in Google Chrome prior to 92.0.4515.107 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30591: Use after free in File System API in Google Chrome prior to 92.0.4515.131 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30594: Use after free in Page Info UI in Google Chrome prior to 92.0.4515.131 allowed a remote attacker to potentially exploit heap corruption via physical access to the device.\n\n- CVE-2021-30597: Use after free in Browser UI in Google Chrome on Chrome prior to 92.0.4515.131 allowed a remote attacker to potentially exploit heap corruption via physical access to the device.\n\n- CVE-2021-30600: Use after free in Printing in Google Chrome prior to 92.0.4515.159 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30601: Use after free in Extensions API in Google Chrome prior to 92.0.4515.159 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30602: Use after free in WebRTC in Google Chrome prior to 92.0.4515.159 allowed an attacker who convinced a user to visit a malicious website to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30604: Use after free in ANGLE in Google Chrome prior to 92.0.4515.159 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30625: Use after free in Selection API in Google Chrome prior to 93.0.4577.82 allowed a remote attacker who convinced the user the visit a malicious website to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30629: Use after free in Permissions in Google Chrome prior to 93.0.4577.82 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37956: Use after free in Offline use in Google Chrome on Android prior to 94.0.4606.54 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37957: Use after free in WebGPU in Google Chrome prior to 94.0.4606.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37959: Use after free in Task Manager in Google Chrome prior to 94.0.4606.54 allowed an attacker who convinced a user to enage in a series of user gestures to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37961: Use after free in Tab Strip in Google Chrome prior to 94.0.4606.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37962: Use after free in Performance Manager in Google Chrome prior to 94.0.4606.54 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37970: Use after free in File System API in Google Chrome prior to 94.0.4606.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37974: Use after free in Safebrowsing in Google Chrome prior to 94.0.4606.71 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37975: Use after free in V8 in Google Chrome prior to 94.0.4606.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37977: Use after free in Garbage Collection in Google Chrome prior to 94.0.4606.81 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37982: Use after free in Incognito in Google Chrome prior to 95.0.4638.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37983: Use after free in Dev Tools in Google Chrome prior to 95.0.4638.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37985: Use after free in V8 in Google Chrome prior to 95.0.4638.54 allowed a remote attacker who had convinced a user to allow for connection to debugger to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37987: Use after free in Network APIs in Google Chrome prior to 95.0.4638.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37988: Use after free in Profiles in Google Chrome prior to 95.0.4638.54 allowed a remote attacker who convinced a user to engage in specific gestures to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37993: Use after free in PDF Accessibility in Google Chrome prior to 95.0.4638.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37997: Use after free in Sign-In in Google Chrome prior to 95.0.4638.69 allowed a remote attacker who convinced a user to sign into Chrome to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37998: Use after free in Garbage Collection in Google Chrome prior to 95.0.4638.69 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-38496: During operations on MessageTasks, a task may have been removed while it was still scheduled, resulting in memory corruption and a potentially exploitable crash. This vulnerability affects Thunderbird < 78.15, Thunderbird < 91.2, Firefox ESR < 91.2, Firefox ESR < 78.15, and Firefox < 93.\n\n- CVE-2021-38498: During process shutdown, a document could have caused a use-after-free of a languages service object, leading to memory corruption and a potentially exploitable crash. This vulnerability affects Firefox < 93, Thunderbird < 91.2, and Firefox ESR < 91.2.\n\n- CVE-2021-43057: An issue was discovered in the Linux kernel before 5.14.8. A use-after-free in selinux_ptrace_traceme (aka the SELinux handler for PTRACE_TRACEME) could be used by local attackers to cause memory corruption and escalate privileges, aka CID-a3727a8bac0a. This occurs because of an attempt to access the subjective credentials of another task.\n\n- CVE-2021-43790: Lucet is a native WebAssembly compiler and runtime. There is a bug in the main branch of `lucet-runtime` affecting all versions published to crates.io that allows a use-after-free in an Instance object that could result in memory corruption, data race, or other related issues. This bug was introduced early in the development of Lucet and is present in all releases. As a result of this bug, and dependent on the memory backing for the Instance objects, it is possible to trigger a use-after-free when the Instance is dropped. Users should upgrade to the main branch of the Lucet repository. Lucet no longer provides versioned releases on crates.io. There is no way to remediate this vulnerability without upgrading.\n\n- CVE-2021-44047: A use-after-free vulnerability exists when reading a DWF/DWFX file using Open Design Alliance Drawings SDK before 2022.11. The specific issue exists with parsing DWF/DWFX files. Crafted data in a DWF/DWFX file and lack of proper validation of input data can trigger a write operation past the end of an allocated buffer. An attacker can leverage this vulnerability to execute code in the context of the current process.\n\n- CVE-2021-1651: Diagnostics Hub Standard Collector Elevation of Privilege Vulnerability\n\n- CVE-2021-26900: Windows Win32k Elevation of Privilege Vulnerability\n\n- CVE-2021-31170: Windows Graphics Component Elevation of Privilege Vulnerability\n\n- CVE-2021-31188: Windows Graphics Component Elevation of Privilege Vulnerability\n\n- CVE-2021-34486: Windows Event Tracing Elevation of Privilege Vulnerability\n\n- CVE-2021-40449: Win32k Elevation of Privilege Vulnerability\n\n- CVE-2021-40125: A vulnerability in the Internet Key Exchange Version 2 (IKEv2) implementation of Cisco Adaptive Security Appliance (ASA) Software and Cisco Firepower Threat Defense (FTD) Software could allow an authenticated, remote attacker to trigger a denial of service (DoS) condition on an affected device. This vulnerability is due to improper control of a resource. An attacker with the ability to spoof a trusted IKEv2 site-to-site VPN peer and in possession of valid IKEv2 credentials for that peer could exploit this vulnerability by sending malformed, authenticated IKEv2 messages to an affected device. A successful exploit could allow the attacker to trigger a reload of the device.\n\n- CVE-2021-34498: Windows GDI Elevation of Privilege Vulnerability\n\n- CVE-2021-22893: Pulse Connect Secure 9.0R3/9.1R1 and higher is vulnerable to an authentication bypass vulnerability exposed by the Windows File Share Browser and Pulse Secure Collaboration features of Pulse Connect Secure that can allow an unauthenticated user to perform remote arbitrary code execution on the Pulse Connect Secure gateway. This vulnerability has been exploited in the wild.\n\n- CVE-2021-22348: There is a Memory Buffer Improper Operation Limit Vulnerability in Huawei Smartphone. Successful exploitation of this vulnerability may cause code to execute.\n\n- CVE-2021-22350: There is a Memory Buffer Improper Operation Limit Vulnerability in Huawei Smartphone. Successful exploitation of this vulnerability may cause the device to crash and restart.\n\n- CVE-2021-22353: There is a Memory Buffer Improper Operation Limit Vulnerability in Huawei Smartphone. Successful exploitation of this vulnerability may cause the kernel to restart.\n\n- CVE-2021-22390: There is a Memory Buffer Improper Operation Limit Vulnerability in Huawei Smartphone.Successful exploitation of this vulnerability may cause certain codes to be executed.\n\n- CVE-2020-24349: njs through 0.4.3, used in NGINX, allows control-flow hijack in njs_value_property in njs_value.c. NOTE: the vendor considers the issue to be \"fluff\" in the NGINX use case because there is no remote attack surface.\n\n- CVE-2021-37045: There is an UAF vulnerability in Huawei Smartphone.Successful exploitation of this vulnerability may cause the device to restart unexpectedly and the kernel-mode code to be executed.\n\n- CVE-2021-39803: In ~Impl of C2AllocatorIon.cpp, there is a possible out of bounds read due to a use after free. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12LAndroid ID: A-193790350\n\n- CVE-2021-42612: A use after free in cleanup_index in index.c in Halibut 1.2 allows an attacker to cause a segmentation fault or possibly have other unspecified impact via a crafted text document.\n\n- CVE-2021-42614: A use after free in info_width_internal in bk_info.c in Halibut 1.2 allows an attacker to cause a segmentation fault or possibly have unspecified other impact via a crafted text document.\n\n- CVE-2020-0674: A remote code execution vulnerability exists in the way that the scripting engine handles objects in memory in Internet Explorer, aka 'Scripting Engine Memory Corruption Vulnerability'. This CVE ID is unique from CVE-2020-0673, CVE-2020-0710, CVE-2020-0711, CVE-2020-0712, CVE-2020-0713, CVE-2020-0767.\n\n- CVE-2020-16017: Use after free in site isolation in Google Chrome prior to 86.0.4240.198 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2020-3992: OpenSLP as used in VMware ESXi (7.0 before ESXi_7.0.1-0.0.16850804, 6.7 before ESXi670-202010401-SG, 6.5 before ESXi650-202010401-SG) has a use-after-free issue. A malicious actor residing in the management network who has access to port 427 on an ESXi machine may be able to trigger a use-after-free in the OpenSLP service resulting in remote code execution.\n\n- CVE-2020-6572: Use after free in Media in Google Chrome prior to 81.0.4044.92 allowed a remote attacker to execute arbitrary code via a crafted HTML page.\n\n- CVE-2021-1048: In ep_loop_check_proc of eventpoll.c, there is a possible way to corrupt memory due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-204573007References: Upstream kernel\n\n- CVE-2021-1905: Possible use after free due to improper handling of memory mapping of multiple processes simultaneously. in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2021-28550: Acrobat Reader DC versions versions 2021.001.20150 (and earlier), 2020.001.30020 (and earlier) and 2017.011.30194 (and earlier) are affected by a Use After Free vulnerability. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-28663: The Arm Mali GPU kernel driver allows privilege escalation or information disclosure because GPU memory operations are mishandled, leading to a use-after-free. This affects Bifrost r0p0 through r28p0 before r29p0, Valhall r19p0 through r28p0 before r29p0, and Midgard r4p0 through r30p0.\n\n- CVE-2021-30633: Use after free in Indexed DB API in Google Chrome prior to 93.0.4577.82 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2021-30661: A use after free issue was addressed with improved memory management. This issue is fixed in Safari 14.1, iOS 12.5.3, iOS 14.5 and iPadOS 14.5, watchOS 7.4, tvOS 14.5, macOS Big Sur 11.3. Processing maliciously crafted web content may lead to arbitrary code execution. Apple is aware of a report that this issue may have been actively exploited..\n\n- CVE-2021-30762: A use after free issue was addressed with improved memory management. This issue is fixed in iOS 12.5.4. Processing maliciously crafted web content may lead to arbitrary code execution. Apple is aware of a report that this issue may have been actively exploited..\n\n- CVE-2021-30858: A use after free issue was addressed with improved memory management. This issue is fixed in iOS 14.8 and iPadOS 14.8, macOS Big Sur 11.6. Processing maliciously crafted web content may lead to arbitrary code execution. Apple is aware of a report that this issue may have been actively exploited.\n\n- CVE-2021-31166: HTTP Protocol Stack Remote Code Execution Vulnerability\n\n- CVE-2021-37973: Use after free in Portals in Google Chrome prior to 94.0.4606.61 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2021-35120: Improper handling between export and release functions on the same handle from client can lead to use after free in Snapdragon Compute, Snapdragon Connectivity, Snapdragon Industrial IOT, Snapdragon Mobile\n\n- CVE-2021-3700: A use-after-free vulnerability was found in usbredir in versions prior to 0.11.0 in the usbredirparser_serialize() in usbredirparser/usbredirparser.c. This issue occurs when serializing large amounts of buffered write data in the case of a slow or blocked destination.\n\n- CVE-2021-38005: Use after free in loader in Google Chrome prior to 96.0.4664.45 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-38006: Use after free in storage foundation in Google Chrome prior to 96.0.4664.45 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-38008: Use after free in media in Google Chrome prior to 96.0.4664.45 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-38011: Use after free in storage foundation in Google Chrome prior to 96.0.4664.45 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-39812: In TBD of TBD, there is a possible out of bounds read due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-205522359References: N/A\n\n- CVE-2021-4052: Use after free in web apps in Google Chrome prior to 96.0.4664.93 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2021-4053: Use after free in UI in Google Chrome on Linux prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4057: Use after free in file API in Google Chrome prior to 96.0.4664.93 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4063: Use after free in developer tools in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4064: Use after free in screen capture in Google Chrome on ChromeOS prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4065: Use after free in autofill in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4067: Use after free in window manager in Google Chrome on ChromeOS prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4099: Use after free in Swiftshader in Google Chrome prior to 96.0.4664.110 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4102: Use after free in V8 in Google Chrome prior to 96.0.4664.110 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0096: Use after free in Storage in Google Chrome prior to 97.0.4692.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0098: Use after free in Screen Capture in Google Chrome on Chrome OS prior to 97.0.4692.71 allowed an attacker who convinced a user to perform specific user gestures to potentially exploit heap corruption via specific user gestures.\n\n- CVE-2022-0099: Use after free in Sign-in in Google Chrome prior to 97.0.4692.71 allowed a remote attacker who convinced a user to perform specific user gestures to potentially exploit heap corruption via specific user gesture.\n\n- CVE-2022-0103: Use after free in SwiftShader in Google Chrome prior to 97.0.4692.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0105: Use after free in PDF Accessibility in Google Chrome prior to 97.0.4692.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0106: Use after free in Autofill in Google Chrome prior to 97.0.4692.71 allowed a remote attacker who convinced a user to perform specific user gesture to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0107: Use after free in File Manager API in Google Chrome on Chrome OS prior to 97.0.4692.71 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0289: Use after free in Safe browsing in Google Chrome prior to 97.0.4692.99 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0293: Use after free in Web packaging in Google Chrome prior to 97.0.4692.99 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0295: Use after free in Omnibox in Google Chrome prior to 97.0.4692.99 allowed a remote attacker who convinced the user to engage is specific user interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0296: Use after free in Printing in Google Chrome prior to 97.0.4692.99 allowed a remote attacker who convinced the user to engage is specific user interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0297: Use after free in Vulkan in Google Chrome prior to 97.0.4692.99 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0298: Use after free in Scheduling in Google Chrome prior to 97.0.4692.99 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0300: Use after free in Text Input Method Editor in Google Chrome on Android prior to 97.0.4692.99 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0301: Heap buffer overflow in DevTools in Google Chrome prior to 97.0.4692.99 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0302: Use after free in Omnibox in Google Chrome prior to 97.0.4692.99 allowed an attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0304: Use after free in Bookmarks in Google Chrome prior to 97.0.4692.99 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0307: Use after free in Optimization Guide in Google Chrome prior to 97.0.4692.99 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0308: Use after free in Data Transfer in Google Chrome on Chrome OS prior to 97.0.4692.99 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0453: Use after free in Reader Mode in Google Chrome prior to 98.0.4758.80 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0456: Use after free in Web Search in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via profile destruction.\n\n- CVE-2022-0458: Use after free in Thumbnail Tab Strip in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0459: Use after free in Screen Capture in Google Chrome prior to 98.0.4758.80 allowed a remote attacker who had compromised the renderer process and convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0460: Use after free in Window Dialogue in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0463: Use after free in Accessibility in Google Chrome prior to 98.0.4758.80 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via user interaction.\n\n- CVE-2022-0464: Use after free in Accessibility in Google Chrome prior to 98.0.4758.80 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via user interaction.\n\n- CVE-2022-0465: Use after free in Extensions in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via user interaction.\n\n- CVE-2022-0468: Use after free in Payments in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0469: Use after free in Cast in Google Chrome prior to 98.0.4758.80 allowed a remote attacker who convinced a user to engage in specific interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0603: Use after free in File Manager in Google Chrome on Chrome OS prior to 98.0.4758.102 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0605: Use after free in Webstore API in Google Chrome prior to 98.0.4758.102 allowed an attacker who convinced a user to install a malicious extension and convinced a user to enage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0606: Use after free in ANGLE in Google Chrome prior to 98.0.4758.102 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0607: Use after free in GPU in Google Chrome prior to 98.0.4758.102 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0609: Use after free in Animation in Google Chrome prior to 98.0.4758.102 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0646: A flaw use after free in the Linux kernel Management Component Transport Protocol (MCTP) subsystem was found in the way user triggers cancel_work_sync after the unregister_netdev during removing device. A local user could use this flaw to crash the system or escalate their privileges on the system. It is actual from Linux Kernel 5.17-rc1 (when mctp-serial.c introduced) till 5.17-rc5.\n\n- CVE-2022-0791: Use after free in Omnibox in Google Chrome prior to 99.0.4844.51 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via user interactions.\n\n- CVE-2022-0793: Use after free in Cast in Google Chrome prior to 99.0.4844.51 allowed an attacker who convinced a user to install a malicious extension and engage in specific user interaction to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2022-0794: Use after free in WebShare in Google Chrome prior to 99.0.4844.51 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0796: Use after free in Media in Google Chrome prior to 99.0.4844.51 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0798: Use after free in MediaStream in Google Chrome prior to 99.0.4844.51 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2022-0805: Use after free in Browser Switcher in Google Chrome prior to 99.0.4844.51 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via user interaction.\n\n- CVE-2022-0808: Use after free in Chrome OS Shell in Google Chrome on Chrome OS prior to 99.0.4844.51 allowed a remote attacker who convinced a user to engage in a series of user interaction to potentially exploit heap corruption via user interactions.\n\n- CVE-2022-0971: Use after free in Blink Layout in Google Chrome on Android prior to 99.0.4844.74 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0972: Use after free in Extensions in Google Chrome prior to 99.0.4844.74 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0973: Use after free in Safe Browsing in Google Chrome prior to 99.0.4844.74 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0974: Use after free in Splitscreen in Google Chrome on Chrome OS prior to 99.0.4844.74 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0975: Use after free in ANGLE in Google Chrome prior to 99.0.4844.74 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0977: Use after free in Browser UI in Google Chrome on Chrome OS prior to 99.0.4844.74 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0978: Use after free in ANGLE in Google Chrome prior to 99.0.4844.74 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0979: Use after free in Safe Browsing in Google Chrome on Android prior to 99.0.4844.74 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0980: Use after free in New Tab Page in Google Chrome prior to 99.0.4844.74 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-1125: Use after free in Portals in Google Chrome prior to 100.0.4896.60 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via user interaction.\n\n- CVE-2022-1127: Use after free in QR Code Generator in Google Chrome prior to 100.0.4896.60 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via user interaction.\n\n- CVE-2022-1131: Use after free in Cast UI in Google Chrome prior to 100.0.4896.60 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1133: Use after free in WebRTC Perf in Google Chrome prior to 100.0.4896.60 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1135: Use after free in Shopping Cart in Google Chrome prior to 100.0.4896.60 allowed a remote attacker to potentially exploit heap corruption via standard feature user interaction.\n\n- CVE-2022-1136: Use after free in Tab Strip in Google Chrome prior to 100.0.4896.60 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via specific set of user gestures.\n\n- CVE-2022-1141: Use after free in File Manager in Google Chrome prior to 100.0.4896.60 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via specific user gesture.\n\n- CVE-2022-1144: Use after free in WebUI in Google Chrome prior to 100.0.4896.60 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via specific input into DevTools.\n\n- CVE-2022-1145: Use after free in Extensions in Google Chrome prior to 100.0.4896.60 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via specific user interaction and profile destruction.\n\n- CVE-2022-1305: Use after free in storage in Google Chrome prior to 100.0.4896.88 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1308: Use after free in BFCache in Google Chrome prior to 100.0.4896.88 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1310: Use after free in regular expressions in Google Chrome prior to 100.0.4896.88 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1311: Use after free in shell in Google Chrome on ChromeOS prior to 100.0.4896.88 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1313: Use after free in tab groups in Google Chrome prior to 100.0.4896.88 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1477: Use after free in Vulkan in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1478: Use after free in SwiftShader in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1479: Use after free in ANGLE in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1481: Use after free in Sharing in Google Chrome on Mac prior to 101.0.4951.41 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1485: Use after free in File System API in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1487: Use after free in Ozone in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via running a Wayland test.\n\n- CVE-2022-1490: Use after free in Browser Switcher in Google Chrome prior to 101.0.4951.41 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1491: Use after free in Bookmarks in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via specific and direct user interaction.\n\n- CVE-2022-1493: Use after free in Dev Tools in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via specific and direct user interaction.\n\n- CVE-2022-1496: Use after free in File Manager in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via specific and direct user interaction.\n\n- CVE-2022-1633: Use after free in Sharesheet in Google Chrome on Chrome OS prior to 101.0.4951.64 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-1634: Use after free in Browser UI in Google Chrome prior to 101.0.4951.64 allowed a remote attacker who had convinced a user to engage in specific UI interaction to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-1635: Use after free in Permission Prompts in Google Chrome prior to 101.0.4951.64 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-1636: Use after free in Performance APIs in Google Chrome prior to 101.0.4951.64 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1639: Use after free in ANGLE in Google Chrome prior to 101.0.4951.64 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1640: Use after free in Sharing in Google Chrome prior to 101.0.4951.64 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1641: Use after free in Web UI Diagnostics in Google Chrome on Chrome OS prior to 101.0.4951.64 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via specific user interaction.\n\n- CVE-2022-1734: A flaw in Linux Kernel found in nfcmrvl_nci_unregister_dev() in drivers/nfc/nfcmrvl/main.c can lead to use after free both read or write when non synchronized between cleanup routine and firmware download routine.\n\n- CVE-2022-1854: Use after free in ANGLE in Google Chrome prior to 102.0.5005.61 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1855: Use after free in Messaging in Google Chrome prior to 102.0.5005.61 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1856: Use after free in User Education in Google Chrome prior to 102.0.5005.61 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension or specific user interaction.\n\n- CVE-2022-1859: Use after free in Performance Manager in Google Chrome prior to 102.0.5005.61 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1860: Use after free in UI Foundations in Google Chrome on Chrome OS prior to 102.0.5005.61 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-1861: Use after free in Sharing in Google Chrome on Chrome OS prior to 102.0.5005.61 allowed a remote attacker who convinced a user to enage in specific user interactions to potentially exploit heap corruption via specific user interaction.\n\n- CVE-2022-1863: Use after free in Tab Groups in Google Chrome prior to 102.0.5005.61 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension and specific user interaction.\n\n- CVE-2022-1864: Use after free in WebApp Installs in Google Chrome prior to 102.0.5005.61 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension and specific user interaction.\n\n- CVE-2022-1865: Use after free in Bookmarks in Google Chrome prior to 102.0.5005.61 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension and specific user interaction.\n\n- CVE-2022-1866: Use after free in Tablet Mode in Google Chrome on Chrome OS prior to 102.0.5005.61 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-1870: Use after free in App Service in Google Chrome prior to 102.0.5005.61 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2022-1919: Use after free in Codecs in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2007: Use after free in WebGPU in Google Chrome prior to 102.0.5005.115 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2011: Use after free in ANGLE in Google Chrome prior to 102.0.5005.115 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-20447: In PAN_WriteBuf of pan_api.cc, there is a possible out of bounds read due to a use after free. This could lead to remote information disclosure over Bluetooth with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-233604485\n\n- CVE-2022-20552: In btif_a2dp_sink_command_ready of btif_a2dp_sink.cc, there is a possible out of bounds read due to a use after free. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-243922806\n\n- CVE-2022-20554: In removeEventHubDevice of InputDevice.cpp, there is a possible OOB read due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-245770596\n\n- CVE-2022-20581: In the Pixel camera driver, there is a possible use after free due to a logic error in the code. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-245916120References: N/A\n\n- CVE-2022-2156: Use after free in Core in Google Chrome prior to 103.0.5060.53 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2157: Use after free in Interest groups in Google Chrome prior to 103.0.5060.53 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2158: Type confusion in V8 in Google Chrome prior to 103.0.5060.53 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2161: Use after free in WebApp Provider in Google Chrome prior to 103.0.5060.53 allowed a remote attacker who convinced the user to engage in specific user interactions to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2163: Use after free in Cast UI and Toolbar in Google Chrome prior to 103.0.5060.134 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via UI interaction.\n\n- CVE-2022-2296: Use after free in Chrome OS Shell in Google Chrome on Chrome OS prior to 103.0.5060.114 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via direct UI interactions.\n\n- CVE-2022-23608: PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In versions up to and including 2.11.1 when in a dialog set (or forking) scenario, a hash key shared by multiple UAC dialogs can potentially be prematurely freed when one of the dialogs is destroyed . The issue may cause a dialog set to be registered in the hash table multiple times (with different hash keys) leading to undefined behavior such as dialog list collision which eventually leading to endless loop. A patch is available in commit db3235953baa56d2fb0e276ca510fefca751643f which will be included in the next release. There are no known workarounds for this issue.\n\n- CVE-2022-2399: Use after free in WebGPU in Google Chrome prior to 100.0.4896.88 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2477: Use after free in Guest View in Google Chrome prior to 103.0.5060.134 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2478: Use after free in PDF in Google Chrome prior to 103.0.5060.134 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2480: Use after free in Service Worker API in Google Chrome prior to 103.0.5060.134 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2481: Use after free in Views in Google Chrome prior to 103.0.5060.134 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via UI interaction.\n\n- CVE-2022-2603: Use after free in Omnibox in Google Chrome prior to 104.0.5112.79 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2604: Use after free in Safe Browsing in Google Chrome prior to 104.0.5112.79 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2606: Use after free in Managed devices API in Google Chrome prior to 104.0.5112.79 allowed a remote attacker who convinced a user to enable a specific Enterprise policy to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2613: Use after free in Input in Google Chrome on Chrome OS prior to 104.0.5112.79 allowed a remote attacker who convinced a user to enage in specific user interactions to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2614: Use after free in Sign-In Flow in Google Chrome prior to 104.0.5112.79 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-28269: Acrobat Reader DC versions 22.001.20085 (and earlier), 20.005.3031x (and earlier) and 17.012.30205 (and earlier) are affected by a use-after-free vulnerability in the processing of Annotation objects that could result in a memory leak in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2022-2852: Use after free in FedCM in Google Chrome prior to 104.0.5112.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2855: Use after free in ANGLE in Google Chrome prior to 104.0.5112.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2858: Use after free in Sign-In Flow in Google Chrome prior to 104.0.5112.101 allowed a remote attacker to potentially exploit heap corruption via specific UI interaction.\n\n- CVE-2022-2859: Use after free in Chrome OS Shell in Google Chrome prior to 104.0.5112.101 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2896: Measuresoft ScadaPro Server (All Versions) allows use after free while processing a specific project file.\n\n- CVE-2022-2998: Use after free in Browser Creation in Google Chrome prior to 104.0.5112.101 allowed a remote attacker who had convinced a user to engage in a specific UI interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3038: Use after free in Network Service in Google Chrome prior to 105.0.5195.52 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3039: Use after free in WebSQL in Google Chrome prior to 105.0.5195.52 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3041: Use after free in WebSQL in Google Chrome prior to 105.0.5195.52 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3046: Use after free in Browser Tag in Google Chrome prior to 105.0.5195.52 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3055: Use after free in Passwords in Google Chrome prior to 105.0.5195.52 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3058: Use after free in Sign-In Flow in Google Chrome prior to 105.0.5195.52 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via crafted UI interaction.\n\n- CVE-2022-3196: Use after free in PDF in Google Chrome prior to 105.0.5195.125 allowed a remote attacker to potentially exploit heap corruption via a crafted PDF file. (Chromium security severity: High)\n\n- CVE-2022-3197: Use after free in PDF in Google Chrome prior to 105.0.5195.125 allowed a remote attacker to potentially exploit heap corruption via a crafted PDF file. (Chromium security severity: High)\n\n- CVE-2022-3198: Use after free in PDF in Google Chrome prior to 105.0.5195.125 allowed a remote attacker to potentially exploit heap corruption via a crafted PDF file. (Chromium security severity: High)\n\n- CVE-2022-3199: Use after free in Frames in Google Chrome prior to 105.0.5195.125 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-32317: The MPlayer Project v1.5 was discovered to contain a heap use-after-free resulting in a double free in the preinit function at libvo/vo_v4l2.c. This vulnerability can lead to a Denial of Service (DoS) via a crafted file. The device=strdup statement is not executed on every call. Note: This has been disputed by third parties as invalid and not reproduceable.\n\n- CVE-2022-3445: Use after free in Skia in Google Chrome prior to 106.0.5249.119 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-3448: Use after free in Permissions API in Google Chrome prior to 106.0.5249.119 allowed a remote attacker who convinced a user to engage in specific UI gestures to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-34484: The Mozilla Fuzzing Team reported potential vulnerabilities present in Thunderbird 91.10. Some of these bugs showed evidence of memory corruption and we presume that with enough effort some of these could have been exploited to run arbitrary code. This vulnerability affects Firefox < 102, Firefox ESR < 91.11, Thunderbird < 102, and Thunderbird < 91.11.\n\n- CVE-2022-3449: Use after free in Safe Browsing in Google Chrome prior to 106.0.5249.119 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension. (Chromium security severity: High)\n\n- CVE-2022-34568: SDL v1.2 was discovered to contain a use-after-free via the XFree function at /src/video/x11/SDL_x11yuv.c.\n\n- CVE-2022-3654: Use after free in Layout in Google Chrome prior to 107.0.5304.62 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-3657: Use after free in Extensions in Google Chrome prior to 107.0.5304.62 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension. (Chromium security severity: Medium)\n\n- CVE-2022-3658: Use after free in Feedback service on Chrome OS in Google Chrome on Chrome OS prior to 107.0.5304.62 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via specific UI interaction. (Chromium security severity: Medium)\n\n- CVE-2022-3659: Use after free in Accessibility in Google Chrome on Chrome OS prior to 107.0.5304.62 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via specific UI interactions. (Chromium security severity: Medium)\n\n- CVE-2022-3842: Use after free in Passwords in Google Chrome prior to 105.0.5195.125 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-3863: Use after free in Browser History in Google Chrome prior to 100.0.4896.75 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chrome security severity: High)\n\n- CVE-2022-3885: Use after free in V8 in Google Chrome prior to 107.0.5304.106 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-3886: Use after free in Speech Recognition in Google Chrome prior to 107.0.5304.106 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-3887: Use after free in Web Workers in Google Chrome prior to 107.0.5304.106 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-3888: Use after free in WebCodecs in Google Chrome prior to 107.0.5304.106 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4175: Use after free in Camera Capture in Google Chrome prior to 108.0.5359.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4177: Use after free in Extensions in Google Chrome prior to 108.0.5359.71 allowed an attacker who convinced a user to install an extension to potentially exploit heap corruption via a crafted Chrome Extension and UI interaction. (Chromium security severity: High)\n\n- CVE-2022-4178: Use after free in Mojo in Google Chrome prior to 108.0.5359.71 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4179: Use after free in Audio in Google Chrome prior to 108.0.5359.71 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension. (Chromium security severity: High)\n\n- CVE-2022-4180: Use after free in Mojo in Google Chrome prior to 108.0.5359.71 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension. (Chromium security severity: High)\n\n- CVE-2022-4181: Use after free in Forms in Google Chrome prior to 108.0.5359.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4191: Use after free in Sign-In in Google Chrome prior to 108.0.5359.71 allowed a remote attacker who convinced a user to engage in specific UI interaction to potentially exploit heap corruption via profile destruction. (Chromium security severity: Medium)\n\n- CVE-2022-4192: Use after free in Live Caption in Google Chrome prior to 108.0.5359.71 allowed a remote attacker who convinced a user to engage in specific UI interaction to potentially exploit heap corruption via UI interaction. (Chromium security severity: Medium)\n\n- CVE-2022-4194: Use after free in Accessibility in Google Chrome prior to 108.0.5359.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: Medium)\n\n- CVE-2022-42332: x86 shadow plus log-dirty mode use-after-free In environments where host assisted address translation is necessary but Hardware Assisted Paging (HAP) is unavailable, Xen will run guests in so called shadow mode. Shadow mode maintains a pool of memory used for both shadow page tables as well as auxiliary data structures. To migrate or snapshot guests, Xen additionally runs them in so called log-dirty mode. The data structures needed by the log-dirty tracking are part of aformentioned auxiliary data. In order to keep error handling efforts within reasonable bounds, for operations which may require memory allocations shadow mode logic ensures up front that enough memory is available for the worst case requirements. Unfortunately, while page table memory is properly accounted for on the code path requiring the potential establishing of new shadows, demands by the log-dirty infrastructure were not taken into consideration. As a result, just established shadow page tables could be freed again immediately, while other code is still accessing them on the assumption that they would remain allocated.\n\n- CVE-2022-4436: Use after free in Blink Media in Google Chrome prior to 108.0.5359.124 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4437: Use after free in Mojo IPC in Google Chrome prior to 108.0.5359.124 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4438: Use after free in Blink Frames in Google Chrome prior to 108.0.5359.124 allowed a remote attacker who convinced the user to engage in specific UI interactions to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4439: Use after free in Aura in Google Chrome on Windows prior to 108.0.5359.124 allowed a remote attacker who convinced the user to engage in specific UI interactions to potentially exploit heap corruption via specific UI interactions. (Chromium security severity: High)\n\n- CVE-2022-4440: Use after free in Profiles in Google Chrome prior to 108.0.5359.124 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: Medium)\n\n- CVE-2022-44550: The graphics display module has a UAF vulnerability when traversing graphic layers. Successful exploitation of this vulnerability may affect system availability.\n\n- CVE-2022-45406: If an out-of-memory condition occurred when creating a JavaScript global, a JavaScript realm may be deleted while references to it lived on in a BaseShape. This could lead to a use-after-free causing a potentially exploitable crash. This vulnerability affects Firefox ESR < 102.5, Thunderbird < 102.5, and Firefox < 107.\n\n- CVE-2022-29228: Envoy is a cloud-native high-performance proxy. In versions prior to 1.22.1 the OAuth filter would try to invoke the remaining filters in the chain after emitting a local response, which triggers an ASSERT() in newer versions and corrupts memory on earlier versions. continueDecoding() shouldn\u2019t ever be called from filters after a local reply has been sent. Users are advised to upgrade. There are no known workarounds for this issue.\n\n- CVE-2022-23459: Jsonxx or Json++ is a JSON parser, writer and reader written in C++. In affected versions of jsonxx use of the Value class may lead to memory corruption via a double free or via a use after free. The value class has a default assignment operator which may be used with pointer types which may point to alterable data where the pointer itself is not updated. This issue exists on the current commit of the jsonxx project. The project itself has been archived and updates are not expected. Users are advised to find a replacement.\n\n- CVE-2022-3370: Use after free in Custom Elements in Google Chrome prior to 106.0.5249.91 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-43945: The Linux kernel NFSD implementation prior to versions 5.19.17 and 6.0.2 are vulnerable to buffer overflow. NFSD tracks the number of pages held by each NFSD thread by combining the receive and send buffers of a remote procedure call (RPC) into a single array of pages. A client can force the send buffer to shrink by sending an RPC message over TCP with garbage data added at the end of the message. The RPC message with garbage data is still correctly formed according to the specification and is passed forward to handlers. Vulnerable code in NFSD is not expecting the oversized request and writes beyond the allocated buffer space. CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H\n\n- CVE-2021-1048: In ep_loop_check_proc of eventpoll.c, there is a possible way to corrupt memory due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-204573007References: Upstream kernel\n\n- CVE-2021-21193: Use after free in Blink in Google Chrome prior to 89.0.4389.90 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21206: Use after free in Blink in Google Chrome prior to 89.0.4389.128 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30554: Use after free in WebGL in Google Chrome prior to 91.0.4472.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37975: Use after free in V8 in Google Chrome prior to 94.0.4606.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-22620: A use after free issue was addressed with improved memory management. This issue is fixed in macOS Monterey 12.2.1, iOS 15.3.1 and iPadOS 15.3.1, Safari 15.3 (v. 16612.4.9.1.8 and 15612.4.9.1.8). Processing maliciously crafted web content may lead to arbitrary code execution. Apple is aware of a report that this issue may have been actively exploited..\n\n- CVE-2022-26485: Removing an XSLT parameter during processing could have lead to an exploitable use-after-free. We have had reports of attacks in the wild abusing this flaw. This vulnerability affects Firefox < 97.0.2, Firefox ESR < 91.6.1, Firefox for Android < 97.3.0, Thunderbird < 91.6.2, and Focus < 97.3.0.\n\n- CVE-2022-26486: An unexpected message in the WebGPU IPC framework could lead to a use-after-free and exploitable sandbox escape. We have had reports of attacks in the wild abusing this flaw. This vulnerability affects Firefox < 97.0.2, Firefox ESR < 91.6.1, Firefox for Android < 97.3.0, Thunderbird < 91.6.2, and Focus < 97.3.0.\n\n- CVE-2022-38181: The Arm Mali GPU kernel driver allows unprivileged users to access freed memory because GPU memory operations are mishandled. This affects Bifrost r0p0 through r38p1, and r39p0; Valhall r19p0 through r38p1, and r39p0; and Midgard r4p0 through r32p0.\n\n- CVE-2022-0523: Use After Free in GitHub repository radareorg/radare2 prior to 5.6.2.\n\n- CVE-2022-22034: Windows Graphics Component Elevation of Privilege Vulnerability\n\n- CVE-2022-0581: Crash in the CMS protocol dissector in Wireshark 3.6.0 to 3.6.1 and 3.4.0 to 3.4.11 allows denial of service via packet injection or crafted capture file\n\n- CVE-2022-3541: A vulnerability classified as critical has been found in Linux Kernel. This affects the function spl2sw_nvmem_get_mac_address of the file drivers/net/ethernet/sunplus/spl2sw_driver.c of the component BPF. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier VDB-211041 was assigned to this vulnerability.\n\n- CVE-2022-3545: A vulnerability has been found in Linux Kernel and classified as critical. Affected by this vulnerability is the function area_cache_get of the file drivers/net/ethernet/netronome/nfp/nfpcore/nfp_cppcore.c of the component IPsec. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier VDB-211045 was assigned to this vulnerability.\n\n- CVE-2022-3559: A vulnerability was found in Exim and classified as problematic. This issue affects some unknown processing of the component Regex Handler. The manipulation leads to use after free. The name of the patch is 4e9ed49f8f12eb331b29bd5b6dc3693c520fddc2. It is recommended to apply a patch to fix this issue. The identifier VDB-211073 was assigned to this vulnerability.\n\n- CVE-2022-3620: A vulnerability was found in Exim and classified as problematic. This issue affects the function dmarc_dns_lookup of the file dmarc.c of the component DMARC Handler. The manipulation leads to use after free. The attack may be initiated remotely. The name of the patch is 12fb3842f81bcbd4a4519d5728f2d7e0e3ca1445. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211919.\n\n- CVE-2022-3625: A vulnerability was found in Linux Kernel. It has been classified as critical. This affects the function devlink_param_set/devlink_param_get of the file net/core/devlink.c of the component IPsec. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier VDB-211929 was assigned to this vulnerability.\n\n- CVE-2022-3636: A vulnerability, which was classified as critical, was found in Linux Kernel. This affects the function __mtk_ppe_check_skb of the file drivers/net/ethernet/mediatek/mtk_ppe.c of the component Ethernet Handler. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211935.\n\n- CVE-2022-3640: A vulnerability, which was classified as critical, was found in Linux Kernel. Affected is the function l2cap_conn_del of the file net/bluetooth/l2cap_core.c of the component Bluetooth. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211944.\n\n- CVE-2022-3649: A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is the function nilfs_new_inode of the file fs/nilfs2/inode.c of the component BPF. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211992.\n\n- CVE-2022-3705: A vulnerability was found in vim and classified as problematic. Affected by this issue is the function qf_update_buffer of the file quickfix.c of the component autocmd Handler. The manipulation leads to use after free. The attack may be launched remotely. Upgrading to version 9.0.0805 is able to address this issue. The name of the patch is d0fab10ed2a86698937e3c3fed2f10bd9bb5e731. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-212324.\n\n- CVE-2021-30262: Improper validation of a socket state when socket events are being sent to clients can lead to invalid access of memory in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2022-35254: An unauthenticated attacker can cause a denial-of-service to the following products: Ivanti Connect Secure (ICS) in versions prior to 9.1R14.3, 9.1R15.2, 9.1R16.2, and 22.2R4, Ivanti Policy Secure (IPS) in versions prior to 9.1R17 and 22.3R1, and Ivanti Neurons for Zero-Trust Access in versions prior to 22.3R1.\n\nRelated Weaknesses:\n\n- CWE-825 (ChildOf)\n\n- CWE-672 (ChildOf)\n\n- CWE-672 (ChildOf)\n\n- CWE-672 (ChildOf)\n\n- CWE-120 (CanPrecede)\n\n- CWE-123 (CanPrecede)",
        "type": "Variant",
        "source": "sparse",
        "search_source": "weakness:memory corruption",
        "sources": [
          "base",
          "weakness"
        ],
        "boost_factor": 2.8,
        "boosted": true,
        "metadata": {
          "source": "sparse",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          }
        }
      },
      {
        "cwe_id": "122",
        "name": "Heap-based Buffer Overflow",
        "description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
        "score": 59.76424520678538,
        "matched_text": "CWE-122: Heap-based Buffer Overflow\n\nType: Variant\n\nStatus: Draft\n\nDescription:\n\nA heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().\n\nReal-World Examples:\n\n- CVE-2021-43537: Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n\n- CVE-2007-4268: Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)\n\n- CVE-2009-2523: Chain: product does not handle when an input string is not NULL terminated (CWE-170), leading to buffer over-read (CWE-125) or heap-based buffer overflow (CWE-122).\n\n- CVE-2021-29529: Chain: machine-learning product can have a heap-based buffer overflow (CWE-122) when some integer-oriented bounds are calculated by using ceiling() and floor() on floating point values (CWE-1339)\n\n- CVE-2010-1866: Chain: integer overflow (CWE-190) causes a negative signed value, which later bypasses a maximum-only check (CWE-839), leading to heap-based buffer overflow (CWE-122).\n\nTop 25 CWE Examples:\n\n- CVE-2020-11176: While processing server certificate from IPSec server, certificate validation for subject alternative name API can cause heap overflow which can lead to memory corruption in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Mobile\n\n- CVE-2020-11182: Possible heap overflow while parsing NAL header due to lack of check of length of data received from user in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile\n\n- CVE-2020-18900: A heap-based buffer overflow in the libexe_io_handle_read_coff_optional_header function of libyal libexe before 20181128. NOTE: the vendor has disputed this as described in libyal/libexe issue 1 on GitHub\n\n- CVE-2020-21600: libde265 v1.0.4 contains a heap buffer overflow in the put_weighted_pred_avg_16_fallback function, which can be exploited via a crafted a file.\n\n- CVE-2020-21602: libde265 v1.0.4 contains a heap buffer overflow in the put_weighted_bipred_16_fallback function, which can be exploited via a crafted a file.\n\n- CVE-2020-21606: libde265 v1.0.4 contains a heap buffer overflow fault in the put_epel_16_fallback function, which can be exploited via a crafted a file.\n\n- CVE-2020-21677: A heap-based buffer overflow in the sixel_encoder_output_without_macro function in encoder.c of Libsixel 1.8.4 allows attackers to cause a denial of service (DOS) via converting a crafted PNG file into Sixel format.\n\n- CVE-2020-21814: A heap based buffer overflow issue exists in GNU LibreDWG 0.10.2641 via htmlwescape ../../programs/escape.c:97.\n\n- CVE-2020-21818: A heap based buffer overflow vulnerability exists in GNU LibreDWG 0.10.2641 via htmlescape ../../programs/escape.c:48.\n\n- CVE-2020-21819: A heap based buffer overflow vulnerability exists in GNU LibreDWG 0.10.2641via htmlescape ../../programs/escape.c:51.\n\n- CVE-2020-21827: A heap based buffer overflow vulnerability exists in GNU LibreDWG 0.10 via read_2004_compressed_section ../../src/decode.c:2379.\n\n- CVE-2020-21830: A heap based buffer overflow vulneraibility exists in GNU LibreDWG 0.10 via bit_calc_CRC ../../src/bits.c:2213.\n\n- CVE-2020-21831: A heap based buffer overflow vulnerability exists in GNU LibreDWG 0.10 via read_2004_section_handles ../../src/decode.c:2637.\n\n- CVE-2020-21832: A heap based buffer overflow vulnerability exists in GNU LibreDWG 0.10 via read_2004_compressed_section ../../src/decode.c:2417.\n\n- CVE-2020-21833: A heap based buffer overflow vulnerability exits in GNU LibreDWG 0.10 via: read_2004_section_classes ../../src/decode.c:2440.\n\n- CVE-2020-21838: A heap based buffer overflow vulnerability exits in GNU LibreDWG 0.10 via: read_2004_section_appinfo ../../src/decode.c:2842.\n\n- CVE-2020-21840: A heap based buffer overflow vulnerability exits in GNU LibreDWG 0.10 via bit_search_sentinel ../../src/bits.c:1985.\n\n- CVE-2020-21841: A heap based buffer overflow vulnerability exits in GNU LibreDWG 0.10 via bit_read_B ../../src/bits.c:135.\n\n- CVE-2020-21842: A heap based buffer overflow vulnerability exists in GNU LibreDWG 0.10 via read_2004_section_revhistory ../../src/decode.c:3051.\n\n- CVE-2020-21843: A heap based buffer overflow vulnerability exits in GNU LibreDWG 0.10 via bit_read_RC ../../src/bits.c:318.\n\n- CVE-2020-22016: A heap-based Buffer Overflow vulnerability in FFmpeg 4.2 at libavcodec/get_bits.h when writing .mov files, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22017: A heap-based Buffer Overflow vulnerability exists in FFmpeg 4.2 at ff_fill_rectangle in libavfilter/drawutils.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22022: A heap-based Buffer Overflow vulnerability exists in FFmpeg 4.2 in filter_frame at libavfilter/vf_fieldorder.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22023: A heap-based Buffer Overflow vulnerabililty exists in FFmpeg 4.2 in filter_frame at libavfilter/vf_bitplanenoise.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22025: A heap-based Buffer Overflow vulnerability exists in gaussian_blur at libavfilter/vf_edgedetect.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22027: A heap-based Buffer Overflow vulnerability exits in FFmpeg 4.2 in deflate16 at libavfilter/vf_neighbor.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22029: A heap-based Buffer Overflow vulnerability exists in FFmpeg 4.2 at libavfilter/vf_colorconstancy.c: in slice_get_derivative, which crossfade_samples_fltp, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22030: A heap-based Buffer Overflow vulnerability exists in FFmpeg 4.2 at libavfilter/af_afade.c in crossfade_samples_fltp, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22031: A Heap-based Buffer Overflow vulnerability exists in FFmpeg 4.2 at libavfilter/vf_w3fdif.c in filter16_complex_low, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22032: A heap-based Buffer Overflow vulnerability exists FFmpeg 4.2 at libavfilter/vf_edgedetect.c in gaussian_blur, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22033: A heap-based Buffer Overflow Vulnerability exists FFmpeg 4.2 at libavfilter/vf_vmafmotion.c in convolution_y_8bit, which could let a remote malicious user cause a Denial of Service.\n\n- CVE-2020-22034: A heap-based Buffer Overflow vulnerability exists FFmpeg 4.2 at libavfilter/vf_floodfill.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22035: A heap-based Buffer Overflow vulnerability exists in FFmpeg 4.2 in get_block_row at libavfilter/vf_bm3d.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22036: A heap-based Buffer Overflow vulnerability exists in FFmpeg 4.2 in filter_intra at libavfilter/vf_bwdif.c, which might lead to memory corruption and other potential consequences.\n\n- CVE-2020-22675: An issue was discovered in gpac 0.8.0. The GetGhostNum function in stbl_read.c has a heap-based buffer overflow which can lead to a denial of service (DOS) via a crafted input.\n\n- CVE-2020-22677: An issue was discovered in gpac 0.8.0. The dump_data_hex function in box_dump.c has a heap-based buffer overflow which can lead to a denial of service (DOS) via a crafted input.\n\n- CVE-2020-22678: An issue was discovered in gpac 0.8.0. The gf_media_nalu_remove_emulation_bytes function in av_parsers.c has a heap-based buffer overflow which can lead to a denial of service (DOS) via a crafted input.\n\n- CVE-2020-23266: An issue was discovered in gpac 0.8.0. The OD_ReadUTF8String function in odf_code.c has a heap-based buffer overflow which can lead to a denial of service (DOS) via a crafted media file.\n\n- CVE-2020-23267: An issue was discovered in gpac 0.8.0. The gf_hinter_track_process function in isom_hinter_track_process.c has a heap-based buffer overflow which can lead to a denial of service (DOS) via a crafted media file\n\n- CVE-2020-23269: An issue was discovered in gpac 0.8.0. The stbl_GetSampleSize function in isomedia/stbl_read.c has a heap-based buffer overflow which can lead to a denial of service (DOS) via a crafted media file.\n\n- CVE-2020-23332: A heap-based buffer overflow exists in the AP4_StdcFileByteStream::ReadPartial component located in /StdC/Ap4StdCFileByteStream.cpp of Bento4 version 06c39d9. This issue can lead to a denial of service (DOS).\n\n- CVE-2020-23333: A heap-based buffer overflow exists in the AP4_CttsAtom::AP4_CttsAtom component located in /Core/Ap4Utils.h of Bento4 version 06c39d9. This can lead to a denial of service (DOS).\n\n- CVE-2020-23706: A heap-based buffer overflow vulnerability in the function ok_jpg_decode_block_subsequent_scan() ok_jpg.c:1102 of ok-file-formats through 2020-06-26 allows attackers to cause a Denial of Service (DOS) via a crafted jpeg file.\n\n- CVE-2020-23707: A heap-based buffer overflow vulnerability in the function ok_jpg_decode_block_progressive() at ok_jpg.c:1054 of ok-file-formats through 2020-06-26 allows attackers to cause a Denial of Service (DOS) via a crafted jpeg file.\n\n- CVE-2020-23852: A heap based buffer overflow vulnerability exists in ffjpeg through 2020-07-02 in the jfif_decode(void *ctxt, BMP *pb) function at ffjpeg/src/jfif.c (line 544 & line 545), which could cause a denial of service by submitting a malicious jpeg image.\n\n- CVE-2020-23861: A heap-based buffer overflow vulnerability exists in LibreDWG 0.10.1 via the read_system_page function at libredwg-0.10.1/src/decode_r2007.c:666:5, which causes a denial of service by submitting a dwg file.\n\n- CVE-2020-23886: XnView MP v0.96.4 was discovered to contain a heap overflow which allows attackers to cause a denial of service (DoS) via a crafted pict file. Related to a User Mode Write AV starting at ntdll!RtlpLowFragHeapFree.\n\n- CVE-2020-23887: XnView MP v0.96.4 was discovered to contain a heap overflow which allows attackers to cause a denial of service (DoS) via a crafted ico file. Related to a Read Access Violation starting at USER32!SmartStretchDIBits+0x33.\n\n- CVE-2020-23907: An issue was discovered in retdec v3.3. In function canSplitFunctionOn() of ir_modifications.cpp, there is a possible out of bounds read due to a heap buffer overflow. The impact is: Deny of Service, Memory Disclosure, and Possible Code Execution.\n\n- CVE-2020-24133: A heap buffer overflow vulnerability in the r_asm_swf_disass function of Radare2-extras before commit e74a93c allows attackers to execute arbitrary code or carry out denial of service (DOS) attacks.\n\n- CVE-2020-24829: An issue was discovered in GPAC v0.8.0, as demonstrated by MP4Box. It contains a heap-based buffer overflow in gf_m2ts_section_complete in media_tools/mpegts.c that can cause a denial of service (DOS) via a crafted MP4 file.\n\n- CVE-2020-26797: Mediainfo before version 20.08 has a heap buffer overflow vulnerability via MediaInfoLib::File_Gxf::ChooseParser_ChannelGrouping.\n\n- CVE-2020-28011: Exim 4 before 4.94.2 allows Heap-based Buffer Overflow in queue_run via two sender options: -R and -S. This may cause privilege escalation from exim to root.\n\n- CVE-2020-28013: Exim 4 before 4.94.2 allows Heap-based Buffer Overflow because it mishandles \"-F '.('\" on the command line, and thus may allow privilege escalation from any user to root. This occurs because of the interpretation of negative sizes in strncpy.\n\n- CVE-2020-28592: A heap-based buffer overflow vulnerability exists in the configuration server functionality of the Cosori Smart 5.8-Quart Air Fryer CS158-AF 1.1.0. A specially crafted JSON object can lead to remote code execution. An attacker can send a malicious packet to trigger this vulnerability.\n\n- CVE-2020-29614: This issue was addressed with improved checks. This issue is fixed in macOS Big Sur 11.2, Security Update 2021-001 Catalina, Security Update 2021-001 Mojave, macOS Big Sur 11.1, Security Update 2020-001 Catalina, Security Update 2020-007 Mojave, iOS 14.3 and iPadOS 14.3, tvOS 14.3. Processing a maliciously crafted file may lead to heap corruption.\n\n- CVE-2020-35979: An issue was discovered in GPAC version 0.8.0 and 1.0.1. There is heap-based buffer overflow in the function gp_rtp_builder_do_avc() in ietf/rtp_pck_mpeg4.c.\n\n- CVE-2020-36400: ZeroMQ libzmq 4.3.3 has a heap-based buffer overflow in zmq::tcp_read, a different vulnerability than CVE-2021-20235.\n\n- CVE-2020-36428: matio (aka MAT File I/O Library) 1.5.18 through 1.5.21 has a heap-based buffer overflow in ReadInt32DataDouble (called from ReadInt32Data and Mat_VarRead4).\n\n- CVE-2020-36430: libass 0.15.x before 0.15.1 has a heap-based buffer overflow in decode_chars (called from decode_font and process_text) because the wrong integer data type is used for subtraction.\n\n- CVE-2020-7461: In FreeBSD 12.1-STABLE before r365010, 11.4-STABLE before r365011, 12.1-RELEASE before p9, 11.4-RELEASE before p3, and 11.3-RELEASE before p13, dhclient(8) fails to handle certain malformed input related to handling of DHCP option 119 resulting a heap overflow. The heap overflow could in principle be exploited to achieve remote code execution. The affected process runs with reduced privileges in a Capsicum sandbox, limiting the immediate impact of an exploit.\n\n- CVE-2021-0325: In ih264d_parse_pslice of ih264d_parse_pslice.c, there is a possible out of bounds write due to a heap buffer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-8.1 Android-9 Android-10 Android-11Android ID: A-174238784\n\n- CVE-2021-0353: In kisd, there is a possible memory corruption due to a heap buffer overflow. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Product: Android; Versions: Android-11; Patch ID: ALPS05425247.\n\n- CVE-2021-0426: In parsePrimaryFieldFirstUidAnnotation of LogEvent.cpp, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11Android ID: A-174485572\n\n- CVE-2021-0427: In parseExclusiveStateAnnotation of LogEvent.cpp, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11Android ID: A-174488848\n\n- CVE-2021-0457: In the FingerTipS touch screen driver, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-157155375\n\n- CVE-2021-0464: In sound_trigger_event_alloc of platform.h, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-167663878\n\n- CVE-2021-0474: In avrc_msg_cback of avrc_api.cc, there is a possible out of bounds write due to a heap buffer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11 Android-8.1 Android-9 Android-10Android ID: A-177611958\n\n- CVE-2021-0512: In __hidinput_change_resolution_multipliers of hid-input.c, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-173843328References: Upstream kernel\n\n- CVE-2021-0519: In BITSTREAM_FLUSH of ih264e_bitstream.h, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-8.1 Android-9Android ID: A-176533109\n\n- CVE-2021-0577: In flv extractor, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-187161771\n\n- CVE-2021-0690: In ih264d_mark_err_slice_skip of ih264d_parse_pslice.c, there is a possible out of bounds write due to a heap buffer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-9 Android-10 Android-11 Android-8.1Android ID: A-182152757\n\n- CVE-2021-1767: This issue was addressed with improved checks. This issue is fixed in macOS Big Sur 11.2, Security Update 2021-001 Catalina, Security Update 2021-001 Mojave, iOS 14.4 and iPadOS 14.4. Processing a maliciously crafted image may lead to heap corruption.\n\n- CVE-2021-1883: This issue was addressed with improved checks. This issue is fixed in Security Update 2021-004 Mojave, iOS 14.5 and iPadOS 14.5, watchOS 7.4, Security Update 2021-003 Catalina, tvOS 14.5, macOS Big Sur 11.3. Processing maliciously crafted server messages may lead to heap corruption.\n\n- CVE-2021-1975: Possible heap overflow due to improper length check of domain while parsing the DNS response in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2021-20194: There is a vulnerability in the linux kernel versions higher than 5.2 (if kernel compiled with config params CONFIG_BPF_SYSCALL=y , CONFIG_BPF=y , CONFIG_CGROUPS=y , CONFIG_CGROUP_BPF=y , CONFIG_HARDENED_USERCOPY not set, and BPF hook to getsockopt is registered). As result of BPF execution, the local user can trigger bug in __cgroup_bpf_run_filter_getsockopt() function that can lead to heap overflow (because of non-hardened usercopy). The impact of attack could be deny of service or possibly privileges escalation.\n\n- CVE-2021-20284: A flaw was found in GNU Binutils 2.35.1, where there is a heap-based buffer overflow in _bfd_elf_slurp_secondary_reloc_section in elf.c due to the number of symbols not calculated correctly. The highest threat from this vulnerability is to system availability.\n\n- CVE-2021-20494: IBM Security Identity Manager Adapters 6.0 and 7.0 are vulnerable to a heap based buffer overflow, caused by improper bounds. An authenticared user could overflow the buffer and cause the service to crash. IBM X-Force ID: 197882.\n\n- CVE-2021-20573: IBM Security Identity Manager Adapters 6.0 and 7.0 are vulnerable to a heap-based buffer overflow, caused by improper bounds checking. A remote authenticated attacker could overflow the and cause the server to crash. IBM X-Force ID: 199249.\n\n- CVE-2021-20587: Heap-based buffer overflow vulnerability in Mitsubishi Electric FA Engineering Software (CPU Module Logging Configuration Tool versions 1.112R and prior, CW Configurator versions 1.011M and prior, Data Transfer versions 3.44W and prior, EZSocket versions 5.4 and prior, FR Configurator all versions, FR Configurator SW3 all versions, FR Configurator2 versions 1.24A and prior, GT Designer3 Version1(GOT1000) versions 1.250L and prior, GT Designer3 Version1(GOT2000) versions 1.250L and prior, GT SoftGOT1000 Version3 versions 3.245F and prior, GT SoftGOT2000 Version1 versions 1.250L and prior, GX Configurator-DP versions 7.14Q and prior, GX Configurator-QP all versions, GX Developer versions 8.506C and prior, GX Explorer all versions, GX IEC Developer all versions, GX LogViewer versions 1.115U and prior, GX RemoteService-I all versions, GX Works2 versions 1.597X and prior, GX Works3 versions 1.070Y and prior, iQ Monozukuri ANDON (Data Transfer) all versions, iQ Monozukuri Process Remote Monitoring (Data Transfer) all versions, M_CommDTM-HART all versions, M_CommDTM-IO-Link versions 1.03D and prior, MELFA-Works versions 4.4 and prior, MELSEC WinCPU Setting Utility all versions, MELSOFT EM Software Development Kit (EM Configurator) versions 1.015R and prior, MELSOFT Navigator versions 2.74C and prior, MH11 SettingTool Version2 versions 2.004E and prior, MI Configurator versions 1.004E and prior, MT Works2 versions 1.167Z and prior, MX Component versions 5.001B and prior, Network Interface Board CC IE Control utility versions 1.29F and prior, Network Interface Board CC IE Field Utility versions 1.16S and prior, Network Interface Board CC-Link Ver.2 Utility versions 1.23Z and prior, Network Interface Board MNETH utility versions 34L and prior, PX Developer versions 1.53F and prior, RT ToolBox2 versions 3.73B and prior, RT ToolBox3 versions 1.82L and prior, Setting/monitoring tools for the C Controller module (SW4PVC-CCPU) versions 4.12N and prior and SLMP Data Collector versions 1.04E and prior) allows a remote unauthenticated attacker to cause a DoS condition of the software products, and possibly to execute a malicious program on the personal computer running the software products although it has not been reproduced, by spoofing MELSEC, GOT or FREQROL and returning crafted reply packets.\n\n- CVE-2021-21017: Acrobat Reader DC versions versions 2020.013.20074 (and earlier), 2020.001.30018 (and earlier) and 2017.011.30188 (and earlier) are affected by a heap-based buffer overflow vulnerability. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-21077: Adobe Animate version 21.0.3 (and earlier) is affected by a Heap-based Buffer Overflow vulnerability. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-21113: Heap buffer overflow in Skia in Google Chrome prior to 87.0.4280.141 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21116: Heap buffer overflow in audio in Google Chrome prior to 87.0.4280.141 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21128: Heap buffer overflow in Blink in Google Chrome prior to 88.0.4324.96 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21143: Heap buffer overflow in Extensions in Google Chrome prior to 88.0.4324.146 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2021-21144: Heap buffer overflow in Tab Groups in Google Chrome prior to 88.0.4324.146 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2021-21148: Heap buffer overflow in V8 in Google Chrome prior to 88.0.4324.150 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21152: Heap buffer overflow in Media in Google Chrome on Linux prior to 88.0.4324.182 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21154: Heap buffer overflow in Tab Strip in Google Chrome prior to 88.0.4324.182 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2021-21155: Heap buffer overflow in Tab Strip in Google Chrome on Windows prior to 88.0.4324.182 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2021-21156: Heap buffer overflow in V8 in Google Chrome prior to 88.0.4324.182 allowed a remote attacker to potentially exploit heap corruption via a crafted script.\n\n- CVE-2021-21160: Heap buffer overflow in WebAudio in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21161: Heap buffer overflow in TabStrip in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21192: Heap buffer overflow in tab groups in Google Chrome prior to 89.0.4389.90 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21196: Heap buffer overflow in TabStrip in Google Chrome on Windows prior to 89.0.4389.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21197: Heap buffer overflow in TabStrip in Google Chrome prior to 89.0.4389.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21222: Heap buffer overflow in V8 in Google Chrome prior to 90.0.4430.85 allowed a remote attacker who had compromised the renderer process to bypass site isolation via a crafted HTML page.\n\n- CVE-2021-21225: Out of bounds memory access in V8 in Google Chrome prior to 90.0.4430.85 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21233: Heap buffer overflow in ANGLE in Google Chrome on Windows prior to 90.0.4430.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21555: Dell PowerEdge R640, R740, R740XD, R840, R940, R940xa, MX740c, MX840c, and T640 Server BIOS contain a heap-based buffer overflow vulnerability in systems with NVDIMM-N installed. A local malicious user with high privileges may potentially exploit this vulnerability, leading to a denial of Service, arbitrary code execution, or information disclosure in UEFI or BIOS Preboot Environment.\n\n- CVE-2021-21795: A heap-based buffer overflow vulnerability exists in the PSD read_icc_icCurve_data functionality of Accusoft ImageGear 19.9. A specially crafted malformed file can lead to an integer overflow that, in turn, leads to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21808: A memory corruption vulnerability exists in the PNG png_palette_process functionality of Accusoft ImageGear 19.9. A specially crafted malformed file can lead to a heap buffer overflow. An attacker can provide malicious inputs to trigger this vulnerability.\n\n- CVE-2021-21810: A memory corruption vulnerability exists in the XML-parsing ParseAttribs functionality of AT&T Labs\u2019 Xmill 0.7. A specially crafted XML file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21811: A memory corruption vulnerability exists in the XML-parsing CreateLabelOrAttrib functionality of AT&T Labs\u2019 Xmill 0.7. A specially crafted XML file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21825: A heap-based buffer overflow vulnerability exists in the XML Decompression PlainTextUncompressor::UncompressItem functionality of AT&T Labs\u2019 Xmill 0.7. A specially crafted XMI file can lead to remote code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21826: A heap-based buffer overflow vulnerability exists in the XML Decompression DecodeTreeBlock functionality of AT&T Labs Xmill 0.7. Within `DecodeTreeBlock` which is called during the decompression of an XMI file, a UINT32 is loaded from the file and used as trusted input as the length of a buffer. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21827: A heap-based buffer overflow vulnerability exists in the XML Decompression DecodeTreeBlock functionality of AT&T Labs Xmill 0.7. Within `DecodeTreeBlock` which is called during the decompression of an XMI file, a UINT32 is loaded from the file and used as trusted input as the length of a buffer. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21828: A heap-based buffer overflow vulnerability exists in the XML Decompression DecodeTreeBlock functionality of AT&T Labs Xmill 0.7. In the default case of DecodeTreeBlock a label is created via CurPath::AddLabel in order to track the label for later reference. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21829: A heap-based buffer overflow vulnerability exists in the XML Decompression EnumerationUncompressor::UncompressItem functionality of AT&T Labs\u2019 Xmill 0.7. A specially crafted XMI file can lead to remote code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21830: A heap-based buffer overflow vulnerability exists in the XML Decompression LabelDict::Load functionality of AT&T Labs\u2019 Xmill 0.7. A specially crafted XMI file can lead to remote code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21897: A code execution vulnerability exists in the DL_Dxf::handleLWPolylineData functionality of Ribbonsoft dxflib 3.17.0. A specially-crafted .dxf file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21899: A code execution vulnerability exists in the dwgCompressor::copyCompBytes21 functionality of LibreCad libdxfrw 2.2.0-rc2-19-ge02f3580. A specially-crafted .dwg file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21940: A heap-based buffer overflow vulnerability exists in the pushMuxer processRtspInfo functionality of Anker Eufy Homebase 2 2.1.6.9h. A specially-crafted network packet can lead to a heap buffer overflow. An attacker can send a malicious packet to trigger this vulnerability.\n\n- CVE-2021-22427: There is a Heap-based Buffer Overflow Vulnerability in Huawei Smartphone.Successful exploitation of this vulnerability may lead to authentication bypass.\n\n- CVE-2021-22465: A component of the HarmonyOS has a Heap-based Buffer Overflow vulnerability. Local attackers may exploit this vulnerability to cause Kernel System unavailable.\n\n- CVE-2021-22641: A heap-based buffer overflow issue has been identified in the way the application processes project files, allowing an attacker to craft a special project file that may allow arbitrary code execution on the Tellus Lite V-Simulator and V-Server Lite (versions prior to 4.0.10.0).\n\n- CVE-2021-25289: An issue was discovered in Pillow before 8.1.1. TiffDecode has a heap-based buffer overflow when decoding crafted YCbCr files because of certain interpretation conflicts with LibTIFF in RGBA mode. NOTE: this issue exists because of an incomplete fix for CVE-2020-35654.\n\n- CVE-2021-25475: A possible heap-based buffer overflow vulnerability in DSP kernel driver prior to SMR Oct-2021 Release 1 allows arbitrary memory write and code execution.\n\n- CVE-2021-25479: A possible heap-based buffer overflow vulnerability in Exynos CP Chipset prior to SMR Oct-2021 Release 1 allows arbitrary memory write and code execution.\n\n- CVE-2021-25495: A possible heap buffer overflow vulnerability in libSPenBase library of Samsung Notes prior to Samsung Note version 4.3.02.61 allows arbitrary code execution.\n\n- CVE-2021-25832: A heap buffer overflow vulnerability inside of BMP image processing was found at [core] module of ONLYOFFICE DocumentServer v4.0.0-9-v6.0.0. Using this vulnerability, an attacker is able to gain remote code executions on DocumentServer.\n\n- CVE-2021-25900: An issue was discovered in the smallvec crate before 0.6.14 and 1.x before 1.6.1 for Rust. There is a heap-based buffer overflow in SmallVec::insert_many.\n\n- CVE-2021-26096: Multiple instances of heap-based buffer overflow in the command shell of FortiSandbox before 4.0.0 may allow an authenticated attacker to manipulate memory and alter its content by means of specifically crafted command line arguments.\n\n- CVE-2021-26603: A heap overflow issue was found in ARK library of bandisoft Co., Ltd when the Ark_DigPathA function parsed a file path. This vulnerability is due to missing support for string length check.\n\n- CVE-2021-26691: In Apache HTTP Server versions 2.4.0 to 2.4.46 a specially crafted SessionHeader sent by an origin server could cause a heap overflow\n\n- CVE-2021-26951: An issue was discovered in the calamine crate before 0.17.0 for Rust. It allows attackers to overwrite heap-memory locations because Vec::set_len is used without proper memory claiming, and this uninitialized memory is used for a user-provided Read operation, as demonstrated by Sectors::get.\n\n- CVE-2021-27034: A heap-based buffer overflow could occur while parsing PICT, PCX, RCL or TIFF files in Autodesk Design Review 2018, 2017, 2013, 2012, 2011. This vulnerability can be exploited to execute arbitrary code.\n\n- CVE-2021-27954: A heap-based buffer overflow vulnerability exists on the ecobee3 lite 4.5.81.200 device in the HKProcessConfig function of the HomeKit Wireless Access Control setup process. A threat actor can exploit this vulnerability to force the device to connect to a SSID or cause a denial of service.\n\n- CVE-2021-28026: jpeg-xl v0.3.2 is affected by a heap buffer overflow in /lib/jxl/coeff_order.cc ReadPermutation. When decoding a malicous jxl file using djxl, an attacker can trigger arbitrary code execution or a denial of service.\n\n- CVE-2021-28211: A heap overflow in LzmaUefiDecompressGetInfo function in EDK II.\n\n- CVE-2021-28233: Heap-based Buffer Overflow vulnerability exists in ok-file-formats 1 via the ok_jpg_generate_huffman_table function in ok_jpg.c.\n\n- CVE-2021-28603: Adobe After Effects version 18.2 (and earlier) is affected by a Heap-based Buffer Overflow vulnerability when parsing a specially crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-28604: Adobe After Effects version 18.2 (and earlier) is affected by a Heap-based Buffer Overflow vulnerability when parsing a specially crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-28607: Adobe After Effects version 18.2 (and earlier) is affected by a heap corruption vulnerability when parsing a specially crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-28608: Adobe After Effects version 18.2 (and earlier) is affected by a Heap-based Buffer Overflow vulnerability when parsing a specially crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-28610: Adobe After Effects version 18.2 (and earlier) is affected by a Heap-based Buffer Overflow vulnerability when parsing a specially crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-29323: OpenSource Moddable v10.5.0 was discovered to contain a heap buffer overflow via the component /modules/network/wifi/esp/modwifi.c.\n\n- CVE-2021-29325: OpenSource Moddable v10.5.0 was discovered to contain a heap buffer overflow in the fx_String_prototype_repeat function at /moddable/xs/sources/xsString.c.\n\n- CVE-2021-29326: OpenSource Moddable v10.5.0 was discovered to contain a heap buffer overflow in the fxIDToString function at /moddable/xs/sources/xsSymbol.c.\n\n- CVE-2021-29327: OpenSource Moddable v10.5.0 was discovered to contain a heap buffer overflow in the fx_ArrayBuffer function at /moddable/xs/sources/xsDataView.c.\n\n- CVE-2021-29464: Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. A heap buffer overflow was found in Exiv2 versions v0.27.3 and earlier. The heap overflow is triggered when Exiv2 is used to write metadata into a crafted image file. An attacker could potentially exploit the vulnerability to gain code execution, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when writing the metadata, which is a less frequently used Exiv2 operation than reading the metadata. For example, to trigger the bug in the Exiv2 command-line application, you need to add an extra command-line argument such as `insert`. The bug is fixed in version v0.27.4.\n\n- CVE-2021-29512: TensorFlow is an end-to-end open source platform for machine learning. If the `splits` argument of `RaggedBincount` does not specify a valid `SparseTensor`(https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor), then an attacker can trigger a heap buffer overflow. This will cause a read from outside the bounds of the `splits` tensor buffer in the implementation of the `RaggedBincount` op(https://github.com/tensorflow/tensorflow/blob/8b677d79167799f71c42fd3fa074476e0295413a/tensorflow/core/kernels/bincount_op.cc#L430-L433). Before the `for` loop, `batch_idx` is set to 0. The user controls the `splits` array, making it contain only one element, 0. Thus, the code in the `while` loop would increment `batch_idx` and then try to read `splits(1)`, which is outside of bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3, as these are also affected.\n\n- CVE-2021-29514: TensorFlow is an end-to-end open source platform for machine learning. If the `splits` argument of `RaggedBincount` does not specify a valid `SparseTensor`(https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor), then an attacker can trigger a heap buffer overflow. This will cause a read from outside the bounds of the `splits` tensor buffer in the implementation of the `RaggedBincount` op(https://github.com/tensorflow/tensorflow/blob/8b677d79167799f71c42fd3fa074476e0295413a/tensorflow/core/kernels/bincount_op.cc#L430-L446). Before the `for` loop, `batch_idx` is set to 0. The attacker sets `splits(0)` to be 7, hence the `while` loop does not execute and `batch_idx` remains 0. This then results in writing to `out(-1, bin)`, which is before the heap allocated buffer for the output tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3, as these are also affected.\n\n- CVE-2021-29520: TensorFlow is an end-to-end open source platform for machine learning. Missing validation between arguments to `tf.raw_ops.Conv3DBackprop*` operations can result in heap buffer overflows. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/4814fafb0ca6b5ab58a09411523b2193fed23fed/tensorflow/core/kernels/conv_grad_shape_utils.cc#L94-L153) assumes that the `input`, `filter_sizes` and `out_backprop` tensors have the same shape, as they are accessed in parallel. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29535: TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedMul` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/87cf4d3ea9949051e50ca3f071fc909538a51cd0/tensorflow/core/kernels/quantized_mul_op.cc#L287-L290) assumes that the 4 arguments are always valid scalars and tries to access the numeric value directly. However, if any of these tensors is empty, then `.flat<T>()` is an empty buffer and accessing the element at position 0 results in overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29536: TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedReshape` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a324ac84e573fba362a5e53d4e74d5de6729933e/tensorflow/core/kernels/quantized_reshape_op.cc#L38-L55) assumes that the 2 arguments are always valid scalars and tries to access the numeric value directly. However, if any of these tensors is empty, then `.flat<T>()` is an empty buffer and accessing the element at position 0 results in overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29537: TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedResizeBilinear` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/50711818d2e61ccce012591eeb4fdf93a8496726/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L705-L706) assumes that the 2 arguments are always valid scalars and tries to access the numeric value directly. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29540: TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow to occur in `Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1b0296c3b8dd9bd948f924aa8cd62f87dbb7c3da/tensorflow/core/kernels/conv_grad_filter_ops.cc#L495-L497) computes the size of the filter tensor but does not validate that it matches the number of elements in `filter_sizes`. Later, when reading/writing to this buffer, code uses the value computed here, instead of the number of elements in the tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29542: TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow by passing crafted inputs to `tf.raw_ops.StringNGrams`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1cdd4da14282210cc759e468d9781741ac7d01bf/tensorflow/core/kernels/string_ngrams_op.cc#L171-L185) fails to consider corner cases where input would be split in such a way that the generated tokens should only contain padding elements. If input is such that `num_tokens` is 0, then, for `data_start_index=0` (when left padding is present), the marked line would result in reading `data[-1]`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29558: TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `tf.raw_ops.SparseSplit`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/699bff5d961f0abfde8fa3f876e6d241681fbef8/tensorflow/core/util/sparse/sparse_tensor.h#L528-L530) accesses an array element based on a user controlled offset. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29560: TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `tf.raw_ops.RaggedTensorToTensor`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/d94227d43aa125ad8b54115c03cece54f6a1977b/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L219-L222) uses the same index to access two arrays in parallel. Since the user controls the shape of the input arguments, an attacker could trigger a heap OOB access when `parent_output_index` is shorter than `row_split`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29576: TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPool3DGradGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/596c05a159b6fbb9e39ca10b3f7753b7244fa1e9/tensorflow/core/kernels/pooling_ops_3d.cc#L694-L696) does not check that the initialization of `Pool3dParameters` completes successfully. Since the constructor(https://github.com/tensorflow/tensorflow/blob/596c05a159b6fbb9e39ca10b3f7753b7244fa1e9/tensorflow/core/kernels/pooling_ops_3d.cc#L48-L88) uses `OP_REQUIRES` to validate conditions, the first assertion that fails interrupts the initialization of `params`, making it contain invalid data. In turn, this might cause a heap buffer overflow, depending on default initialized values. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29577: TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.AvgPool3DGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/d80ffba9702dc19d1fac74fc4b766b3fa1ee976b/tensorflow/core/kernels/pooling_ops_3d.cc#L376-L450) assumes that the `orig_input_shape` and `grad` tensors have similar first and last dimensions but does not check that this assumption is validated. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29578: TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.FractionalAvgPoolGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/dcba796a28364d6d7f003f6fe733d82726dda713/tensorflow/core/kernels/fractional_avg_pool_op.cc#L216) fails to validate that the pooling sequence arguments have enough elements as required by the `out_backprop` tensor shape. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29579: TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/ab1e644b48c82cb71493f4362b4dd38f4577a1cf/tensorflow/core/kernels/maxpooling_op.cc#L194-L203) fails to validate that indices used to access elements of input/output arrays are valid. Whereas accesses to `input_backprop_flat` are guarded by `FastBoundsCheck`, the indexing in `out_backprop_flat` can result in OOB access. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.\n\n- CVE-2021-29998: An issue was discovered in Wind River VxWorks before 6.5. There is a possible heap overflow in dhcp client.\n\n- CVE-2021-30019: In the adts_dmx_process function in filters/reframe_adts.c in GPAC 1.0.1, a crafted file may cause ctx->hdr.frame_size to be smaller than ctx->hdr.hdr_size, resulting in size to be a negative number and a heap overflow in the memcpy.\n\n- CVE-2021-30020: In the function gf_hevc_read_pps_bs_internal function in media_tools/av_parsers.c in GPAC 1.0.1 there is a loop, which with crafted file, pps->num_tile_columns may be larger than sizeof(pps->column_width), which results in a heap overflow in the loop.\n\n- CVE-2021-30186: CODESYS V2 runtime system SP before 2.4.7.55 has a Heap-based Buffer Overflow.\n\n- CVE-2021-30498: A flaw was found in libcaca. A heap buffer overflow in export.c in function export_tga might lead to memory corruption and other potential consequences.\n\n- CVE-2021-30508: Heap buffer overflow in Media Feeds in Google Chrome prior to 90.0.4430.212 allowed an attacker who convinced a user to enable certain features in Chrome to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30516: Heap buffer overflow in History in Google Chrome prior to 90.0.4430.212 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30518: Heap buffer overflow in Reader Mode in Google Chrome prior to 90.0.4430.212 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30521: Heap buffer overflow in Autofill in Google Chrome on Android prior to 91.0.4472.77 allowed a remote attacker to perform out of bounds memory access via a crafted HTML page.\n\n- CVE-2021-30559: Out of bounds write in ANGLE in Google Chrome prior to 91.0.4472.164 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30564: Heap buffer overflow in WebXR in Google Chrome prior to 91.0.4472.164 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30568: Heap buffer overflow in WebGL in Google Chrome prior to 92.0.4515.107 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30575: Out of bounds write in Autofill in Google Chrome prior to 92.0.4515.107 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30590: Heap buffer overflow in Bookmarks in Google Chrome prior to 92.0.4515.131 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-30614: Chromium: CVE-2021-30614 Heap buffer overflow in TabStrip\n\n- CVE-2021-30632: Out of bounds write in V8 in Google Chrome prior to 93.0.4577.82 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-31254: Buffer overflow in the tenc_box_read function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file, related invalid IV sizes.\n\n- CVE-2021-31320: Telegram Android <7.1.0 (2090), Telegram iOS <7.1, and Telegram macOS <7.1 are affected by a Heap Buffer Overflow in the VGradientCache::generateGradientColorTable function of their custom fork of the rlottie library. A remote attacker might be able to overwrite heap memory out-of-bounds on a victim device via a malicious animated sticker.\n\n- CVE-2021-31322: Telegram Android <7.1.0 (2090), Telegram iOS <7.1, and Telegram macOS <7.1 are affected by a Heap Buffer Overflow in the LOTGradient::populate function of their custom fork of the rlottie library. A remote attacker might be able to access heap memory out-of-bounds on a victim device via a malicious animated sticker.\n\n- CVE-2021-31323: Telegram Android <7.1.0 (2090), Telegram iOS <7.1, and Telegram macOS <7.1 are affected by a Heap Buffer Overflow in the LottieParserImpl::parseDashProperty function of their custom fork of the rlottie library. A remote attacker might be able to access heap memory out-of-bounds on a victim device via a malicious animated sticker.\n\n- CVE-2021-31598: An issue was discovered in libezxml.a in ezXML 0.8.6. The function ezxml_decode() performs incorrect memory handling while parsing crafted XML files, leading to a heap-based buffer overflow.\n\n- CVE-2021-32136: Heap buffer overflow in the print_udta function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.\n\n- CVE-2021-32137: Heap buffer overflow in the URL_GetProtocolType function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.\n\n- CVE-2021-32263: ok-file-formats through 2021-04-29 has a heap-based buffer overflow in the ok_csv_circular_buffer_read function in ok_csv.c.\n\n- CVE-2021-3246: A heap buffer overflow vulnerability in msadpcm_decode_block of libsndfile 1.0.30 allows attackers to execute arbitrary code via a crafted WAV file.\n\n- CVE-2021-32484: In modem 2G RRM, there is a possible system crash due to a heap buffer overflow. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: MOLY00500621; Issue ID: ALPS04964917.\n\n- CVE-2021-32485: In modem 2G RRM, there is a possible system crash due to a heap buffer overflow. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: MOLY00500621; Issue ID: ALPS04964926.\n\n- CVE-2021-32486: In modem 2G RRM, there is a possible system crash due to a heap buffer overflow. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: MOLY00500621; Issue ID: ALPS04964928.\n\n- CVE-2021-32487: In modem 2G RRM, there is a possible system crash due to a heap buffer overflow. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: MOLY00500736; Issue ID: ALPS04938456.\n\n- CVE-2021-32493: A flaw was found in djvulibre-3.5.28 and earlier. A heap buffer overflow in function DJVU::GBitmap::decode() via crafted djvu file may lead to application crash and other consequences.\n\n- CVE-2021-33000: Parsing a maliciously crafted project file may cause a heap-based buffer overflow, which may allow an attacker to perform arbitrary code execution. User interaction is required on the WebAccess HMI Designer (versions 2.1.9.95 and prior).\n\n- CVE-2021-33023: Advantech WebAccess versions 9.02 and prior are vulnerable to a heap-based buffer overflow, which may allow an attacker to remotely execute code.\n\n- CVE-2021-33285: In NTFS-3G versions < 2021.8.22, when a specially crafted NTFS attribute is supplied to the function ntfs_get_attribute_value, a heap buffer overflow can occur allowing for memory disclosure or denial of service. The vulnerability is caused by an out-of-bound buffer access which can be triggered by mounting a crafted ntfs partition. The root cause is a missing consistency check after reading an MFT record : the \"bytes_in_use\" field should be less than the \"bytes_allocated\" field. When it is not, the parsing of the records proceeds into the wild.\n\n- CVE-2021-33286: In NTFS-3G versions < 2021.8.22, when a specially crafted unicode string is supplied in an NTFS image a heap buffer overflow can occur and allow for code execution.\n\n- CVE-2021-33287: In NTFS-3G versions < 2021.8.22, when specially crafted NTFS attributes are read in the function ntfs_attr_pread_i, a heap buffer overflow can occur and allow for writing to arbitrary memory or denial of service of the application.\n\n- CVE-2021-33289: In NTFS-3G versions < 2021.8.22, when a specially crafted MFT section is supplied in an NTFS image a heap buffer overflow can occur and allow for code execution.\n\n- CVE-2021-3345: _gcry_md_block_write in cipher/hash-common.c in Libgcrypt version 1.9.0 has a heap-based buffer overflow when the digest final function sets a large count value. It is recommended to upgrade to 1.9.1 or later.\n\n- CVE-2021-33485: CODESYS Control Runtime system before 3.5.17.10 has a Heap-based Buffer Overflow.\n\n- CVE-2021-3404: In ytnef 1.9.3, the SwapWord function in lib/ytnef.c allows remote attackers to cause a denial-of-service (and potentially code execution) due to a heap buffer overflow which can be triggered via a crafted file.\n\n- CVE-2021-3405: A flaw was found in libebml before 1.4.2. A heap overflow bug exists in the implementation of EbmlString::ReadData and EbmlUnicodeString::ReadData in libebml.\n\n- CVE-2021-34067: Heap based buffer overflow in tsMuxer 2.6.16 allows attackers to cause a Denial of Service (DoS) by running the application with a crafted file.\n\n- CVE-2021-34068: Heap based buffer overflow in tsMuxer 2.6.16 allows attackers to cause a Denial of Service (DoS) by running the application with a crafted file.\n\n- CVE-2021-34071: Heap based buffer overflow in tsMuxer 2.6.16 allows attackers to cause a Denial of Service (DoS) by running the application with a crafted file.\n\n- CVE-2021-34373: Trusty trusted Linux kernel (TLK) contains a vulnerability in the NVIDIA TLK kernel where a lack of heap hardening could cause heap overflows, which might lead to information disclosure and denial of service.\n\n- CVE-2021-34380: Bootloader contains a vulnerability in NVIDIA MB2 where potential heap overflow might cause corruption of the heap metadata, which might lead to arbitrary code execution, denial of service, and information disclosure during secure boot.\n\n- CVE-2021-34383: Bootloader contains a vulnerability in NVIDIA MB2 where a potential heap overflow might lead to denial of service or escalation of privileges.\n\n- CVE-2021-34384: Bootloader contains a vulnerability in NVIDIA MB2 where a potential heap overflow could cause memory corruption, which might lead to denial of service or code execution.\n\n- CVE-2021-34388: Bootloader contains a vulnerability in NVIDIA TegraBoot where a potential heap overflow might allow an attacker to control all the RAM after the heap block, leading to denial of service or code execution.\n\n- CVE-2021-3470: A heap overflow issue was found in Redis in versions before 5.0.10, before 6.0.9 and before 6.2.0 when using a heap allocator other than jemalloc or glibc's malloc, leading to potential out of bound write or process crash. Effectively this flaw does not affect the vast majority of users, who use jemalloc or glibc malloc.\n\n- CVE-2021-3491: The io_uring subsystem in the Linux kernel allowed the MAX_RW_COUNT limit to be bypassed in the PROVIDE_BUFFERS operation, which led to negative values being usedin mem_rw when reading /proc/<PID>/mem. This could be used to create a heap overflow leading to arbitrary code execution in the kernel. It was addressed via commit d1f82808877b (\"io_uring: truncate lengths larger than MAX_RW_COUNT on provide buffers\") (v5.13-rc1) and backported to the stable kernels in v5.12.4, v5.11.21, and v5.10.37. It was introduced in ddf0322db79c (\"io_uring: add IORING_OP_PROVIDE_BUFFERS\") (v5.7-rc1).\n\n- CVE-2021-3496: A heap-based buffer overflow was found in jhead in version 3.06 in Get16u() in exif.c when processing a crafted file.\n\n- CVE-2021-3498: GStreamer before 1.18.4 might cause heap corruption when parsing certain malformed Matroska files.\n\n- CVE-2021-3507: A heap buffer overflow was found in the floppy disk emulator of QEMU up to 6.0.0 (including). It could occur in fdctrl_transfer_handler() in hw/block/fdc.c while processing DMA read data transfers from the floppy drive to the guest system. A privileged guest user could use this flaw to crash the QEMU process on the host resulting in DoS scenario, or potential information leakage from the host memory.\n\n- CVE-2021-35266: In NTFS-3G versions < 2021.8.22, when a specially crafted NTFS inode pathname is supplied in an NTFS image a heap buffer overflow can occur resulting in memory disclosure, denial of service and even code execution.\n\n- CVE-2021-35268: In NTFS-3G versions < 2021.8.22, when a specially crafted NTFS inode is loaded in the function ntfs_inode_real_open, a heap buffer overflow can occur allowing for code execution and escalation of privileges.\n\n- CVE-2021-35269: NTFS-3G versions < 2021.8.22, when a specially crafted NTFS attribute from the MFT is setup in the function ntfs_attr_setup_flag, a heap buffer overflow can occur allowing for code execution and escalation of privileges.\n\n- CVE-2021-35344: tsMuxer v2.6.16 was discovered to contain a heap-based buffer overflow via the function BitStreamReader::getCurVal in bitStream.h.\n\n- CVE-2021-35346: tsMuxer v2.6.16 was discovered to contain a heap-based buffer overflow via the function HevcSpsUnit::short_term_ref_pic_set(int) in hevc.cpp.\n\n- CVE-2021-35392: Realtek Jungle SDK version v2.x up to v3.4.14B provides a 'WiFi Simple Config' server that implements both UPnP and SSDP protocols. The binary is usually named wscd or mini_upnpd and is the successor to miniigd. The server is vulnerable to a heap buffer overflow that is present due to unsafe crafting of SSDP NOTIFY messages from received M-SEARCH messages ST header.\n\n- CVE-2021-36065: Adobe Photoshop versions 21.2.10 (and earlier) and 22.4.3 (and earlier) are affected by a heap-based buffer overflow vulnerability that could result in arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-36073: Adobe Bridge version 11.1 (and earlier) is affected by a heap-based buffer overflow vulnerability when parsing a crafted .SGI file. An attacker could leverage this vulnerability to execute code in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-36089: Grok 7.6.6 through 9.2.0 has a heap-based buffer overflow in grk::FileFormatDecompress::apply_palette_clr (called from grk::FileFormatDecompress::applyColour).\n\n- CVE-2021-3625: Buffer overflow in Zephyr USB DFU DNLOAD. Zephyr versions >= v2.5.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-c3gr-hgvr-f363\n\n- CVE-2021-3634: A flaw has been found in libssh in versions prior to 0.9.6. The SSH protocol keeps track of two shared secrets during the lifetime of the session. One of them is called secret_hash and the other session_id. Initially, both of them are the same, but after key re-exchange, previous session_id is kept and used as an input to new secret_hash. Historically, both of these buffers had shared length variable, which worked as long as these buffers were same. But the key re-exchange operation can also change the key exchange method, which can be based on hash of different size, eventually creating \"secret_hash\" of different size than the session_id has. This becomes an issue when the session_id memory is zeroed or when it is used again during second key re-exchange.\n\n- CVE-2021-36530: ngiflib 0.4 has a heap overflow in GetByteStr() at ngiflib.c:108 in NGIFLIB_NO_FILE mode, GetByteStr() copy memory buffer without checking the boundary.\n\n- CVE-2021-36531: ngiflib 0.4 has a heap overflow in GetByte() at ngiflib.c:70 in NGIFLIB_NO_FILE mode, GetByte() reads memory buffer without checking the boundary.\n\n- CVE-2021-36584: An issue was discovered in GPAC 1.0.1. There is a heap-based buffer overflow in the function gp_rtp_builder_do_tx3g function in ietf/rtp_pck_3gpp.c, as demonstrated by MP4Box. This can cause a denial of service (DOS).\n\n- CVE-2021-36977: matio (aka MAT File I/O Library) 1.5.20 and 1.5.21 has a heap-based buffer overflow in H5MM_memcpy (called from H5MM_malloc and H5C_load_entry), related to use of HDF5 1.12.0.\n\n- CVE-2021-36978: QPDF 9.x through 9.1.1 and 10.x through 10.0.4 has a heap-based buffer overflow in Pl_ASCII85Decoder::write (called from Pl_AES_PDF::flush and Pl_AES_PDF::finish) when a certain downstream write fails.\n\n- CVE-2021-37022: There is a Heap-based Buffer Overflow vulnerability in Huawei Smartphone.Successful exploitation of this vulnerability will cause root permission which can be escalated.\n\n- CVE-2021-3756: libmysofa is vulnerable to Heap-based Buffer Overflow\n\n- CVE-2021-37650: TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.ExperimentalDatasetToTFRecord` and `tf.raw_ops.DatasetToTFRecord` can trigger heap buffer overflow and segmentation fault. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/data/experimental/to_tf_record_op.cc#L93-L102) assumes that all records in the dataset are of string type. However, there is no check for that, and the example given above uses numeric types. We have patched the issue in GitHub commit e0b6e58c328059829c3eb968136f17aa72b6c876. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.\n\n- CVE-2021-3770: vim is vulnerable to Heap-based Buffer Overflow\n\n- CVE-2021-37978: Heap buffer overflow in Blink in Google Chrome prior to 94.0.4606.81 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37979: heap buffer overflow in WebRTC in Google Chrome prior to 94.0.4606.81 allowed a remote attacker who convinced a user to browse to a malicious website to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-37981: Heap buffer overflow in Skia in Google Chrome prior to 95.0.4638.54 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2021-37984: Heap buffer overflow in PDFium in Google Chrome prior to 95.0.4638.54 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-38098: Corel PDF Fusion 2.6.2.0 is affected by a Heap Corruption vulnerability when parsing a crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious PDF file.\n\n- CVE-2021-38592: Wasm3 0.5.0 has a heap-based buffer overflow in op_Const64 (called from EvaluateExpression and m3_LoadModule).\n\n- CVE-2021-38614: Polipo through 1.1.1, when NDEBUG is used, allows a heap-based buffer overflow during parsing of a Range header. NOTE: This vulnerability only affects products that are no longer supported by the maintainer\n\n- CVE-2021-39256: A crafted NTFS image can cause a heap-based buffer overflow in ntfs_inode_lookup_by_name in NTFS-3G < 2021.8.22.\n\n- CVE-2021-39261: A crafted NTFS image can cause a heap-based buffer overflow in ntfs_compressed_pwrite in NTFS-3G < 2021.8.22.\n\n- CVE-2021-39518: An issue was discovered in libjpeg through 2020021. LineBuffer::FetchRegion() in linebuffer.cpp has a heap-based buffer overflow.\n\n- CVE-2021-39522: An issue was discovered in libredwg through v0.10.1.3751. bit_wcs2len() in bits.c has a heap-based buffer overflow.\n\n- CVE-2021-39525: An issue was discovered in libredwg through v0.10.1.3751. bit_read_fixed() in bits.c has a heap-based buffer overflow.\n\n- CVE-2021-39527: An issue was discovered in libredwg through v0.10.1.3751. appinfo_private() in decode.c has a heap-based buffer overflow.\n\n- CVE-2021-39530: An issue was discovered in libredwg through v0.10.1.3751. bit_wcs2nlen() in bits.c has a heap-based buffer overflow.\n\n- CVE-2021-39533: An issue was discovered in libslax through v0.22.1. slaxLexer() in slaxlexer.c has a heap-based buffer overflow.\n\n- CVE-2021-39534: An issue was discovered in libslax through v0.22.1. slaxIsCommentStart() in slaxlexer.c has a heap-based buffer overflow.\n\n- CVE-2021-39536: An issue was discovered in libxsmm through v1.16.1-93. The JIT code has a heap-based buffer overflow.\n\n- CVE-2021-39537: An issue was discovered in ncurses through v6.2-1. _nc_captoinfo in captoinfo.c has a heap-based buffer overflow.\n\n- CVE-2021-39544: An issue was discovered in sela through 20200412. file::WavFile::writeToFile() in wav_file.c has a heap-based buffer overflow.\n\n- CVE-2021-39546: An issue was discovered in sela through 20200412. rice::RiceDecoder::process() in rice_decoder.cpp has a heap-based buffer overflow.\n\n- CVE-2021-39550: An issue was discovered in sela through 20200412. file::SelaFile::readFromFile() in sela_file.cpp has a heap-based buffer overflow.\n\n- CVE-2021-39551: An issue was discovered in sela through 20200412. file::SelaFile::readFromFile() in sela_file.c has a heap-based buffer overflow.\n\n- CVE-2021-39552: An issue was discovered in sela through 20200412. file::WavFile::readFromFile() in wav_file.c has a heap-based buffer overflow.\n\n- CVE-2021-3968: vim is vulnerable to Heap-based Buffer Overflow\n\n- CVE-2021-3973: vim is vulnerable to Heap-based Buffer Overflow\n\n- CVE-2020-12895: Pool/Heap Overflow in AMD Graphics Driver for Windows 10 in Escape 0x110037 may lead to escalation of privilege, information disclosure or denial of service.\n\n- CVE-2020-13600: Malformed SPI in response for eswifi can corrupt kernel memory. Zephyr versions >= 1.14.2, >= 2.3.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-hx4p-j86p-2mhr\n\n- CVE-2020-18735: A heap buffer overflow in /src/dds_stream.c of Eclipse IOT Cyclone DDS Project v0.1.0 causes the DDS subscriber server to crash.\n\n- CVE-2020-19721: A heap buffer overflow vulnerability in Ap4TrunAtom.cpp of Bento 1.5.1-628 may lead to an out-of-bounds write while running mp42aac, leading to system crashes and a denial of service (DOS).\n\n- CVE-2020-21547: Libsixel 1.8.2 contains a heap-based buffer overflow in the dither_func_fs function in tosixel.c.\n\n- CVE-2020-21548: Libsixel 1.8.3 contains a heap-based buffer overflow in the sixel_encode_highcolor function in tosixel.c.\n\n- CVE-2020-21594: libde265 v1.0.4 contains a heap buffer overflow in the put_epel_hv_fallback function, which can be exploited via a crafted a file.\n\n- CVE-2020-21595: libde265 v1.0.4 contains a heap buffer overflow in the mc_luma function, which can be exploited via a crafted a file.\n\n- CVE-2020-21597: libde265 v1.0.4 contains a heap buffer overflow in the mc_chroma function, which can be exploited via a crafted a file.\n\n- CVE-2020-21598: libde265 v1.0.4 contains a heap buffer overflow in the ff_hevc_put_unweighted_pred_8_sse function, which can be exploited via a crafted a file.\n\n- CVE-2020-21599: libde265 v1.0.4 contains a heap buffer overflow in the de265_image::available_zscan function, which can be exploited via a crafted a file.\n\n- CVE-2020-21603: libde265 v1.0.4 contains a heap buffer overflow in the put_qpel_0_0_fallback_16 function, which can be exploited via a crafted a file.\n\n- CVE-2020-21604: libde265 v1.0.4 contains a heap buffer overflow fault in the _mm_loadl_epi64 function, which can be exploited via a crafted a file.\n\n- CVE-2020-21813: A heap based buffer overflow issue exists in GNU LibreDWG 0.10.2641 via output_TEXT ../../programs/dwg2SVG.c:114.\n\n- CVE-2020-21836: A heap based buffer overflow vulnerability exists in GNU LibreDWG 0.10 via read_2004_section_preview ../../src/decode.c:3175.\n\n- CVE-2021-44143: A flaw was found in mbsync in isync 1.4.0 through 1.4.3. Due to an unchecked condition, a malicious or compromised IMAP server could use a crafted mail message that lacks headers (i.e., one that starts with an empty line) to provoke a heap overflow, which could conceivably be exploited for remote code execution.\n\n- CVE-2021-42327: dp_link_settings_write in drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c in the Linux kernel through 5.14.14 allows a heap-based buffer overflow by an attacker who can write a string to the AMD GPU display drivers debug filesystem. There are no checks on size within parse_write_buffer_into_params when it uses the size of copy_from_user to copy a userspace buffer into a 40-byte heap buffer.\n\n- CVE-2021-31610: The Bluetooth Classic implementation on AB32VG1 devices does not properly handle the reception of continuous unsolicited LMP responses, allowing attackers in radio range to trigger a denial of service (either restart or deadlock the device) by flooding a device with LMP_AU_rand data.\n\n- CVE-2021-34143: The Bluetooth Classic implementation in the Zhuhai Jieli AC6366C_DEMO_V1.0 does not properly handle the reception of continuous unsolicited LMP responses, allowing attackers in radio range to trigger a denial of service (deadlock) of the device by flooding it with LMP_AU_Rand packets after paging procedure. User intervention is required to restart the device.\n\n- CVE-2021-34149: The Bluetooth Classic implementation on the Texas Instruments CC256XCQFN-EM does not properly handle the reception of continuous LMP_AU_Rand packets, allowing attackers in radio range to trigger a denial of service (deadlock) of the device by flooding it with LMP_AU_Rand packets after the paging procedure.\n\n- CVE-2020-28022: Exim 4 before 4.94.2 has Improper Restriction of Write Operations within the Bounds of a Memory Buffer. This occurs when processing name=value pairs within MAIL FROM and RCPT TO commands.\n\n- CVE-2021-22335: There is a Memory Buffer Improper Operation Limit vulnerability in Huawei Smartphone. Successful exploitation of this vulnerability may cause exceptions in image processing.\n\n- CVE-2021-32020: The kernel in Amazon Web Services FreeRTOS before 10.4.3 has insufficient bounds checking during management of heap memory.\n\n- CVE-2021-34326: A vulnerability has been identified in JT2Go (All versions < V13.2), Solid Edge SE2021 (All Versions < SE2021MP5), Teamcenter Visualization (All versions < V13.2). The plmxmlAdapterSE70.dll library in affected applications lacks proper validation of user-supplied data when parsing PAR files. This could result in an out of bounds write past the fixed-length heap-based buffer. An attacker could leverage this vulnerability to execute code in the context of the current process. (ZDI-CAN-13422)\n\n- CVE-2021-43247: Windows TCP/IP Driver Elevation of Privilege Vulnerability\n\n- CVE-2020-23273: Heap-buffer overflow in the randomize_iparp function in edit_packet.c. of Tcpreplay v4.3.2 allows attackers to cause a denial of service (DOS) via a crafted pcap.\n\n- CVE-2020-23873: pdf2xml v2.0 was discovered to contain a heap-buffer overflow in the function TextPage::dump.\n\n- CVE-2020-23874: pdf2xml v2.0 was discovered to contain a heap-buffer overflow in the function TextPage::addAttributsNode.\n\n- CVE-2021-46790: ntfsck in NTFS-3G through 2021.8.22 has a heap-based buffer overflow involving buffer+512*3-2. NOTE: the upstream position is that ntfsck is deprecated; however, it is shipped by some Linux distributions.\n\n- CVE-2020-15999: Heap buffer overflow in Freetype in Google Chrome prior to 86.0.4240.111 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2020-16010: Heap buffer overflow in UI in Google Chrome on Android prior to 86.0.4240.185 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2020-16013: Inappropriate implementation in V8 in Google Chrome prior to 86.0.4240.198 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2020-9819: A memory consumption issue was addressed with improved memory handling. This issue is fixed in iOS 13.5 and iPadOS 13.5, iOS 12.4.7, watchOS 6.2.5, watchOS 5.3.7. Processing a maliciously crafted mail message may lead to heap corruption.\n\n- CVE-2020-1027: An elevation of privilege vulnerability exists in the way that the Windows Kernel handles objects in memory, aka 'Windows Kernel Elevation of Privilege Vulnerability'. This CVE ID is unique from CVE-2020-0913, CVE-2020-1000, CVE-2020-1003.\n\n- CVE-2021-20043: A Heap-based buffer overflow vulnerability in SonicWall SMA100 getBookmarks method allows a remote authenticated attacker to potentially execute code as the nobody user in the appliance. This vulnerability affected SMA 200, 210, 400, 410 and 500v appliances.\n\n- CVE-2021-21793: An out-of-bounds write vulnerability exists in the JPG sof_nb_comp header processing functionality of Accusoft ImageGear 19.8 and 19.9. A specially crafted malformed file can lead to memory corruption. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21962: A heap-based buffer overflow vulnerability exists in the OTA Update u-download functionality of Sealevel Systems, Inc. SeaConnect 370W v1.3.34. A series of specially-crafted MQTT payloads can lead to remote code execution. An attacker must perform a man-in-the-middle attack in order to trigger this vulnerability.\n\n- CVE-2021-23157: WECON LeviStudioU Versions 2019-09-21 and prior are vulnerable to a heap-based buffer overflow, which may allow an attacker to remotely execute code.\n\n- CVE-2021-23165: A flaw was found in htmldoc before v1.9.12. Heap buffer overflow in pspdf_prepare_outpages(), in ps-pdf.cxx may lead to execute arbitrary code and denial of service.\n\n- CVE-2021-23169: A heap-buffer overflow was found in the copyIntoFrameBuffer function of OpenEXR in versions before 3.0.1. An attacker could use this flaw to execute arbitrary code with the permissions of the user running the application compiled against OpenEXR.\n\n- CVE-2021-26252: A flaw was found in htmldoc in v1.9.12. Heap buffer overflow in pspdf_prepare_page(),in ps-pdf.cxx may lead to execute arbitrary code and denial of service.\n\n- CVE-2021-26259: A flaw was found in htmldoc in v1.9.12. Heap buffer overflow in render_table_row(),in ps-pdf.cxx may lead to arbitrary code execution and denial of service.\n\n- CVE-2021-28237: LibreDWG v0.12.3 was discovered to contain a heap-buffer overflow via decode_preR13.\n\n- CVE-2021-28277: A Heap-based Buffer Overflow vulnerabilty exists in jhead 3.04 and 3.05 is affected by: Buffer Overflow via the RemoveUnknownSections function in jpgfile.c.\n\n- CVE-2021-28278: A Heap-based Buffer Overflow vulnerability exists in jhead 3.04 and 3.05 via the RemoveSectionType function in jpgfile.c.\n\n- CVE-2021-33657: There is a heap overflow problem in video/SDL_pixels.c in SDL (Simple DirectMedia Layer) 2.x to 2.0.18 versions. By crafting a malicious .BMP file, an attacker can cause the application using this library to crash, denial of service or Code execution.\n\n- CVE-2021-33912: libspf2 before 1.2.11 has a four-byte heap-based buffer overflow that might allow remote attackers to execute arbitrary code (via an unauthenticated e-mail message from anywhere on the Internet) with a crafted SPF DNS record, because of incorrect sprintf usage in SPF_record_expand_data in spf_expand.c. The vulnerable code may be part of the supply chain of a site's e-mail infrastructure (e.g., with additional configuration, Exim can use libspf2; the Postfix web site links to unofficial patches for use of libspf2 with Postfix; older versions of spfquery relied on libspf2) but most often is not.\n\n- CVE-2021-33913: libspf2 before 1.2.11 has a heap-based buffer overflow that might allow remote attackers to execute arbitrary code (via an unauthenticated e-mail message from anywhere on the Internet) with a crafted SPF DNS record, because of SPF_record_expand_data in spf_expand.c. The amount of overflowed data depends on the relationship between the length of an entire domain name and the length of its leftmost label. The vulnerable code may be part of the supply chain of a site's e-mail infrastructure (e.g., with additional configuration, Exim can use libspf2; the Postfix web site links to unofficial patches for use of libspf2 with Postfix; older versions of spfquery relied on libspf2) but most often is not.\n\n- CVE-2021-34583: Crafted web server requests may cause a heap-based buffer overflow and could therefore trigger a denial-of- service condition due to a crash in the CODESYS V2 web server prior to V1.1.9.22.\n\n- CVE-2021-3575: A heap-based buffer overflow was found in openjpeg in color.c:379:42 in sycc420_to_rgb when decompressing a crafted .j2k file. An attacker could use this to execute arbitrary code with the permissions of the application compiled against openjpeg.\n\n- CVE-2021-3610: A heap-based buffer overflow vulnerability was found in ImageMagick in versions prior to 7.0.11-14 in ReadTIFFImage() in coders/tiff.c. This issue is due to an incorrect setting of the pixel array size, which can lead to a crash and segmentation fault.\n\n- CVE-2021-36173: A heap-based buffer overflow in the firmware signature verification function of FortiOS versions 7.0.1, 7.0.0, 6.4.0 through 6.4.6, 6.2.0 through 6.2.9, and 6.0.0 through 6.0.13 may allow an attacker to execute arbitrary code via specially crafted installation images.\n\n- CVE-2021-36412: A heap-based buffer overflow vulnerability exists in MP4Box in GPAC 1.0.1 via the gp_rtp_builder_do_mpeg12_video function, which allows attackers to possibly have unspecified other impact via a crafted file in the MP4Box command,\n\n- CVE-2021-36417: A heap-based buffer overflow vulnerability exists in GPAC v1.0.1 in the gf_isom_dovi_config_get function in MP4Box, which causes a denial of service or execute arbitrary code via a crafted file.\n\n- CVE-2021-37049: There is a Heap-based buffer overflow vulnerability in Huawei Smartphone.Successful exploitation of this vulnerability may rewrite the memory of adjacent objects.\n\n- CVE-2021-38013: Heap buffer overflow in fingerprint recognition in Google Chrome on ChromeOS prior to 96.0.4664.45 allowed a remote attacker who had compromised a WebUI renderer process to potentially perform a sandbox escape via a crafted HTML page.\n\n- CVE-2021-3835: Buffer overflow in usb device class. Zephyr versions >= v2.6.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-fm6v-8625-99jf\n\n- CVE-2021-3861: The RNDIS USB device class includes a buffer overflow vulnerability. Zephyr versions >= v2.6.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-hvfp-w4h8-gxvj\n\n- CVE-2021-39665: In checkSpsUpdated of AAVCAssembler.cpp, there is a possible out of bounds read due to a heap buffer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-12Android ID: A-204077881\n\n- CVE-2021-39667: In ih264d_parse_decode_slice of ih264d_parse_slice.c, there is a possible out of bounds write due to a heap buffer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12Android ID: A-205702093\n\n- CVE-2021-39675: In GKI_getbuf of gki_buffer.cc, there is a possible out of bounds write due to a heap buffer overflow. This could lead to remote escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-12Android ID: A-205729183\n\n- CVE-2021-39996: There is a Heap-based buffer overflow vulnerability with the NFC module in smartphones. Successful exploitation of this vulnerability may cause memory overflow.\n\n- CVE-2021-40010: The bone voice ID TA has a heap overflow vulnerability.Successful exploitation of this vulnerability may result in malicious code execution.\n\n- CVE-2021-40014: The bone voice ID trusted application (TA) has a heap overflow vulnerability. Successful exploitation of this vulnerability may affect data confidentiality. \n\n- CVE-2021-40026: There is a Heap-based buffer overflow vulnerability in the AOD module in smartphones. Successful exploitation of this vulnerability may affect service integrity.\n\n- CVE-2021-40058: There is a heap-based buffer overflow vulnerability in the video framework. Successful exploitation of this vulnerability may affect availability.\n\n- CVE-2021-40060: There is a heap-based buffer overflow vulnerability in the video framework. Successful exploitation of this vulnerability may affect availability.\n\n- CVE-2021-40064: There is a heap-based buffer overflow vulnerability in system components. Successful exploitation of this vulnerability may affect system stability.\n\n- CVE-2021-40164: A heap-based buffer overflow could occur while parsing TIFF, PICT, TGA, or RLC files. This vulnerability may be exploited to execute arbitrary code.\n\n- CVE-2021-4055: Heap buffer overflow in extensions in Google Chrome prior to 96.0.4664.93 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted Chrome Extension.\n\n- CVE-2021-4058: Heap buffer overflow in ANGLE in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4062: Heap buffer overflow in BFCache in Google Chrome prior to 96.0.4664.93 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-4079: Out of bounds write in WebRTC in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via crafted WebRTC packets.\n\n- CVE-2021-4101: Heap buffer overflow in Swiftshader in Google Chrome prior to 96.0.4664.110 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-41017: Multiple heap-based buffer overflow vulnerabilities in some web API controllers of FortiWeb 6.4.1, 6.4.0, and 6.3.0 through 6.3.15 may allow a remote authenticated attacker to execute arbitrary code or commands via specifically crafted HTTP requests.\n\n- CVE-2021-41396: Live555 through 1.08 does not handle socket connections properly. A huge number of incoming socket connections in a short time invokes the error-handling module, in which a heap-based buffer overflow happens. An attacker can leverage this to launch a DoS attack.\n\n- CVE-2021-41736: Faust v2.35.0 was discovered to contain a heap-buffer overflow in the function realPropagate() at propagate.cpp.\n\n- CVE-2021-41987: In the SCEP Server of RouterOS in certain Mikrotik products, an attacker can trigger a heap-based buffer overflow that leads to remote code execution. The attacker must know the scep_server_name value. This affects RouterOS 6.46.8, 6.47.9, and 6.47.10.\n\n- CVE-2021-4214: A heap overflow flaw was found in libpngs' pngimage.c program. This flaw allows an attacker with local network access to pass a specially crafted PNG file to the pngimage utility, causing an application to crash, leading to a denial of service.\n\n- CVE-2021-42199: An issue was discovered in swftools through 20201222. A heap buffer overflow exists in the function swf_FontExtract_DefineTextCallback() located in swftext.c. It allows an attacker to cause code execution.\n\n- CVE-2021-42585: A heap buffer overflow was discovered in copy_compressed_bytes in decode_r2007.c in dwgread before 0.12.4 via a crafted dwg file.\n\n- CVE-2021-42586: A heap buffer overflow was discovered in copy_bytes in decode_r2007.c in dwgread before 0.12.4 via a crafted dwg file.\n\n- CVE-2021-42739: The firewire subsystem in the Linux kernel through 5.14.13 has a buffer overflow related to drivers/media/firewire/firedtv-avc.c and drivers/media/firewire/firedtv-ci.c, because avc_ca_pmt mishandles bounds checking.\n\n- CVE-2021-42781: Heap buffer overflow issues were found in Opensc before version 0.22.0 in pkcs15-oberthur.c that could potentially crash programs using the library.\n\n- CVE-2021-43071: A heap-based buffer overflow in Fortinet FortiWeb version 6.4.1 and 6.4.0, version 6.3.15 and below, version 6.2.6 and below allows attacker to execute unauthorized code or commands via crafted HTTP requests to the LogReport API controller.\n\n- CVE-2021-43304: Heap buffer overflow in Clickhouse's LZ4 compression codec when parsing a malicious query. There is no verification that the copy operations in the LZ4::decompressImpl loop and especially the arbitrary copy operation wildCopy<copy_amount>(op, ip, copy_end), don\u2019t exceed the destination buffer\u2019s limits.\n\n- CVE-2021-43305: Heap buffer overflow in Clickhouse's LZ4 compression codec when parsing a malicious query. There is no verification that the copy operations in the LZ4::decompressImpl loop and especially the arbitrary copy operation wildCopy<copy_amount>(op, ip, copy_end), don\u2019t exceed the destination buffer\u2019s limits. This issue is very similar to CVE-2021-43304, but the vulnerable copy operation is in a different wildCopy call.\n\n- CVE-2021-43311: A heap-based buffer overflow was discovered in upx, during the generic pointer 'p' points to an inaccessible address in func get_le32(). The problem is essentially caused in PackLinuxElf32::elf_lookup() at p_lx_elf.cpp:5382.\n\n- CVE-2021-43312: A heap-based buffer overflow was discovered in upx, during the variable 'bucket' points to an inaccessible address. The issue is being triggered in the function PackLinuxElf64::invert_pt_dynamic at p_lx_elf.cpp:5239.\n\n- CVE-2021-43313: A heap-based buffer overflow was discovered in upx, during the variable 'bucket' points to an inaccessible address. The issue is being triggered in the function PackLinuxElf32::invert_pt_dynamic at p_lx_elf.cpp:1688.\n\n- CVE-2021-43314: A heap-based buffer overflows was discovered in upx, during the generic pointer 'p' points to an inaccessible address in func get_le32(). The problem is essentially caused in PackLinuxElf32::elf_lookup() at p_lx_elf.cpp:5368\n\n- CVE-2021-43315: A heap-based buffer overflows was discovered in upx, during the generic pointer 'p' points to an inaccessible address in func get_le32(). The problem is essentially caused in PackLinuxElf32::elf_lookup() at p_lx_elf.cpp:5349\n\n- CVE-2021-43316: A heap-based buffer overflow was discovered in upx, during the generic pointer 'p' points to an inaccessible address in func get_le64().\n\n- CVE-2021-43317: A heap-based buffer overflows was discovered in upx, during the generic pointer 'p' points to an inaccessible address in func get_le32(). The problem is essentially caused in PackLinuxElf64::elf_lookup() at p_lx_elf.cpp:5404\n\n- CVE-2021-43527: NSS (Network Security Services) versions prior to 3.73 or 3.68.1 ESR are vulnerable to a heap overflow when handling DER-encoded DSA or RSA-PSS signatures. Applications using NSS for handling signatures encoded within CMS, S/MIME, PKCS \\\\#7, or PKCS \\\\#12 are likely to be impacted. Applications using NSS for certificate validation or other TLS, X.509, OCSP or CRL functionality may be impacted, depending on how they configure NSS. *Note: This vulnerability does NOT impact Mozilla Firefox.* However, email clients and PDF viewers that use NSS for signature verification, such as Thunderbird, LibreOffice, Evolution and Evince are believed to be impacted. This vulnerability affects NSS < 3.73 and NSS < 3.68.1.\n\n- CVE-2021-43529: Thunderbird versions prior to 91.3.0 are vulnerable to the heap overflow described in CVE-2021-43527 when processing S/MIME messages. Thunderbird versions 91.3.0 and later will not call the vulnerable code when processing S/MIME messages that contain certificates with DER-encoded DSA or RSA-PSS signatures.\n\n- CVE-2021-44648: GNOME gdk-pixbuf 2.42.6 is vulnerable to a heap-buffer overflow vulnerability when decoding the lzw compressed stream of image data in GIF files with lzw minimum code size equals to 12.\n\n- CVE-2021-44708: Acrobat Reader DC version 21.007.20099 (and earlier), 20.004.30017 (and earlier) and 17.011.30204 (and earlier) are affected by a heap overflow vulnerability due to insecure handling of a crafted file, potentially resulting in arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-44709: Acrobat Reader DC version 21.007.20099 (and earlier), 20.004.30017 (and earlier) and 17.011.30204 (and earlier) are affected by a heap overflow vulnerability due to insecure handling of a crafted file, potentially resulting in arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-44956: Two Heap based buffer overflow vulnerabilities exist in ffjpeg through 01.01.2021. It is similar to CVE-2020-23852. Issues that are in the jfif_decode function at ffjpeg/src/jfif.c (line 552) could cause a Denial of Service by using a crafted jpeg file.\n\n- CVE-2021-45005: Artifex MuJS v1.1.3 was discovered to contain a heap buffer overflow which is caused by conflicting JumpList of nested try/finally statements.\n\n- CVE-2021-45078: stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact, as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.\n\n- CVE-2021-45417: AIDE before 0.17.4 allows local users to obtain root privileges via crafted file metadata (such as XFS extended attributes or tmpfs ACLs), because of a heap-based buffer overflow.\n\n- CVE-2021-45830: A heap-based buffer overflow vulnerability exists in HDF5 1.13.1-1 via H5F_addr_decode_len in /hdf5/src/H5Fint.c, which could cause a Denial of Service.\n\n- CVE-2021-45863: tsMuxer git-2678966 was discovered to contain a heap-based buffer overflow via the function HevcUnit::updateBits in hevc.cpp.\n\n- CVE-2021-45909: An issue was discovered in gif2apng 1.9. There is a heap-based buffer overflow vulnerability in the DecodeLZW function. It allows an attacker to write a large amount of arbitrary data outside the boundaries of a buffer.\n\n- CVE-2021-45910: An issue was discovered in gif2apng 1.9. There is a heap-based buffer overflow within the main function. It allows an attacker to write data outside of the allocated buffer. The attacker has control over a part of the address that data is written to, control over the written data, and (to some extent) control over the amount of data that is written.\n\n- CVE-2021-45911: An issue was discovered in gif2apng 1.9. There is a heap-based buffer overflow in the main function. It allows an attacker to write 2 bytes outside the boundaries of the buffer.\n\n- CVE-2021-45932: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow (4 bytes) in MqttDecode_Publish (called from MqttClient_DecodePacket and MqttClient_HandlePacket).\n\n- CVE-2021-45933: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow (8 bytes) in MqttDecode_Publish (called from MqttClient_DecodePacket and MqttClient_HandlePacket).\n\n- CVE-2021-45934: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttClient_DecodePacket (called from MqttClient_HandlePacket and MqttClient_WaitType).\n\n- CVE-2021-45935: Grok 9.5.0 has a heap-based buffer overflow in openhtj2k::T1OpenHTJ2K::decompress (called from std::__1::__packaged_task_func<std::__1::__bind<grk::T1DecompressScheduler::deco and std::__1::packaged_task<int).\n\n- CVE-2021-45936: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttDecode_Disconnect (called from MqttClient_DecodePacket and MqttClient_WaitType).\n\n- CVE-2021-45937: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttClient_DecodePacket (called from MqttClient_WaitType and MqttClient_Connect).\n\n- CVE-2021-45938: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttClient_DecodePacket (called from MqttClient_WaitType and MqttClient_Unsubscribe).\n\n- CVE-2021-45939: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttClient_DecodePacket (called from MqttClient_WaitType and MqttClient_Subscribe).\n\n- CVE-2021-45940: libbpf 0.6.0 and 0.6.1 has a heap-based buffer overflow (4 bytes) in __bpf_object__open (called from bpf_object__open_mem and bpf-object-fuzzer.c).\n\n- CVE-2021-45941: libbpf 0.6.0 and 0.6.1 has a heap-based buffer overflow (8 bytes) in __bpf_object__open (called from bpf_object__open_mem and bpf-object-fuzzer.c).\n\n- CVE-2021-45942: OpenEXR 3.1.x before 3.1.4 has a heap-based buffer overflow in Imf_3_1::LineCompositeTask::execute (called from IlmThread_3_1::NullThreadPoolProvider::addTask and IlmThread_3_1::ThreadPool::addGlobalTask). NOTE: db217f2 may be inapplicable.\n\n- CVE-2021-45943: GDAL 3.3.0 through 3.4.0 has a heap-based buffer overflow in PCIDSK::CPCIDSKFile::ReadFromFile (called from PCIDSK::CPCIDSKSegment::ReadFromFile and PCIDSK::CPCIDSKBinarySegment::CPCIDSKBinarySegment).\n\n- CVE-2021-45948: Open Asset Import Library (aka assimp) 5.1.0 and 5.1.1 has a heap-based buffer overflow in _m3d_safestr (called from m3d_load and Assimp::M3DWrapper::M3DWrapper).\n\n- CVE-2021-45949: Ghostscript GhostPDL 9.50 through 9.54.0 has a heap-based buffer overflow in sampled_data_finish (called from sampled_data_continue and interp).\n\n- CVE-2021-46474: Jsish v3.5.0 was discovered to contain a heap buffer overflow via jsiEvalCodeSub in src/jsiEval.c. This vulnerability can lead to a Denial of Service (DoS).\n\n- CVE-2021-46475: Jsish v3.5.0 was discovered to contain a heap buffer overflow via jsi_ArraySliceCmd in src/jsiArray.c. This vulnerability can lead to a Denial of Service (DoS).\n\n- CVE-2021-46477: Jsish v3.5.0 was discovered to contain a heap buffer overflow via RegExp_constructor in src/jsiRegexp.c. This vulnerability can lead to a Denial of Service (DoS).\n\n- CVE-2021-46478: Jsish v3.5.0 was discovered to contain a heap buffer overflow via jsiClearStack in src/jsiEval.c. This vulnerability can lead to a Denial of Service (DoS).\n\n- CVE-2021-46480: Jsish v3.5.0 was discovered to contain a heap buffer overflow via jsiValueObjDelete in src/jsiEval.c. This vulnerability can lead to a Denial of Service (DoS).\n\n- CVE-2021-46482: Jsish v3.5.0 was discovered to contain a heap buffer overflow via NumberConstructor at src/jsiNumber.c.\n\n- CVE-2021-46483: Jsish v3.5.0 was discovered to contain a heap buffer overflow via BooleanConstructor at src/jsiBool.c.\n\n- CVE-2021-46518: Cesanta MJS v2.20.0 was discovered to contain a heap buffer overflow via mjs_disown at src/mjs_core.c.\n\n- CVE-2021-46519: Cesanta MJS v2.20.0 was discovered to contain a heap buffer overflow via mjs_array_length at src/mjs_array.c.\n\n- CVE-2021-46520: Cesanta MJS v2.20.0 was discovered to contain a heap buffer overflow via mjs_jprintf at src/mjs_util.c.\n\n- CVE-2021-46522: Cesanta MJS v2.20.0 was discovered to contain a heap buffer overflow via /usr/lib/x86_64-linux-gnu/libasan.so.4+0xaff53.\n\n- CVE-2021-46523: Cesanta MJS v2.20.0 was discovered to contain a heap buffer overflow via to_json_or_debug at mjs/src/mjs_json.c.\n\n- CVE-2021-46524: Cesanta MJS v2.20.0 was discovered to contain a heap buffer overflow via snquote at mjs/src/mjs_json.c.\n\n- CVE-2021-46527: Cesanta MJS v2.20.0 was discovered to contain a heap buffer overflow via mjs_get_cstring at src/mjs_string.c.\n\n- CVE-2021-46822: The PPM reader in libjpeg-turbo through 2.0.90 mishandles use of tjLoadImage for loading a 16-bit binary PPM file into a grayscale buffer and loading a 16-bit binary PGM file into an RGB buffer. This is related to a heap-based buffer overflow in the get_word_rgb_row function in rdppm.c.\n\n- CVE-2022-0100: Heap buffer overflow in Media streams API in Google Chrome prior to 97.0.4692.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0101: Heap buffer overflow in Bookmarks in Google Chrome prior to 97.0.4692.71 allowed a remote attacker who convinced a user to perform specific user gesture to potentially exploit heap corruption via specific user gesture.\n\n- CVE-2022-0104: Heap buffer overflow in ANGLE in Google Chrome prior to 97.0.4692.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0137: A heap buffer overflow in image_set_mask function of HTMLDOC before 1.9.15 allows an attacker to write outside the buffer boundaries.\n\n- CVE-2022-0261: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.\n\n- CVE-2022-0306: Heap buffer overflow in PDFium in Google Chrome prior to 97.0.4692.99 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0310: Heap buffer overflow in Task Manager in Google Chrome prior to 97.0.4692.99 allowed a remote attacker to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-0311: Heap buffer overflow in Task Manager in Google Chrome prior to 97.0.4692.99 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0318: Heap-based Buffer Overflow in vim/vim prior to 8.2.\n\n- CVE-2022-0367: A heap-based buffer overflow flaw was found in libmodbus in function modbus_reply() in src/modbus.c.\n\n- CVE-2022-0454: Heap buffer overflow in ANGLE in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0470: Out of bounds memory access in V8 in Google Chrome prior to 98.0.4758.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0518: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.6.2.\n\n- CVE-2022-0572: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.\n\n- CVE-2022-0604: Heap buffer overflow in Tab Groups in Google Chrome prior to 98.0.4758.102 allowed an attacker who convinced a user to install a malicious extension and engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0610: Inappropriate implementation in Gamepad API in Google Chrome prior to 98.0.4758.102 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0676: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.6.4.\n\n- CVE-2022-0713: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.6.4.\n\n- CVE-2022-0789: Heap buffer overflow in ANGLE in Google Chrome prior to 99.0.4844.51 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0800: Heap buffer overflow in Cast UI in Google Chrome prior to 99.0.4844.51 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0809: Out of bounds memory access in WebXR in Google Chrome prior to 99.0.4844.51 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0891: A heap buffer overflow in ExtractImageSection function in tiffcrop.c in libtiff library Version 4.3.0 allows attacker to trigger unsafe or out of bounds memory access via crafted TIFF image file which could result into application crash, potential information disclosure or any other context-dependent impact\n\n- CVE-2022-0976: Heap buffer overflow in GPU in Google Chrome prior to 99.0.4844.74 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1052: Heap Buffer Overflow in iterate_chained_fixups in GitHub repository radareorg/radare2 prior to 5.6.6.\n\n- CVE-2022-1061: Heap Buffer Overflow in parseDragons in GitHub repository radareorg/radare2 prior to 5.6.8.\n\n- CVE-2022-1142: Heap buffer overflow in WebUI in Google Chrome prior to 100.0.4896.60 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via specific input into DevTools.\n\n- CVE-2022-1143: Heap buffer overflow in WebUI in Google Chrome prior to 100.0.4896.60 allowed a remote attacker who convinced a user to engage in specific user interaction to potentially exploit heap corruption via specific input into DevTools.\n\n- CVE-2022-1238: Out-of-bounds Write in libr/bin/format/ne/ne.c in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability is heap overflow and may be exploitable. For more general description of heap buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/122.html).\n\n- CVE-2022-1240: Heap buffer overflow in libr/bin/format/mach0/mach0.c in GitHub repository radareorg/radare2 prior to 5.8.6. If address sanitizer is disabled during the compiling, the program should executes into the `r_str_ncpy` function. Therefore I think it is very likely to be exploitable. For more general description of heap buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/122.html).\n\n- CVE-2022-1270: In GraphicsMagick, a heap buffer overflow was found when parsing MIFF.\n\n- CVE-2022-1354: A heap buffer overflow flaw was found in Libtiffs' tiffinfo.c in TIFFReadRawDataStriped() function. This flaw allows an attacker to pass a crafted TIFF file to the tiffinfo tool, triggering a heap buffer overflow issue and causing a crash that leads to a denial of service.\n\n- CVE-2022-1383: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.6.8. The bug causes the program reads data past the end of the intented buffer. Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash.\n\n- CVE-2022-1437: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.7.0. The bug causes the program reads data past the end of the intented buffer. Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash.\n\n- CVE-2022-1482: Inappropriate implementation in WebGL in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1483: Heap buffer overflow in WebGPU in Google Chrome prior to 101.0.4951.41 allowed a remote attacker who had compromised the renderer process to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1484: Heap buffer overflow in Web UI Settings in Google Chrome prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1489: Out of bounds memory access in UI Shelf in Google Chrome on Chrome OS, Lacros prior to 101.0.4951.41 allowed a remote attacker to potentially exploit heap corruption via specific user interactions.\n\n- CVE-2022-1621: Heap buffer overflow in vim_strncpy find_word in GitHub repository vim/vim prior to 8.2.4919. This vulnerability is capable of crashing software, Bypass Protection Mechanism, Modify Memory, and possible remote execution\n\n- CVE-2022-1638: Heap buffer overflow in V8 Internationalization in Google Chrome prior to 101.0.4951.64 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1876: Heap buffer overflow in DevTools in Google Chrome prior to 102.0.5005.61 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-20106: In MM service, there is a possible out of bounds write due to a heap-based buffer overflow. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: DTV03330460; Issue ID: DTV03330460.\n\n- CVE-2022-20166: In various methods of kernel base drivers, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-182388481References: Upstream kernel\n\n- CVE-2022-20202: In ih264_resi_trans_quant_4x4_sse42 of ih264_resi_trans_quant_sse42.c, there is a possible out of bounds read due to a heap buffer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-12LAndroid ID: A-204704614\n\n- CVE-2022-20209: In hme_add_new_node_to_a_sorted_array of hme_utils.c, there is a possible out of bounds read due to a heap buffer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-12LAndroid ID: A-207502397\n\n- CVE-2022-20247: In Media, there is a possible out of bounds read due to a heap buffer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-229858836\n\n- CVE-2022-20273: In Bluetooth, there is a possible out of bounds read due to a heap buffer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-206478022\n\n- CVE-2022-29210: TensorFlow is an open source platform for machine learning. In version 2.8.0, the `TensorKey` hash function used total estimated `AllocatedBytes()`, which (a) is an estimate per tensor, and (b) is a very poor hash function for constants (e.g. `int32_t`). It also tried to access individual tensor bytes through `tensor.data()` of size `AllocatedBytes()`. This led to ASAN failures because the `AllocatedBytes()` is an estimate of total bytes allocated by a tensor, including any pointed-to constructs (e.g. strings), and does not refer to contiguous bytes in the `.data()` buffer. The discoverers could not use this byte vector anyway because types such as `tstring` include pointers, whereas they needed to hash the string values themselves. This issue is patched in Tensorflow versions 2.9.0 and 2.8.1.\n\n- CVE-2022-2991: A heap-based buffer overflow was found in the Linux kernel's LightNVM subsystem. The issue results from the lack of proper validation of the length of user-supplied data prior to copying it to a fixed-length heap-based buffer. This vulnerability allows a local attacker to escalate privileges and execute arbitrary code in the context of the kernel. The attacker must first obtain the ability to execute high-privileged code on the target system to exploit this vulnerability.\n\n- CVE-2022-29917: Mozilla developers Andrew McCreight, Gabriele Svelto, Tom Ritter and the Mozilla Fuzzing Team reported memory safety bugs present in Firefox 99 and Firefox ESR 91.8. Some of these bugs showed evidence of memory corruption and we presume that with enough effort some of these could have been exploited to run arbitrary code. This vulnerability affects Thunderbird < 91.9, Firefox ESR < 91.9, and Firefox < 100.\n\n- CVE-2022-30292: Heap-based buffer overflow in sqbaselib.cpp in SQUIRREL 3.2 due to lack of a certain sq_reservestack call.\n\n- CVE-2022-30293: In WebKitGTK through 2.36.0 (and WPE WebKit), there is a heap-based buffer overflow in WebCore::TextureMapperLayer::setContentsLayer in WebCore/platform/graphics/texmap/TextureMapperLayer.cpp.\n\n- CVE-2022-3040: Use after free in Layout in Google Chrome prior to 105.0.5195.52 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3043: Heap buffer overflow in Screen Capture in Google Chrome on Chrome OS prior to 105.0.5195.52 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-30474: Tenda AC Series Router AC18_V15.03.05.19(6318) was discovered to contain a heap overflow in the httpd module when handling /goform/saveParentControlInfo request.\n\n- CVE-2022-3437: A heap-based buffer overflow vulnerability was found in Samba within the GSSAPI unwrap_des() and unwrap_des3() routines of Heimdal. The DES and Triple-DES decryption routines in the Heimdal GSSAPI library allow a length-limited write buffer overflow on malloc() allocated memory when presented with a maliciously small packet. This flaw allows a remote user to send specially crafted malicious data to the application, possibly resulting in a denial of service (DoS) attack.\n\n- CVE-2022-34502: Radare2 v5.7.0 was discovered to contain a heap buffer overflow via the function consume_encoded_name_new at format/wasm/wasm.c. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted binary file.\n\n- CVE-2022-34503: QPDF v8.4.2 was discovered to contain a heap buffer overflow via the function QPDF::processXRefStream. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted PDF file.\n\n- CVE-2022-35104: SWFTools commit 772e55a2 was discovered to contain a heap-buffer overflow via DCTStream::reset() at /xpdf/Stream.cc.\n\n- CVE-2022-35105: SWFTools commit 772e55a2 was discovered to contain a heap-buffer overflow via /bin/png2swf+0x552cea.\n\n- CVE-2022-35109: SWFTools commit 772e55a2 was discovered to contain a heap-buffer overflow via draw_stroke at /gfxpoly/stroke.c.\n\n- CVE-2022-35113: SWFTools commit 772e55a2 was discovered to contain a heap-buffer overflow via swf_DefineLosslessBitsTagToImage at /modules/swfbits.c.\n\n- CVE-2022-35447: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b04de.\n\n- CVE-2022-35448: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b55af.\n\n- CVE-2022-35449: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b0466.\n\n- CVE-2022-35450: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b84b1.\n\n- CVE-2022-35451: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b03b5.\n\n- CVE-2022-35452: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b0b2c.\n\n- CVE-2022-35453: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6c08a6.\n\n- CVE-2022-35454: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b05aa.\n\n- CVE-2022-35455: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b0d63.\n\n- CVE-2022-35456: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x617087.\n\n- CVE-2022-35458: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b05ce.\n\n- CVE-2022-35459: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6e412a.\n\n- CVE-2022-35460: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x61731f.\n\n- CVE-2022-35461: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6c0a32.\n\n- CVE-2022-35462: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6c0bc3.\n\n- CVE-2022-35463: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b0478.\n\n- CVE-2022-35464: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6171b2.\n\n- CVE-2022-35465: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6c0414.\n\n- CVE-2022-35466: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6c0473.\n\n- CVE-2022-35467: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6e41b8.\n\n- CVE-2022-35468: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6e420d.\n\n- CVE-2022-35470: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x65fc97.\n\n- CVE-2022-35471: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6e41b0.\n\n- CVE-2022-35474: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6b544e.\n\n- CVE-2022-35475: OTFCC v0.10.4 was discovered to contain a heap-buffer overflow via /release-x64/otfccdump+0x6e41a8.\n\n- CVE-2022-35623: In Nordic nRF5 SDK for Mesh 5.0, a heap overflow vulnerability can be triggered by sending a series of segmented control packets and access packets with the same SeqAuth\n\n- CVE-2022-35624: In Nordic nRF5 SDK for Mesh 5.0, a heap overflow vulnerability can be triggered by sending a series of segmented packets with SegO > SegN\n\n- CVE-2022-3570: Multiple heap buffer overflows in tiffcrop.c utility in libtiff library Version 4.4.0 allows attacker to trigger unsafe or out of bounds memory access via crafted TIFF image file which could result into application crash, potential information disclosure or any other context-dependent impact\n\n- CVE-2022-35711: Adobe ColdFusion versions Update 14 (and earlier) and Update 4 (and earlier) are affected by a Heap-based Buffer Overflow vulnerability that could result in arbitrary code execution in the context of the current user. Exploitation of this issue does not require user interaction, the vulnerability is triggered when a crafted network packet is sent to the server.\n\n- CVE-2022-35712: Adobe ColdFusion versions Update 14 (and earlier) and Update 4 (and earlier) are affected by a Heap-based Buffer Overflow vulnerability that could result in arbitrary code execution in the context of the current user. Exploitation of this issue does not require user interaction, the vulnerability is triggered when a crafted network packet is sent to the server.\n\n- CVE-2022-36150: tifig v0.2.2 was discovered to contain a heap-buffer overflow via __asan_memmove at /asan/asan_interceptors_memintrinsics.cpp.\n\n- CVE-2022-4135: Heap buffer overflow in GPU in Google Chrome prior to 107.0.5304.121 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page. (Chromium security severity: High)\n\n- CVE-2022-4141: Heap based buffer overflow in vim/vim 9.0.0946 and below by allowing an attacker to CTRL-W gf in the expression used in the RHS of the substitute command.\n\n- CVE-2022-41428: Bento4 v1.6.0-639 was discovered to contain a heap overflow via the AP4_BitReader::ReadBits function in mp4mux.\n\n- CVE-2022-41429: Bento4 v1.6.0-639 was discovered to contain a heap overflow via the AP4_Atom::TypeFromString function in mp4tag.\n\n- CVE-2022-41430: Bento4 v1.6.0-639 was discovered to contain a heap overflow via the AP4_BitReader::ReadBit function in mp4mux.\n\n- CVE-2022-41595: The phones have the heap overflow, out-of-bounds read, and null pointer vulnerabilities in the fingerprint trusted application (TA).Successful exploitation of this vulnerability may affect the fingerprint service.\n\n- CVE-2022-42499: In sms_SendMmCpErrMsg of sms_MmConManagement.c, there is a possible out of bounds write due to a heap buffer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-242001391References: N/A\n\n- CVE-2022-4291: The aswjsflt.dll library from Avast Antivirus windows contained a potentially exploitable heap corruption vulnerability that could enable an attacker to bypass the sandbox of the application it was loaded into, if applicable. This issue was fixed in version 18.0.1478 of the Script Shield Component. \n\n- CVE-2021-21958: A heap-based buffer overflow vulnerability exists in the Hword HwordApp.dll functionality of Hancom Office 2020 11.0.0.2353. A specially-crafted malformed file can lead to memory corruption and potential arbitrary code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2022-37434: zlib through 1.2.12 has a heap-based buffer over-read or buffer overflow in inflate in inflate.c via a large gzip header extra field. NOTE: only applications that call inflateGetHeader are affected. Some common applications bundle the affected zlib source code but may be unable to call inflateGetHeader (e.g., see the nodejs/node reference).\n\n- CVE-2022-46393: An issue was discovered in Mbed TLS before 2.28.2 and 3.x before 3.3.0. There is a potential heap-based buffer overflow and heap-based buffer over-read in DTLS if MBEDTLS_SSL_DTLS_CONNECTION_ID is enabled and MBEDTLS_SSL_CID_IN_LEN_MAX > 2 * MBEDTLS_SSL_CID_OUT_LEN_MAX.\n\n- CVE-2022-22612: A memory consumption issue was addressed with improved memory handling. This issue is fixed in tvOS 15.4, iOS 15.4 and iPadOS 15.4, iTunes 12.12.3 for Windows, watchOS 8.5, macOS Monterey 12.3. Processing a maliciously crafted image may lead to heap corruption.\n\n- CVE-2022-23318: A heap-buffer-overflow in pcf2bdf, versions >= 1.05 allows an attacker to trigger unsafe memory access via a specially crafted PCF font file. This out-of-bound read may lead to an application crash, information disclosure via program memory or other context-dependent impact.\n\n- CVE-2022-35557: A stack overflow vulnerability exists in /goform/wifiSSIDget in Tenda W6 V1.0.0.9(4122) version, which can be exploited by attackers to cause a denial of service (DoS) via the index parameter.\n\n- CVE-2022-4498: In TP-Link routers, Archer C5 and WR710N-V1, running the latest available code, when receiving HTTP Basic Authentication the httpd service can be sent a crafted packet that causes a heap overflow. This can result in either a DoS (by crashing the httpd process) or an arbitrary code execution.\n\n- CVE-2022-42475: A heap-based buffer overflow vulnerability [CWE-122] in FortiOS SSL-VPN 7.2.0 through 7.2.2, 7.0.0 through 7.0.8, 6.4.0 through 6.4.10, 6.2.0 through 6.2.11, 6.0.15 and earlier and FortiProxy SSL-VPN 7.2.0 through 7.2.1, 7.0.7 and earlier may allow a remote unauthenticated attacker to execute arbitrary code or commands via specifically crafted requests.\n\n- CVE-2022-2294: Heap buffer overflow in WebRTC in Google Chrome prior to 103.0.5060.114 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-26318: On WatchGuard Firebox and XTM appliances, an unauthenticated user can execute arbitrary code, aka FBX-22786. This vulnerability impacts Fireware OS before 12.7.2_U2, 12.x before 12.1.3_U8, and 12.2.x through 12.5.x before 12.5.9_U2.\n\n- CVE-2022-2598: Out-of-bounds Write to API in GitHub repository vim/vim prior to 9.0.0100. \n\n- CVE-2022-25363: WatchGuard Firebox and XTM appliances allow an authenticated remote attacker with unprivileged credentials to modify privileged management user credentials. This vulnerability impacts Fireware OS before 12.7.2_U2, 12.x before 12.1.3_U8, and 12.2.x through 12.5.x before 12.5.9_U2.\n\n- CVE-2022-3974: A vulnerability classified as critical was found in Axiomatic Bento4. Affected by this vulnerability is the function AP4_StdcFileByteStream::ReadPartial of the file Ap4StdCFileByteStream.cpp of the component mp4info. The manipulation leads to heap-based buffer overflow. The attack can be launched remotely. The exploit has been disclosed to the public and may be used. The identifier VDB-213553 was assigned to this vulnerability.\n\n- CVE-2021-40647: In man2html 1.6g, a specific string being read in from a file will overwrite the size parameter in the top chunk of the heap. This at least causes the program to segmentation abort if the heap size parameter isn't aligned correctly. In version before GLIBC version 2.29 and aligned correctly, it allows arbitrary write anywhere in the programs memory.\n\n- CVE-2021-3567: A flaw was found in Caribou due to a regression of CVE-2020-25712 fix. An attacker could use this flaw to bypass screen-locking applications that leverage Caribou as an input mechanism. The highest threat from this vulnerability is to system availability.\n\nRelated Weaknesses:\n\n- CWE-788 (ChildOf)\n\n- CWE-787 (ChildOf)",
        "type": "Variant",
        "source": "sparse",
        "search_source": "weakness:memory corruption",
        "sources": [
          "base",
          "weakness"
        ],
        "boost_factor": 2.8,
        "boosted": true,
        "metadata": {
          "source": "sparse",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          }
        }
      },
      {
        "cwe_id": "415",
        "name": "Double Free",
        "description": "The product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.",
        "score": 53.504177185489525,
        "matched_text": "CWE-415: Double Free\n\nType: Variant\n\nStatus: Draft\n\nAlternative Terms:\n\nDouble-free\n\nDouble-free\n\nDouble-free\n\nDescription:\n\nThe product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.\n\nExtended Details:\n\nWhen a program calls free() twice with the same argument, the program's memory management data structures become corrupted. This corruption can cause the program to crash or, in some circumstances, cause two later calls to malloc() to return the same pointer. If malloc() returns the same value twice and the program later gives the attacker control over the data that is written into this doubly-allocated memory, the program becomes vulnerable to a buffer overflow attack.\n\nReal-World Examples:\n\n- CVE-2006-5051: Chain: Signal handler contains too much functionality (CWE-828), introducing a race condition (CWE-362) that leads to a double free (CWE-415).\n\n- CVE-2004-0642: Double free resultant from certain error conditions.\n\n- CVE-2004-0772: Double free resultant from certain error conditions.\n\n- CVE-2005-1689: Double free resultant from certain error conditions.\n\n- CVE-2003-0545: Double free from invalid ASN.1 encoding.\n\n- CVE-2003-1048: Double free from malformed GIF.\n\n- CVE-2005-0891: Double free from malformed GIF.\n\n- CVE-2002-0059: Double free from malformed compressed data.\n\nTop 25 CWE Examples:\n\n- CVE-2020-11231: Two threads call one or both functions concurrently leading to corruption of pointers and reference counters which in turn can lead to heap corruption in Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile\n\n- CVE-2020-14354: A possible use-after-free and double-free in c-ares lib version 1.16.0 if ares_destroy() is called prior to ares_getaddrinfo() completing. This flaw possibly allows an attacker to crash the service that uses c-ares lib. The highest threat from this vulnerability is to this service availability.\n\n- CVE-2021-0392: In main of main.cpp, there is a possible memory corruption due to a double free. This could lead to local escalation of privilege with User execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-9Android ID: A-175124730\n\n- CVE-2021-0498: In memory management driver, there is a possible memory corruption due to a double free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-183461321\n\n- CVE-2021-0528: In memory management driver, there is a possible memory corruption due to a double free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-185195266\n\n- CVE-2021-1119: NVIDIA vGPU software contains a vulnerability in the Virtual GPU Manager (vGPU plugin), where it can double-free a pointer, which may lead to denial of service. This flaw may result in a write-what-where condition, allowing an attacker to execute arbitrary code impacting integrity and availability.\n\n- CVE-2021-1875: A double free issue was addressed with improved memory management. This issue is fixed in Security Update 2021-002 Catalina, Security Update 2021-003 Mojave, iOS 14.5 and iPadOS 14.5, watchOS 7.4, tvOS 14.5, macOS Big Sur 11.3. Processing a maliciously crafted file may lead to heap corruption.\n\n- CVE-2021-1888: Memory corruption in key parsing and import function due to double freeing the same heap allocation in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2021-1934: Possible memory corruption due to improper check when application loader object is explicitly destructed while application is unloading in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT\n\n- CVE-2021-30535: Double free in ICU in Google Chrome prior to 91.0.4472.77 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-32613: In radare2 through 5.3.0 there is a double free vulnerability in the pyc parse via a crafted file which can lead to DoS.\n\n- CVE-2021-3403: In ytnef 1.9.3, the TNEFSubjectHandler function in lib/ytnef.c allows remote attackers to cause a denial-of-service (and potentially code execution) due to a double free which can be triggered via a crafted file.\n\n- CVE-2021-3407: A flaw was found in mupdf 1.18.0. Double free of object during linearization may lead to memory corruption and other potential consequences.\n\n- CVE-2021-3564: A flaw double-free memory corruption in the Linux kernel HCI device initialization subsystem was found in the way user attach malicious HCI TTY Bluetooth device. A local user could use this flaw to crash the system. This flaw affects all the Linux kernel versions starting from 3.13.\n\n- CVE-2021-37652: TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.BoostedTreesCreateEnsemble` can result in a use after free error if an attacker supplies specially crafted arguments. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/boosted_trees/resource_ops.cc#L55) uses a reference counted resource and decrements the refcount if the initialization fails, as it should. However, when the code was written, the resource was represented as a naked pointer but later refactoring has changed it to be a smart pointer. Thus, when the pointer leaves the scope, a subsequent `free`-ing of the resource occurs, but this fails to take into account that the refcount has already reached 0, thus the resource has been already freed. During this double-free process, members of the resource object are accessed for cleanup but they are invalid as the entire resource has been freed. We have patched the issue in GitHub commit 5ecec9c6fbdbc6be03295685190a45e7eee726ab. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.\n\n- CVE-2020-14123: There is a pointer double free vulnerability in Some MIUI Services. When a function is called, the memory pointer is copied to two function modules, and an attacker can cause the pointer to be repeatedly released through malicious operations, resulting in the affected module crashing and affecting normal functionality, and if successfully exploited the vulnerability can cause elevation of privileges.\n\n- CVE-2021-42778: A heap double free issue was found in Opensc before version 0.22.0 in sc_pkcs15_free_tokeninfo.\n\n- CVE-2021-42613: A double free in cleanup_index in index.c in Halibut 1.2 allows an attacker to cause a denial of service or possibly have other unspecified impact via a crafted text document.\n\n- CVE-2021-22600: A double free bug in packet_set_ring() in net/packet/af_packet.c can be exploited by a local user through crafted syscalls to escalate privileges or deny service. We recommend upgrading kernel past the effected versions or rebuilding past ec6af094ea28f0f2dda1a6a33b14cd57e36a9755\n\n- CVE-2020-9859: A memory consumption issue was addressed with improved memory handling. This issue is fixed in iOS 13.5.1 and iPadOS 13.5.1, macOS Catalina 10.15.5 Supplemental Update, tvOS 13.4.6, watchOS 6.2.6. An application may be able to execute arbitrary code with kernel privileges.\n\n- CVE-2021-23158: A flaw was found in htmldoc in v1.9.12. Double-free in function pspdf_export(),in ps-pdf.cxx may result in a write-what-where condition, allowing an attacker to execute arbitrary code and denial of service.\n\n- CVE-2022-2008: Double free in WebGL in Google Chrome prior to 102.0.5005.115 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-40304: An issue was discovered in libxml2 before 2.10.3. Certain invalid XML entity definitions can corrupt a hash table key, potentially leading to subsequent logic errors. In one case, a double-free can be provoked.\n\nRelated Weaknesses:\n\n- CWE-825 (ChildOf)\n\n- CWE-1341 (ChildOf)\n\n- CWE-672 (ChildOf)\n\n- CWE-672 (ChildOf)\n\n- CWE-672 (ChildOf)\n\n- CWE-666 (ChildOf)\n\n- CWE-416 (PeerOf)\n\n- CWE-123 (PeerOf)",
        "type": "Variant",
        "source": "sparse",
        "search_source": "weakness:memory corruption",
        "sources": [
          "base",
          "weakness"
        ],
        "boost_factor": 2.8,
        "boosted": true,
        "metadata": {
          "source": "sparse",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          }
        }
      },
      {
        "cwe_id": "190",
        "name": "Integer Overflow or Wraparound",
        "description": "The product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.",
        "score": 51.530627528621274,
        "matched_text": "CWE-190: Integer Overflow or Wraparound\n\nType: Base\n\nStatus: Stable\n\nAlternative Terms:\n\nOverflow - The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nWraparound - The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nwrap, wrap-around, wrap around - Alternate spellings of \"wraparound\"\n\nOverflow - The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nWraparound - The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nwrap, wrap-around, wrap around - Alternate spellings of \"wraparound\"\n\nOverflow - The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nWraparound - The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nwrap, wrap-around, wrap around - Alternate spellings of \"wraparound\"\n\nDescription:\n\nThe product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.\n\nReal-World Examples:\n\n- CVE-2021-43537: Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n\n- CVE-2022-21668: Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n\n- CVE-2022-0545: Chain: 3D renderer has an integer overflow (CWE-190) leading to write-what-where condition (CWE-123) using a crafted image.\n\n- CVE-2021-30860: Chain: improper input validation (CWE-20) leads to integer overflow (CWE-190) in mobile OS, as exploited in the wild per CISA KEV.\n\n- CVE-2021-30663: Chain: improper input validation (CWE-20) leads to integer overflow (CWE-190) in mobile OS, as exploited in the wild per CISA KEV.\n\n- CVE-2018-10887: Chain: unexpected sign extension (CWE-194) leads to integer overflow (CWE-190), causing an out-of-bounds read (CWE-125)\n\n- CVE-2019-1010006: Chain: compiler optimization (CWE-733) removes or modifies code used to detect integer overflow (CWE-190), allowing out-of-bounds write (CWE-787).\n\n- CVE-2010-1866: Chain: integer overflow (CWE-190) causes a negative signed value, which later bypasses a maximum-only check (CWE-839), leading to heap-based buffer overflow (CWE-122).\n\n- CVE-2010-2753: Chain: integer overflow leads to use-after-free\n\n- CVE-2005-1513: Chain: integer overflow in securely-coded mail program leads to buffer overflow. In 2005, this was regarded as unrealistic to exploit, but in 2020, it was rediscovered to be easier to exploit due to evolutions of the technology.\n\n- CVE-2002-0391: Integer overflow via a large number of arguments.\n\n- CVE-2002-0639: Integer overflow in OpenSSH as listed in the demonstrative examples.\n\n- CVE-2005-1141: Image with large width and height leads to integer overflow.\n\n- CVE-2005-0102: Length value of -1 leads to allocation of 0 bytes and resultant heap overflow.\n\n- CVE-2004-2013: Length value of -1 leads to allocation of 0 bytes and resultant heap overflow.\n\n- CVE-2017-1000121: chain: unchecked message size metadata allows integer overflow (CWE-190) leading to buffer overflow (CWE-119).\n\n- CVE-2013-1591: Chain: an integer overflow (CWE-190) in the image size calculation causes an infinite loop (CWE-835) which sequentially allocates buffers without limits (CWE-1325) until the stack is full.\n\nTop 25 CWE Examples:\n\n- CVE-2020-11279: Memory corruption while processing crafted SDES packets due to improper length check in sdes packets recieved in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2020-28020: Exim 4 before 4.92 allows Integer Overflow to Buffer Overflow, in which an unauthenticated remote attacker can execute arbitrary code by leveraging the mishandling of continuation lines during header-length restriction.\n\n- CVE-2020-35198: An issue was discovered in Wind River VxWorks 7. The memory allocator has a possible integer overflow in calculating a memory block's size to be allocated by calloc(). As a result, the actual memory allocated is smaller than the buffer size specified by the arguments, leading to memory corruption.\n\n- CVE-2021-0355: In kisd, there is a possible out of bounds write due to an integer overflow. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Product: Android; Versions: Android-11; Patch ID: ALPS05425581.\n\n- CVE-2021-0436: In CryptoPlugin::decrypt of CryptoPlugin.cpp, there is a possible out of bounds read due to integer overflow. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-8.1 Android-9 Android-10 Android-11Android ID: A-176496160\n\n- CVE-2021-0458: In the FingerTipS touch screen driver, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-157156744\n\n- CVE-2021-0460: In the FingerTipS touch screen driver, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-156739245\n\n- CVE-2021-0494: In memory management driver, there is a possible out of bounds write due to an integer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-183461318\n\n- CVE-2021-0610: In memory management driver, there is a possible memory corruption due to an integer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05403499; Issue ID: ALPS05411456.\n\n- CVE-2021-0621: In asf extractor, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05489178; Issue ID: ALPS05561383.\n\n- CVE-2021-0623: In asf extractor, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05489178; Issue ID: ALPS05585817.\n\n- CVE-2021-0627: In OMA DRM, there is a possible memory corruption due to an integer overflow. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05722434; Issue ID: ALPS05722434.\n\n- CVE-2021-21309: Redis is an open-source, in-memory database that persists on disk. In affected versions of Redis an integer overflow bug in 32-bit Redis version 4.0 or newer could be exploited to corrupt the heap and potentially result with remote code execution. Redis 4.0 or newer uses a configurable limit for the maximum supported bulk input size. By default, it is 512MB which is a safe value for all platforms. If the limit is significantly increased, receiving a large request from a client may trigger several integer overflow scenarios, which would result with buffer overflow and heap corruption. We believe this could in certain conditions be exploited for remote code execution. By default, authenticated Redis users have access to all configuration parameters and can therefore use the \u201cCONFIG SET proto-max-bulk-len\u201d to change the safe default, making the system vulnerable. **This problem only affects 32-bit Redis (on a 32-bit system, or as a 32-bit executable running on a 64-bit system).** The problem is fixed in version 6.2, and the fix is back ported to 6.0.11 and 5.0.11. Make sure you use one of these versions if you are running 32-bit Redis. An additional workaround to mitigate the problem without patching the redis-server executable is to prevent clients from directly executing `CONFIG SET`: Using Redis 6.0 or newer, ACL configuration can be used to block the command. Using older versions, the `rename-command` configuration directive can be used to rename the command to a random string unknown to users, rendering it inaccessible. Please note that this workaround may have an additional impact on users or operational systems that expect `CONFIG SET` to behave in certain ways.\n\n- CVE-2021-21807: An integer overflow vulnerability exists in the DICOM parse_dicom_meta_info functionality of Accusoft ImageGear 19.9. A specially crafted malformed file can lead to a stack-based buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21834: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input when decoding the atom for the \u201cco64\u201d FOURCC can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21835: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input when decoding the atom associated with the \u201ccsgp\u201d FOURCC can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21836: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input using the \u201cctts\u201d FOURCC code can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21837: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21838: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21839: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21840: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input used to process an atom using the \u201csaio\u201d FOURCC code cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21841: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input when reading an atom using the 'sbgp' FOURCC code can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21842: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow when processing an atom using the 'ssix' FOURCC code, due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21843: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. After validating the number of ranges, at [41] the library will multiply the count by the size of the GF_SubsegmentRangeInfo structure. On a 32-bit platform, this multiplication can result in an integer overflow causing the space of the array being allocated to be less than expected. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21844: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input when encountering an atom using the \u201cstco\u201d FOURCC code, can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21845: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input in \u201cstsc\u201d decoder can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21846: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input in \u201cstsz\u201d decoder can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21847: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input in \u201cstts\u201d decoder can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21848: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. The library will actually reuse the parser for atoms with the \u201cstsz\u201d FOURCC code when parsing atoms that use the \u201cstz2\u201d FOURCC code and can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21849: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow when the library encounters an atom using the \u201ctfra\u201d FOURCC code due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21850: An exploitable integer overflow vulnerability exists within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow when the library encounters an atom using the \u201ctrun\u201d FOURCC code due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21851: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input at \u201ccsgp\u201d decoder sample group description indices can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21852: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input at \u201cstss\u201d decoder can cause an integer overflow due to unchecked arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21853: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked addition arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21854: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked addition arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21855: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked addition arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21856: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked addition arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21857: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked addition arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-21858: Multiple exploitable integer overflow vulnerabilities exist within the MPEG-4 decoding functionality of the GPAC Project on Advanced Content library v1.0.1. A specially crafted MPEG-4 input can cause an integer overflow due to unchecked addition arithmetic resulting in a heap-based buffer overflow that causes memory corruption. An attacker can convince a user to open a video to trigger this vulnerability.\n\n- CVE-2021-22412: There is an Integer Overflow Vulnerability in Huawei Smartphone.Successful exploitation of this vulnerability may cause random kernel address access.\n\n- CVE-2021-22413: There is an Integer Overflow Vulnerability in Huawei Smartphone.Successful exploitation of this vulnerability may cause the system to reset.\n\n- CVE-2021-23215: An integer overflow leading to a heap-buffer overflow was found in the DwaCompressor of OpenEXR in versions before 3.0.1. An attacker could use this flaw to crash an application compiled with OpenEXR.\n\n- CVE-2021-24025: Due to incorrect string size calculations inside the preg_quote function, a large input string passed to the function can trigger an integer overflow leading to a heap overflow. This issue affects HHVM versions prior to 4.56.3, all versions between 4.57.0 and 4.80.1, all versions between 4.81.0 and 4.93.1, and versions 4.94.0, 4.95.0, 4.96.0, 4.97.0, 4.98.0.\n\n- CVE-2021-24036: Passing an attacker controlled size when creating an IOBuf could cause integer overflow, leading to an out of bounds write on the heap with the possibility of remote code execution. This issue affects versions of folly prior to v2021.07.22.00. This issue affects HHVM versions prior to 4.80.5, all versions between 4.81.0 and 4.102.1, all versions between 4.103.0 and 4.113.0, and versions 4.114.0, 4.115.0, 4.116.0, 4.117.0, 4.118.0 and 4.118.1.\n\n- CVE-2021-25803: A buffer overflow vulnerability in the vlc_input_attachment_New component of VideoLAN VLC Media Player 3.0.11 allows attackers to cause an out-of-bounds read via a crafted .avi file.\n\n- CVE-2021-26260: An integer overflow leading to a heap-buffer overflow was found in the DwaCompressor of OpenEXR in versions before 3.0.1. An attacker could use this flaw to crash an application compiled with OpenEXR. This is a different flaw from CVE-2021-23215.\n\n- CVE-2021-26461: Apache Nuttx Versions prior to 10.1.0 are vulnerable to integer wrap-around in functions malloc, realloc and memalign. This improper memory assignment can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-26825: An integer overflow issue exists in Godot Engine up to v3.2 that can be triggered when loading specially crafted.TGA image files. The vulnerability exists in ImageLoaderTGA::load_image() function at line: const size_t buffer_size = (tga_header.image_width * tga_header.image_height) * pixel_size; The bug leads to Dynamic stack buffer overflow. Depending on the context of the application, attack vector can be local or remote, and can lead to code execution and/or system crash.\n\n- CVE-2021-26945: An integer overflow leading to a heap-buffer overflow was found in OpenEXR in versions before 3.0.1. An attacker could use this flaw to crash an application compiled with OpenEXR.\n\n- CVE-2021-30354: Amazon Kindle e-reader prior to and including version 5.13.4 contains an Integer Overflow that leads to a Heap-Based Buffer Overflow in function CJBig2Image::expand() and results in a memory corruption that leads to code execution when parsing a crafted PDF book.\n\n- CVE-2021-31292: An integer overflow in CrwMap::encode0x1810 of Exiv2 0.27.3 allows attackers to trigger a heap-based buffer overflow and cause a denial of service (DOS) via crafted metadata.\n\n- CVE-2021-31870: An issue was discovered in klibc before 2.0.9. Multiplication in the calloc() function may result in an integer overflow and a subsequent heap buffer overflow.\n\n- CVE-2021-31871: An issue was discovered in klibc before 2.0.9. An integer overflow in the cpio command may result in a NULL pointer dereference on 64-bit systems.\n\n- CVE-2021-31873: An issue was discovered in klibc before 2.0.9. Additions in the malloc() function may result in an integer overflow and a subsequent heap buffer overflow.\n\n- CVE-2021-32625: Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker. An integer overflow bug in Redis version 6.0 or newer, could be exploited using the STRALGO LCS command to corrupt the heap and potentially result with remote code execution. This is a result of an incomplete fix by CVE-2021-29477. The problem is fixed in version 6.2.4 and 6.0.14. An additional workaround to mitigate the problem without patching the redis-server executable is to use ACL configuration to prevent clients from using the STRALGO LCS command. On 64 bit systems which have the fixes of CVE-2021-29477 (6.2.3 or 6.0.13), it is sufficient to make sure that the proto-max-bulk-len config parameter is smaller than 2GB (default is 512MB).\n\n- CVE-2021-32628: Redis is an open source, in-memory database that persists on disk. An integer overflow bug in the ziplist data structure used by all versions of Redis can be exploited to corrupt the heap and potentially result with remote code execution. The vulnerability involves modifying the default ziplist configuration parameters (hash-max-ziplist-entries, hash-max-ziplist-value, zset-max-ziplist-entries or zset-max-ziplist-value) to a very large value, and then constructing specially crafted commands to create very large ziplists. The problem is fixed in Redis versions 6.2.6, 6.0.16, 5.0.14. An additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from modifying the above configuration parameters. This can be done using ACL to restrict unprivileged users from using the CONFIG SET command.\n\n- CVE-2021-34385: Trusty TLK contains a vulnerability in the NVIDIA TLK kernel where an integer overflow in the calculation of a length could lead to a heap overflow.\n\n- CVE-2021-34386: Trusty TLK contains a vulnerability in the NVIDIA TLK kernel where an integer overflow in the calloc size calculation can cause the multiplication of count and size can overflow, which might lead to heap overflows.\n\n- CVE-2021-39254: A crafted NTFS image can cause an integer overflow in memmove, leading to a heap-based buffer overflow in the function ntfs_attr_record_resize, in NTFS-3G < 2021.8.22.\n\n- CVE-2021-40346: An integer overflow exists in HAProxy 2.0 through 2.5 in htx_add_header that can be exploited to perform an HTTP request smuggling attack, allowing an attacker to bypass all configured http-request HAProxy ACLs and possibly other ACLs.\n\n- CVE-2021-41864: prealloc_elems_and_freelist in kernel/bpf/stackmap.c in the Linux kernel before 5.14.12 allows unprivileged users to trigger an eBPF multiplication integer overflow with a resultant out-of-bounds write.\n\n- CVE-2021-41991: The in-memory certificate cache in strongSwan before 5.9.4 has a remote integer overflow upon receiving many requests with different certificates to fill the cache and later trigger the replacement of cache entries. The code attempts to select a less-often-used cache entry by means of a random number generator, but this is not done correctly. Remote code execution might be a slight possibility.\n\n- CVE-2021-43784: runc is a CLI tool for spawning and running containers on Linux according to the OCI specification. In runc, netlink is used internally as a serialization system for specifying the relevant container configuration to the `C` portion of the code (responsible for the based namespace setup of containers). In all versions of runc prior to 1.0.3, the encoder did not handle the possibility of an integer overflow in the 16-bit length field for the byte array attribute type, meaning that a large enough malicious byte array attribute could result in the length overflowing and the attribute contents being parsed as netlink messages for container configuration. This vulnerability requires the attacker to have some control over the configuration of the container and would allow the attacker to bypass the namespace restrictions of the container by simply adding their own netlink payload which disables all namespaces. The main users impacted are those who allow untrusted images with untrusted configurations to run on their machines (such as with shared cloud infrastructure). runc version 1.0.3 contains a fix for this bug. As a workaround, one may try disallowing untrusted namespace paths from your container. It should be noted that untrusted namespace paths would allow the attacker to disable namespace protections entirely even in the absence of this bug.\n\n- CVE-2021-36155: LengthPrefixedMessageReader in gRPC Swift 1.1.0 and earlier allocates buffers of arbitrary length, which allows remote attackers to cause uncontrolled resource consumption and deny service.\n\n- CVE-2020-28009: Exim 4 before 4.94.2 allows Integer Overflow to Buffer Overflow because get_stdinput allows unbounded reads that are accompanied by unbounded increases in a certain size variable. NOTE: exploitation may be impractical because of the execution time needed to overflow (multiple days).\n\n- CVE-2020-28017: Exim 4 before 4.94.2 allows Integer Overflow to Buffer Overflow in receive_add_recipient via an e-mail message with fifty million recipients. NOTE: remote exploitation may be difficult because of resource consumption.\n\n- CVE-2021-22323: There is an Integer Overflow Vulnerability in Huawei Smartphone. Successful exploitation of these vulnerabilities may escalate the permission to that of the root user.\n\n- CVE-2021-32027: A flaw was found in postgresql in versions before 13.3, before 12.7, before 11.12, before 10.17 and before 9.6.22. While modifying certain SQL array values, missing bounds checks let authenticated database users write arbitrary bytes to a wide area of server memory. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.\n\n- CVE-2021-3410: A flaw was found in libcaca v0.99.beta19. A buffer overflow issue in caca_resize function in libcaca/caca/canvas.c may lead to local execution of arbitrary code in the user context.\n\n- CVE-2020-14344: An integer overflow leading to a heap-buffer overflow was found in The X Input Method (XIM) client was implemented in libX11 before version 1.6.10. As per upstream this is security relevant when setuid programs call XIM client functions while running with elevated privileges. No such programs are shipped with Red Hat Enterprise Linux.\n\n- CVE-2020-6059: An exploitable out of bounds read vulnerability exists in the way MiniSNMPD version 1.4 parses incoming SNMP packets. A specially crafted SNMP request can trigger an out of bounds memory read which can result in sensitive information disclosure and Denial Of Service. In order to trigger this vulnerability, an attacker needs to send a specially crafted packet to the vulnerable server.\n\n- CVE-2020-6099: An exploitable code execution vulnerability exists in the file format parsing functionality of Graphisoft BIMx Desktop Viewer 2019.2.2328. A specially crafted file can cause a heap buffer overflow resulting in a code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-22680: NXP MQX Versions 5.1 and prior are vulnerable to integer overflow in mem_alloc, _lwmem_alloc and _partition functions. This unverified memory assignment can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-27419: uClibc-ng versions prior to 1.0.37 are vulnerable to integer wrap-around in functions malloc-simple. This improper memory assignment can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-27425: Cesanta Software Mongoose-OS v2.17.0 is vulnerable to integer wrap-around in function mm_malloc. This improper memory assignment can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-27427: RIOT OS version 2020.01.1 is vulnerable to integer wrap-around in its implementation of calloc function, which can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-27433: ARM mbed-ualloc memory library version 1.3.0 is vulnerable to integer wrap-around in function mbed_krbs, which can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-27435: ARM mbed product Version 6.3.0 is vulnerable to integer wrap-around in malloc_wrapper function, which can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-27439: TencentOS-tiny version 3.1.0 is vulnerable to integer wrap-around in function 'tos_mmheap_alloc incorrect calculation of effective memory allocation size. This improper memory assignment can lead to arbitrary memory allocation, resulting in unexpected behavior such as a crash or a remote code injection/execution.\n\n- CVE-2021-27417: eCosCentric eCosPro RTOS Versions 2.0.1 through 4.5.3 are vulnerable to integer wraparound in function calloc (an implementation of malloc). The unverified memory assignment can lead to arbitrary memory allocation, resulting in a heap-based buffer overflow.\n\n- CVE-2021-30663: An integer overflow was addressed with improved input validation. This issue is fixed in iOS 14.5.1 and iPadOS 14.5.1, tvOS 14.6, iOS 12.5.3, Safari 14.1.1, macOS Big Sur 11.3.1. Processing maliciously crafted web content may lead to arbitrary code execution.\n\n- CVE-2021-30860: An integer overflow was addressed with improved input validation. This issue is fixed in Security Update 2021-005 Catalina, iOS 14.8 and iPadOS 14.8, macOS Big Sur 11.6, watchOS 7.6.2. Processing a maliciously crafted PDF may lead to arbitrary code execution. Apple is aware of a report that this issue may have been actively exploited.\n\n- CVE-2021-0677: In ccu driver, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05827154; Issue ID: ALPS05827154.\n\n- CVE-2021-1047: In valid_ipc_dram_addr of cm_access_control.c, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-197966306References: N/A\n\n- CVE-2021-21832: A memory corruption vulnerability exists in the ISO Parsing functionality of Disc Soft Ltd Deamon Tools Pro 8.3.0.0767. A specially crafted malformed file can lead to an out-of-bounds write. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21914: A heap-based buffer overflow vulnerability exists in the DecoderStream::Append functionality of Accusoft ImageGear 19.10. A specially-crafted file can lead to code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-21948: A heap-based buffer overflow vulnerability exists in the readDatHeadVec functionality of AnyCubic Chitubox AnyCubic Plugin 1.0.0. A specially-crafted GF file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2021-22437: There is a software integer overflow leading to a TOCTOU condition in smartphones. Successful exploitation of this vulnerability may cause random address access.\n\n- CVE-2021-3782: An internal reference count is held on the buffer pool, incremented every time a new buffer is created from the pool. The reference count is maintained as an int; on LP64 systems this can cause the reference count to overflow if the client creates a large number of wl_shm buffer objects, or if it can coerce the server to create a large number of external references to the buffer storage. With the reference count overflowing, a use-after-free can be constructed on the wl_shm_pool tracking structure, where values may be incremented or decremented; it may also be possible to construct a limited oracle to leak 4 bytes of server-side memory to the attacking client at a time.\n\n- CVE-2021-39762: In tremolo, there is a possible out of bounds read due to an integer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-12LAndroid ID: A-210625816\n\n- CVE-2021-40417: When parsing a file that is submitted to the DPDecoder service as a job, the service will use the combination of decoding parameters that were submitted with the job along with fields that were parsed for the submitted video by the R3D SDK to calculate the size of a heap buffer. Due to an integer overflow with regards to this calculation, this can result in an undersized heap buffer being allocated. When this heap buffer is written to, a heap-based buffer overflow will occur. This can result in code execution under the context of the application.\n\n- CVE-2021-4206: A flaw was found in the QXL display device emulation in QEMU. An integer overflow in the cursor_alloc() function can lead to the allocation of a small cursor object followed by a subsequent heap-based buffer overflow. This flaw allows a malicious privileged guest user to crash the QEMU process on the host or potentially execute arbitrary code within the context of the QEMU process.\n\n- CVE-2021-46829: GNOME GdkPixbuf (aka GDK-PixBuf) before 2.42.8 allows a heap-based buffer overflow when compositing or clearing frames in GIF files, as demonstrated by io-gif-animation.c composite_frame. This overflow is controllable and could be abused for code execution, especially on 32-bit systems.\n\n- CVE-2022-0204: A heap overflow vulnerability was found in bluez in versions prior to 5.63. An attacker with local network access could pass specially crafted files causing an application to halt or crash, leading to a denial of service.\n\n- CVE-2022-0545: An integer overflow in the processing of loaded 2D images leads to a write-what-where vulnerability and an out-of-bounds read vulnerability, allowing an attacker to leak sensitive information or achieve code execution in the context of the Blender process when a specially crafted image file is loaded. This flaw affects Blender versions prior to 2.83.19, 2.93.8 and 3.1.\n\n- CVE-2022-0608: Integer overflow in Mojo in Google Chrome prior to 98.0.4758.102 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-1922: DOS / potential heap overwrite in mkv demuxing using zlib decompression. Integer overflow in matroskademux element in gst_matroska_decompress_data function which causes a segfault, or could cause a heap overwrite, depending on libc and OS. Depending on the libc used, and the underlying OS capabilities, it could be just a segfault or a heap overwrite. If the libc uses mmap for large chunks, and the OS supports mmap, then it is just a segfault (because the realloc before the integer overflow will use mremap to reduce the size of the chunk, and it will start to write to unmapped memory). However, if using a libc implementation that does not use mmap, or if the OS does not support mmap while using libc, then this could result in a heap overwrite.\n\n- CVE-2022-1923: DOS / potential heap overwrite in mkv demuxing using bzip decompression. Integer overflow in matroskademux element in bzip decompression function which causes a segfault, or could cause a heap overwrite, depending on libc and OS. Depending on the libc used, and the underlying OS capabilities, it could be just a segfault or a heap overwrite. If the libc uses mmap for large chunks, and the OS supports mmap, then it is just a segfault (because the realloc before the integer overflow will use mremap to reduce the size of the chunk, and it will start to write to unmapped memory). However, if using a libc implementation that does not use mmap, or if the OS does not support mmap while using libc, then this could result in a heap overwrite.\n\n- CVE-2022-1924: DOS / potential heap overwrite in mkv demuxing using lzo decompression. Integer overflow in matroskademux element in lzo decompression function which causes a segfault, or could cause a heap overwrite, depending on libc and OS. Depending on the libc used, and the underlying OS capabilities, it could be just a segfault or a heap overwrite. If the libc uses mmap for large chunks, and the OS supports mmap, then it is just a segfault (because the realloc before the integer overflow will use mremap to reduce the size of the chunk, and it will start to write to unmapped memory). However, if using a libc implementation that does not use mmap, or if the OS does not support mmap while using libc, then this could result in a heap overwrite.\n\n- CVE-2022-1925: DOS / potential heap overwrite in mkv demuxing using HEADERSTRIP decompression. Integer overflow in matroskaparse element in gst_matroska_decompress_data function which causes a heap overflow. Due to restrictions on chunk sizes in the matroskademux element, the overflow can't be triggered, however the matroskaparse element has no size checks.\n\n- CVE-2022-21729: Tensorflow is an Open Source Machine Learning Framework. The implementation of `UnravelIndex` is vulnerable to a division by zero caused by an integer overflow bug. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.\n\n- CVE-2022-21743: In ion, there is a possible use after free due to an integer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS06371108; Issue ID: ALPS06371108.\n\n- CVE-2022-22074: Memory Corruption during wma file playback due to integer overflow in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2022-22081: Memory corruption in audio module due to integer overflow in Snapdragon Auto, Snapdragon Connectivity, Snapdragon Mobile, Snapdragon Wearables\n\n- CVE-2022-22106: Memory corruption in multimedia due to improper length check while copying the data in Snapdragon Auto\n\n- CVE-2022-2329: A CWE-190: Integer Overflow or Wraparound vulnerability exists that could cause heap-based buffer overflow, leading to denial of service and potentially remote code execution when an attacker sends multiple specially crafted messages. Affected Products: IGSS Data Server - IGSSdataServer.exe (Versions prior to V15.0.0.22073)\n\n- CVE-2022-23559: Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would cause an integer overflow in embedding lookup operations. Both `embedding_size` and `lookup_size` are products of values provided by the user. Hence, a malicious user could trigger overflows in the multiplication. In certain scenarios, this can then result in heap OOB read/write. Users are advised to upgrade to a patched version.\n\n- CVE-2022-24310: A CWE-190: Integer Overflow or Wraparound vulnerability exists that could cause heap-based buffer overflow, leading to denial of service and potentially remote code execution when an attacker sends multiple specially crafted messages. Affected Product: Interactive Graphical SCADA System Data Server (V15.0.0.22020 and prior)\n\n- CVE-2022-24724: cmark-gfm is GitHub's extended version of the C reference implementation of CommonMark. Prior to versions 0.29.0.gfm.3 and 0.28.3.gfm.21, an integer overflow in cmark-gfm's table row parsing `table.c:row_from_string` may lead to heap memory corruption when parsing tables who's marker rows contain more than UINT16_MAX columns. The impact of this heap corruption ranges from Information Leak to Arbitrary Code Execution depending on how and where `cmark-gfm` is used. If `cmark-gfm` is used for rendering remote user controlled markdown, this vulnerability may lead to Remote Code Execution (RCE) in applications employing affected versions of the `cmark-gfm` library. This vulnerability has been patched in the following cmark-gfm versions 0.29.0.gfm.3 and 0.28.3.gfm.21. A workaround is available. The vulnerability exists in the table markdown extensions of cmark-gfm. Disabling the table extension will prevent this vulnerability from being triggered.\n\n- CVE-2022-24795: yajl-ruby is a C binding to the YAJL JSON parsing and generation library. The 1.x branch and the 2.x branch of `yajl` contain an integer overflow which leads to subsequent heap memory corruption when dealing with large (~2GB) inputs. The reallocation logic at `yajl_buf.c#L64` may result in the `need` 32bit integer wrapping to 0 when `need` approaches a value of 0x80000000 (i.e. ~2GB of data), which results in a reallocation of buf->alloc into a small heap chunk. These integers are declared as `size_t` in the 2.x branch of `yajl`, which practically prevents the issue from triggering on 64bit platforms, however this does not preclude this issue triggering on 32bit builds on which `size_t` is a 32bit integer. Subsequent population of this under-allocated heap chunk is based on the original buffer size, leading to heap memory corruption. This vulnerability mostly impacts process availability. Maintainers believe exploitation for arbitrary code execution is unlikely. A patch is available and anticipated to be part of yajl-ruby version 1.4.2. As a workaround, avoid passing large inputs to YAJL.\n\n- CVE-2022-25291: An integer overflow in WatchGuard Firebox and XTM appliances allows an authenticated remote attacker to trigger a heap-based buffer overflow and potentially execute arbitrary code by initiating a firmware update with a malicious upgrade image. This vulnerability impacts Fireware OS before 12.7.2_U2, 12.x before 12.1.3_U8, and 12.2.x through 12.5.x before 12.5.9_U2.\n\n- CVE-2022-2566: A heap out-of-bounds memory write exists in FFMPEG since version 5.1. The size calculation in `build_open_gop_key_points()` goes through all entries in the loop and adds `sc->ctts_data[i].count` to `sc->sample_offsets_count`. This can lead to an integer overflow resulting in a small allocation with `av_calloc()`. An attacker can cause remote code execution via a malicious mp4 file. We recommend upgrading past commit c953baa084607dd1d84c3bfcce3cf6a87c3e6e05\n\n- CVE-2022-26459: In vow, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07032634; Issue ID: ALPS07032634.\n\n- CVE-2022-26495: In nbd-server in nbd before 3.24, there is an integer overflow with a resultant heap-based buffer overflow. A value of 0xffffffff in the name length field will cause a zero-sized buffer to be allocated for the name, resulting in a write to a dangling pointer. This issue exists for the NBD_OPT_INFO, NBD_OPT_GO, and NBD_OPT_EXPORT_NAME messages.\n\n- CVE-2022-28331: On Windows, Apache Portable Runtime 1.7.0 and earlier may write beyond the end of a stack based buffer in apr_socket_sendv(). This is a result of integer overflow.\n\n- CVE-2022-28471: In ffjpeg (commit hash: caade60), the function bmp_load() in bmp.c contains an integer overflow vulnerability, which eventually results in the heap overflow in jfif_encode() in jfif.c. This is due to the incomplete patch for issue 38\n\n- CVE-2022-29203: TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.SpaceToBatchND` (in all backends such as XLA and handwritten kernels) is vulnerable to an integer overflow: The result of this integer overflow is used to allocate the output tensor, hence we get a denial of service via a `CHECK`-failure (assertion failure), as in TFSA-2021-198. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue.\n\n- CVE-2022-29886: An integer overflow vulnerability exists in the way ESTsoft Alyac 2.5.8.544 parses OLE files. A specially-crafted OLE file can lead to a heap buffer overflow, which can result in arbitrary code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2022-32543: An integer overflow vulnerability exists in the way ESTsoft Alyac 2.5.8.544 parses OLE files. A specially-crafted OLE file can lead to a heap buffer overflow which can result in arbitrary code execution. An attacker can provide a malicious file to trigger this vulnerability.\n\n- CVE-2022-33266: Memory corruption in Audio due to integer overflow to buffer overflow while music playback of clips like amr,evrc,qcelp with modified content.\n\n- CVE-2022-35289: A write-what-where condition in hermes caused by an integer overflow, prior to commit 5b6255ae049fa4641791e47fad994e8e8c4da374 allows attackers to potentially execute arbitrary code via crafted JavaScript. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected.\n\n- CVE-2022-35951: Redis is an in-memory database that persists on disk. Versions 7.0.0 and above, prior to 7.0.5 are vulnerable to an Integer Overflow. Executing an `XAUTOCLAIM` command on a stream key in a specific state, with a specially crafted `COUNT` argument may cause an integer overflow, a subsequent heap overflow, and potentially lead to remote code execution. This has been patched in Redis version 7.0.5. No known workarounds exist.\n\n- CVE-2022-39343: Azure RTOS FileX is a FAT-compatible file system that\u2019s fully integrated with Azure RTOS ThreadX. In versions before 6.2.0, the Fault Tolerant feature of Azure RTOS FileX includes integer under and overflows which may be exploited to achieve buffer overflow and modify memory contents. When a valid log file with correct ID and checksum is detected by the `_fx_fault_tolerant_enable` function an attempt to recover the previous failed write operation is taken by call of `_fx_fault_tolerant_apply_logs`. This function iterates through the log entries and performs required recovery operations. When properly crafted a log including entries of type `FX_FAULT_TOLERANT_DIR_LOG_TYPE` may be utilized to introduce unexpected behavior. This issue has been patched in version 6.2.0. A workaround to fix line 218 in fx_fault_tolerant_apply_logs.c is documented in the GHSA.\n\n- CVE-2022-41318: A buffer over-read was discovered in libntlmauth in Squid 2.5 through 5.6. Due to incorrect integer-overflow protection, the SSPI and SMB authentication helpers are vulnerable to reading unintended memory locations. In some configurations, cleartext credentials from these locations are sent to a client. This is fixed in 5.7.\n\n- CVE-2022-4172: An integer overflow and buffer overflow issues were found in the ACPI Error Record Serialization Table (ERST) device of QEMU in the read_erst_record() and write_erst_record() functions. Both issues may allow the guest to overrun the host buffer allocated for the ERST memory device. A malicious guest could use these flaws to crash the QEMU process on the host.\n\n- CVE-2022-42898: PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has \"a similar bug.\"\n\n- CVE-2022-44638: In libpixman in Pixman before 0.42.2, there is an out-of-bounds write (aka heap-based buffer overflow) in rasterize_edges_8 due to an integer overflow in pixman_sample_floor_y.\n\n- CVE-2022-3970: A vulnerability was found in LibTIFF. It has been classified as critical. This affects the function TIFFReadRGBATileExt of the file libtiff/tif_getimage.c. The manipulation leads to integer overflow. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used. The name of the patch is 227500897dfb07fb7d27f7aa570050e62617e3be. It is recommended to apply a patch to fix this issue. The identifier VDB-213549 was assigned to this vulnerability.\n\n- CVE-2022-4202: A vulnerability, which was classified as problematic, was found in GPAC 2.1-DEV-rev490-g68064e101-master. Affected is the function lsr_translate_coords of the file laser/lsr_dec.c. The manipulation leads to integer overflow. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used. The name of the patch is b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908. It is recommended to apply a patch to fix this issue. VDB-214518 is the identifier assigned to this vulnerability.\n\n- CVE-2022-25705: Memory corruption in modem due to integer overflow to buffer overflow while handling APDU response\n\n- CVE-2022-25748: Memory corruption in WLAN due to integer overflow to buffer overflow while parsing GTK frames. in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer Electronics Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables, Snapdragon Wired Infrastructure and Networking\n\n- CVE-2022-33219: Memory corruption in Automotive due to integer overflow to buffer overflow while registering a new listener with shared buffer.\n\n- CVE-2022-39907: Integer overflow vulnerability in Samsung decoding library for video thumbnails prior to SMR Dec-2022 Release 1 allows local attacker to perform Out-Of-Bounds Write.\n\n- CVE-2022-40530: Memory corruption in WLAN due to integer overflow to buffer overflow in WLAN during initialization phase.\n\n- CVE-2021-20268: An out-of-bounds access flaw was found in the Linux kernel's implementation of the eBPF code verifier in the way a user running the eBPF script calls dev_map_init_map or sock_map_alloc. This flaw allows a local user to crash the system or possibly escalate their privileges. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.\n\n- CVE-2022-28937: FISCO-BCOS release-3.0.0-rc2 was discovered to contain an issue where a malicious node, via an invalid proposal with an invalid header, will cause normal nodes to stop producing new blocks and processing new clients' requests.\n\n- CVE-2022-1699: Uncontrolled Resource Consumption in GitHub repository causefx/organizr prior to 2.1.2000. This vulnerability can be abused by doing a DDoS attack for which genuine users will not able to access resources/applications.\n\nRelated Weaknesses:\n\n- CWE-682 (ChildOf)\n\n- CWE-682 (ChildOf)\n\n- CWE-20 (ChildOf)\n\n- CWE-119 (CanPrecede)",
        "type": "Base",
        "source": "sparse",
        "search_source": "weakness:memory corruption",
        "sources": [
          "base",
          "weakness"
        ],
        "boost_factor": 2.8,
        "boosted": true,
        "metadata": {
          "source": "sparse",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Be careful of terminology problems with \"overflow,\" \"underflow,\" and \"wraparound\" - see Terminology Notes. Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ],
            "suggestions": [
              {
                "CweID": "191",
                "Comment": "Integer Underflow (Wrap or Wraparound). Consider CWE-191 when the result is less than the minimum value that can be represented (sometimes called \"underflows\")."
              }
            ]
          }
        }
      },
      {
        "cwe_id": "788",
        "name": "Access of Memory Location After End of Buffer",
        "description": "The product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.",
        "score": 51.05905723022035,
        "matched_text": "CWE-788: Access of Memory Location After End of Buffer\n\nType: Base\n\nStatus: Incomplete\n\nDescription:\n\nThe product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.\n\nExtended Details:\n\nThis typically occurs when a pointer or its index is incremented to a position after the buffer; or when pointer arithmetic results in a position after the buffer.\n\nReal-World Examples:\n\n- CVE-2009-2550: Classic stack-based buffer overflow in media player using a long entry in a playlist\n\n- CVE-2009-2403: Heap-based buffer overflow in media player using a long entry in a playlist\n\n- CVE-2009-0689: large precision value in a format string triggers overflow\n\n- CVE-2009-0558: attacker-controlled array index leads to code execution\n\n- CVE-2008-4113: OS kernel trusts userland-supplied length value, allowing reading of sensitive information\n\n- CVE-2007-4268: Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)\n\nTop 25 CWE Examples:\n\n- CVE-2021-28602: Adobe After Effects version 18.2 (and earlier) is affected by a memory corruption vulnerability when parsing a specially crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-28605: Adobe After Effects version 18.2 (and earlier) is affected by a memory corruption vulnerability when parsing a specially crafted file. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-36059: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-36067: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-36068: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-36069: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-36076: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-36077: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious SVG file, potentially resulting in local application denial of service in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-36078: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-39816: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-39817: Adobe Bridge version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious Bridge file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-39818: Adobe InCopy version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious TIFF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-39819: Adobe InCopy version 11.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious XML file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-39824: Adobe Premiere Elements version 2021.2235820 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious png file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-39830: Adobe Framemaker versions 2019 Update 8 (and earlier) and 2020 Release Update 2 (and earlier) are affected by a memory corruption vulnerability due to insecure handling of a malicious PDF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-39832: Adobe Framemaker versions 2019 Update 8 (and earlier) and 2020 Release Update 2 (and earlier) are affected by a memory corruption vulnerability due to insecure handling of a malicious PDF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40700: Adobe Premiere Elements version 2021.2235820 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious TIFF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40701: Adobe Premiere Elements version 2021.2235820 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious m4a file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40702: Adobe Premiere Elements version 2021.2235820 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious psd file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40703: Adobe Premiere Elements version 2021.2235820 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious m4a file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40710: Adobe Premiere Pro version 15.4 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious .svg file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40715: Adobe Premiere Pro version 15.4 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious .exr file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40733: Adobe Animate version 21.0.9 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious .psd file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40751: Adobe After Effects version 18.4 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious .m4a file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40752: Adobe After Effects version 18.4 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious .m4a file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40753: Adobe After Effects version 18.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious SVG file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40754: Adobe After Effects version 18.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40755: Adobe After Effects version 18.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious SGI file in the DoReadContinue function, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40757: Adobe After Effects version 18.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious MXF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40758: Adobe After Effects version 18.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40759: Adobe After Effects version 18.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious .m4a file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40760: Adobe After Effects version 18.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious .m4a file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40770: Adobe Prelude version 10.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40771: Adobe Prelude version 10.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40772: Adobe Prelude version 10.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-40775: Adobe Prelude version 10.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious SVG file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-42266: Adobe Animate version 21.0.9 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious FLA file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42723: Adobe Bridge version 11.1.1 (and earlier) is affected by an out-of-bounds read vulnerability when parsing a crafted SGI file, which could result in a read past the end of an allocated memory structure. An attacker could leverage this vulnerability to execute code in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-42726: Adobe Bridge version 11.1.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42737: Adobe Prelude version 10.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-42738: Adobe Prelude version 10.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious MXF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-43011: Adobe Prelude version 10.1 (and earlier) are affected by a memory corruption vulnerability. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious M4A file.\n\n- CVE-2021-43012: Adobe Prelude version 10.1 (and earlier) are affected by a memory corruption vulnerability. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious M4A file.\n\n- CVE-2021-43013: Adobe Media Encoder version 15.4.1 (and earlier) are affected by a memory corruption vulnerability. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-43015: Adobe InCopy version 16.4 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious GIF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required in that the victim must open a specially crafted file to exploit this vulnerability.\n\n- CVE-2021-42721: Acrobat Bridge versions 11.1.1 and earlier are affected by a use-after-free vulnerability in the processing of Format event actions that could result in arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-42267: Adobe Animate version 21.0.9 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious FLA file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-36070: Adobe Media Encoder version 15.1 (and earlier) is affected by an improper memory access vulnerability when parsing a crafted .SVG file. An attacker could leverage this vulnerability to execute code in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-40142: In OPC Foundation Local Discovery Server (LDS) before 1.04.402.463, remote attackers can cause a denial of service (DoS) by sending carefully crafted messages that lead to Access of a Memory Location After the End of a Buffer.\n\n- CVE-2021-41771: ImportedSymbols in debug/macho (for Open or OpenFat) in Go before 1.16.10 and 1.17.x before 1.17.3 Accesses a Memory Location After the End of a Buffer, aka an out-of-bounds slice situation.\n\n- CVE-2021-45067: Acrobat Reader DC version 21.007.20099 (and earlier), 20.004.30017 (and earlier) and 17.011.30204 (and earlier) are affected by an Access of Memory Location After End of Buffer vulnerability that could lead to disclosure of sensitive memory. An attacker could leverage this vulnerability to bypass mitigations such as ASLR. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-44712: Acrobat Reader DC version 21.007.20099 (and earlier), 20.004.30017 (and earlier) and 17.011.30204 (and earlier) are affected by an Access of Memory Location After End of Buffer vulnerability that could lead to application denial-of-service. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2021-39820: Adobe InDesign versions 16.3 (and earlier), and 16.3.1 (and earlier) is affected by an Out-of-bounds Write vulnerability due to insecure handling of a malicious TIFF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40734: Adobe Audition version 14.4 (and earlier) is affected by a memory corruption vulnerability when parsing a SVG file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40735: Adobe Audition version 14.4 (and earlier) is affected by a memory corruption vulnerability, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40736: Adobe Audition version 14.4 (and earlier) is affected by a memory corruption vulnerability, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40738: Adobe Audition version 14.4 (and earlier) is affected by a memory corruption vulnerability when parsing a WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40739: Adobe Audition version 14.4 (and earlier) is affected by a memory corruption vulnerability when parsing a M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40740: Adobe Audition version 14.4 (and earlier) is affected by a memory corruption vulnerability when parsing a M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40763: Adobe Character Animator version 4.4 (and earlier) is affected by a memory corruption vulnerability when parsing a WAF file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40764: Adobe Character Animator version 4.4 (and earlier) is affected by a memory corruption vulnerability when parsing a M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40765: Adobe Character Animator version 4.4 (and earlier) is affected by a memory corruption vulnerability when parsing a M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40777: Adobe Media Encoder version 15.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40779: Adobe Media Encoder version 15.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40780: Adobe Media Encoder version 15.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40783: Adobe Premiere Rush version 1.5.16 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40784: Adobe Premiere Rush version 1.5.16 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40786: Adobe Premiere Elements 20210809.daily.2242976 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40787: Adobe Premiere Elements 20210809.daily.2242976 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40792: Adobe Premiere Pro version 15.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40793: Adobe Premiere Pro version 15.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-40794: Adobe Premiere Pro version 15.4.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42526: Adobe Premiere Elements 20210809.daily.2242976 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42527: Adobe Premiere Elements 20210809.daily.2242976 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42724: Adobe Bridge version 11.1.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42725: Adobe Bridge version 11.1.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious M4A file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42729: Adobe Bridge version 11.1.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious WAV file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-42730: Adobe Bridge version 11.1.1 (and earlier) is affected by a memory corruption vulnerability due to insecure handling of a malicious PSD file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-43754: Adobe Prelude version 22.1.1 (and earlier) is affected by an Out-of-bounds Write vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-43755: Adobe After Effects versions 22.0 (and earlier) and 18.4.2 (and earlier) are affected by an Out-of-bounds Write vulnerability due to insecure handling of a malicious file, potentially resulting in arbitrary code execution in the context of the current user. User interaction is required to exploit this vulnerability.\n\n- CVE-2021-43756: Adobe Media Encoder versions 22.0, 15.4.2 (and earlier) are affected by an Out-of-bounds Write vulnerability. An unauthenticated attacker could leverage this vulnerability to achieve arbitrary code execution in the context of the current user. Exploitation of this issue requires user interaction in that a victim must open a malicious file.\n\n- CVE-2022-0521: Access of Memory Location After End of Buffer in GitHub repository radareorg/radare2 prior to 5.6.2.\n\nRelated Weaknesses:\n\n- CWE-119 (ChildOf)\n\n- CWE-119 (ChildOf)\n\n- CWE-119 (ChildOf)",
        "type": "Base",
        "source": "sparse",
        "search_source": "weakness:memory corruption",
        "sources": [
          "base",
          "weakness"
        ],
        "boost_factor": 2.8,
        "boosted": true,
        "metadata": {
          "source": "sparse",
          "mapping_notes": {
            "usage": "Discouraged",
            "rationale": "The CWE entry might be misused when lower-level CWE entries might be available. It also overlaps existing CWE entries and might be deprecated in the future.",
            "comments": "If the \"Access\" operation is known to be a read or a write, then investigate children of entries such as CWE-787: Out-of-bounds Write and CWE-125: Out-of-bounds Read.",
            "reasons": [
              "Potential Deprecation",
              "Frequent Misuse"
            ]
          }
        }
      },
      {
        "cwe_id": "366",
        "name": "Race Condition within a Thread",
        "description": "If two threads of execution use a resource simultaneously, there exists the possibility that resources may be used while invalid, in turn making the state of execution undefined.",
        "score": 50.5279456484442,
        "matched_text": "CWE-366: Race Condition within a Thread\n\nType: Base\n\nStatus: Draft\n\nDescription:\n\nIf two threads of execution use a resource simultaneously, there exists the possibility that resources may be used while invalid, in turn making the state of execution undefined.\n\nReal-World Examples:\n\n- CVE-2022-2621: Chain: two threads in a web browser use the same resource (CWE-366), but one of those threads can destroy the resource before the other has completed (CWE-416).\n\nTop 25 CWE Examples:\n\n- CVE-2021-0652: In VectorDrawable::VectorDrawable of VectorDrawable.java, there is a possible way to introduce a memory corruption due to sharing of not thread-safe objects. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-8.1 Android-9 Android-10 Android-11Android ID: A-185178568\n\n- CVE-2021-21165: Data race in audio in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-21166: Data race in audio in Google Chrome prior to 89.0.4389.72 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2021-26569: Race Condition within a Thread vulnerability in iscsi_snapshot_comm_core in Synology DiskStation Manager (DSM) before 6.2.3-25426-3 allows remote attackers to execute arbitrary code via crafted web requests.\n\n- CVE-2020-36447: An issue was discovered in the v9 crate through 2020-12-18 for Rust. There is an unconditional implementation of Sync for SyncRef<T>.\n\n- CVE-2020-36448: An issue was discovered in the cache crate through 2020-11-24 for Rust. There are unconditional implementations of Send and Sync for Cache<K>.\n\n- CVE-2020-36449: An issue was discovered in the kekbit crate before 0.3.4 for Rust. For ShmWriter<H>, Send is implemented without requiring H: Send.\n\n- CVE-2020-36450: An issue was discovered in the bunch crate through 2020-11-12 for Rust. There are unconditional implementations of Send and Sync for Bunch<T>.\n\n- CVE-2020-36451: An issue was discovered in the rcu_cell crate through 2020-11-14 for Rust. There are unconditional implementations of Send and Sync for RcuCell<T>.\n\n- CVE-2020-36455: An issue was discovered in the slock crate through 2020-11-17 for Rust. Slock<T> unconditionally implements Send and Sync.\n\n- CVE-2020-36456: An issue was discovered in the toolshed crate through 2020-11-15 for Rust. In CopyCell<T>, the Send trait lacks bounds on the contained type.\n\n- CVE-2020-36457: An issue was discovered in the lever crate before 0.1.1 for Rust. AtomicBox<T> implements the Send and Sync traits for all types T.\n\n- CVE-2020-36458: An issue was discovered in the lexer crate through 2020-11-10 for Rust. For ReaderResult<T, E>, there is an implementation of Sync with a trait bound of T: Send, E: Send.\n\n- CVE-2020-36459: An issue was discovered in the dces crate through 2020-12-09 for Rust. The World type is marked as Send but lacks bounds on its EntityStore and ComponentStore.\n\n- CVE-2020-36461: An issue was discovered in the noise_search crate through 2020-12-10 for Rust. There are unconditional implementations of Send and Sync for MvccRwLock.\n\n- CVE-2020-36462: An issue was discovered in the syncpool crate before 0.1.6 for Rust. There is an unconditional implementation of Send for Bucket2.\n\n- CVE-2020-36463: An issue was discovered in the multiqueue crate through 2020-12-25 for Rust. There are unconditional implementations of Send for InnerSend<RW, T>, InnerRecv<RW, T>, FutInnerSend<RW, T>, and FutInnerRecv<RW, T>.\n\n- CVE-2021-33078: Race condition within a thread in firmware for some Intel(R) Optane(TM) SSD and Intel(R) SSD DC Products may allow a privileged user to potentially enable denial of service via local access.\n\n- CVE-2021-44733: A use-after-free exists in drivers/tee/tee_shm.c in the TEE subsystem in the Linux kernel through 5.15.11. This occurs because of a race condition in tee_shm_get_from_id during an attempt to free a shared memory object.\n\n- CVE-2022-20148: In TBD of TBD, there is a possible use-after-free due to a race condition. This could lead to local escalation of privilege in the kernel with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-219513976References: Upstream kernel\n\n- CVE-2022-2607: Use after free in Tab Strip in Google Chrome on Chrome OS prior to 104.0.5112.79 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2608: Use after free in Overview Mode in Google Chrome on Chrome OS prior to 104.0.5112.79 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2609: Use after free in Nearby Share in Google Chrome on Chrome OS prior to 104.0.5112.79 allowed a remote attacker who convinced a user to engage in specific user interactions to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2617: Use after free in Extensions API in Google Chrome prior to 104.0.5112.79 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2621: Use after free in Extensions in Google Chrome prior to 104.0.5112.79 allowed an attacker who convinced a user to install a malicious extension to potentially exploit heap corruption via specific UI interactions.\n\n- CVE-2022-2857: Use after free in Blink in Google Chrome prior to 104.0.5112.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-2742: Use after free in Exosphere in Google Chrome on Chrome OS and Lacros prior to 104.0.5112.79 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via crafted UI interactions. (Chrome security severity: High)\n\n- CVE-2022-2854: Use after free in SwiftShader in Google Chrome prior to 104.0.5112.101 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3049: Use after free in SplitScreen in Google Chrome on Chrome OS, Lacros prior to 105.0.5195.52 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-3071: Use after free in Tab Strip in Google Chrome on Chrome OS, Lacros prior to 105.0.5195.52 allowed a remote attacker who convinced a user to engage in specific UI interactions to potentially exploit heap corruption via crafted UI interaction.\n\nRelated Weaknesses:\n\n- CWE-362 (ChildOf)\n\n- CWE-662 (ChildOf)\n\n- CWE-662 (ChildOf)",
        "type": "Base",
        "source": "sparse",
        "search_source": "weakness:memory corruption",
        "sources": [
          "base",
          "weakness"
        ],
        "boost_factor": 2.8,
        "boosted": true,
        "metadata": {
          "source": "sparse",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          }
        }
      },
      {
        "cwe_id": "822",
        "name": "Untrusted Pointer Dereference",
        "description": "The product obtains a value from an untrusted source, converts this value to a pointer, and dereferences the resulting pointer.",
        "score": 48.46614763081808,
        "matched_text": "CWE-822: Untrusted Pointer Dereference\n\nType: Base\n\nStatus: Incomplete\n\nDescription:\n\nThe product obtains a value from an untrusted source, converts this value to a pointer, and dereferences the resulting pointer.\n\nExtended Details:\n\n\n\nAn attacker can supply a pointer for memory locations that the product is not expecting. If the pointer is dereferenced for a write operation, the attack might allow modification of critical state variables, cause a crash, or execute code. If the dereferencing operation is for a read, then the attack might allow reading of sensitive data, cause a crash, or set a variable to an unexpected value (since the value will be read from an unexpected memory location).\n\n\nThere are several variants of this weakness, including but not necessarily limited to:\n\n\n  - The untrusted value is directly invoked as a function call.\n\n  - In OS kernels or drivers where there is a boundary between \"userland\" and privileged memory spaces, an untrusted pointer might enter through an API or system call (see CWE-781 for one such example).\n\n  - Inadvertently accepting the value from an untrusted control sphere when it did not have to be accepted as input at all. This might occur when the code was originally developed to be run by a single user in a non-networked environment, and the code is then ported to or otherwise exposed to a networked environment.\n\n\n\nReal-World Examples:\n\n- CVE-2007-5655: message-passing framework interprets values in packets as pointers, causing a crash.\n\n- CVE-2010-2299: labeled as a \"type confusion\" issue, also referred to as a \"stale pointer.\" However, the bug ID says \"contents are simply interpreted as a pointer... renderer ordinarily doesn't supply this pointer directly\". The \"handle\" in the untrusted area is replaced in one function, but not another - thus also, effectively, exposure to wrong sphere (CWE-668).\n\n- CVE-2009-1719: Untrusted dereference using undocumented constructor.\n\n- CVE-2009-1250: An error code is incorrectly checked and interpreted as a pointer, leading to a crash.\n\n- CVE-2009-0311: An untrusted value is obtained from a packet and directly called as a function pointer, leading to code execution.\n\n- CVE-2010-1818: Undocumented attribute in multimedia software allows \"unmarshaling\" of an untrusted pointer.\n\n- CVE-2010-3189: ActiveX control for security software accepts a parameter that is assumed to be an initialized pointer.\n\n- CVE-2010-1253: Spreadsheet software treats certain record values that lead to \"user-controlled pointer\" (might be untrusted offset, not untrusted pointer).\n\nTop 25 CWE Examples:\n\n- CVE-2021-22649: Luxion KeyShot versions prior to 10.1, Luxion KeyShot Viewer versions prior to 10.1, Luxion KeyShot Network Rendering versions prior to 10.1, and Luxion KeyVR versions prior to 10.1 have multiple NULL pointer dereference issues while processing project files, which may allow an attacker to execute arbitrary code.\n\n- CVE-2021-40157: A user may be tricked into opening a malicious FBX file which may exploit an Untrusted Pointer Dereference vulnerability in FBX\u2019s Review version 1.5.0 and prior causing it to run arbitrary code on the system.\n\n- CVE-2021-1973: A FTM Diag command can allow an arbitrary write into modem OS space in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2021-20239: A flaw was found in the Linux kernel in versions before 5.4.92 in the BPF protocol. This flaw allows an attacker with a local account to leak information about kernel internal addresses. The highest threat from this vulnerability is to confidentiality.\n\n- CVE-2020-7452: In FreeBSD 12.1-STABLE before r357490, 12.1-RELEASE before 12.1-RELEASE-p3, 11.3-STABLE before r357489, and 11.3-RELEASE before 11.3-RELEASE-p7, incorrect use of a user-controlled pointer in the epair virtual network module allowed vnet jailed privileged users to panic the host system and potentially execute arbitrary code in the kernel.\n\n- CVE-2021-46019: An untrusted pointer dereference in rec_db_destroy() at rec-db.c of GNU Recutils v1.8.90 can lead to a segmentation fault or application crash.\n\n- CVE-2021-46237: An untrusted pointer dereference vulnerability exists in GPAC v1.1.0 via the function gf_node_unregister () at scenegraph/base_scenegraph.c. This vulnerability can lead to a Denial of Service (DoS).\n\n- CVE-2021-46243: An untrusted pointer dereference vulnerability exists in HDF5 v1.13.1-1 via the function H5O__dtype_decode_helper () at hdf5/src/H5Odtype.c. This vulnerability can lead to a Denial of Service (DoS).\n\n- CVE-2021-46020: An untrusted pointer dereference in mrb_vm_exec() of mruby v3.0.0 can lead to a segmentation fault or application crash.\n\n- CVE-2021-46023: An Untrusted Pointer Dereference was discovered in function mrb_vm_exec in mruby before 3.1.0-rc. The vulnerability causes a segmentation fault and application crash.\n\n- CVE-2022-22098: Memory corruption in multimedia driver due to untrusted pointer dereference while reading data from socket in Snapdragon Auto\n\n- CVE-2022-25661: Memory corruption due to untrusted pointer dereference in kernel in Snapdragon Auto, Snapdragon Compute, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile\n\n- CVE-2022-25658: Memory corruption due to incorrect pointer arithmetic when attempting to change the endianness in video parser function in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables\n\n- CVE-2021-41837: An issue was discovered in AhciBusDxe in the kernel 5.0 through 5.5 in Insyde InsydeH2O. Because of an Untrusted Pointer Dereference that causes SMM memory corruption, an attacker may be able to write fixed or predictable data to SMRAM. Exploiting this issue could lead to escalating privileges to SMM.\n\n- CVE-2021-41839: An issue was discovered in NvmExpressDxe in the kernel 5.0 through 5.5 in Insyde InsydeH2O. Because of an Untrusted Pointer Dereference that causes SMM memory corruption, an attacker may be able to write fixed or predictable data to SMRAM. Exploiting this issue could lead to escalating privileges to SMM.\n\n- CVE-2022-25662: Information disclosure due to untrusted pointer dereference in kernel in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile, Snapdragon Wearables\n\n- CVE-2022-22716: Microsoft Excel Information Disclosure Vulnerability\n\n- CVE-2022-29275: In UsbCoreDxe, untrusted input may allow SMRAM or OS memory tampering Use of untrusted pointers could allow OS or SMRAM memory tampering leading to escalation of privileges. This issue was discovered by Insyde during security review. It was fixed in: Kernel 5.0: version 05.09.21 Kernel 5.1: version 05.17.21 Kernel 5.2: version 05.27.21 Kernel 5.3: version 05.36.21 Kernel 5.4: version 05.44.21 Kernel 5.5: version 05.52.21 https://www.insyde.com/security-pledge/SA-2022058\n\n- CVE-2022-29279: Use of a untrusted pointer allows tampering with SMRAM and OS memory in SdHostDriver and SdMmcDevice Use of a untrusted pointer allows tampering with SMRAM and OS memory in SdHostDriver and SdMmcDevice. This issue was discovered by Insyde during security review. It was fixed in: Kernel 5.0: version 05.09.17 Kernel 5.1: version 05.17.17 Kernel 5.2: version 05.27.17 Kernel 5.3: version 05.36.17 Kernel 5.4: version 05.44.17 Kernel 5.5: version 05.52.17 https://www.insyde.com/security-pledge/SA-2022062\n\nRelated Weaknesses:\n\n- CWE-119 (ChildOf)\n\n- CWE-119 (ChildOf)\n\n- CWE-119 (ChildOf)\n\n- CWE-125 (CanPrecede)\n\n- CWE-787 (CanPrecede)",
        "type": "Base",
        "source": "sparse",
        "search_source": "weakness:memory corruption",
        "sources": [
          "base",
          "weakness"
        ],
        "boost_factor": 2.8,
        "boosted": true,
        "metadata": {
          "source": "sparse",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          }
        }
      },
      {
        "cwe_id": "908",
        "name": "Use of Uninitialized Resource",
        "description": "The product uses or accesses a resource that has not been initialized.",
        "score": 47.42449593239558,
        "matched_text": "CWE-908: Use of Uninitialized Resource\n\nType: Base\n\nStatus: Incomplete\n\nDescription:\n\nThe product uses or accesses a resource that has not been initialized.\n\nExtended Details:\n\nWhen a resource has not been properly initialized, the product may behave unexpectedly. This may lead to a crash or invalid memory access, but the consequences vary depending on the type of resource and how it is used within the product.\n\nReal-World Examples:\n\n- CVE-2019-9805: Chain: Creation of the packet client occurs before initialization is complete (CWE-696) resulting in a read from uninitialized memory (CWE-908), causing memory corruption.\n\n- CVE-2008-4197: Use of uninitialized memory may allow code execution.\n\n- CVE-2008-2934: Free of an uninitialized pointer leads to crash and possible code execution.\n\n- CVE-2008-0063: Product does not clear memory contents when generating an error message, leading to information leak.\n\n- CVE-2008-0062: Lack of initialization triggers NULL pointer dereference or double-free.\n\n- CVE-2008-0081: Uninitialized variable leads to code execution in popular desktop application.\n\n- CVE-2008-3688: Chain: Uninitialized variable leads to infinite loop.\n\n- CVE-2008-3475: Chain: Improper initialization leads to memory corruption.\n\n- CVE-2005-1036: Chain: Bypass of access restrictions due to improper authorization (CWE-862) of a user results from an improperly initialized (CWE-909) I/O permission bitmap\n\n- CVE-2008-3597: Chain: game server can access player data structures before initialization has happened leading to NULL dereference\n\n- CVE-2009-2692: Chain: uninitialized function pointers can be dereferenced allowing code execution\n\n- CVE-2009-0949: Chain: improper initialization of memory can lead to NULL dereference\n\n- CVE-2009-3620: Chain: some unprivileged ioctls do not verify that a structure has been initialized before invocation, leading to NULL dereference\n\nTop 25 CWE Examples:\n\n- CVE-2021-0473: In rw_t3t_process_error of rw_t3t.cc, there is a possible double free due to uninitialized data. This could lead to remote code execution over NFC with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-9 Android-10 Android-11 Android-8.1Android ID: A-179687208\n\n- CVE-2021-0495: In memory management driver, there is a possible out of bounds write due to uninitialized data. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-183459083\n\n- CVE-2021-0526: In memory management driver, there is a possible out of bounds write due to uninitialized data. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-185195264\n\n- CVE-2021-0530: In memory management driver, there is a possible out of bounds write due to uninitialized data. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android SoCAndroid ID: A-185196175\n\n- CVE-2021-0634: In display driver, there is a possible memory corruption due to uninitialized data. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05594994; Issue ID: ALPS05594994.\n\n- CVE-2021-25905: An issue was discovered in the bra crate before 0.1.1 for Rust. It lacks soundness because it can read uninitialized memory.\n\n- CVE-2021-28033: An issue was discovered in the byte_struct crate before 0.6.1 for Rust. There can be a drop of uninitialized memory if a certain deserialization method panics.\n\n- CVE-2021-29631: In FreeBSD 13.0-STABLE before n246941-20f96f215562, 12.2-STABLE before r370400, 11.4-STABLE before r370399, 13.0-RELEASE before p4, 12.2-RELEASE before p10, and 11.4-RELEASE before p13, certain VirtIO-based device models in bhyve failed to handle errors when fetching I/O descriptors. A malicious guest may cause the device model to operate on uninitialized I/O vectors leading to memory corruption, crashing of the bhyve process, and possibly arbitrary code execution in the bhyve process.\n\n- CVE-2021-29930: An issue was discovered in the arenavec crate through 2021-01-12 for Rust. A drop of uninitialized memory can sometimes occur upon a panic in T::default().\n\n- CVE-2021-29934: An issue was discovered in PartialReader in the uu_od crate before 0.0.4 for Rust. Attackers can read the contents of uninitialized memory locations via a user-provided Read operation.\n\n- CVE-2021-29980: Uninitialized memory in a canvas object could have caused an incorrect free() leading to memory corruption and a potentially exploitable crash. This vulnerability affects Thunderbird < 78.13, Thunderbird < 91, Firefox ESR < 78.13, and Firefox < 91.\n\n- CVE-2021-30454: An issue was discovered in the outer_cgi crate before 0.2.1 for Rust. A user-provided Read instance receives an uninitialized memory buffer from KeyValueReader.\n\n- CVE-2021-29937: An issue was discovered in the telemetry crate through 2021-02-17 for Rust. There is a drop of uninitialized memory if a value.clone() call panics within misc::vec_with_size().\n\n- CVE-2021-3545: An information disclosure vulnerability was found in the virtio vhost-user GPU device (vhost-user-gpu) of QEMU in versions up to and including 6.0. The flaw exists in virgl_cmd_get_capset_info() in contrib/vhost-user-gpu/virgl.c and could occur due to the read of uninitialized memory. A malicious guest could exploit this issue to leak memory from the host.\n\n- CVE-2020-36432: An issue was discovered in the alg_ds crate through 2020-08-25 for Rust. There is a drop of uninitialized memory in Matrix::new().\n\n- CVE-2020-36452: An issue was discovered in the array-tools crate before 0.3.2 for Rust. FixedCapacityDequeLike::clone() has a drop of uninitialized memory.\n\n- CVE-2021-28035: An issue was discovered in the stack_dst crate before 0.6.1 for Rust. Because of the push_inner behavior, a drop of uninitialized memory can occur upon a val.clone() panic.\n\n- CVE-2021-28029: An issue was discovered in the toodee crate before 0.3.0 for Rust. The row-insertion feature allows attackers to read the contents of uninitialized memory locations.\n\n- CVE-2021-36282: Dell EMC PowerScale OneFS versions 8.2.x - 9.1.0.x contain a use of uninitialized resource vulnerability. This can potentially allow an authenticated user with ISI_PRIV_LOGIN_CONSOLE or ISI_PRIV_LOGIN_SSH privileges to gain access up to 24 bytes of data within the /ifs kernel stack under certain conditions.\n\n- CVE-2021-43848: h2o is an open source http server. In code prior to the `8c0eca3` commit h2o may attempt to access uninitialized memory. When receiving QUIC frames in certain order, HTTP/3 server-side implementation of h2o can be misguided to treat uninitialized memory as HTTP/3 frames that have been received. When h2o is used as a reverse proxy, an attacker can abuse this vulnerability to send internal state of h2o to backend servers controlled by the attacker or third party. Also, if there is an HTTP endpoint that reflects the traffic sent from the client, an attacker can use that reflector to obtain internal state of h2o. This internal state includes traffic of other connections in unencrypted form and TLS session tickets. This vulnerability exists in h2o server with HTTP/3 support, between commit 93af138 and d1f0f65. None of the released versions of h2o are affected by this vulnerability. There are no known workarounds. Users of unreleased versions of h2o using HTTP/3 are advised to upgrade immediately.\n\n- CVE-2021-39671: In code generated by aidl_const_expressions.cpp, there is a possible out of bounds read due to uninitialized data. This could lead to information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-12Android ID: A-206718630\n\n- CVE-2022-26437: In httpclient, there is a possible out of bounds write due to uninitialized data. This could lead to remote escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: WSAP00103831; Issue ID: WSAP00103831.\n\n- CVE-2022-2949:  Altair HyperView Player versions 2021.1.0.27 and prior are vulnerable to the use of uninitialized memory vulnerability during parsing of H3D files. A DWORD is extracted from an uninitialized buffer and, after sign extension, is used as an index into a stack variable to increment a counter leading to memory corruption. \n\n- CVE-2022-2950:  Altair HyperView Player versions 2021.1.0.27 and prior are vulnerable to the use of uninitialized memory vulnerability during parsing of H3D files. A DWORD is extracted from an uninitialized buffer and, after sign extension, is used as an index into a stack variable to increment a counter leading to memory corruption. \n\n- CVE-2022-32615: In ccd, there is a possible out of bounds write due to uninitialized data. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07326559; Issue ID: ALPS07326559.\n\n- CVE-2022-32616: In isp, there is a possible out of bounds write due to uninitialized data. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07341258; Issue ID: ALPS07341258.\n\n- CVE-2022-39283: FreeRDP is a free remote desktop protocol library and clients. All FreeRDP based clients when using the `/video` command line switch might read uninitialized data, decode it as audio/video and display the result. FreeRDP based server implementations are not affected. This issue has been patched in version 2.8.1. If you cannot upgrade do not use the `/video` switch.\n\n- CVE-2022-20015: In kd_camera_hw driver, there is a possible information disclosure due to uninitialized data. This could lead to local information disclosure with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05862966; Issue ID: ALPS05862966.\n\n- CVE-2022-20357: In writeToParcel of SurfaceControl.cpp, there is a possible information disclosure due to uninitialized data. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-12 Android-12LAndroid ID: A-214999987\n\n- CVE-2022-38668: HTTP applications (servers) based on Crow through 1.0+4 may reveal potentially sensitive uninitialized data from stack memory when fulfilling a request for a static file smaller than 16 KB.\n\n- CVE-2022-0494: A kernel information leak flaw was identified in the scsi_ioctl function in drivers/scsi/scsi_ioctl.c in the Linux kernel. This flaw allows a local attacker with a special user privilege (CAP_SYS_ADMIN or CAP_SYS_RAWIO) to create issues with confidentiality.\n\nRelated Weaknesses:\n\n- CWE-665 (ChildOf)\n\n- CWE-665 (ChildOf)",
        "type": "Base",
        "source": "sparse",
        "search_source": "weakness:memory corruption",
        "sources": [
          "base",
          "weakness"
        ],
        "boost_factor": 2.8,
        "boosted": true,
        "metadata": {
          "source": "sparse",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          }
        }
      },
      {
        "cwe_id": "191",
        "name": "Integer Underflow (Wrap or Wraparound)",
        "description": "The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.",
        "score": 10.227986494513978,
        "matched_text": "CWE-191: Integer Underflow (Wrap or Wraparound)\n\nType: Base\n\nStatus: Draft\n\nAlternative Terms:\n\nInteger underflow - \n\n\"Integer underflow\" is sometimes used to identify signedness errors in which an originally positive number becomes negative as a result of subtraction. However, there are cases of bad subtraction in which unsigned integers are involved, so it's not always a signedness issue.\n\n\n\"Integer underflow\" is occasionally used to describe array index errors in which the index is negative.\n\n\nInteger underflow - \n\n\"Integer underflow\" is sometimes used to identify signedness errors in which an originally positive number becomes negative as a result of subtraction. However, there are cases of bad subtraction in which unsigned integers are involved, so it's not always a signedness issue.\n\n\n\"Integer underflow\" is occasionally used to describe array index errors in which the index is negative.\n\n\nInteger underflow - \n\n\"Integer underflow\" is sometimes used to identify signedness errors in which an originally positive number becomes negative as a result of subtraction. However, there are cases of bad subtraction in which unsigned integers are involved, so it's not always a signedness issue.\n\n\n\"Integer underflow\" is occasionally used to describe array index errors in which the index is negative.\n\n\nDescription:\n\nThe product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.\n\nExtended Details:\n\nThis can happen in signed and unsigned cases.\n\nReal-World Examples:\n\n- CVE-2004-0816: Integer underflow in firewall via malformed packet.\n\n- CVE-2004-1002: Integer underflow by packet with invalid length.\n\n- CVE-2005-0199: Long input causes incorrect length calculation.\n\n- CVE-2005-1891: Malformed icon causes integer underflow in loop counter variable.\n\nTop 25 CWE Examples:\n\n- CVE-2021-27486: FATEK Automation WinProladder Versions 3.30 and prior is vulnerable to an integer underflow, which may cause an out-of-bounds write and allow an attacker to execute arbitrary code.\n\n- CVE-2021-28027: An issue was discovered in the bam crate before 0.1.3 for Rust. There is an integer underflow and out-of-bounds write during the loading of a bgzip block.\n\n- CVE-2021-28362: An issue was discovered in Contiki through 3.0. When sending an ICMPv6 error message because of invalid extension header options in an incoming IPv6 packet, there is an attempt to remove the RPL extension headers. Because the packet length and the extension header length are unchecked (with respect to the available data) at this stage, and these variables are susceptible to integer underflow, it is possible to construct an invalid extension header that will cause memory corruption issues and lead to a Denial-of-Service condition. This is related to rpl-ext-header.c.\n\n- CVE-2021-3321: Integer Underflow in Zephyr in IEEE 802154 Fragment Reassembly Header Removal. Zephyr versions >= >=2.4.0 contain Integer Overflow to Buffer Overflow (CWE-680). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-w44j-66g7-xw99\n\n- CVE-2021-31178: Microsoft Office Information Disclosure Vulnerability\n\n- CVE-2021-4066: Integer underflow in ANGLE in Google Chrome prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.\n\n- CVE-2022-0185: A heap-based buffer overflow flaw was found in the way the legacy_parse_param function in the Filesystem Context functionality of the Linux kernel verified the supplied parameters length. An unprivileged (in case of unprivileged user namespaces enabled, otherwise needs namespaced CAP_SYS_ADMIN privilege) local user able to open a filesystem that does not support the Filesystem Context API (and thus fallbacks to legacy handling) could use this flaw to escalate their privileges on the system.\n\n- CVE-2022-0544: An integer underflow in the DDS loader of Blender leads to an out-of-bounds read, possibly allowing an attacker to read sensitive data using a crafted DDS image file. This flaw affects Blender versions prior to 2.83.19, 2.93.8 and 3.1.\n\n- CVE-2022-20073: In preloader (usb), there is a possible out of bounds write due to a integer underflow. This could lead to local escalation of privilege, for an attacker who has physical access to the device, with no additional execution privileges needed. User interaction is needed for exploitation. Patch ID: ALPS06160841; Issue ID: ALPS06160841.\n\n- CVE-2022-20393: In extract3GPPGlobalDescriptions of TextDescriptions.cpp, there is a possible out of bounds read due to an integer overflow. This could lead to local information disclosure from the media server with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-11 Android-12 Android-12LAndroid ID: A-233735886\n\n- CVE-2022-20483: In several functions that parse avrc response in avrc_pars_ct.cc and related files, there are possible out of bounds reads due to integer overflows. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-242459126\n\n- CVE-2022-20516: In rw_t3t_act_handle_check_ndef_rsp of rw_t3t.cc, there is a possible out of bounds read due to an integer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-224002331\n\n- CVE-2022-23613: xrdp is an open source remote desktop protocol (RDP) server. In affected versions an integer underflow leading to a heap overflow in the sesman server allows any unauthenticated attacker which is able to locally access a sesman server to execute code as root. This vulnerability has been patched in version 0.9.18.1 and above. Users are advised to upgrade. There are no known workarounds.\n\n- CVE-2022-39293: Azure RTOS USBX is a high-performance USB host, device, and on-the-go (OTG) embedded stack, that is fully integrated with Azure RTOS ThreadX. The case is, in [_ux_host_class_pima_read](https://github.com/azure-rtos/usbx/blob/master/common/usbx_host_classes/src/ux_host_class_pima_read.c), there is data length from device response, returned in the very first packet, and read by [L165 code](https://github.com/azure-rtos/usbx/blob/082fd9db09a3669eca3358f10b8837a5c1635c0b/common/usbx_host_classes/src/ux_host_class_pima_read.c#L165), as header_length. Then in [L178 code](https://github.com/azure-rtos/usbx/blob/082fd9db09a3669eca3358f10b8837a5c1635c0b/common/usbx_host_classes/src/ux_host_class_pima_read.c#L178), there is a \u201cif\u201d branch, which check the expression of \u201c(header_length - UX_HOST_CLASS_PIMA_DATA_HEADER_SIZE) > data_length\u201d where if header_length is smaller than UX_HOST_CLASS_PIMA_DATA_HEADER_SIZE, calculation could overflow and then [L182 code](https://github.com/azure-rtos/usbx/blob/082fd9db09a3669eca3358f10b8837a5c1635c0b/common/usbx_host_classes/src/ux_host_class_pima_read.c#L182) the calculation of data_length is also overflow, this way the later [while loop start from L192](https://github.com/azure-rtos/usbx/blob/082fd9db09a3669eca3358f10b8837a5c1635c0b/common/usbx_host_classes/src/ux_host_class_pima_read.c#L192) can move data_pointer to unexpected address and cause write buffer overflow. The fix has been included in USBX release [6.1.12](https://github.com/azure-rtos/usbx/releases/tag/v6.1.12_rel). The following can be used as a workaround: Add check of `header_length`: 1. It must be greater than `UX_HOST_CLASS_PIMA_DATA_HEADER_SIZE`. 1. It should be greater or equal to the current returned data length (`transfer_request -> ux_transfer_request_actual_length`).\n\n- CVE-2022-4338: An integer underflow in Organization Specific TLV was found in various versions of OpenvSwitch.\n\n- CVE-2021-31956: Windows NTFS Elevation of Privilege Vulnerability\n\n- CVE-2022-22715: Named Pipe File System Elevation of Privilege Vulnerability\n\nRelated Weaknesses:\n\n- CWE-682 (ChildOf)\n\n- CWE-682 (ChildOf)",
        "type": "Base",
        "search_source": "base_query",
        "metadata": {
          "source": "sparse",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          }
        }
      },
      {
        "cwe_id": "770",
        "name": "Allocation of Resources Without Limits or Throttling",
        "description": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
        "score": 9.972354828241215,
        "matched_text": "CWE-770: Allocation of Resources Without Limits or Throttling\n\nType: Base\n\nStatus: Incomplete\n\nDescription:\n\nThe product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.\n\nExtended Details:\n\n\n\nCode frequently has to work with limited resources, so programmers must be careful to ensure that resources are not consumed too quickly, or too easily. Without use of quotas, resource limits, or other protection mechanisms, it can be easy for an attacker to consume many resources by rapidly making many requests, or causing larger resources to be used than is needed. When too many resources are allocated, or if a single resource is too large, then it can prevent the code from working correctly, possibly leading to a denial of service.\n\n\nReal-World Examples:\n\n- CVE-2022-21668: Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n\n- CVE-2009-4017: Language interpreter does not restrict the number of temporary files being created when handling a MIME request with a large number of parts..\n\n- CVE-2009-2726: Driver does not use a maximum width when invoking sscanf style functions, causing stack consumption.\n\n- CVE-2009-2540: Large integer value for a length property in an object causes a large amount of memory allocation.\n\n- CVE-2009-2054: Product allows exhaustion of file descriptors when processing a large number of TCP packets.\n\n- CVE-2008-5180: Communication product allows memory consumption with a large number of SIP requests, which cause many sessions to be created.\n\n- CVE-2008-1700: Product allows attackers to cause a denial of service via a large number of directives, each of which opens a separate window.\n\n- CVE-2005-4650: CMS does not restrict the number of searches that can occur simultaneously, leading to resource exhaustion.\n\n- CVE-2020-15100: web application scanner attempts to read an excessively large file created by a user, causing process termination\n\n- CVE-2020-7218: Go-based workload orchestrator does not limit resource usage with unauthenticated connections, allowing a DoS by flooding the service\n\nTop 25 CWE Examples:\n\n- CVE-2020-19463: An issue has been found in function vfprintf in PDF2JSON 0.70 that allows attackers to cause a Denial of Service due to a stack overflow.\n\n- CVE-2020-19464: An issue has been found in function XRef::fetch in PDF2JSON 0.70 that allows attackers to cause a Denial of Service due to a stack overflow .\n\n- CVE-2021-29324: OpenSource Moddable v10.5.0 was discovered to contain a stack overflow via the component /moddable/xs/sources/xsScript.c.\n\n- CVE-2021-29329: OpenSource Moddable v10.5.0 was discovered to contain a stack overflow in the fxBinaryExpressionNodeDistribute function at /moddable/xs/sources/xsTree.c.\n\n- CVE-2021-41800: MediaWiki before 1.36.2 allows a denial of service (resource consumption because of lengthy query processing time). Visiting Special:Contributions can sometimes result in a long running SQL query because PoolCounter protection is mishandled.\n\n- CVE-2021-35492: Wowza Streaming Engine through 4.8.11+5 could allow an authenticated, remote attacker to exhaust filesystem resources via the /enginemanager/server/vhost/historical.jsdata vhost parameter. This is due to the insufficient management of available filesystem resources. An attacker could exploit this vulnerability through the Virtual Host Monitoring section by requesting random virtual-host historical data and exhausting available filesystem resources. A successful exploit could allow the attacker to cause database errors and cause the device to become unresponsive to web-based management. (Manual intervention is required to free filesystem resources and return the application to an operational state.)\n\n- CVE-2021-22174: Crash in USB HID dissector in Wireshark 3.4.0 to 3.4.2 allows denial of service via packet injection or crafted capture file\n\n- CVE-2020-22785: Etherpad < 1.8.3 is affected by a missing lock check which could cause a denial of service. Aggressively targeting random pad import endpoints with empty data would flatten all pads due to lack of rate limiting and missing ownership check.\n\n- CVE-2021-33831: api/account/register in the TH Wildau COVID-19 Contact Tracing application through 2021-09-01 has Incorrect Access Control. An attacker can interfere with tracing of infection chains by creating 500 random users within 2500 seconds.\n\n- CVE-2020-28200: The Sieve engine in Dovecot before 2.3.15 allows Uncontrolled Resource Consumption, as demonstrated by a situation with a complex regular expression for the regex extension.\n\n- CVE-2021-41591: ACINQ Eclair before 0.6.3 allows loss of funds because of dust HTLC exposure.\n\n- CVE-2021-41592: Blockstream c-lightning through 0.10.1 allows loss of funds because of dust HTLC exposure.\n\n- CVE-2021-41593: Lightning Labs lnd before 0.13.3-beta allows loss of funds because of dust HTLC exposure.\n\n- CVE-2020-24821: A vulnerability in the dwarf::cursor::skip_form function of Libelfin v0.3 allows attackers to cause a denial of service (DOS) through a segmentation fault via a crafted ELF file.\n\n- CVE-2020-24822: A vulnerability in the dwarf::cursor::uleb function of Libelfin v0.3 allows attackers to cause a denial of service (DOS) through a segmentation fault via a crafted ELF file.\n\n- CVE-2020-24823: A vulnerability in the dwarf::to_string function of Libelfin v0.3 allows attackers to cause a denial of service (DOS) through a segmentation fault via a crafted ELF file.\n\n- CVE-2020-24825: A vulnerability in the line_table::line_table function of Libelfin v0.3 allows attackers to cause a denial of service (DOS) through a segmentation fault via a crafted ELF file.\n\n- CVE-2020-24826: A vulnerability in the elf::section::as_strtab function of Libelfin v0.3 allows attackers to cause a denial of service (DOS) through a segmentation fault via a crafted ELF file.\n\n- CVE-2021-0217: A vulnerability in processing of certain DHCP packets from adjacent clients on EX Series and QFX Series switches running Juniper Networks Junos OS with DHCP local/relay server configured may lead to exhaustion of DMA memory causing a Denial of Service (DoS). Over time, exploitation of this vulnerability may cause traffic to stop being forwarded, or to crashing of the fxpc process. When Packet DMA heap utilization reaches 99%, the system will become unstable. Packet DMA heap utilization can be monitored through the following command: user@junos# request pfe execute target fpc0 timeout 30 command \"show heap\" ID Base Total(b) Free(b) Used(b) % Name -- ---------- ----------- ----------- ----------- --- ----------- 0 213301a8 536870488 387228840 149641648 27 Kernel 1 91800000 8388608 3735120 4653488 55 DMA 2 92000000 75497472 74452192 1045280 1 PKT DMA DESC 3 d330000 335544320 257091400 78452920 23 Bcm_sdk 4 96800000 184549376 2408 184546968 99 Packet DMA <--- 5 903fffe0 20971504 20971504 0 0 Blob An indication of the issue occurring may be observed through the following log messages: Dec 10 08:07:00.124 2020 hostname fpc0 brcm_pkt_buf_alloc:523 (buf alloc) failed allocating packet buffer Dec 10 08:07:00.126 2020 hostname fpc0 (buf alloc) failed allocating packet buffer Dec 10 08:07:00.128 2020 hostname fpc0 brcm_pkt_buf_alloc:523 (buf alloc) failed allocating packet buffer Dec 10 08:07:00.130 2020 hostnameC fpc0 (buf alloc) failed allocating packet buffer This issue affects Juniper Networks Junos OS on EX Series and QFX Series: 17.4R3 versions prior to 17.4R3-S3; 18.1R3 versions between 18.1R3-S6 and 18.1R3-S11; 18.2R3 versions prior to 18.2R3-S6; 18.3R3 versions prior to 18.3R3-S4; 18.4R2 versions prior to 18.4R2-S5; 18.4R3 versions prior to 18.4R3-S6; 19.1 versions between 19.1R2 and 19.1R3-S3; 19.2 versions prior to 19.2R3-S1; 19.3 versions prior to 19.3R2-S5, 19.3R3; 19.4 versions prior to 19.4R2-S2, 19.4R3; 20.1 versions prior to 20.1R2; 20.2 versions prior to 20.2R1-S2, 20.2R2. Junos OS versions prior to 17.4R3 are unaffected by this vulnerability.\n\n- CVE-2021-0242: A vulnerability due to the improper handling of direct memory access (DMA) buffers on EX4300 switches on Juniper Networks Junos OS allows an attacker sending specific unicast frames to trigger a Denial of Service (DoS) condition by exhausting DMA buffers, causing the FPC to crash and the device to restart. The DMA buffer leak is seen when receiving these specific, valid unicast frames on an interface without Layer 2 Protocol Tunneling (L2PT) or dot1x configured. Interfaces with either L2PT or dot1x configured are not vulnerable to this issue. When this issue occurs, DMA buffer usage keeps increasing and the following error log messages may be observed: Apr 14 14:29:34.360 /kernel: pid 64476 (pfex_junos), uid 0: exited on signal 11 (core dumped) Apr 14 14:29:33.790 init: pfe-manager (PID 64476) terminated by signal number 11. Core dumped! The DMA buffers on the FPC can be monitored by the executing vty command 'show heap': ID Base Total(b) Free(b) Used(b) % Name -- ---------- ----------- ----------- ----------- --- ----------- 0 4a46000 268435456 238230496 30204960 11 Kernel 1 18a46000 67108864 17618536 49490328 73 Bcm_sdk 2 23737000 117440512 18414552 99025960 84 DMA buf <<<<< keeps increasing 3 2a737000 16777216 16777216 0 0 DMA desc This issue affects Juniper Networks Junos OS on the EX4300: 17.3 versions prior to 17.3R3-S11; 17.4 versions prior to 17.4R2-S13, 17.4R3-S4; 18.1 versions prior to 18.1R3-S12; 18.2 versions prior to 18.2R2-S8, 18.2R3-S7; 18.3 versions prior to 18.3R3-S4; 18.4 versions prior to 18.4R1-S8, 18.4R2-S7, 18.4R3-S7; 19.1 versions prior to 19.1R1-S6, 19.1R2-S2, 19.1R3-S4; 19.2 versions prior to 19.2R1-S6, 19.2R3-S2; 19.3 versions prior to 19.3R3-S2; 19.4 versions prior to 19.4R2-S3, 19.4R3-S1; 20.1 versions prior to 20.1R2; 20.2 versions prior to 20.2R2-S1, 20.2R3; 20.3 versions prior to 20.3R1-S1, 20.3R2.\n\n- CVE-2021-0338: In SystemSettingsValidators, there is a possible permanent denial of service due to missing bounds checks on UI settings. This could lead to local denial of service with User execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11Android ID: A-156260178\n\n- CVE-2021-0420: In memory management driver, there is a possible system crash due to a missing bounds check. This could lead to local denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05403499; Issue ID: ALPS05381065.\n\n- CVE-2021-0422: In memory management driver, there is a possible system crash due to a missing bounds check. This could lead to local denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05403499; Issue ID: ALPS05381071.\n\n- CVE-2021-0424: In memory management driver, there is a possible system crash due to a missing bounds check. This could lead to local denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS05403499; Issue ID: ALPS05393787.\n\n- CVE-2021-20185: It was found in Moodle before version 3.10.1, 3.9.4, 3.8.7 and 3.5.16 that messaging did not impose a character limit when sending messages, which could result in client-side (browser) denial of service for users receiving very large messages.\n\n- CVE-2021-29430: Sydent is a reference Matrix identity server. Sydent does not limit the size of requests it receives from HTTP clients. A malicious user could send an HTTP request with a very large body, leading to memory exhaustion and denial of service. Sydent also does not limit response size for requests it makes to remote Matrix homeservers. A malicious homeserver could return a very large response, again leading to memory exhaustion and denial of service. This affects any server which accepts registration requests from untrusted clients. This issue has been patched by releases 89071a1, 0523511, f56eee3. As a workaround request sizes can be limited in an HTTP reverse-proxy. There are no known workarounds for the problem with overlarge responses.\n\n- CVE-2021-29932: An issue was discovered in the parse_duration crate through 2021-03-18 for Rust. It allows attackers to cause a denial of service (CPU and memory consumption) via a duration string with a large exponent.\n\n- CVE-2021-32699: Wings is the control plane software for the open source Pterodactyl game management system. All versions of Pterodactyl Wings prior to `1.4.4` are vulnerable to system resource exhaustion due to improper container process limits being defined. A malicious user can consume more resources than intended and cause downstream impacts to other clients on the same hardware, eventually causing the physical server to stop responding. Users should upgrade to `1.4.4` to mitigate the issue. There is no non-code based workaround for impacted versions of the software. Users running customized versions of this software can manually set a PID limit for containers created.\n\n- CVE-2021-3478: There's a flaw in OpenEXR's scanline input file functionality in versions before 3.0.0-beta. An attacker able to submit a crafted file to be processed by OpenEXR could consume excessive system memory. The greatest impact of this flaw is to system availability.\n\n- CVE-2021-38463: The affected product does not properly control the allocation of resources. A user may be able to allocate unlimited memory buffers using API functions.\n\n- CVE-2021-38465: The webinstaller is a Golang web server executable that enables the generation of an Auvesy image agent. Resource consumption can be achieved by generating large amounts of installations, which are then saved without limitation in the temp folder of the webinstaller executable.\n\n- CVE-2021-3912: OctoRPKI tries to load the entire contents of a repository in memory, and in the case of a GZIP bomb, unzip it in memory, making it possible to create a repository that makes OctoRPKI run out of memory (and thus crash).\n\n- CVE-2021-41546: A vulnerability has been identified in RUGGEDCOM ROX MX5000 (All versions < V2.14.1), RUGGEDCOM ROX RX1400 (All versions < V2.14.1), RUGGEDCOM ROX RX1500 (All versions < V2.14.1), RUGGEDCOM ROX RX1501 (All versions < V2.14.1), RUGGEDCOM ROX RX1510 (All versions < V2.14.1), RUGGEDCOM ROX RX1511 (All versions < V2.14.1), RUGGEDCOM ROX RX1512 (All versions < V2.14.1), RUGGEDCOM ROX RX1524 (All versions < V2.14.1), RUGGEDCOM ROX RX1536 (All versions < V2.14.1), RUGGEDCOM ROX RX5000 (All versions < V2.14.1). Affected devices write crashdumps without checking if enough space is available on the filesystem. Once the crashdump fills the entire root filesystem, affected devices fail to boot successfully. An attacker can leverage this vulnerability to cause a permanent Denial-of-Service.\n\n- CVE-2021-21274: Synapse is a Matrix reference homeserver written in python (pypi package matrix-synapse). Matrix is an ecosystem for open federated Instant Messaging and VoIP. In Synapse before version 1.25.0, a malicious homeserver could redirect requests to their .well-known file to a large file. This can lead to a denial of service attack where homeservers will consume significantly more resources when requesting the .well-known file of a malicious homeserver. This affects any server which accepts federation requests from untrusted servers. Issue is resolved in version 1.25.0. As a workaround the `federation_domain_whitelist` setting can be used to restrict the homeservers communicated with over federation.\n\n- CVE-2021-21294: Http4s (http4s-blaze-server) is a minimal, idiomatic Scala interface for HTTP services. Http4s before versions 0.21.17, 0.22.0-M2, and 1.0.0-M14 have a vulnerability which can lead to a denial-of-service. Blaze-core, a library underlying http4s-blaze-server, accepts connections unboundedly on its selector pool. This has the net effect of amplifying degradation in services that are unable to handle their current request load, since incoming connections are still accepted and added to an unbounded queue. Each connection allocates a socket handle, which drains a scarce OS resource. This can also confound higher level circuit breakers which work based on detecting failed connections. http4s provides a general \"MaxActiveRequests\" middleware mechanism for limiting open connections, but it is enforced inside the Blaze accept loop, after the connection is accepted and the socket opened. Thus, the limit only prevents the number of connections which can be simultaneously processed, not the number of connections which can be held open. In 0.21.17, 0.22.0-M2, and 1.0.0-M14, a new \"maxConnections\" property, with a default value of 1024, has been added to the `BlazeServerBuilder`. Setting the value to a negative number restores unbounded behavior, but is strongly disrecommended. The NIO2 backend does not respect `maxConnections`. Its use is now deprecated in http4s-0.21, and the option is removed altogether starting in http4s-0.22. There are several possible workarounds described in the refrenced GitHub Advisory GHSA-xhv5-w9c5-2r2w.\n\n- CVE-2021-23053: On version 15.1.x before 15.1.3, 14.1.x before 14.1.3.1, and 13.1.x before 13.1.3.6, when the brute force protection feature of BIG-IP Advanced WAF or BIG-IP ASM is enabled on a virtual server and the virtual server is under brute force attack, the MySQL database may run out of disk space due to lack of row limit on undisclosed tables in the MYSQL database. Note: Software versions which have reached End of Technical Support (EoTS) are not evaluated.\n\n- CVE-2021-41167: modern-async is an open source JavaScript tooling library for asynchronous operations using async/await and promises. In affected versions a bug affecting two of the functions in this library: forEachSeries and forEachLimit. They should limit the concurrency of some actions but, in practice, they don't. Any code calling these functions will be written thinking they would limit the concurrency but they won't. This could lead to potential security issues in other projects. The problem has been patched in 1.0.4. There is no workaround.\n\n- CVE-2021-42262: An issue was discovered in Softing OPC UA C++ SDK before 5.70. An invalid XML element in the type dictionary makes the OPC/UA client crash due to an out-of-memory condition.\n\n- CVE-2020-35210: A vulnerability in Atomix v3.1.5 allows attackers to cause a denial of service (DoS) via a Raft session flooding attack using Raft OpenSessionRequest messages.\n\n- CVE-2021-32476: A denial-of-service risk was identified in the draft files area, due to it not respecting user file upload limits. Moodle versions 3.10 to 3.10.3, 3.9 to 3.9.6, 3.8 to 3.8.8, 3.5 to 3.5.17 and earlier unsupported versions are affected.\n\n- CVE-2021-43662: totolink EX300_v2, ver V4.0.3c.140_B20210429 and A720R ,ver V4.1.5cu.470_B20200911 have an issue which causes uncontrolled resource consumption.\n\n- CVE-2020-3566: A vulnerability in the Distance Vector Multicast Routing Protocol (DVMRP) feature of Cisco IOS XR Software could allow an unauthenticated, remote attacker to exhaust process memory of an affected device. The vulnerability is due to insufficient queue management for Internet Group Management Protocol (IGMP) packets. An attacker could exploit this vulnerability by sending crafted IGMP traffic to an affected device. A successful exploit could allow the attacker to cause memory exhaustion, resulting in instability of other processes. These processes may include, but are not limited to, interior and exterior routing protocols. Cisco will release software updates that address this vulnerability.\n\n- CVE-2020-3569: Multiple vulnerabilities in the Distance Vector Multicast Routing Protocol (DVMRP) feature of Cisco IOS XR Software could allow an unauthenticated, remote attacker to either immediately crash the Internet Group Management Protocol (IGMP) process or make it consume available memory and eventually crash. The memory consumption may negatively impact other processes that are running on the device. These vulnerabilities are due to the incorrect handling of IGMP packets. An attacker could exploit these vulnerabilities by sending crafted IGMP traffic to an affected device. A successful exploit could allow the attacker to immediately crash the IGMP process or cause memory exhaustion, resulting in other processes becoming unstable. These processes may include, but are not limited to, interior and exterior routing protocols. Cisco will release software updates that address these vulnerabilities.\n\n- CVE-2021-44988: Jerryscript v3.0.0 and below was discovered to contain a stack overflow via ecma_find_named_property in ecma-helpers.c.\n\n- CVE-2021-46050: A Stack Overflow vulnerability exists in Binaryen 103 via the printf_common function.\n\n- CVE-2022-29503: A memory corruption vulnerability exists in the libpthread linuxthreads functionality of uClibC 0.9.33.2 and uClibC-ng 1.0.40. Thread allocation can lead to memory corruption. An attacker can create threads to trigger this vulnerability.\n\n- CVE-2022-35107: SWFTools commit 772e55a2 was discovered to contain a stack overflow via vfprintf at /stdio-common/vfprintf.c.\n\n- CVE-2022-35111: SWFTools commit 772e55a2 was discovered to contain a stack overflow via __sanitizer::StackDepotNode::hash(__sanitizer::StackTrace const&) at /sanitizer_common/sanitizer_stackdepot.cpp.\n\n- CVE-2022-21716: Twisted is an event-based framework for internet applications, supporting Python 3.6+. Prior to 22.2.0, Twisted SSH client and server implement is able to accept an infinite amount of data for the peer's SSH version identifier. This ends up with a buffer using all the available memory. The attach is a simple as `nc -rv localhost 22 < /dev/zero`. A patch is available in version 22.2.0. There are currently no known workarounds.\n\n- CVE-2022-41288: A vulnerability has been identified in JT2Go (All versions < V14.1.0.6), Teamcenter Visualization V13.2 (All versions < V13.2.0.12), Teamcenter Visualization V13.3 (All versions < V13.3.0.8), Teamcenter Visualization V14.0 (All versions < V14.0.0.4), Teamcenter Visualization V14.1 (All versions < V14.1.0.6). The CGM_NIST_Loader.dll contains stack exhaustion vulnerability when parsing a CGM file. An attacker could leverage this vulnerability to crash the application causing denial of service condition.\n\n- CVE-2022-32559: An issue was discovered in Couchbase Server before 7.0.4. Random HTTP requests lead to leaked metrics.\n\n- CVE-2022-3273: Allocation of Resources Without Limits or Throttling in GitHub repository ikus060/rdiffweb prior to 2.5.0a4.\n\n- CVE-2021-3669: A flaw was found in the Linux kernel. Measuring usage of the shared memory does not scale with large shared memory segment counts which could lead to resource exhaustion and DoS.\n\n- CVE-2021-3759: A memory overflow vulnerability was found in the Linux kernel\u2019s ipc functionality of the memcg subsystem, in the way a user calls the semget function multiple times, creating semaphores. This flaw allows a local user to starve the resources, causing a denial of service. The highest threat from this vulnerability is to system availability.\n\n- CVE-2022-1708: A vulnerability was found in CRI-O that causes memory or disk space exhaustion on the node for anyone with access to the Kube API. The ExecSync request runs commands in a container and logs the output of the command. This output is then read by CRI-O after command execution, and it is read in a manner where the entire file corresponding to the output of the command is read in. Thus, if the output of the command is large it is possible to exhaust the memory or the disk space of the node when CRI-O reads the output of the command. The highest threat from this vulnerability is system availability.\n\n- CVE-2022-20143: In addAutomaticZenRule of ZenModeHelper.java, there is a possible permanent denial of service due to resource exhaustion. This could lead to local denial of service with User execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12LAndroid ID: A-220735360\n\n- CVE-2022-20478: In NotificationChannel of NotificationChannel.java, there is a possible failure to persist permissions settings due to resource exhaustion. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-241764135\n\n- CVE-2022-20479: In NotificationChannel of NotificationChannel.java, there is a possible failure to persist permissions settings due to resource exhaustion. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-241764340\n\n- CVE-2022-20480: In NotificationChannel of NotificationChannel.java, there is a possible failure to persist permissions settings due to resource exhaustion. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-241764350\n\n- CVE-2022-20484: In NotificationChannel of NotificationChannel.java, there is a possible failure to persist permissions settings due to resource exhaustion. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-242702851\n\n- CVE-2022-20485: In NotificationChannel of NotificationChannel.java, there is a possible failure to persist permissions settings due to resource exhaustion. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-242702935\n\n- CVE-2022-20486: In NotificationChannel of NotificationChannel.java, there is a possible failure to persist permissions settings due to resource exhaustion. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-242703118\n\n- CVE-2022-20487: In NotificationChannel of NotificationChannel.java, there is a possible failure to persist permissions settings due to resource exhaustion. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10 Android-11 Android-12 Android-12L Android-13Android ID: A-242703202\n\n- CVE-2022-21952: A Missing Authentication for Critical Function vulnerability in spacewalk-java of SUSE Manager Server 4.1, SUSE Manager Server 4.2 allows remote attackers to easily exhaust available disk resources leading to DoS. This issue affects: SUSE Manager Server 4.1 spacewalk-java versions prior to 4.1.46. SUSE Manager Server 4.2 spacewalk-java versions prior to 4.2.37. \n\n- CVE-2022-23487: js-libp2p is the official javascript Implementation of libp2p networking stack. Versions older than `v0.38.0` of js-libp2p are vulnerable to targeted resource exhaustion attacks. These attacks target libp2p\u2019s connection, stream, peer, and memory management. An attacker can cause the allocation of large amounts of memory, ultimately leading to the process getting killed by the host\u2019s operating system. While a connection manager tasked with keeping the number of connections within manageable limits has been part of js-libp2p, this component was designed to handle the regular churn of peers, not a targeted resource exhaustion attack. Users are advised to update their js-libp2p dependency to `v0.38.0` or greater. There are no known workarounds for this vulnerability.\n\n- CVE-2022-23492: go-libp2p is the offical libp2p implementation in the Go programming language. Version `0.18.0` and older of go-libp2p are vulnerable to targeted resource exhaustion attacks. These attacks target libp2p\u2019s connection, stream, peer, and memory management. An attacker can cause the allocation of large amounts of memory, ultimately leading to the process getting killed by the host\u2019s operating system. While a connection manager tasked with keeping the number of connections within manageable limits has been part of go-libp2p, this component was designed to handle the regular churn of peers, not a targeted resource exhaustion attack. Users are advised to upgrade their version of go-libp2p to version `0.18.1` or newer. Users unable to upgrade may consult the denial of service (dos) mitigation page for more information on how to incorporate mitigation strategies, monitor your application, and respond to attacks.\n\n- CVE-2022-23913: In Apache ActiveMQ Artemis prior to 2.20.0 or 2.19.1, an attacker could partially disrupt availability (DoS) through uncontrolled resource consumption of memory.\n\n- CVE-2022-2406: The legacy Slack import feature in Mattermost version 6.7.0 and earlier fails to properly limit the sizes of imported files, which allows an authenticated attacker to crash the server by importing large files via the Slack import REST API.\n\n- CVE-2022-28871: A Denial-of-Service (DoS) vulnerability was discovered in F-Secure Atlant whereby the fsicapd component used in certain F-Secure products while scanning larger packages/fuzzed files consume too much memory eventually can crash the scanning engine. The exploit can be triggered remotely by an attacker.\n\n- CVE-2022-31075: KubeEdge is an open source system for extending native containerized application orchestration capabilities to hosts at Edge. Prior to versions 1.11.1, 1.10.2, and 1.9.4, EdgeCore may be susceptible to a DoS attack on CloudHub if an attacker was to send a well-crafted HTTP request to `/edge.crt`. If an attacker can send a well-crafted HTTP request to CloudHub, and that request has a very large body, that request can crash the HTTP service through a memory exhaustion vector. The request body is being read into memory, and a body that is larger than the available memory can lead to a successful attack. Because the request would have to make it through authorization, only authorized users may perform this attack. The consequence of the exhaustion is that CloudHub will be in denial of service. KubeEdge is affected only when users enable the CloudHub module in the file `cloudcore.yaml`. This bug has been fixed in Kubeedge 1.11.1, 1.10.2, and 1.9.4. As a workaround, disable the CloudHub switch in the config file `cloudcore.yaml`.\n\n- CVE-2022-31078: KubeEdge is an open source system for extending native containerized application orchestration capabilities to hosts at Edge. Prior to versions 1.11.1, 1.10.2, and 1.9.4, the CloudCore Router does not impose a limit on the size of responses to requests made by the REST handler. An attacker could use this weakness to make a request that will return an HTTP response with a large body and cause DoS of CloudCore. In the HTTP Handler API, the rest handler makes a request to a pre-specified handle. The handle will return an HTTP response that is then read into memory. The consequence of the exhaustion is that CloudCore will be in a denial of service. Only an authenticated user of the cloud can make an attack. It will be affected only when users enable `router` module in the config file `cloudcore.yaml`. This bug has been fixed in Kubeedge 1.11.1, 1.10.2, and 1.9.4. As a workaround, disable the router switch in the config file `cloudcore.yaml`.\n\n- CVE-2022-31079: KubeEdge is an open source system for extending native containerized application orchestration capabilities to hosts at Edge. Prior to versions 1.11.1, 1.10.2, and 1.9.4, the Cloud Stream server and the Edge Stream server reads the entire message into memory without imposing a limit on the size of this message. An attacker can exploit this by sending a large message to exhaust memory and cause a DoS. The Cloud Stream server and the Edge Stream server are under DoS attack in this case. The consequence of the exhaustion is that the CloudCore and EdgeCore will be in a denial of service. Only an authenticated user can cause this issue. It will be affected only when users enable `cloudStream` module in the config file `cloudcore.yaml` and enable `edgeStream` module in the config file `edgecore.yaml`. This bug has been fixed in Kubeedge 1.11.1, 1.10.2, and 1.9.4. As a workaround, disable cloudStream module in the config file `cloudcore.yaml` and disable edgeStream module in the config file `edgecore.yaml`.\n\n- CVE-2022-3147: Mattermost version 7.0.x and earlier fails to sufficiently limit the in-memory sizes of concurrently uploaded JPEG images, which allows authenticated users to cause resource exhaustion on specific system configurations, resulting in server-side Denial of Service.\n\n- CVE-2022-33749: XAPI open file limit DoS It is possible for an unauthenticated client on the network to cause XAPI to hit its file-descriptor limit. This causes XAPI to be unable to accept new requests for other (trusted) clients, and blocks XAPI from carrying out any tasks that require the opening of file descriptors.\n\n- CVE-2022-3423: Allocation of Resources Without Limits or Throttling in GitHub repository nocodb/nocodb prior to 0.92.0. \n\n- CVE-2022-35915: OpenZeppelin Contracts is a library for secure smart contract development. The target contract of an EIP-165 `supportsInterface` query can cause unbounded gas consumption by returning a lot of data, while it is generally assumed that this operation has a bounded cost. The issue has been fixed in v4.7.2. Users are advised to upgrade. There are no known workarounds for this issue.\n\n- CVE-2022-41932: XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. It's possible to make XWiki create many new schemas and fill them with tables just by using a crafted user identifier in the login form. This may lead to degraded database performance. The problem has been patched in XWiki 13.10.8, 14.6RC1 and 14.4.2. Users are advised to upgrade. There are no known workarounds for this issue.\n\n- CVE-2022-2134: Allocation of Resources Without Limits or Throttling in GitHub repository inventree/inventree prior to 0.8.0.\n\n- CVE-2022-43686: In Concrete CMS (formerly concrete5) below 8.5.10 and between 9.0.0 and 9.1.2, the authTypeConcreteCookieMap table can be filled up causing a denial of service (high load).\n\n- CVE-2022-41725: A denial of service is possible from excessive resource consumption in net/http and mime/multipart. Multipart form parsing with mime/multipart.Reader.ReadForm can consume largely unlimited amounts of memory and disk files. This also affects form parsing in the net/http package with the Request methods FormFile, FormValue, ParseMultipartForm, and PostFormValue. ReadForm takes a maxMemory parameter, and is documented as storing \"up to maxMemory bytes +10MB (reserved for non-file parts) in memory\". File parts which cannot be stored in memory are stored on disk in temporary files. The unconfigurable 10MB reserved for non-file parts is excessively large and can potentially open a denial of service vector on its own. However, ReadForm did not properly account for all memory consumed by a parsed form, such as map entry overhead, part names, and MIME headers, permitting a maliciously crafted form to consume well over 10MB. In addition, ReadForm contained no limit on the number of disk files created, permitting a relatively small request body to create a large number of disk temporary files. With fix, ReadForm now properly accounts for various forms of memory overhead, and should now stay within its documented limit of 10MB + maxMemory bytes of memory consumption. Users should still be aware that this limit is high and may still be hazardous. In addition, ReadForm now creates at most one on-disk temporary file, combining multiple form parts into a single temporary file. The mime/multipart.File interface type's documentation states, \"If stored on disk, the File's underlying concrete type will be an *os.File.\". This is no longer the case when a form contains more than one file part, due to this coalescing of parts into a single file. The previous behavior of using distinct files for each form part may be reenabled with the environment variable GODEBUG=multipartfiles=distinct. Users should be aware that multipart.ReadForm and the http.Request methods that call it do not limit the amount of disk consumed by temporary files. Callers can limit the size of form data with http.MaxBytesReader.\n\nRelated Weaknesses:\n\n- CWE-400 (ChildOf)\n\n- CWE-665 (ChildOf)\n\n- CWE-400 (ChildOf)",
        "type": "Base",
        "search_source": "base_query",
        "metadata": {
          "source": "sparse",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          }
        }
      }
    ],
    "graph_results": [
      {
        "doc_id": "123",
        "text": "CWE-123: Write-what-where Condition",
        "score": 3.5671999999999997,
        "metadata": {
          "doc_id": "123",
          "name": "Write-what-where Condition",
          "type": "base",
          "original_content": "CWE-123: Write-what-where Condition",
          "relationships": [
            {
              "source_id": "123",
              "target_id": "590",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "123",
              "target_id": "479",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "123",
              "target_id": "416",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "123",
              "target_id": "364",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "123",
              "target_id": "134",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "123",
              "target_id": "120",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "123",
              "target_id": "119",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1340"
              }
            },
            {
              "source_id": "123",
              "target_id": "119",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1305"
              }
            },
            {
              "source_id": "123",
              "target_id": "787",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "787",
              "target_id": "123",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "590",
              "target_id": "123",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "479",
              "target_id": "123",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "416",
              "target_id": "123",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "415",
              "target_id": "123",
              "label": "PEEROF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "364",
              "target_id": "123",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "134",
              "target_id": "123",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "120",
              "target_id": "123",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "119",
              "target_id": "123",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1305"
              }
            }
          ],
          "score_components": {
            "relationship_chain": 1.0,
            "abstraction_path": 0.7200000000000001,
            "sequence_path": 1.0,
            "peer_group": 0.9
          },
          "abstraction_factor": 1.3,
          "graph_path_info": {
            "path_types": [
              "relationship_chain",
              "abstraction_path_down",
              "vulnerability_sequence_forward",
              "peer_relationship"
            ],
            "best_paths": {
              "relationship_chain": {
                "path": [
                  [
                    "416",
                    "123",
                    "CANPRECEDE"
                  ]
                ],
                "score": 1.0,
                "type": "relationship_chain",
                "source": "416"
              },
              "abstraction_path_down": {
                "path": [
                  [
                    "787",
                    "123",
                    "PARENTOF"
                  ]
                ],
                "score": 0.7200000000000001,
                "type": "abstraction_path_down",
                "source": "787"
              },
              "vulnerability_sequence_forward": {
                "path": [
                  [
                    "416",
                    "123",
                    "CANPRECEDE"
                  ]
                ],
                "score": 1.0,
                "type": "vulnerability_sequence_forward",
                "source": "416"
              },
              "peer_relationship": {
                "path": [
                  [
                    "415",
                    "123",
                    "PEEROF"
                  ]
                ],
                "score": 0.9,
                "type": "peer_relationship",
                "source": "415"
              }
            }
          },
          "abstraction_level": "base",
          "position": "after",
          "sources": [
            "graph"
          ],
          "source": "graph",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "graph"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "graph": 3.5671999999999997
            }
          }
        },
        "similarity": 3.5671999999999997
      },
      {
        "doc_id": "843",
        "text": "The product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.",
        "score": 0.6087283403376947,
        "metadata": {
          "doc_id": "843",
          "name": "Access of Resource Using Incompatible Type ('Type Confusion')",
          "type": "Base",
          "extended_description": "\n\nWhen the product accesses the resource using an incompatible type, this could trigger logical errors because the resource does not have expected properties. In languages without memory safety, such as C and C++, type confusion can lead to out-of-bounds memory access.\n\n\nWhile this weakness is frequently associated with unions when parsing data with many different embedded object types in C, it can be present in any application that can interpret the same variable or memory location in multiple ways.\n\n\nThis weakness is not unique to C and C++. For example, errors in PHP applications can be triggered by providing array parameters when scalars are expected, or vice versa. Languages such as Perl, which perform automatic conversion of a variable of one type when it is accessed as if it were another type, can also contain these issues.\n",
          "alternate_terms": [
            "Object Type Confusion"
          ],
          "original_content": "The product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.",
          "relationships": [
            {
              "source_id": "843",
              "target_id": "119",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "843",
              "target_id": "704",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1003"
              }
            },
            {
              "source_id": "843",
              "target_id": "704",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "704",
              "target_id": "843",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "1287",
              "target_id": "843",
              "label": "PEEROF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "119",
              "target_id": "843",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            }
          ],
          "source": "graph",
          "sources": [
            "vector",
            "graph"
          ],
          "vector_score": 0.6087283403376947,
          "graph_score": 3.8038000000000003,
          "score_components": {
            "relationship_chain": 0.8,
            "explicit_mention": 1.0,
            "abstraction_path": 0.9,
            "sequence_path": 0.7200000000000001
          },
          "abstraction_factor": 1.3,
          "graph_path_info": {
            "path_types": [
              "relationship_chain",
              "vulnerability_sequence_forward"
            ],
            "best_paths": {
              "relationship_chain": {
                "path": [
                  [
                    "1260",
                    "119",
                    "CANPRECEDE"
                  ],
                  [
                    "119",
                    "843",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.8,
                "type": "relationship_chain",
                "source": "1260"
              },
              "vulnerability_sequence_forward": {
                "path": [
                  [
                    "1260",
                    "119",
                    "CANPRECEDE"
                  ],
                  [
                    "119",
                    "843",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.7200000000000001,
                "type": "vulnerability_sequence_forward",
                "source": "1260"
              }
            }
          },
          "is_explicit": true,
          "abstraction_level": "base",
          "position": "after",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense",
              "sparse",
              "graph"
            ],
            "retriever_count": 3,
            "normalized_scores": {
              "dense": 0.5532373381039504,
              "sparse": 67.60603023958426,
              "graph": 2.5257713361350778
            }
          }
        },
        "similarity": 2.5257713361350778
      },
      {
        "doc_id": "1260",
        "text": "The product allows address regions to overlap, which can result in the bypassing of intended memory protection.",
        "score": 0.5771677994437826,
        "metadata": {
          "doc_id": "1260",
          "name": "Improper Handling of Overlap Between Protected Memory Ranges",
          "type": "Base",
          "extended_description": "\n\nIsolated memory regions and access control (read/write) policies are used by hardware to protect privileged software. Software components are often allowed to change or remap memory region definitions in order to enable flexible and dynamically changeable memory management by system software.\n\n\nIf a software component running at lower privilege can program a memory address region to overlap with other memory regions used by software running at higher privilege, privilege escalation may be available to attackers. The memory protection unit (MPU) logic can incorrectly handle such an address overlap and allow the lower-privilege software to read or write into the protected memory region, resulting in privilege escalation attack. An address overlap weakness can also be used to launch a denial of service attack on the higher-privilege software memory regions.\n",
          "alternate_terms": [],
          "original_content": "The product allows address regions to overlap, which can result in the bypassing of intended memory protection.",
          "relationships": [
            {
              "source_id": "1260",
              "target_id": "119",
              "label": "CANPRECEDE",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "1260",
              "target_id": "284",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "284",
              "target_id": "1260",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "119",
              "target_id": "1260",
              "label": "CANFOLLOW",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            }
          ],
          "source": "graph",
          "sources": [
            "vector",
            "graph"
          ],
          "vector_score": 0.5771677994437826,
          "graph_score": 3.5698000000000003,
          "score_components": {
            "relationship_chain": 0.6,
            "explicit_mention": 1.0,
            "abstraction_path": 0.9,
            "sequence_path": 0.7200000000000001
          },
          "abstraction_factor": 1.3,
          "graph_path_info": {
            "path_types": [
              "relationship_chain",
              "vulnerability_sequence_forward"
            ],
            "best_paths": {
              "relationship_chain": {
                "path": [
                  [
                    "415",
                    "123",
                    "PEEROF"
                  ],
                  [
                    "123",
                    "119",
                    "CHILDOF"
                  ],
                  [
                    "119",
                    "1260",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.6,
                "type": "relationship_chain",
                "source": "415"
              },
              "vulnerability_sequence_forward": {
                "path": [
                  [
                    "843",
                    "119",
                    "CANPRECEDE"
                  ],
                  [
                    "119",
                    "1260",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.7200000000000001,
                "type": "vulnerability_sequence_forward",
                "source": "843"
              }
            }
          },
          "is_explicit": true,
          "abstraction_level": "base",
          "position": "after",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense",
              "graph"
            ],
            "retriever_count": 2,
            "normalized_scores": {
              "dense": 0.5423218496153519,
              "graph": 2.372747119777513
            }
          }
        },
        "similarity": 2.372747119777513
      },
      {
        "doc_id": "416",
        "text": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
        "score": 0.5992290665367083,
        "metadata": {
          "doc_id": "416",
          "name": "Use After Free",
          "type": "Variant",
          "extended_description": null,
          "alternate_terms": [
            "Dangling pointer",
            "UAF",
            "Use-After-Free"
          ],
          "original_content": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
          "relationships": [
            {
              "source_id": "416",
              "target_id": "754",
              "label": "CANFOLLOW",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "416",
              "target_id": "364",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "416",
              "target_id": "362",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "416",
              "target_id": "1265",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "416",
              "target_id": "123",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "416",
              "target_id": "120",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "416",
              "target_id": "672",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1340"
              }
            },
            {
              "source_id": "416",
              "target_id": "672",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1305"
              }
            },
            {
              "source_id": "416",
              "target_id": "672",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1003"
              }
            },
            {
              "source_id": "416",
              "target_id": "825",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "825",
              "target_id": "416",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "754",
              "target_id": "416",
              "label": "CANPRECEDE",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "672",
              "target_id": "416",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1003"
              }
            },
            {
              "source_id": "415",
              "target_id": "416",
              "label": "PEEROF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "364",
              "target_id": "416",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "362",
              "target_id": "416",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "1265",
              "target_id": "416",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "123",
              "target_id": "416",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "120",
              "target_id": "416",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            }
          ],
          "source": "graph",
          "sources": [
            "vector",
            "graph"
          ],
          "vector_score": 0.5992290665367083,
          "graph_score": 3.372,
          "score_components": {
            "relationship_chain": 0.7,
            "explicit_mention": 1.0,
            "sequence_path": 0.8,
            "peer_group": 0.9
          },
          "abstraction_factor": 1.2,
          "graph_path_info": {
            "path_types": [
              "relationship_chain",
              "vulnerability_sequence_forward",
              "peer_relationship"
            ],
            "best_paths": {
              "relationship_chain": {
                "path": [
                  [
                    "415",
                    "416",
                    "PEEROF"
                  ]
                ],
                "score": 0.7,
                "type": "relationship_chain",
                "source": "415"
              },
              "vulnerability_sequence_forward": {
                "path": [
                  [
                    "415",
                    "364",
                    "CANFOLLOW"
                  ],
                  [
                    "364",
                    "416",
                    "CANPRECEDE"
                  ]
                ],
                "score": 0.8,
                "type": "vulnerability_sequence_forward",
                "source": "415"
              },
              "peer_relationship": {
                "path": [
                  [
                    "415",
                    "416",
                    "PEEROF"
                  ]
                ],
                "score": 0.9,
                "type": "peer_relationship",
                "source": "415"
              }
            }
          },
          "is_explicit": true,
          "abstraction_level": "variant",
          "position": "after",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense",
              "sparse",
              "graph"
            ],
            "retriever_count": 3,
            "normalized_scores": {
              "dense": 0.5564290782764135,
              "sparse": 60.782740992322296,
              "graph": 2.262891626614683
            }
          }
        },
        "similarity": 2.262891626614683
      },
      {
        "doc_id": "415",
        "text": "The product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.",
        "score": 0.5710550232704926,
        "metadata": {
          "doc_id": "415",
          "name": "Double Free",
          "type": "Variant",
          "extended_description": "When a program calls free() twice with the same argument, the program's memory management data structures become corrupted. This corruption can cause the program to crash or, in some circumstances, cause two later calls to malloc() to return the same pointer. If malloc() returns the same value twice and the program later gives the attacker control over the data that is written into this doubly-allocated memory, the program becomes vulnerable to a buffer overflow attack.",
          "alternate_terms": [
            "Double-free"
          ],
          "original_content": "The product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.",
          "relationships": [
            {
              "source_id": "415",
              "target_id": "364",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "415",
              "target_id": "123",
              "label": "PEEROF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "415",
              "target_id": "416",
              "label": "PEEROF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "415",
              "target_id": "666",
              "label": "CHILDOF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "415",
              "target_id": "672",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1340"
              }
            },
            {
              "source_id": "415",
              "target_id": "672",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1305"
              }
            },
            {
              "source_id": "415",
              "target_id": "672",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1003"
              }
            },
            {
              "source_id": "415",
              "target_id": "1341",
              "label": "CHILDOF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "415",
              "target_id": "825",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "825",
              "target_id": "415",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "672",
              "target_id": "415",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1003"
              }
            },
            {
              "source_id": "666",
              "target_id": "415",
              "label": "PARENTOF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "364",
              "target_id": "415",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "1341",
              "target_id": "415",
              "label": "PARENTOF",
              "properties": {
                "view_id": "1000"
              }
            }
          ],
          "source": "graph",
          "sources": [
            "vector",
            "graph"
          ],
          "vector_score": 0.5710550232704926,
          "graph_score": 3.372,
          "score_components": {
            "explicit_mention": 1.0,
            "relationship_chain": 0.7,
            "sequence_path": 0.8,
            "peer_group": 0.9
          },
          "abstraction_factor": 1.2,
          "graph_path_info": {
            "path_types": [
              "relationship_chain",
              "vulnerability_sequence_forward",
              "peer_relationship"
            ],
            "best_paths": {
              "relationship_chain": {
                "path": [
                  [
                    "415",
                    "416",
                    "PEEROF"
                  ]
                ],
                "score": 0.7,
                "type": "relationship_chain",
                "source": "416"
              },
              "vulnerability_sequence_forward": {
                "path": [
                  [
                    "416",
                    "364",
                    "CANFOLLOW"
                  ],
                  [
                    "364",
                    "415",
                    "CANPRECEDE"
                  ]
                ],
                "score": 0.8,
                "type": "vulnerability_sequence_forward",
                "source": "416"
              },
              "peer_relationship": {
                "path": [
                  [
                    "415",
                    "416",
                    "PEEROF"
                  ]
                ],
                "score": 0.9,
                "type": "peer_relationship",
                "source": "416"
              }
            }
          },
          "is_explicit": true,
          "abstraction_level": "variant",
          "position": "after",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "sparse",
              "graph"
            ],
            "retriever_count": 2,
            "normalized_scores": {
              "sparse": 53.504177185489525,
              "graph": 2.2516220093081967
            }
          }
        },
        "similarity": 2.2516220093081967
      },
      {
        "doc_id": "364",
        "text": "CWE-364: Signal Handler Race Condition",
        "score": 2.2100000000000004,
        "metadata": {
          "doc_id": "364",
          "name": "Signal Handler Race Condition",
          "type": "base",
          "original_content": "CWE-364: Signal Handler Race Condition",
          "relationships": [
            {
              "source_id": "364",
              "target_id": "831",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "364",
              "target_id": "828",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "364",
              "target_id": "432",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "364",
              "target_id": "123",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "364",
              "target_id": "416",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "364",
              "target_id": "415",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "364",
              "target_id": "362",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "831",
              "target_id": "364",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "828",
              "target_id": "364",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "432",
              "target_id": "364",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "416",
              "target_id": "364",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "415",
              "target_id": "364",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "368",
              "target_id": "364",
              "label": "CANALSOBE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "362",
              "target_id": "364",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "123",
              "target_id": "364",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            }
          ],
          "score_components": {
            "relationship_chain": 1.0,
            "sequence_path": 1.0
          },
          "abstraction_factor": 1.3,
          "graph_path_info": {
            "path_types": [
              "relationship_chain",
              "vulnerability_sequence_forward",
              "vulnerability_sequence_backward"
            ],
            "best_paths": {
              "relationship_chain": {
                "path": [
                  [
                    "415",
                    "364",
                    "CANFOLLOW"
                  ]
                ],
                "score": 1.0,
                "type": "relationship_chain",
                "source": "415"
              },
              "vulnerability_sequence_forward": {
                "path": [
                  [
                    "415",
                    "364",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.9,
                "type": "vulnerability_sequence_forward",
                "source": "415"
              },
              "vulnerability_sequence_backward": {
                "path": [
                  [
                    "364",
                    "415",
                    "CANPRECEDE"
                  ]
                ],
                "score": 1.0,
                "type": "vulnerability_sequence_backward",
                "source": "415"
              }
            }
          },
          "position": "before",
          "sources": [
            "graph"
          ],
          "source": "graph",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "graph"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "graph": 2.2100000000000004
            }
          }
        },
        "similarity": 2.2100000000000004
      },
      {
        "doc_id": "825",
        "text": "CWE-825: Expired Pointer Dereference",
        "score": 2.2100000000000004,
        "metadata": {
          "doc_id": "825",
          "name": "Expired Pointer Dereference",
          "type": "base",
          "original_content": "CWE-825: Expired Pointer Dereference",
          "relationships": [
            {
              "source_id": "825",
              "target_id": "562",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "825",
              "target_id": "416",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "825",
              "target_id": "415",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "825",
              "target_id": "787",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "825",
              "target_id": "125",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "825",
              "target_id": "672",
              "label": "CHILDOF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "825",
              "target_id": "119",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1340"
              }
            },
            {
              "source_id": "825",
              "target_id": "119",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1305"
              }
            },
            {
              "source_id": "825",
              "target_id": "119",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "787",
              "target_id": "825",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "672",
              "target_id": "825",
              "label": "PARENTOF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "562",
              "target_id": "825",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "416",
              "target_id": "825",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "415",
              "target_id": "825",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "125",
              "target_id": "825",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "119",
              "target_id": "825",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            }
          ],
          "score_components": {
            "relationship_chain": 1.0,
            "sequence_path": 1.0
          },
          "abstraction_factor": 1.3,
          "graph_path_info": {
            "path_types": [
              "relationship_chain",
              "vulnerability_sequence_forward",
              "vulnerability_sequence_backward"
            ],
            "best_paths": {
              "relationship_chain": {
                "path": [
                  [
                    "787",
                    "825",
                    "CANFOLLOW"
                  ]
                ],
                "score": 1.0,
                "type": "relationship_chain",
                "source": "787"
              },
              "vulnerability_sequence_forward": {
                "path": [
                  [
                    "787",
                    "825",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.9,
                "type": "vulnerability_sequence_forward",
                "source": "787"
              },
              "vulnerability_sequence_backward": {
                "path": [
                  [
                    "825",
                    "787",
                    "CANPRECEDE"
                  ]
                ],
                "score": 1.0,
                "type": "vulnerability_sequence_backward",
                "source": "787"
              }
            }
          },
          "position": "before",
          "sources": [
            "graph"
          ],
          "source": "graph",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "graph"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "graph": 2.2100000000000004
            }
          }
        },
        "similarity": 2.2100000000000004
      },
      {
        "doc_id": "120",
        "text": "CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
        "score": 2.2100000000000004,
        "metadata": {
          "doc_id": "120",
          "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
          "type": "base",
          "original_content": "CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
          "relationships": [
            {
              "source_id": "120",
              "target_id": "785",
              "label": "PARENTOF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "120",
              "target_id": "456",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "120",
              "target_id": "416",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "120",
              "target_id": "231",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "120",
              "target_id": "170",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "120",
              "target_id": "20",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "700"
              }
            },
            {
              "source_id": "120",
              "target_id": "123",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "120",
              "target_id": "119",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1340"
              }
            },
            {
              "source_id": "120",
              "target_id": "119",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1305"
              }
            },
            {
              "source_id": "120",
              "target_id": "119",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1003"
              }
            },
            {
              "source_id": "120",
              "target_id": "119",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "785",
              "target_id": "120",
              "label": "CHILDOF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "456",
              "target_id": "120",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "416",
              "target_id": "120",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "231",
              "target_id": "120",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "20",
              "target_id": "120",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "700"
              }
            },
            {
              "source_id": "196",
              "target_id": "120",
              "label": "CANALSOBE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "170",
              "target_id": "120",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "123",
              "target_id": "120",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "119",
              "target_id": "120",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            }
          ],
          "score_components": {
            "relationship_chain": 1.0,
            "sequence_path": 1.0
          },
          "abstraction_factor": 1.3,
          "graph_path_info": {
            "path_types": [
              "relationship_chain",
              "vulnerability_sequence_forward"
            ],
            "best_paths": {
              "relationship_chain": {
                "path": [
                  [
                    "416",
                    "120",
                    "CANPRECEDE"
                  ]
                ],
                "score": 1.0,
                "type": "relationship_chain",
                "source": "416"
              },
              "vulnerability_sequence_forward": {
                "path": [
                  [
                    "416",
                    "120",
                    "CANPRECEDE"
                  ]
                ],
                "score": 1.0,
                "type": "vulnerability_sequence_forward",
                "source": "416"
              }
            }
          },
          "position": "after",
          "sources": [
            "graph"
          ],
          "source": "graph",
          "mapping_notes": {
            "usage": "Allowed-with-Review",
            "rationale": "There are some indications that this CWE ID might be misused and selected simply because it mentions \"buffer overflow\" - an increasingly vague term. This CWE entry is only appropriate for \"Buffer Copy\" operations (not buffer reads), in which where there is no \"Checking [the] Size of Input\", and (by implication of the copy) writing past the end of the buffer.",
            "comments": "If the vulnerability being analyzed involves out-of-bounds reads, then consider CWE-125 or descendants. For root cause analysis: if there is any input validation, consider children of CWE-20 such as CWE-1284. If there is a calculation error for buffer sizes, consider CWE-131 or similar.",
            "reasons": [
              "Frequent Misuse"
            ]
          },
          "score_info": {
            "retrievers": [
              "graph"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "graph": 2.2100000000000004
            }
          }
        },
        "similarity": 2.2100000000000004
      },
      {
        "doc_id": "1265",
        "text": "CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
        "score": 2.2100000000000004,
        "metadata": {
          "doc_id": "1265",
          "name": "Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
          "type": "base",
          "original_content": "CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
          "relationships": [
            {
              "source_id": "1265",
              "target_id": "416",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "1265",
              "target_id": "663",
              "label": "PEEROF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "1265",
              "target_id": "691",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "691",
              "target_id": "1265",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "416",
              "target_id": "1265",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            }
          ],
          "score_components": {
            "relationship_chain": 1.0,
            "sequence_path": 1.0
          },
          "abstraction_factor": 1.3,
          "graph_path_info": {
            "path_types": [
              "relationship_chain",
              "vulnerability_sequence_forward",
              "vulnerability_sequence_backward"
            ],
            "best_paths": {
              "relationship_chain": {
                "path": [
                  [
                    "416",
                    "1265",
                    "CANFOLLOW"
                  ]
                ],
                "score": 1.0,
                "type": "relationship_chain",
                "source": "416"
              },
              "vulnerability_sequence_forward": {
                "path": [
                  [
                    "416",
                    "1265",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.9,
                "type": "vulnerability_sequence_forward",
                "source": "416"
              },
              "vulnerability_sequence_backward": {
                "path": [
                  [
                    "1265",
                    "416",
                    "CANPRECEDE"
                  ]
                ],
                "score": 1.0,
                "type": "vulnerability_sequence_backward",
                "source": "416"
              }
            }
          },
          "position": "before",
          "sources": [
            "graph"
          ],
          "source": "graph",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "graph"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "graph": 2.2100000000000004
            }
          }
        },
        "similarity": 2.2100000000000004
      },
      {
        "doc_id": "122",
        "text": "CWE-122: Heap-based Buffer Overflow",
        "score": 2.1624,
        "metadata": {
          "doc_id": "122",
          "name": "Heap-based Buffer Overflow",
          "type": "variant",
          "original_content": "CWE-122: Heap-based Buffer Overflow",
          "relationships": [
            {
              "source_id": "122",
              "target_id": "787",
              "label": "CHILDOF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "122",
              "target_id": "788",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "788",
              "target_id": "122",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "787",
              "target_id": "122",
              "label": "PARENTOF",
              "properties": {
                "view_id": "1000"
              }
            }
          ],
          "score_components": {
            "relationship_chain": 0.3,
            "explicit_mention": 1.0,
            "abstraction_path": 0.76
          },
          "abstraction_factor": 1.2,
          "graph_path_info": {
            "path_types": [
              "relationship_chain",
              "abstraction_path_down"
            ],
            "best_paths": {
              "relationship_chain": {
                "path": [
                  [
                    "787",
                    "122",
                    "PARENTOF"
                  ]
                ],
                "score": 0.3,
                "type": "relationship_chain",
                "source": "787"
              },
              "abstraction_path_down": {
                "path": [
                  [
                    "787",
                    "122",
                    "PARENTOF"
                  ]
                ],
                "score": 0.76,
                "type": "abstraction_path_down",
                "source": "787"
              }
            }
          },
          "is_explicit": true,
          "abstraction_level": "variant",
          "sources": [
            "graph"
          ],
          "source": "graph",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense",
              "sparse",
              "graph"
            ],
            "retriever_count": 3,
            "normalized_scores": {
              "dense": 0.5070551867766302,
              "sparse": 59.76424520678538,
              "graph": 2.1624
            }
          }
        },
        "similarity": 2.1624
      },
      {
        "doc_id": "787",
        "text": "The product writes data past the end, or before the beginning, of the intended buffer.",
        "score": 0.6420077580310037,
        "metadata": {
          "doc_id": "787",
          "name": "Out-of-bounds Write",
          "type": "Base",
          "extended_description": null,
          "alternate_terms": [
            "Memory Corruption"
          ],
          "original_content": "The product writes data past the end, or before the beginning, of the intended buffer.",
          "relationships": [
            {
              "source_id": "787",
              "target_id": "825",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "787",
              "target_id": "824",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "787",
              "target_id": "823",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "787",
              "target_id": "822",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "787",
              "target_id": "124",
              "label": "PARENTOF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "787",
              "target_id": "123",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "787",
              "target_id": "122",
              "label": "PARENTOF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "787",
              "target_id": "121",
              "label": "PARENTOF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "787",
              "target_id": "119",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1340"
              }
            },
            {
              "source_id": "787",
              "target_id": "119",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1305"
              }
            },
            {
              "source_id": "787",
              "target_id": "119",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1003"
              }
            },
            {
              "source_id": "787",
              "target_id": "119",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "825",
              "target_id": "787",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "824",
              "target_id": "787",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "823",
              "target_id": "787",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "822",
              "target_id": "787",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "124",
              "target_id": "787",
              "label": "CHILDOF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "123",
              "target_id": "787",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "122",
              "target_id": "787",
              "label": "CHILDOF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "121",
              "target_id": "787",
              "label": "CHILDOF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "119",
              "target_id": "787",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            }
          ],
          "source": "graph",
          "sources": [
            "vector",
            "graph"
          ],
          "vector_score": 0.6420077580310037,
          "graph_score": 2.821,
          "score_components": {
            "relationship_chain": 0.6,
            "explicit_mention": 1.0,
            "abstraction_path": 0.9
          },
          "abstraction_factor": 1.3,
          "graph_path_info": {
            "path_types": [
              "relationship_chain",
              "abstraction_path_up"
            ],
            "best_paths": {
              "relationship_chain": {
                "path": [
                  [
                    "1260",
                    "119",
                    "CANPRECEDE"
                  ],
                  [
                    "119",
                    "822",
                    "PARENTOF"
                  ],
                  [
                    "822",
                    "787",
                    "CANPRECEDE"
                  ]
                ],
                "score": 0.6,
                "type": "relationship_chain",
                "source": "1260"
              },
              "abstraction_path_up": {
                "path": [
                  [
                    "122",
                    "787",
                    "CHILDOF"
                  ]
                ],
                "score": 0.5599999999999999,
                "type": "abstraction_path_up",
                "source": "122"
              }
            }
          },
          "is_explicit": true,
          "abstraction_level": "base",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "dense",
              "sparse",
              "graph"
            ],
            "retriever_count": 3,
            "normalized_scores": {
              "dense": 0.6044956188779271,
              "sparse": 1000.0,
              "graph": 1.9494031032124015
            }
          }
        },
        "similarity": 1.9494031032124015
      },
      {
        "doc_id": "562",
        "text": "CWE-562: Return of Stack Variable Address",
        "score": 1.7680000000000005,
        "metadata": {
          "doc_id": "562",
          "name": "Return of Stack Variable Address",
          "type": "base",
          "original_content": "CWE-562: Return of Stack Variable Address",
          "relationships": [
            {
              "source_id": "562",
              "target_id": "825",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "562",
              "target_id": "672",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "562",
              "target_id": "758",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "825",
              "target_id": "562",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "758",
              "target_id": "562",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "672",
              "target_id": "562",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            }
          ],
          "score_components": {
            "relationship_chain": 0.8,
            "sequence_path": 0.8
          },
          "abstraction_factor": 1.3,
          "graph_path_info": {
            "path_types": [
              "relationship_chain",
              "vulnerability_sequence_forward",
              "vulnerability_sequence_backward"
            ],
            "best_paths": {
              "relationship_chain": {
                "path": [
                  [
                    "415",
                    "672",
                    "CHILDOF"
                  ],
                  [
                    "672",
                    "562",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.8,
                "type": "relationship_chain",
                "source": "415"
              },
              "vulnerability_sequence_forward": {
                "path": [
                  [
                    "787",
                    "825",
                    "CANFOLLOW"
                  ],
                  [
                    "825",
                    "562",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.7200000000000001,
                "type": "vulnerability_sequence_forward",
                "source": "787"
              },
              "vulnerability_sequence_backward": {
                "path": [
                  [
                    "825",
                    "787",
                    "CANPRECEDE"
                  ],
                  [
                    "562",
                    "825",
                    "CANPRECEDE"
                  ]
                ],
                "score": 0.8,
                "type": "vulnerability_sequence_backward",
                "source": "787"
              }
            }
          },
          "position": "before",
          "sources": [
            "graph"
          ],
          "source": "graph",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "graph"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "graph": 1.7680000000000005
            }
          }
        },
        "similarity": 1.7680000000000005
      },
      {
        "doc_id": "134",
        "text": "CWE-134: Use of Externally-Controlled Format String",
        "score": 1.6848000000000003,
        "metadata": {
          "doc_id": "134",
          "name": "Use of Externally-Controlled Format String",
          "type": "base",
          "original_content": "CWE-134: Use of Externally-Controlled Format String",
          "relationships": [
            {
              "source_id": "134",
              "target_id": "20",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "700"
              }
            },
            {
              "source_id": "134",
              "target_id": "123",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "134",
              "target_id": "668",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1003"
              }
            },
            {
              "source_id": "134",
              "target_id": "668",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "668",
              "target_id": "134",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "20",
              "target_id": "134",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "700"
              }
            },
            {
              "source_id": "123",
              "target_id": "134",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            }
          ],
          "score_components": {
            "relationship_chain": 0.8,
            "sequence_path": 0.7200000000000001
          },
          "abstraction_factor": 1.3,
          "graph_path_info": {
            "path_types": [
              "relationship_chain",
              "vulnerability_sequence_forward"
            ],
            "best_paths": {
              "relationship_chain": {
                "path": [
                  [
                    "415",
                    "123",
                    "PEEROF"
                  ],
                  [
                    "123",
                    "134",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.8,
                "type": "relationship_chain",
                "source": "415"
              },
              "vulnerability_sequence_forward": {
                "path": [
                  [
                    "416",
                    "123",
                    "CANPRECEDE"
                  ],
                  [
                    "123",
                    "134",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.7200000000000001,
                "type": "vulnerability_sequence_forward",
                "source": "416"
              }
            }
          },
          "position": "after",
          "sources": [
            "graph"
          ],
          "source": "graph",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "graph"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "graph": 1.6848000000000003
            }
          }
        },
        "similarity": 1.6848000000000003
      },
      {
        "doc_id": "170",
        "text": "CWE-170: Improper Null Termination",
        "score": 1.6848000000000003,
        "metadata": {
          "doc_id": "170",
          "name": "Improper Null Termination",
          "type": "base",
          "original_content": "CWE-170: Improper Null Termination",
          "relationships": [
            {
              "source_id": "170",
              "target_id": "682",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "170",
              "target_id": "193",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "170",
              "target_id": "20",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "700"
              }
            },
            {
              "source_id": "170",
              "target_id": "463",
              "label": "PEEROF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "170",
              "target_id": "464",
              "label": "PEEROF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "170",
              "target_id": "147",
              "label": "CANALSOBE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "170",
              "target_id": "126",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "170",
              "target_id": "120",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "170",
              "target_id": "707",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "707",
              "target_id": "170",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "682",
              "target_id": "170",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "20",
              "target_id": "170",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "700"
              }
            },
            {
              "source_id": "193",
              "target_id": "170",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "126",
              "target_id": "170",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "120",
              "target_id": "170",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            }
          ],
          "score_components": {
            "relationship_chain": 0.8,
            "sequence_path": 0.7200000000000001
          },
          "abstraction_factor": 1.3,
          "graph_path_info": {
            "path_types": [
              "relationship_chain",
              "vulnerability_sequence_forward"
            ],
            "best_paths": {
              "relationship_chain": {
                "path": [
                  [
                    "416",
                    "120",
                    "CANPRECEDE"
                  ],
                  [
                    "120",
                    "170",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.8,
                "type": "relationship_chain",
                "source": "416"
              },
              "vulnerability_sequence_forward": {
                "path": [
                  [
                    "416",
                    "120",
                    "CANPRECEDE"
                  ],
                  [
                    "120",
                    "170",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.7200000000000001,
                "type": "vulnerability_sequence_forward",
                "source": "416"
              }
            }
          },
          "position": "after",
          "sources": [
            "graph"
          ],
          "source": "graph",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "graph"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "graph": 1.6848000000000003
            }
          }
        },
        "similarity": 1.6848000000000003
      },
      {
        "doc_id": "1257",
        "text": "CWE-1257: Improper Access Control Applied to Mirrored or Aliased Memory Regions",
        "score": 1.6848000000000003,
        "metadata": {
          "doc_id": "1257",
          "name": "Improper Access Control Applied to Mirrored or Aliased Memory Regions",
          "type": "base",
          "original_content": "CWE-1257: Improper Access Control Applied to Mirrored or Aliased Memory Regions",
          "relationships": [
            {
              "source_id": "1257",
              "target_id": "119",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "1257",
              "target_id": "284",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "284",
              "target_id": "1257",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "119",
              "target_id": "1257",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            }
          ],
          "score_components": {
            "relationship_chain": 0.8,
            "sequence_path": 0.7200000000000001
          },
          "abstraction_factor": 1.3,
          "graph_path_info": {
            "path_types": [
              "relationship_chain",
              "vulnerability_sequence_forward"
            ],
            "best_paths": {
              "relationship_chain": {
                "path": [
                  [
                    "1260",
                    "119",
                    "CANPRECEDE"
                  ],
                  [
                    "119",
                    "1257",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.8,
                "type": "relationship_chain",
                "source": "1260"
              },
              "vulnerability_sequence_forward": {
                "path": [
                  [
                    "1260",
                    "119",
                    "CANPRECEDE"
                  ],
                  [
                    "119",
                    "1257",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.7200000000000001,
                "type": "vulnerability_sequence_forward",
                "source": "1260"
              }
            }
          },
          "position": "after",
          "sources": [
            "graph"
          ],
          "source": "graph",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "graph"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "graph": 1.6848000000000003
            }
          }
        },
        "similarity": 1.6848000000000003
      },
      {
        "doc_id": "128",
        "text": "CWE-128: Wrap-around Error",
        "score": 1.6848000000000003,
        "metadata": {
          "doc_id": "128",
          "name": "Wrap-around Error",
          "type": "base",
          "original_content": "CWE-128: Wrap-around Error",
          "relationships": [
            {
              "source_id": "128",
              "target_id": "190",
              "label": "PEEROF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "128",
              "target_id": "119",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "128",
              "target_id": "682",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "682",
              "target_id": "128",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "119",
              "target_id": "128",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            }
          ],
          "score_components": {
            "relationship_chain": 0.8,
            "sequence_path": 0.7200000000000001
          },
          "abstraction_factor": 1.3,
          "graph_path_info": {
            "path_types": [
              "relationship_chain",
              "vulnerability_sequence_forward"
            ],
            "best_paths": {
              "relationship_chain": {
                "path": [
                  [
                    "1260",
                    "119",
                    "CANPRECEDE"
                  ],
                  [
                    "119",
                    "128",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.8,
                "type": "relationship_chain",
                "source": "1260"
              },
              "vulnerability_sequence_forward": {
                "path": [
                  [
                    "1260",
                    "119",
                    "CANPRECEDE"
                  ],
                  [
                    "119",
                    "128",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.7200000000000001,
                "type": "vulnerability_sequence_forward",
                "source": "1260"
              }
            }
          },
          "position": "after",
          "sources": [
            "graph"
          ],
          "source": "graph",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "graph"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "graph": 1.6848000000000003
            }
          }
        },
        "similarity": 1.6848000000000003
      },
      {
        "doc_id": "131",
        "text": "CWE-131: Incorrect Calculation of Buffer Size",
        "score": 1.6848000000000003,
        "metadata": {
          "doc_id": "131",
          "name": "Incorrect Calculation of Buffer Size",
          "type": "base",
          "original_content": "CWE-131: Incorrect Calculation of Buffer Size",
          "relationships": [
            {
              "source_id": "131",
              "target_id": "467",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "131",
              "target_id": "119",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "131",
              "target_id": "682",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1340"
              }
            },
            {
              "source_id": "131",
              "target_id": "682",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1305"
              }
            },
            {
              "source_id": "131",
              "target_id": "682",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1003"
              }
            },
            {
              "source_id": "131",
              "target_id": "682",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "682",
              "target_id": "131",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "467",
              "target_id": "131",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "119",
              "target_id": "131",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            }
          ],
          "score_components": {
            "relationship_chain": 0.8,
            "sequence_path": 0.7200000000000001
          },
          "abstraction_factor": 1.3,
          "graph_path_info": {
            "path_types": [
              "relationship_chain",
              "vulnerability_sequence_forward"
            ],
            "best_paths": {
              "relationship_chain": {
                "path": [
                  [
                    "1260",
                    "119",
                    "CANPRECEDE"
                  ],
                  [
                    "119",
                    "131",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.8,
                "type": "relationship_chain",
                "source": "1260"
              },
              "vulnerability_sequence_forward": {
                "path": [
                  [
                    "1260",
                    "119",
                    "CANPRECEDE"
                  ],
                  [
                    "119",
                    "131",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.7200000000000001,
                "type": "vulnerability_sequence_forward",
                "source": "1260"
              }
            }
          },
          "position": "after",
          "sources": [
            "graph"
          ],
          "source": "graph",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "graph"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "graph": 1.6848000000000003
            }
          }
        },
        "similarity": 1.6848000000000003
      },
      {
        "doc_id": "1339",
        "text": "CWE-1339: Insufficient Precision or Accuracy of a Real Number",
        "score": 1.6848000000000003,
        "metadata": {
          "doc_id": "1339",
          "name": "Insufficient Precision or Accuracy of a Real Number",
          "type": "base",
          "original_content": "CWE-1339: Insufficient Precision or Accuracy of a Real Number",
          "relationships": [
            {
              "source_id": "1339",
              "target_id": "119",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "1339",
              "target_id": "834",
              "label": "CANPRECEDE",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "1339",
              "target_id": "190",
              "label": "PEEROF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "1339",
              "target_id": "682",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "834",
              "target_id": "1339",
              "label": "CANFOLLOW",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "682",
              "target_id": "1339",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "119",
              "target_id": "1339",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            }
          ],
          "score_components": {
            "relationship_chain": 0.8,
            "sequence_path": 0.7200000000000001
          },
          "abstraction_factor": 1.3,
          "graph_path_info": {
            "path_types": [
              "relationship_chain",
              "vulnerability_sequence_forward"
            ],
            "best_paths": {
              "relationship_chain": {
                "path": [
                  [
                    "1260",
                    "119",
                    "CANPRECEDE"
                  ],
                  [
                    "119",
                    "1339",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.8,
                "type": "relationship_chain",
                "source": "1260"
              },
              "vulnerability_sequence_forward": {
                "path": [
                  [
                    "1260",
                    "119",
                    "CANPRECEDE"
                  ],
                  [
                    "119",
                    "1339",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.7200000000000001,
                "type": "vulnerability_sequence_forward",
                "source": "1260"
              }
            }
          },
          "position": "after",
          "sources": [
            "graph"
          ],
          "source": "graph",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "graph"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "graph": 1.6848000000000003
            }
          }
        },
        "similarity": 1.6848000000000003
      },
      {
        "doc_id": "190",
        "text": "CWE-190: Integer Overflow or Wraparound",
        "score": 1.6848000000000003,
        "metadata": {
          "doc_id": "190",
          "name": "Integer Overflow or Wraparound",
          "type": "base",
          "original_content": "CWE-190: Integer Overflow or Wraparound",
          "relationships": [
            {
              "source_id": "190",
              "target_id": "680",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "190",
              "target_id": "119",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "190",
              "target_id": "20",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "700"
              }
            },
            {
              "source_id": "190",
              "target_id": "682",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1003"
              }
            },
            {
              "source_id": "190",
              "target_id": "682",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "682",
              "target_id": "190",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "680",
              "target_id": "190",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "680",
              "target_id": "190",
              "label": "STARTSWITH",
              "properties": {
                "view_id": "709"
              }
            },
            {
              "source_id": "20",
              "target_id": "190",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "700"
              }
            },
            {
              "source_id": "1339",
              "target_id": "190",
              "label": "PEEROF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "128",
              "target_id": "190",
              "label": "PEEROF",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "119",
              "target_id": "190",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            }
          ],
          "score_components": {
            "relationship_chain": 0.8,
            "sequence_path": 0.7200000000000001
          },
          "abstraction_factor": 1.3,
          "graph_path_info": {
            "path_types": [
              "relationship_chain",
              "vulnerability_sequence_forward"
            ],
            "best_paths": {
              "relationship_chain": {
                "path": [
                  [
                    "1260",
                    "119",
                    "CANPRECEDE"
                  ],
                  [
                    "119",
                    "190",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.8,
                "type": "relationship_chain",
                "source": "1260"
              },
              "vulnerability_sequence_forward": {
                "path": [
                  [
                    "1260",
                    "119",
                    "CANPRECEDE"
                  ],
                  [
                    "119",
                    "190",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.7200000000000001,
                "type": "vulnerability_sequence_forward",
                "source": "1260"
              }
            }
          },
          "position": "after",
          "sources": [
            "graph"
          ],
          "source": "graph",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Be careful of terminology problems with \"overflow,\" \"underflow,\" and \"wraparound\" - see Terminology Notes. Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ],
            "suggestions": [
              {
                "CweID": "191",
                "Comment": "Integer Underflow (Wrap or Wraparound). Consider CWE-191 when the result is less than the minimum value that can be represented (sometimes called \"underflows\")."
              }
            ]
          },
          "score_info": {
            "retrievers": [
              "sparse",
              "graph"
            ],
            "retriever_count": 2,
            "normalized_scores": {
              "sparse": 51.530627528621274,
              "graph": 1.6848000000000003
            }
          }
        },
        "similarity": 1.6848000000000003
      },
      {
        "doc_id": "193",
        "text": "CWE-193: Off-by-one Error",
        "score": 1.6848000000000003,
        "metadata": {
          "doc_id": "193",
          "name": "Off-by-one Error",
          "type": "base",
          "original_content": "CWE-193: Off-by-one Error",
          "relationships": [
            {
              "source_id": "193",
              "target_id": "119",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "193",
              "target_id": "170",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "193",
              "target_id": "617",
              "label": "CANPRECEDE",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "193",
              "target_id": "682",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1003"
              }
            },
            {
              "source_id": "193",
              "target_id": "682",
              "label": "CHILDOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "682",
              "target_id": "193",
              "label": "PARENTOF",
              "properties": {
                "ordinal": "Primary",
                "view_id": "1000"
              }
            },
            {
              "source_id": "617",
              "target_id": "193",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "170",
              "target_id": "193",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            },
            {
              "source_id": "119",
              "target_id": "193",
              "label": "CANFOLLOW",
              "properties": {
                "view_id": "1000"
              }
            }
          ],
          "score_components": {
            "relationship_chain": 0.8,
            "sequence_path": 0.7200000000000001
          },
          "abstraction_factor": 1.3,
          "graph_path_info": {
            "path_types": [
              "relationship_chain",
              "vulnerability_sequence_forward"
            ],
            "best_paths": {
              "relationship_chain": {
                "path": [
                  [
                    "1260",
                    "119",
                    "CANPRECEDE"
                  ],
                  [
                    "119",
                    "193",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.8,
                "type": "relationship_chain",
                "source": "1260"
              },
              "vulnerability_sequence_forward": {
                "path": [
                  [
                    "1260",
                    "119",
                    "CANPRECEDE"
                  ],
                  [
                    "119",
                    "193",
                    "CANFOLLOW"
                  ]
                ],
                "score": 0.7200000000000001,
                "type": "vulnerability_sequence_forward",
                "source": "1260"
              }
            }
          },
          "position": "after",
          "sources": [
            "graph"
          ],
          "source": "graph",
          "mapping_notes": {
            "usage": "Allowed",
            "rationale": "This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.",
            "comments": "Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.",
            "reasons": [
              "Acceptable-Use"
            ]
          },
          "score_info": {
            "retrievers": [
              "graph"
            ],
            "retriever_count": 1,
            "normalized_scores": {
              "graph": 1.6848000000000003
            }
          }
        },
        "similarity": 1.6848000000000003
      }
    ]
  },
  "retrieval_time": 4.787710189819336
}