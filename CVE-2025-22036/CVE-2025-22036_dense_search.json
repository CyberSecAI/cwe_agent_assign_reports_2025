{
  "retriever": "dense",
  "query": "In the Linux kernel, the following vulnerability has been resolved exfat fix random stack corruption after get_block When get_block is called with a buffer_head allocated on the stack, such as do_mpage_readpage, stack corruption due to buffer_head UAF may occur in the following race condition situation. mpage_read_folio > do_mpage_readpage exfat_get_block bh_read __bh_read get_bh(bh) submit_bh wait_on_buffer ... end_buffer_read_sync __end_buffer_read_notouch unlock_buffer > ... ... ... ... > . . another_function > put_bh(bh) atomic_dec(bh->b_count) * stack corruption here * This patch returns -EAGAIN if a folio does not have buffers when bh_read needs to be called. By doing this, the caller can fallback to functions like block_read_full_folio(), create a buffer_head in the folio, and then call get_block again. Lets do not call bh_read() with on-stack buffer_head.",
  "keyphrases": {
    "rootcause": [
      "race condition"
    ],
    "weakness": [
      "stack corruption"
    ]
  },
  "timestamp": "2025-07-12 10:00:53",
  "cve_id": "CVE-2025-22036",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "126",
      "name": "Buffer Over-read",
      "type": "Variant",
      "score": 0.5100563759774299
    },
    {
      "cwe_id": "805",
      "name": "Buffer Access with Incorrect Length Value",
      "type": "Base",
      "score": 0.5070755242686598
    },
    {
      "cwe_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "type": "Base",
      "score": 0.5016996688674614
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 0.49949641067550427
    },
    {
      "cwe_id": "122",
      "name": "Heap-based Buffer Overflow",
      "type": "Variant",
      "score": 0.4986576310224357
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "type": "Class",
      "score": 0.49549486012769556
    },
    {
      "cwe_id": "190",
      "name": "Integer Overflow or Wraparound",
      "type": "Base",
      "score": 0.4942962787720637
    },
    {
      "cwe_id": "131",
      "name": "Incorrect Calculation of Buffer Size",
      "type": "Base",
      "score": 0.49133027961358705
    },
    {
      "cwe_id": "124",
      "name": "Buffer Underwrite ('Buffer Underflow')",
      "type": "Base",
      "score": 0.4902001469338648
    },
    {
      "cwe_id": "1260",
      "name": "Improper Handling of Overlap Between Protected Memory Ranges",
      "type": "Base",
      "score": 0.48971215263534046
    },
    {
      "cwe_id": "366",
      "name": "Race Condition within a Thread",
      "type": "Base",
      "score": 0.47515733867075516
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "type": "Variant",
      "score": 0.46677834641683774
    },
    {
      "cwe_id": "909",
      "name": "Missing Initialization of Resource",
      "type": "Class",
      "score": 0.4665872034264401
    },
    {
      "cwe_id": "127",
      "name": "Buffer Under-read",
      "type": "Variant",
      "score": 0.4587019391426843
    },
    {
      "cwe_id": "908",
      "name": "Use of Uninitialized Resource",
      "type": "Base",
      "score": 0.4574594461666129
    },
    {
      "cwe_id": "1252",
      "name": "CPU Hardware Not Configured to Support Exclusivity of Write and Execute Operations",
      "type": "Base",
      "score": 0.4563262563060234
    },
    {
      "cwe_id": "1342",
      "name": "Information Exposure through Microarchitectural State after Transient Execution",
      "type": "Base",
      "score": 0.4560848492879601
    },
    {
      "cwe_id": "125",
      "name": "Out-of-bounds Read",
      "type": "Base",
      "score": 0.45553628775360583
    },
    {
      "cwe_id": "782",
      "name": "Exposed IOCTL with Insufficient Access Control",
      "type": "Variant",
      "score": 0.4546256495589342
    },
    {
      "cwe_id": "786",
      "name": "Access of Memory Location Before Start of Buffer",
      "type": "Base",
      "score": 0.45447684899083163
    }
  ]
}