# Vulnerability Information: CVE-2024-8375

## Vulnerability Description
There exists a **use after free** vulnerability in Reverb. Reverb supports the VARIANT datatype, which is supposed to represent an arbitrary object in C++. When a tensor proto of type VARIANT is unpacked, memory is first allocated to store the entire tensor, and a ctor is called on each instance. Afterwards, Reverb copies the content in tensor_content to the previously mentioned pre-allocated memory, which results in the bytes in tensor_content overwriting the vtable pointers of all the objects which were previously allocated. Reverb exposes 2 relevant gRPC endpoints InsertStream and SampleStream. The attacker can insert this stream into the servers database, then when the client next calls SampleStream they will unpack the tensor into RAM, and when any method on that object is called (including its destructor) the attacker gains control of the Program Counter. We recommend upgrading past git commit https//github.com/google-deepmind/reverb/commit/6a0dcf4c9e842b7f999912f792aaa6f6bd261a25

### Vulnerability Description Key Phrases
- **rootcause:** **use after free**
- **product:** Reverb

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of the vulnerability:

**Root Cause:**

The vulnerability stems from improper handling of the `VARIANT` data type during deserialization of TensorFlow tensors in Reverb. When a tensor of type `VARIANT` is unpacked, memory is allocated and the constructor of the contained object is called. Subsequently, the `tensor_content` field of the proto is copied into this allocated memory, overwriting the object's vtable pointers.

**Weaknesses/Vulnerabilities:**

*   **Vtable Overwrite:** The primary vulnerability is the overwrite of vtable pointers due to the uncontrolled copy of data from the `tensor_content` field into pre-allocated memory for VARIANT tensors.
*   **Unsafe Deserialization:** The deserialization process does not validate or sanitize the `tensor_content` data when handling the `VARIANT` datatype leading to the overwrite.
*   **Lack of Authentication/Authorization:** The affected gRPC endpoints (`InsertStream` and `SampleStream`) are not authenticated and do not enforce any form of authorization.

**Impact of Exploitation:**

*   **Remote Code Execution (RCE):** By crafting a malicious `tensor_content` payload, an attacker can overwrite the vtable pointer of an object. When any method is invoked on that object, including its destructor, the attacker gains control of the program counter, leading to arbitrary code execution.

**Attack Vectors:**

*   **Network:** An attacker can exploit this vulnerability remotely by interacting with the Reverb server's gRPC endpoints.
*   **gRPC Endpoints:** Specifically, the `InsertStream` and `SampleStream` gRPC endpoints are the attack vectors.

**Required Attacker Capabilities/Position:**

*   **Network Access:** The attacker needs network access to communicate with the Reverb server.
*   **Knowledge of gRPC:** The attacker needs to know how to interact with the `InsertStream` to insert malicious data, and subsequently cause a client to call `SampleStream` to trigger the vulnerability
*   **Malicious Payload Creation:** The attacker must create a `tensor_content` payload that overwrites the vtable pointer to redirect execution flow to attacker controlled memory.

**Additional Notes:**

*   The vulnerability was fixed in commit `6a0dcf4`.
* The issue was found and fixed retroactively.
* The vulnerability allows an attacker to gain control of the Program Counter which can then be leveraged to achieve RCE.
* The vulnerability exists because the `tensor_content` bytes overwrite the allocated object's virtual table pointers when deserializing a `VARIANT` tensor.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 415 | Double Free | Variant | Allowed | sparse | 0.781 |
| 2 | 911 | Improper Update of Reference Count | Base | Allowed | sparse | 0.766 |
| 3 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.761 |
| 4 | 824 | Access of Uninitialized Pointer | Base | Allowed | sparse | 0.743 |
| 5 | 122 | Heap-based Buffer Overflow | Variant | Allowed | sparse | 0.730 |
| 6 | 190 | Integer Overflow or Wraparound | Base | Allowed | sparse | 0.706 |
| 7 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.701 |
| 8 | 476 | NULL Pointer Dereference | Base | Allowed | sparse | 0.701 |
| 9 | 244 | Improper Clearing of Heap Memory Before Release ('Heap Inspection') | Variant | Allowed | dense | 0.461 |
| 10 | 123 | Write-what-where Condition | Base | Allowed | graph | 0.003 |

