{
  "retriever": "sparse",
  "query": "In the Linux kernel, the following vulnerability has been resolved Revert libfs fix infinite directory reads for offset dir The current directory offset allocator (based on mtree_alloc_cyclic) stores the next offset value to return in octx->next_offset. This mechanism typically returns values that increase monotonically over time. Eventually, though, the newly allocated offset value wraps back to a low number (say, 2) which is smaller than other already- allocated offset values. Yu Kuai reports that, after commit 64a7ce76fb90 (libfs fix infinite directory reads for offset dir), if a directorys offset allocator wraps, existing entries are no longer visible via readdir/getdents because offset_readdir() stops listing entries once an entrys offset is larger than octx->next_offset. These entries vanish persistently -- they can be looked up, but will never again appear in readdir(3) output. The reason for this is that the commit treats directory offsets as monotonically increasing integer values rather than opaque cookies, and introduces this comparison if (dentry2offset(dentry) >= last_index) { On 64-bit platforms, the directory offset value upper bound is 2^63 - 1. Directory offsets will monotonically increase for millions of years without wrapping. On 32-bit platforms, however, LONG_MAX is 2^31 - 1. The allocator can wrap after only a few weeks (at worst). Revert commit 64a7ce76fb90 (libfs fix infinite directory reads for offset dir) to prepare for a fix that can work properly on 32-bit systems and might apply to recent LTS kernels where shmem employs the simple_offset mechanism.",
  "keyphrases": {
    "rootcause": [
      "directory offset value wraps back"
    ]
  },
  "timestamp": "2025-07-12 06:57:25",
  "cve_id": "CVE-2024-57952",
  "result_count": 11,
  "results": [
    {
      "cwe_id": "823",
      "name": "Use of Out-of-range Pointer Offset",
      "score": 1117.2815226169296,
      "search_source": "rootcause:directory offset value wraps back"
    },
    {
      "cwe_id": "125",
      "name": "Out-of-bounds Read",
      "score": 1031.5320651998968,
      "search_source": "rootcause:directory offset value wraps back"
    },
    {
      "cwe_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "score": 979.9338819690397,
      "search_source": "rootcause:directory offset value wraps back"
    },
    {
      "cwe_id": "190",
      "name": "Integer Overflow or Wraparound",
      "score": 944.3428796333374,
      "search_source": "rootcause:directory offset value wraps back"
    },
    {
      "cwe_id": "839",
      "name": "Numeric Range Comparison Without Minimum Check",
      "score": 933.2670899435216,
      "search_source": "rootcause:directory offset value wraps back"
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "score": 901.7428789372179,
      "search_source": "rootcause:directory offset value wraps back"
    },
    {
      "cwe_id": "681",
      "name": "Incorrect Conversion between Numeric Types",
      "score": 899.8626767290032,
      "search_source": "rootcause:directory offset value wraps back"
    },
    {
      "cwe_id": "194",
      "name": "Unexpected Sign Extension",
      "score": 890.5532864414963,
      "search_source": "rootcause:directory offset value wraps back"
    },
    {
      "cwe_id": "22",
      "name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
      "score": 854.6372648138858,
      "search_source": "rootcause:directory offset value wraps back"
    },
    {
      "cwe_id": "61",
      "name": "UNIX Symbolic Link (Symlink) Following",
      "score": 846.5389785184968,
      "search_source": "rootcause:directory offset value wraps back"
    },
    {
      "cwe_id": "197",
      "name": "Numeric Truncation Error",
      "score": 279.75082101292696,
      "search_source": "base_query"
    }
  ]
}