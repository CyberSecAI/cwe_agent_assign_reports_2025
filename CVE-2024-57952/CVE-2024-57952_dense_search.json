{
  "retriever": "dense",
  "query": "In the Linux kernel, the following vulnerability has been resolved Revert libfs fix infinite directory reads for offset dir The current directory offset allocator (based on mtree_alloc_cyclic) stores the next offset value to return in octx->next_offset. This mechanism typically returns values that increase monotonically over time. Eventually, though, the newly allocated offset value wraps back to a low number (say, 2) which is smaller than other already- allocated offset values. Yu Kuai reports that, after commit 64a7ce76fb90 (libfs fix infinite directory reads for offset dir), if a directorys offset allocator wraps, existing entries are no longer visible via readdir/getdents because offset_readdir() stops listing entries once an entrys offset is larger than octx->next_offset. These entries vanish persistently -- they can be looked up, but will never again appear in readdir(3) output. The reason for this is that the commit treats directory offsets as monotonically increasing integer values rather than opaque cookies, and introduces this comparison if (dentry2offset(dentry) >= last_index) { On 64-bit platforms, the directory offset value upper bound is 2^63 - 1. Directory offsets will monotonically increase for millions of years without wrapping. On 32-bit platforms, however, LONG_MAX is 2^31 - 1. The allocator can wrap after only a few weeks (at worst). Revert commit 64a7ce76fb90 (libfs fix infinite directory reads for offset dir) to prepare for a fix that can work properly on 32-bit systems and might apply to recent LTS kernels where shmem employs the simple_offset mechanism.",
  "keyphrases": {
    "rootcause": [
      "directory offset value wraps back"
    ]
  },
  "timestamp": "2025-07-12 06:57:25",
  "cve_id": "CVE-2024-57952",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "823",
      "name": "Use of Out-of-range Pointer Offset",
      "type": "Base",
      "score": 0.5096872453029533
    },
    {
      "cwe_id": "835",
      "name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
      "type": "Base",
      "score": 0.4966059238748697
    },
    {
      "cwe_id": "190",
      "name": "Integer Overflow or Wraparound",
      "type": "Base",
      "score": 0.4841027783402662
    },
    {
      "cwe_id": "911",
      "name": "Improper Update of Reference Count",
      "type": "Base",
      "score": 0.47772885100207724
    },
    {
      "cwe_id": "191",
      "name": "Integer Underflow (Wrap or Wraparound)",
      "type": "Base",
      "score": 0.4724987310667533
    },
    {
      "cwe_id": "126",
      "name": "Buffer Over-read",
      "type": "Variant",
      "score": 0.47067074989827307
    },
    {
      "cwe_id": "909",
      "name": "Missing Initialization of Resource",
      "type": "Class",
      "score": 0.4695070929964058
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 0.46935774814708014
    },
    {
      "cwe_id": "62",
      "name": "UNIX Hard Link",
      "type": "Variant",
      "score": 0.46791897821146317
    },
    {
      "cwe_id": "193",
      "name": "Off-by-one Error",
      "type": "Base",
      "score": 0.4670758781635229
    },
    {
      "cwe_id": "122",
      "name": "Heap-based Buffer Overflow",
      "type": "Variant",
      "score": 0.4595887524875899
    },
    {
      "cwe_id": "277",
      "name": "Insecure Inherited Permissions",
      "type": "Variant",
      "score": 0.45842141904155986
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "type": "Class",
      "score": 0.4566040616478035
    },
    {
      "cwe_id": "908",
      "name": "Use of Uninitialized Resource",
      "type": "Base",
      "score": 0.4544057677559721
    },
    {
      "cwe_id": "775",
      "name": "Missing Release of File Descriptor or Handle after Effective Lifetime",
      "type": "Variant",
      "score": 0.4540354765316211
    },
    {
      "cwe_id": "1260",
      "name": "Improper Handling of Overlap Between Protected Memory Ranges",
      "type": "Base",
      "score": 0.4532206466488197
    },
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "type": "Base",
      "score": 0.4527749593437802
    },
    {
      "cwe_id": "789",
      "name": "Memory Allocation with Excessive Size Value",
      "type": "Variant",
      "score": 0.4500694848947155
    },
    {
      "cwe_id": "125",
      "name": "Out-of-bounds Read",
      "type": "Base",
      "score": 0.44843493664979794
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "type": "Base",
      "score": 0.4462962267074141
    }
  ]
}