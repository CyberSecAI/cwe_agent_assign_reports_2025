## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved vrf revert vrf Remove unnecessary RCU-bh critical section This reverts commit 504fc6f4f7f681d2a03aa5f68aad549d90eab853. dev_queue_xmit_nit is expected to be called with BH disabled. __dev_queue_xmit has the following /* Disable soft irqs for various locks below. Also * stops preemption for RCU. */ rcu_read_lock_bh() VRF must follow this invariant. The referenced commit removed this protection. Which triggered a lockdep warning ================================ WARNING inconsistent lock state 6.11.0 #1 Tainted G W -------------------------------- inconsistent {IN-SOFTIRQ-W} -> {SOFTIRQ-ON-W} usage. btserver/134819 [HC0[0]SC0[0]HE1SE1] takes ffff8882da30c118 (rlock-AF_PACKET){+.?.}-{22}, at tpacket_rcv+0x863/0x3b30 {IN-SOFTIRQ-W} state was registered at lock_acquire+0x19a/0x4f0 _raw_spin_lock+0x27/0x40 packet_rcv+0xa33/0x1320 __netif_receive_skb_core.constprop.0+0xcb0/0x3a90 __netif_receive_skb_list_core+0x2c9/0x890 netif_receive_skb_list_internal+0x610/0xcc0 [...] other info that might help us debug this Possible unsafe locking scenario CPU0 ---- lock(rlock-AF_PACKET) lock(rlock-AF_PACKET) *** DEADLOCK *** Call Trace dump_stack_lvl+0x73/0xa0 mark_lock+0x102e/0x16b0 __lock_acquire+0x9ae/0x6170 lock_acquire+0x19a/0x4f0 _raw_spin_lock+0x27/0x40 tpacket_rcv+0x863/0x3b30 dev_queue_xmit_nit+0x709/0xa40 vrf_finish_direct+0x26e/0x340 [vrf] vrf_l3_out+0x5f4/0xe80 [vrf] __ip_local_out+0x51e/0x7a0 [...]

### Vulnerability Description Key Phrases
- **rootcause:** **The commit 504fc6f4f7f681d2a03aa5f68aad549d90eab853 removed the protection of disabling softirqs when calling rcu_read_lock_bh() in VRF. This caused a lockdep warning because dev_queue_xmit_nit is expected to be called with BH disabled.**
- **weakness:** **The commit removed a necessary protection (disabling softirqs) before calling rcu_read_lock_bh() in the VRF implementation, leading to a race condition.**
- **impact:** Lockdep warning and potential deadlock in the kernel. The system may become unstable and crash.
- **vector:** The vulnerability is triggered by network traffic flowing through the VRF device and using the packet socket.
- **attacker:** An attacker could trigger this issue by sending network packets to the vulnerable VRF interface.
- **product:** Linux Kernel
- **version:** 6.11.0
- **component:** VRF

## CVE Reference Links Content Summary
The provided content relates to CVE-2024-49980.

**Root cause of vulnerability:**
The vulnerability is a result of removing an RCU-bh critical section in the VRF (Virtual Routing and Forwarding) driver. This was introduced by commit `504fc6f4f7f6` which removed the `rcu_read_lock_bh()` and `rcu_read_unlock_bh()` calls in `vrf_finish_direct()`. The function `dev_queue_xmit_nit` expects to be called with bottom halves (BH) disabled, and the RCU read lock accomplishes this.

**Weaknesses/vulnerabilities present:**
The primary weakness is a missing RCU read lock in the `vrf_finish_direct()` function.  This creates a race condition leading to inconsistent lock state and potential deadlocks. The `dev_queue_xmit_nit()` is called without the necessary protection, violating an invariant and leading to the issues described.

**Impact of exploitation:**
The exploitation of this vulnerability can lead to a deadlock. The lockdep warning indicates the potential for a deadlock, specifically when `rlock-AF_PACKET` is acquired within an interrupt context while the same lock is already held.

**Attack vectors:**
The vulnerability is triggered when network packets are processed by the VRF driver. The attack vector involves sending network packets to a VRF interface, which will result in the vulnerable `vrf_finish_direct` code being executed. Specifically, if an interrupt occurs while holding `rlock-AF_PACKET` after the `dev_queue_xmit_nit` call, a deadlock can occur.

**Required attacker capabilities/position:**
An attacker needs to be able to send network packets to a VRF interface on the affected system. No specific local access is required for exploitation beyond the ability to send packets into the network.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | alternate_terms | 0.800 |
| 2 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.594 |
| 3 | 59 | Improper Link Resolution Before File Access ('Link Following') | Base | Allowed | sparse | 0.520 |
| 4 | 451 | User Interface (UI) Misrepresentation of Critical Information | Class | Allowed-with-Review | sparse | 0.504 |
| 5 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | sparse | 0.500 |
| 6 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.495 |
| 7 | 250 | Execution with Unnecessary Privileges | Base | Allowed | sparse | 0.492 |
| 8 | 807 | Reliance on Untrusted Inputs in a Security Decision | Base | Allowed | sparse | 0.490 |
| 9 | 413 | Improper Resource Locking | Base | Allowed | dense | 0.552 |
| 10 | 363 | Race Condition Enabling Link Following | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-667: Improper Locking

CWE-59: Improper Link Resolution Before File Access ('Link Following')

CWE-451: User Interface (UI) Misrepresentation of Critical Information

CWE-909: Missing Initialization of Resource

CWE-401: Missing Release of Memory after Effective Lifetime

CWE-250: Execution with Unnecessary Privileges

CWE-807: Reliance on Untrusted Inputs in a Security Decision

CWE-413: Improper Resource Locking

CWE-363: Race Condition Enabling Link Following