## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved drm/xe/client add missing bo locking in show_meminfo() bo_meminfo() wants to inspect bo state like tt and the ttm resource, however this state can change at any point leading to stuff like NPD and UAF, if the bo lock is not held. Grab the bo lock when calling bo_meminfo(), ensuring we drop any spinlocks first. In the case of object_idr we now also need to hold a ref. v2 (MattB) - Also add xe_bo_assert_held() (cherry picked from commit 4f63d712fa104c3ebefcb289d1e733e86d8698c7)

### Vulnerability Description Key Phrases
- **rootcause:** **missing bo locking in show_meminfo() bo_meminfo() ... if the bo lock is not held**
- **impact:** use-after-free (UAF)
- **product:** Linux kernel
- **component:** drm/xe/client

## CVE Reference Links Content Summary
The provided content is related to the following vulnerability:

**Root cause of vulnerability:**
The `bo_meminfo()` function inspects the buffer object (bo) state, including the translation table (tt) and the TTM (Translation Table Manager) resource. This state can change at any time, leading to potential use-after-free (UAF) or null pointer dereference (NPD) issues if the bo lock is not held while accessing it.

**Weaknesses/vulnerabilities present:**
- **Race Condition:** Concurrent access to the buffer object's state without proper locking. Specifically, the `bo_meminfo()` function was called without holding the necessary lock, allowing for potential modification of the bo's state by another thread while `bo_meminfo()` was operating on it, resulting in a race condition.
- **Use-After-Free (UAF):** If the bo's state is modified or freed while `bo_meminfo()` is accessing it, it could result in a use-after-free condition.
- **Null Pointer Dereference (NPD):** Accessing members of a freed object can lead to null pointer dereferences.

**Impact of exploitation:**
Exploitation of this vulnerability could lead to:
- Kernel crash due to NPD or UAF.
- Potential privilege escalation or arbitrary code execution if the UAF can be manipulated.

**Attack vectors:**
An attacker could trigger the `show_meminfo()` function through the debugfs interface, while also concurrently modifying buffer object states.

**Required attacker capabilities/position:**
- The attacker needs to have the ability to trigger the `show_meminfo()` function, typically via a privileged user (or a user with access to debugfs).
- The attacker also needs to be able to trigger changes in buffer object states while `show_meminfo()` is executing.

**Additional details:**
The fix addresses the vulnerability by:
- Adding the `xe_bo_assert_held()` function to assert that the bo lock is held when calling `bo_meminfo()`.
- Ensuring the bo lock is acquired before calling `bo_meminfo()` and released afterwards using `xe_bo_lock()` and `xe_bo_unlock()`.
- Adding a reference to the bo using `xe_bo_get()` to prevent it from being freed while `bo_meminfo()` is operating on it
- Using `dma_resv_trylock` to acquire the lock directly if possible, otherwise acquiring lock with `xe_bo_lock` after dropping other locks to prevent deadlock
- When iterating over the client's list of buffers, a reference is acquired to prevent the bo from being freed
- The fix was backported to stable kernel versions starting from 6.8.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.485 |
| 2 | 833 | Deadlock | Base | Allowed | sparse | 0.459 |
| 3 | 764 | Multiple Locks of a Critical Resource | Base | Allowed | sparse | 0.441 |
| 4 | 476 | NULL Pointer Dereference | Base | Allowed | sparse | 0.420 |
| 5 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | sparse | 0.417 |
| 6 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.405 |
| 7 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.404 |
| 8 | 212 | Improper Removal of Sensitive Information Before Storage or Transfer | Base | Allowed | sparse | 0.399 |
| 9 | 413 | Improper Resource Locking | Base | Allowed | dense | 0.533 |
| 10 | 1325 | Improperly Controlled Sequential Memory Allocation | Base | Allowed | graph | 0.002 |



# Complete CWE Specifications

CWE-667: Improper Locking

CWE-833: Deadlock

CWE-764: Multiple Locks of a Critical Resource

CWE-476: NULL Pointer Dereference

CWE-909: Missing Initialization of Resource

CWE-1284: Improper Validation of Specified Quantity in Input

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer

CWE-413: Improper Resource Locking

CWE-1325: Improperly Controlled Sequential Memory Allocation