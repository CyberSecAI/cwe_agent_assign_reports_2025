# Vulnerability Information: CVE-2024-56694

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved bpf fix **recursive lock** when verdict program return SK_PASS When the stream_verdict program returns SK_PASS, it places the received skb into its own receive queue, but a **recursive lock** eventually occurs, leading to an operating system deadlock. This issue has been present since v6.9. sk_psock_strp_data_ready write_lock_bh(&sk->sk_callback_lock) strp_data_ready strp_read_sock read_sock -> tcp_read_sock strp_recv cb.rcv_msg -> sk_psock_strp_read # now stream_verdict return SK_PASS without peer sock assign __SK_PASS = sk_psock_map_verd(SK_PASS, NULL) sk_psock_verdict_apply sk_psock_skb_ingress_self sk_psock_skb_ingress_enqueue sk_psock_data_ready read_lock_bh(&sk->sk_callback_lock) <= dead lock This topic has been discussed before, but it has not been fixed. Previous discussion https//lore.kernel.org/all/6684a5864ec86_403d20898@john.notmuch

### Vulnerability Description Key Phrases
- **rootcause:** **recursive lock**
- **impact:** deadlock
- **product:** Linux kernel

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of the vulnerability:

**Root Cause:**
The vulnerability stems from a recursive lock situation within the BPF (Berkeley Packet Filter) subsystem of the Linux kernel. Specifically, when a stream_verdict BPF program returns `SK_PASS`, the received skb (socket buffer) is placed back into its own receive queue. This triggers a recursive locking scenario.

**Weaknesses/Vulnerabilities:**
-   **Recursive Lock:** The core issue is the use of `write_lock_bh` followed by a subsequent `read_lock_bh` on the same lock (`sk->sk_callback_lock`) within the data ready handling path. This occurs when a verdict program returns SK_PASS, causing the same socket's data_ready handler to be called again.
-   **Incorrect Lock Usage:** The `sk_psock_strp_data_ready` function initially uses `write_lock_bh` which was unnecessary.

**Impact of Exploitation:**
-   **Operating System Deadlock:** The recursive lock leads to a deadlock, causing the operating system to become unresponsive.

**Attack Vectors:**
-   **BPF Program:** An attacker would need to load a malicious BPF program that uses the stream_verdict functionality and returns `SK_PASS`.

**Required Attacker Capabilities/Position:**
-   **Privileged Access:** The attacker would need the capability to load BPF programs, typically requiring root or elevated privileges.
-   **Knowledge of BPF:** The attacker needs an understanding of BPF programming, particularly the stream_verdict program type.

**Technical Details:**

The provided code snippets show the problematic lock usage:

```
sk_psock_strp_data_ready
write_lock_bh(&sk->sk_callback_lock)
strp_data_ready
strp_read_sock
read_sock -> tcp_read_sock
strp_recv
cb.rcv_msg -> sk_psock_strp_read
# now stream_verdict return SK_PASS without peer sock assign
__SK_PASS = sk_psock_map_verd(SK_PASS, NULL)
sk_psock_verdict_apply
sk_psock_skb_ingress_self
sk_psock_skb_ingress_enqueue
sk_psock_data_ready
read_lock_bh(&sk->sk_callback_lock) <= dead lock
```

The fix involves changing `write_lock_bh` to `read_lock_bh` in `sk_psock_strp_data_ready` function which is the correct lock to be held for the operation being performed at that point in code:

```diff
--- a/net/core/skmsg.c
+++ b/net/core/skmsg.c
@@ -1117,9 +1117,9 @@
 	if (tls_sw_has_ctx_rx(sk)) {
 		psock->saved_data_ready(sk);
 	} else {
-		write_lock_bh(&sk->sk_callback_lock);
+		read_lock_bh(&sk->sk_callback_lock);
 		strp_data_ready(&psock->strp);
-		write_unlock_bh(&sk->sk_callback_lock);
+		read_unlock_bh(&sk->sk_callback_lock);
 	}
 }
 rcu_read_unlock();
```
**Additional Notes:**
*   The vulnerability has been present since v6.9 of the Linux kernel.
*   The fix addresses the recursive lock issue by changing `write_lock_bh` to `read_lock_bh` which eliminates the deadlock.
*   The commits provide the relevant code changes and details of the vulnerability.

This information provides a more detailed analysis than a basic CVE description would provide.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.382 |
| 2 | 833 | Deadlock | Base | Allowed | sparse | 0.346 |
| 3 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | sparse | 0.316 |
| 4 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | Allowed | sparse | 0.307 |
| 5 | 663 | Use of a Non-reentrant Function in a Concurrent Context | Base | Allowed | sparse | 0.306 |
| 6 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.303 |
| 7 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.295 |
| 8 | 201 | Insertion of Sensitive Information Into Sent Data | Base | Allowed | sparse | 0.285 |
| 9 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | dense | 0.507 |
| 10 | 1265 | Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls | Base | Allowed | graph | 0.002 |

