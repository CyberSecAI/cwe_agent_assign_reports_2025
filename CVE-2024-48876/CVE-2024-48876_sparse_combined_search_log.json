{
  "method": "sparse_combined",
  "query": "In the Linux kernel, the following vulnerability has been resolved stackdepot fix stack_depot_save_flags() in NMI context Per documentation, stack_depot_save_flags() was meant to be usable from NMI context if STACK_DEPOT_FLAG_CAN_ALLOC is unset. However, it still would try to take the pool_lock in an attempt to save a stack trace in the current pool (if space is available). This could result in deadlock if an NMI is handled while pool_lock is already held. To avoid deadlock, only try to take the lock in NMI context and give up if unsuccessful. The documentation is fixed to clearly convey this.",
  "keyphrases": {
    "weakness": [
      "deadlock"
    ]
  },
  "timestamp": "2025-07-13T18:59:19.492362",
  "results_count": 10,
  "results_summary": [
    {
      "doc_id": "667",
      "name": "Improper Locking",
      "score": 526.4553386638277
    },
    {
      "doc_id": "833",
      "name": "Deadlock",
      "score": 502.29546885275244
    },
    {
      "doc_id": "451",
      "name": "User Interface (UI) Misrepresentation of Critical Information",
      "score": 448.72425794481927
    },
    {
      "doc_id": "787",
      "name": "Out-of-bounds Write",
      "score": 433.36039867886274
    },
    {
      "doc_id": "674",
      "name": "Uncontrolled Recursion",
      "score": 428.32085961473643
    }
  ]
}