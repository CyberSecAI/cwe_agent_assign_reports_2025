# Vulnerability Information: CVE-2024-46680

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolvedBluetooth btnxpuart Fix random crash seen while removing driverThis fixes the random kernel crash seen while removing the driver, whenrunning the load/unload test over multiple iterations.1) modprobe btnxpuart2) hciconfig hci0 reset3) hciconfig (check hci0 interface up with valid BD address)4) modprobe -r btnxpuartRepeat steps 1 to 4The ps_wakeup() call in btnxpuart_close() schedules the psdata->work(),which gets scheduled after module is removed, causing a kernel crash.This hidden issue got highlighted after enabling Power Save by defaultin 4183a7be7700 (Bluetooth btnxpuart Enable Power Save feature onstartup)The new ps_cleanup() deasserts UART break immediately while closingserdev device, cancels any scheduled ps_work and destroys the ps_lockmutex.[ 85.884604] Unable to handle kernel paging request at virtual address ffffd4a61638f258[ 85.884624] Mem abort info[ 85.884625] ESR = 0x0000000086000007[ 85.884628] EC = 0x21 IABT (current EL), IL = 32 bits[ 85.884633] SET = 0, FnV = 0[ 85.884636] EA = 0, S1PTW = 0[ 85.884638] FSC = 0x07 level 3 translation fault[ 85.884642] swapper pgtable 4k pages, 48-bit VAs, pgdp=0000000041dd0000[ 85.884646] [ffffd4a61638f258] pgd=1000000095fff003, p4d=1000000095fff003, pud=100000004823d003, pmd=100000004823e003, pte=0000000000000000[ 85.884662] Internal error Oops 0000000086000007

### Vulnerability Description Key Phrases
- **rootcause:** **ps_wakeup() call in btnxpuart_close() schedules psdata->work() after module is removed**
- **impact:** Oops and kernel crash
- **vector:** ['modprobe btnxpuart' and 'hciconfig hci0 reset' and 'hciconfig' and 'modprobe -r btnxpuart']
- **product:** Linux kernel
- **component:** Bluetooth btnxpuart driver

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of the vulnerability:

**Root Cause:**

The vulnerability arises from a race condition during the removal of the `btnxpuart` Bluetooth driver module. The `ps_wakeup()` function, called within `btnxpuart_close()`, schedules the `psdata->work()`. This work item can be scheduled to run *after* the module has been removed, leading to a use-after-free condition and a kernel crash. This issue is exacerbated by the fact that power saving is enabled by default, increasing the likelihood of the `psdata->work()` being scheduled.

**Weaknesses/Vulnerabilities:**

- **Use-after-free:** The primary vulnerability is a use-after-free. The `psdata->work()` is scheduled and executed after the memory associated with the driver (and `psdata` itself) has been freed, causing a crash.
- **Race Condition:** The timing of module removal and the scheduling of the work item creates a race condition that is difficult to consistently reproduce without the power saving feature enabled.

**Impact of Exploitation:**

- **Kernel Crash:** The exploitation of this vulnerability results in a kernel crash, leading to a denial of service. The system becomes unstable and may require a reboot.
- **No Data Breach:** There is no indication of data breaches or unauthorized access resulting from the exploitation.

**Attack Vectors:**

- **Module Loading/Unloading:** The attack vector involves repeatedly loading and unloading the `btnxpuart` driver module. Specifically the sequence of:
  1. `modprobe btnxpuart` (load module)
  2. `hciconfig hci0 reset`
  3. `hciconfig` (check interface up)
  4. `modprobe -r btnxpuart` (unload module)

**Required Attacker Capabilities/Position:**

- **Root privileges:** The attacker needs to have root privileges or equivalent to load and unload kernel modules.

**Additional Notes:**

- The issue is triggered when power saving mode is enabled, which is the default in newer kernels.
- The fix introduces a new function `ps_cleanup()`. This function is called in `nxp_serdev_remove()` instead of `ps_cancel_timer()`. The `ps_cleanup()` function deasserts the UART break signal, cancels the scheduled work item (`cancel_work_sync(&psdata->work)`), and destroys the mutex (`mutex_destroy(&psdata->ps_lock)`).
- The provided crash log demonstrates the use-after-free condition and includes the call trace leading up to the crash.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 288 | Authentication Bypass Using an Alternate Path or Channel | Base | Allowed | sparse | 0.534 |
| 2 | 668 | Exposure of Resource to Wrong Sphere | Class | Discouraged | sparse | 0.531 |
| 3 | 787 | Out-of-bounds Write | Base | Allowed | sparse | 0.530 |
| 4 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.516 |
| 5 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.514 |
| 6 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.511 |
| 7 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.509 |
| 8 | 330 | Use of Insufficiently Random Values | Class | Discouraged | sparse | 0.484 |
| 9 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | Allowed | dense | 0.540 |
| 10 | 123 | Write-what-where Condition | Base | Allowed | graph | 0.002 |

