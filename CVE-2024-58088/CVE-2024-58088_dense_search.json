{
  "retriever": "dense",
  "query": "In the Linux kernel, the following vulnerability has been resolved bpf Fix deadlock when freeing cgroup storage The following commit bc235cdb423a (bpf Prevent deadlock from recursive bpf_task_storage_[get|delete]) first introduced deadlock prevention for fentry/fexit programs attaching on bpf_task_storage helpers. That commit also employed the logic in map free path in its v6 version. Later bpf_cgrp_storage was first introduced in c4bcfb38a95e (bpf Implement cgroup storage available to non-cgroup-attached bpf progs) which faces the same issue as bpf_task_storage, instead of its busy counter, NULL was passed to bpf_local_storage_map_free() which opened a window to cause deadlock (acquiring local_storage->lock) _raw_spin_lock_irqsave+0x3d/0x50 bpf_local_storage_update+0xd1/0x460 bpf_cgrp_storage_get+0x109/0x130 bpf_prog_a4d4a370ba857314_cgrp_ptr+0x139/0x170 ? __bpf_prog_enter_recur+0x16/0x80 bpf_trampoline_6442485186+0x43/0xa4 cgroup_storage_ptr+0x9/0x20 (holding local_storage->lock) bpf_selem_unlink_storage_nolock.constprop.0+0x135/0x160 bpf_selem_unlink_storage+0x6f/0x110 bpf_local_storage_map_free+0xa2/0x110 bpf_map_free_deferred+0x5b/0x90 process_one_work+0x17c/0x390 worker_thread+0x251/0x360 kthread+0xd2/0x100 ret_from_fork+0x34/0x50 ret_from_fork_asm+0x1a/0x30 Progs - A SEC(fentry/cgroup_storage_ptr) - cgid (BPF_MAP_TYPE_HASH) Record the id of the cgroup the current task belonging to in this hash map, using the address of the cgroup as the map key. - cgrpa (BPF_MAP_TYPE_CGRP_STORAGE) If current task is a kworker, lookup the above hash map using function parameter @owner as the key to get its corresponding cgroup id which is then used to get a trusted pointer to the cgroup through bpf_cgroup_from_id(). This trusted pointer can then be passed to bpf_cgrp_storage_get() to finally trigger the deadlock issue. - B SEC(tp_btf/sys_enter) - cgrpb (BPF_MAP_TYPE_CGRP_STORAGE) The only purpose of this prog is to fill Prog As hash map by calling bpf_cgrp_storage_get() for as many userspace tasks as possible. Steps to reproduce - Run A - while (true) { Run B Destroy B } Fix this issue by passing its busy counter to the free procedure so it can be properly incremented before storage/smap locking.",
  "keyphrases": {
    "rootcause": [
      "null pointer dereference"
    ]
  },
  "timestamp": "2025-07-12 07:00:35",
  "cve_id": "CVE-2024-58088",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "type": "Class",
      "score": 0.5188808976131718
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 0.5032038207727463
    },
    {
      "cwe_id": "909",
      "name": "Missing Initialization of Resource",
      "type": "Class",
      "score": 0.48571114204935883
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 0.4693576977755224
    },
    {
      "cwe_id": "401",
      "name": "Missing Release of Memory after Effective Lifetime",
      "type": "Variant",
      "score": 0.4659156589956695
    },
    {
      "cwe_id": "1325",
      "name": "Improperly Controlled Sequential Memory Allocation",
      "type": "Base",
      "score": 0.46506940994200996
    },
    {
      "cwe_id": "763",
      "name": "Release of Invalid Pointer or Reference",
      "type": "Base",
      "score": 0.46491360499009315
    },
    {
      "cwe_id": "404",
      "name": "Improper Resource Shutdown or Release",
      "type": "Class",
      "score": 0.4631870086985002
    },
    {
      "cwe_id": "413",
      "name": "Improper Resource Locking",
      "type": "Base",
      "score": 0.46057534466973865
    },
    {
      "cwe_id": "911",
      "name": "Improper Update of Reference Count",
      "type": "Base",
      "score": 0.4590341110530586
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "type": "Variant",
      "score": 0.4417119551083138
    },
    {
      "cwe_id": "832",
      "name": "Unlock of a Resource that is not Locked",
      "type": "Base",
      "score": 0.43764226569550113
    },
    {
      "cwe_id": "366",
      "name": "Race Condition within a Thread",
      "type": "Base",
      "score": 0.43420193518113914
    },
    {
      "cwe_id": "789",
      "name": "Memory Allocation with Excessive Size Value",
      "type": "Variant",
      "score": 0.43350776464149154
    },
    {
      "cwe_id": "126",
      "name": "Buffer Over-read",
      "type": "Variant",
      "score": 0.432743869034846
    },
    {
      "cwe_id": "415",
      "name": "Double Free",
      "type": "Variant",
      "score": 0.43034518460625604
    },
    {
      "cwe_id": "765",
      "name": "Multiple Unlocks of a Critical Resource",
      "type": "Base",
      "score": 0.42968049499240535
    },
    {
      "cwe_id": "590",
      "name": "Free of Memory not on the Heap",
      "type": "Variant",
      "score": 0.4295810944639217
    },
    {
      "cwe_id": "764",
      "name": "Multiple Locks of a Critical Resource",
      "type": "Base",
      "score": 0.42789858458998825
    },
    {
      "cwe_id": "367",
      "name": "Time-of-check Time-of-use (TOCTOU) Race Condition",
      "type": "Base",
      "score": 0.4249357206434307
    }
  ]
}