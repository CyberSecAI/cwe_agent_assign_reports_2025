# Vulnerability Information: CVE-2024-50203

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved bpf, arm64 Fix **address emission with tag-based KASAN enabled** When BPF_TRAMP_F_CALL_ORIG is enabled, the address of a bpf_tramp_image struct on the stack is passed during the size calculation pass and an address on the heap is passed during code generation. This may cause a **heap buffer overflow** if the heap address is tagged because emit_a64_mov_i64() will emit longer code than it did during the size calculation pass. The same problem could occur without tag-based KASAN if one of the 16-bit words of the stack address happened to be all-ones during the size calculation pass. Fix the problem by assuming the worst case (4 instructions) when calculating the size of the bpf_tramp_image address emission.

### Vulnerability Description Key Phrases
- **rootcause:** **address emission with tag-based KASAN enabled**
- **weakness:** **heap buffer overflow**
- **product:** Linux kernel
- **component:** bpf

## CVE Reference Links Content Summary
The provided content relates to a vulnerability in the Linux kernel's BPF JIT compiler for arm64 architecture, specifically when `BPF_TRAMP_F_CALL_ORIG` is enabled.

**Root Cause:**

The vulnerability stems from a discrepancy in how the address of a `bpf_tramp_image` struct is handled during the size calculation pass and the code generation pass of the JIT compilation process. During size calculation, the address of a stack allocated struct is used. During code generation, the address of a heap allocated struct is used. The `emit_a64_mov_i64()` function, which is used to emit code to load the address into a register, could generate a different code size depending on whether the address was a stack or heap address. Specifically, when tag-based KASAN is enabled, heap addresses can have higher bits set (tags), resulting in longer code than when the lower bits of a stack address are set. This can lead to a heap buffer overflow. The issue can also occur without tag-based KASAN if the address on the stack has certain bit patterns.

**Weaknesses/Vulnerabilities:**

*   **Inconsistent Code Size Calculation:** The size calculation pass does not account for the maximum possible code size that `emit_a64_mov_i64()` might generate for an address, particularly when dealing with tagged heap addresses or stack addresses with specific bit patterns.
*   **Heap Buffer Overflow:** Due to the inconsistent code size calculation, during code generation the JIT could write past the end of the allocated buffer on the heap, resulting in a heap buffer overflow.

**Impact of Exploitation:**

A heap buffer overflow can lead to various issues, including:

*   **Memory Corruption:** Overwriting memory can lead to system instability, crashes, or unexpected behavior.
*   **Code Execution:** In some cases, attackers may be able to overwrite function pointers or other critical data, potentially allowing for arbitrary code execution.

**Attack Vectors:**

*   **BPF Program Loading:** An attacker could exploit this vulnerability by loading a carefully crafted BPF program that uses the `BPF_TRAMP_F_CALL_ORIG` flag. This would require the attacker to have the ability to load eBPF programs.

**Required Attacker Capabilities/Position:**

*   **Ability to Load BPF Programs:** The attacker needs the ability to load BPF programs into the kernel. This typically requires `CAP_SYS_ADMIN` capabilities or similar privileges.

**Mitigation:**

The fix addresses this by assuming the worst-case scenario (4 instructions) when calculating the size of the `bpf_tramp_image` address emission during the initial size calculation pass. This ensures that enough space is reserved to emit the address, even if the address turns out to be tagged or have other bit patterns that result in longer code being emitted.

**Additional Notes:**
The fix ensures that the size of the address emission is always at least 4 instructions during the size calculation pass, mitigating the vulnerability in all cases.
The vulnerability exists because the size of generated code for `emit_a64_mov_i64` can vary based on the input address.
The code change explicitly checks if it's the initial size calculation pass using `if (!ctx->image)` and increments the code index by 4 if true. Otherwise, it executes `emit_a64_mov_i64` as usual.
The issue is specific to the arm64 architecture.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | alternate_terms | 0.800 |
| 2 | 190 | Integer Overflow or Wraparound | Base | Allowed | alternate_terms | 0.800 |
| 3 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.736 |
| 4 | 193 | Off-by-one Error | Base | Allowed | sparse | 0.722 |
| 5 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | Allowed | sparse | 0.698 |
| 6 | 191 | Integer Underflow (Wrap or Wraparound) | Base | Allowed | sparse | 0.693 |
| 7 | 194 | Unexpected Sign Extension | Variant | Allowed | sparse | 0.691 |
| 8 | 122 | Heap-based Buffer Overflow | Variant | Allowed | sparse | 0.676 |
| 9 | 1342 | Information Exposure through Microarchitectural State after Transient Execution | Base | Allowed | dense | 0.519 |
| 10 | 1339 | Insufficient Precision or Accuracy of a Real Number | Base | Allowed | graph | 0.003 |

