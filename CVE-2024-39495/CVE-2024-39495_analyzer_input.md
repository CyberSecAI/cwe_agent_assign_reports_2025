# Vulnerability Information: CVE-2024-39495

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved greybus Fix **use-after-free** bug in gb_interface_release due to **race condition**. In gb_interface_create, &intf->mode_switch_completion is bound with gb_interface_mode_switch_work. Then it will be started by gb_interface_request_mode_switch. Here is the relevant code. if (!queue_work(system_long_wq, &intf->mode_switch_work)) { ... } If we call gb_interface_release to make cleanup, there may be an unfinished work. This function will call kfree to free the object intf. However, if gb_interface_mode_switch_work is scheduled to run after kfree, it may cause **use-after-free** error as gb_interface_mode_switch_work will use the object intf. The possible execution flow that may lead to the issue is as follows CPU0 CPU1 | gb_interface_create | gb_interface_request_mode_switch gb_interface_release | kfree(intf) (free) | | gb_interface_mode_switch_work | mutex_lock(&intf->mutex) (use) Fix it by canceling the work before kfree.

### Vulnerability Description Key Phrases
- **rootcause:** **race condition**
- **weakness:** **use-after-free**
- **product:** Linux kernel
- **component:** greybus

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of the vulnerability:

**Root Cause:**

- A race condition exists in the `gb_interface_release` function of the Linux kernel's Greybus driver.
- The `gb_interface_release` function frees the `intf` object using `kfree(intf)`.
- Simultaneously, a worker thread, `gb_interface_mode_switch_work`, might still be scheduled to run after `intf` is freed.
- This worker thread attempts to access members of the freed `intf` object (specifically, `intf->mutex`), leading to a use-after-free (UAF) vulnerability.

**Weaknesses/Vulnerabilities:**

- **Use-After-Free (UAF):** The primary vulnerability is a UAF that occurs when the `gb_interface_mode_switch_work` attempts to access the `intf` object after it has been freed.
- **Race Condition:** The UAF is triggered by a race condition between the `gb_interface_release` function and the scheduling of the `gb_interface_mode_switch_work` work item.

**Impact of Exploitation:**

- **Kernel Crash:** The most likely impact is a kernel crash due to the invalid memory access from the UAF, leading to denial of service.
- **Potential for Privilege Escalation:** While not explicitly mentioned, UAF vulnerabilities can sometimes be leveraged for more severe exploits, like arbitrary code execution with kernel privileges.

**Attack Vectors:**

- An attacker needs to trigger the following sequence of events:
    1. Call `gb_interface_create` to create a Greybus interface.
    2. Call `gb_interface_request_mode_switch` to schedule the `gb_interface_mode_switch_work`.
    3. Call `gb_interface_release` to initiate the cleanup, leading to the `intf` object being freed.
    4. Ensure `gb_interface_mode_switch_work` is scheduled to run after `kfree(intf)`.

**Required Attacker Capabilities/Position:**

- The attacker needs to have the ability to interact with the Greybus driver to call the described functions. This may require a user with certain privileges or a specific device that uses the Greybus framework.
- They need to be able to cause the described race condition by controlling the execution of the two different processes (process calling release and the worker thread).

**Mitigation:**

The provided patch addresses the issue by adding the line `cancel_work_sync(&intf->mode_switch_work);` before `kfree(intf);` in the `gb_interface_release` function. This cancels the potentially pending work item before the object is freed, preventing the UAF.

In summary, this is a use-after-free vulnerability caused by a race condition in the Greybus driver that can lead to a kernel crash. The fix ensures that the work item is cancelled before the object is freed.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | alternate_terms | 1.000 |
| 2 | 416 | Use After Free | Variant | Allowed | alternate_terms | 1.000 |
| 3 | 415 | Double Free | Variant | Allowed | sparse | 0.634 |
| 4 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.633 |
| 5 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.587 |
| 6 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.570 |
| 7 | 364 | Signal Handler Race Condition | Base | Allowed | sparse | 0.570 |
| 8 | 911 | Improper Update of Reference Count | Base | Allowed | sparse | 0.561 |
| 9 | 366 | Race Condition within a Thread | Base | Allowed | dense | 0.480 |
| 10 | 123 | Write-what-where Condition | Base | Allowed | graph | 0.003 |

