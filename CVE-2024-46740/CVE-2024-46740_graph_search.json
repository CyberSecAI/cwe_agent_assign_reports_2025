{
  "retriever": "graph",
  "query": "In the Linux kernel, the following vulnerability has been resolved binder fix UAF caused by offsets overwrite Binder objects are processed and copied individually into the target buffer during transactions. Any raw data in-between these objects is copied as well. However, this raw data copy lacks an out-of-bounds check. If the raw data exceeds the data section size then the copy overwrites the offsets section. This eventually triggers an error that attempts to unwind the processed objects. However, at this point the offsets used to index these objects are now corrupted. Unwinding with corrupted offsets can result in decrements of arbitrary nodes and lead to their premature release. Other users of such nodes are left with a dangling pointer triggering a use-after-free. This issue is made evident by the following KASAN report (trimmed) ================================================================== BUG KASAN slab-use-after-free in _raw_spin_lock+0xe4/0x19c Write of size 4 at addr ffff47fc91598f04 by task binder-util/743 CPU 9 UID 0 PID 743 Comm binder-util Not tainted 6.11.0-rc4 #1 Hardware name linux,dummy-virt (DT) Call trace _raw_spin_lock+0xe4/0x19c binder_free_buf+0x128/0x434 binder_thread_write+0x8a4/0x3260 binder_ioctl+0x18f0/0x258c [...] Allocated by task 743 __kmalloc_cache_noprof+0x110/0x270 binder_new_node+0x50/0x700 binder_transaction+0x413c/0x6da8 binder_thread_write+0x978/0x3260 binder_ioctl+0x18f0/0x Consider specifically these CWEs: CWE-416 CWE-823 CWE-667 CWE-909 CWE-1285 CWE-124 CWE-193 CWE-362",
  "keyphrases": {
    "original_query": "In the Linux kernel, the following vulnerability has been resolved binder fix UAF caused by offsets overwrite Binder objects are processed and copied individually into the target buffer during transactions. Any raw data in-between these objects is copied as well. However, this raw data copy lacks an out-of-bounds check. If the raw data exceeds the data section size then the copy overwrites the offsets section. This eventually triggers an error that attempts to unwind the processed objects. However, at this point the offsets used to index these objects are now corrupted. Unwinding with corrupted offsets can result in decrements of arbitrary nodes and lead to their premature release. Other users of such nodes are left with a dangling pointer triggering a use-after-free. This issue is made evident by the following KASAN report (trimmed) ================================================================== BUG KASAN slab-use-after-free in _raw_spin_lock+0xe4/0x19c Write of size 4 at addr ffff47fc91598f04 by task binder-util/743 CPU 9 UID 0 PID 743 Comm binder-util Not tainted 6.11.0-rc4 #1 Hardware name linux,dummy-virt (DT) Call trace _raw_spin_lock+0xe4/0x19c binder_free_buf+0x128/0x434 binder_thread_write+0x8a4/0x3260 binder_ioctl+0x18f0/0x258c [...] Allocated by task 743 __kmalloc_cache_noprof+0x110/0x270 binder_new_node+0x50/0x700 binder_transaction+0x413c/0x6da8 binder_thread_write+0x978/0x3260 binder_ioctl+0x18f0/0x",
    "enhanced_query": "In the Linux kernel, the following vulnerability has been resolved binder fix UAF caused by offsets overwrite Binder objects are processed and copied individually into the target buffer during transactions. Any raw data in-between these objects is copied as well. However, this raw data copy lacks an out-of-bounds check. If the raw data exceeds the data section size then the copy overwrites the offsets section. This eventually triggers an error that attempts to unwind the processed objects. However, at this point the offsets used to index these objects are now corrupted. Unwinding with corrupted offsets can result in decrements of arbitrary nodes and lead to their premature release. Other users of such nodes are left with a dangling pointer triggering a use-after-free. This issue is made evident by the following KASAN report (trimmed) ================================================================== BUG KASAN slab-use-after-free in _raw_spin_lock+0xe4/0x19c Write of size 4 at addr ffff47fc91598f04 by task binder-util/743 CPU 9 UID 0 PID 743 Comm binder-util Not tainted 6.11.0-rc4 #1 Hardware name linux,dummy-virt (DT) Call trace _raw_spin_lock+0xe4/0x19c binder_free_buf+0x128/0x434 binder_thread_write+0x8a4/0x3260 binder_ioctl+0x18f0/0x258c [...] Allocated by task 743 __kmalloc_cache_noprof+0x110/0x270 binder_new_node+0x50/0x700 binder_transaction+0x413c/0x6da8 binder_thread_write+0x978/0x3260 binder_ioctl+0x18f0/0x Consider specifically these CWEs: CWE-416 CWE-823 CWE-667 CWE-909 CWE-1285 CWE-124 CWE-193 CWE-362",
    "cwe_mentions": [
      "CWE-416",
      "CWE-823",
      "CWE-667",
      "CWE-909",
      "CWE-1285",
      "CWE-124",
      "CWE-193",
      "CWE-362"
    ],
    "search_time": 2.661951780319214
  },
  "timestamp": "2025-07-13 17:36:59",
  "cve_id": "CVE-2024-46740",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "364",
      "name": "Signal Handler Race Condition",
      "type": "base",
      "score": 2.8651999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "787",
      "name": "Out-of-bounds Write",
      "type": "base",
      "score": 2.7196000000000002,
      "relationship_count": 0
    },
    {
      "cwe_id": "123",
      "name": "Write-what-where Condition",
      "type": "base",
      "score": 2.7014000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "120",
      "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
      "type": "base",
      "score": 2.7014000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "129",
      "name": "Improper Validation of Array Index",
      "type": "variant",
      "score": 2.6784000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "193",
      "name": "Off-by-one Error",
      "type": "Base",
      "score": 2.412076807092234,
      "relationship_count": 0
    },
    {
      "cwe_id": "1265",
      "name": "Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "170",
      "name": "Improper Null Termination",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "839",
      "name": "Numeric Range Comparison Without Minimum Check",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "617",
      "name": "Reachable Assertion",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "456",
      "name": "Missing Initialization of a Variable",
      "type": "variant",
      "score": 2.1936,
      "relationship_count": 0
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "type": "Variant",
      "score": 2.169939514693565,
      "relationship_count": 0
    },
    {
      "cwe_id": "124",
      "name": "Buffer Underwrite ('Buffer Underflow')",
      "type": "Base",
      "score": 2.074451527280097,
      "relationship_count": 0
    },
    {
      "cwe_id": "823",
      "name": "Use of Out-of-range Pointer Offset",
      "type": "Base",
      "score": 2.070084808449194,
      "relationship_count": 0
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 1.7574508240541773,
      "relationship_count": 0
    },
    {
      "cwe_id": "825",
      "name": "Expired Pointer Dereference",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "134",
      "name": "Use of Externally-Controlled Format String",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "1257",
      "name": "Improper Access Control Applied to Mirrored or Aliased Memory Regions",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "128",
      "name": "Wrap-around Error",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "1339",
      "name": "Insufficient Precision or Accuracy of a Real Number",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    }
  ]
}