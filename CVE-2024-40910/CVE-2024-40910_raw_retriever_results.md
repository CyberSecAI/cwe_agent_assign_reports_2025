# Raw Retriever Results for CVE-2024-40910

# Raw Retriever Results for CVE-2024-40910
## Query
In the Linux kernel, the following vulnerability has been resolved ax25 Fix refcount imbalance on inbound connections When releasing a socket in ax25_release(), we call netdev_put() to decrease the refcount on the associated ax.25 device. However, the execution path for accepting an incoming connection never calls netdev_hold(). This imbalance leads to refcount errors, and ultimately to kernel crashes. A typical call trace for the above situation will start with one of the following errors refcount_t decrement hit 0 leaking memory. refcount_t underflow use-after-free. And will then have a trace like Call Trace ? show_regs+0x64/0x70 ? __warn+0x83/0x120 ? refcount_warn_saturate+0xb2/0x100 ? report_bug+0x158/0x190 ? prb_read_valid+0x20/0x30 ? handle_bug+0x3e/0x70 ? exc_invalid_op+0x1c/0x70 ? asm_exc_invalid_op+0x1f/0x30 ? refcount_warn_saturate+0xb2/0x100 ? refcount_warn_saturate+0xb2/0x100 ax25_release+0x2ad/0x360 __sock_release+0x35/0xa0 sock_close+0x19/0x20 [...] On reboot (or any attempt to remove the interface), the kernel gets stuck in an infinite loop unregister_netdevice waiting for ax0 to become free. Usage count = 0 This patch corrects these issues by ensuring that we call netdev_hold() and ax25_dev_hold() for new connections in ax25_accept(). This makes the logic leading to ax25_accept() match the logic for ax25_bind() in both cases we increment the refcount, which

## Keyphrases
- **rootcause**: 'refcount imbalance'

## Score Statistics
| Retriever | Min | Max | Mean | Median | Count |
|-----------|-----|-----|------|--------|-------|
| Dense | 0.4777 | 0.5578 | 0.4967 | 0.4884 | 20 |
| Sparse | 706.6280 | 830.4608 | 740.9396 | 733.3467 | 10 |
| Graph | 1.6100 | 2.8652 | 1.8904 | 1.6848 | 20 |

## Graph Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Mapping Usage |
|---|--------|------|-------------|-------|---------------|
| 1 | 364 | Signal Handler Race Condition | base | 2.8652 | Allowed |
| 2 | 123 | Write-what-where Condition | base | 2.4700 | Allowed |
| 3 | 772 | Missing Release of Resource after Effective Lifetime | base | 2.2100 | Allowed |
| 4 | 390 | Detection of Error Condition Without Action | base | 2.2100 | Allowed |
| 5 | 1322 | Use of Blocking Code in Single-threaded, Non-blocking Context | base | 2.2100 | Allowed |
| 6 | 911 | Improper Update of Reference Count | Base | 2.0785 | Allowed |
| 7 | 456 | Missing Initialization of a Variable | variant | 1.8394 | Allowed |
| 8 | 416 | Use After Free | Variant | 1.8236 | Allowed |
| 9 | 120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | base | 1.7680 | Allowed-with-Review |
| 10 | 1341 | Multiple Releases of Same Resource or Handle | base | 1.6848 | Allowed |
| 11 | 1265 | Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls | base | 1.6848 | Allowed |
| 12 | 826 | Premature Release of Resource During Expected Lifetime | base | 1.6848 | Allowed |
| 13 | 562 | Return of Stack Variable Address | base | 1.6848 | Allowed |
| 14 | 1325 | Improperly Controlled Sequential Memory Allocation | base | 1.6848 | Allowed |
| 15 | 386 | Symbolic Name not Mapping to Correct Object | base | 1.6744 | Allowed |

## Dense Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Original Score | Mapping Usage |
|---|--------|------|-------------|-------|----------------|---------------|
| 1 | 911 | Improper Update of Reference Count | Base | 0.5578 | 0.5578 | Allowed |
| 2 | 401 | Missing Release of Memory after Effective Lifetime | Variant | 0.5367 | 0.5367 | Allowed |
| 3 | 833 | Deadlock | Base | 0.5168 | 0.5168 | Allowed |
| 4 | 191 | Integer Underflow (Wrap or Wraparound) | Base | 0.5070 | 0.5070 | Allowed |
| 5 | 909 | Missing Initialization of Resource | Class | 0.5069 | 0.5069 | Allowed-with-Review |
| 6 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | 0.5069 | 0.5069 | Allowed-with-Review |
| 7 | 775 | Missing Release of File Descriptor or Handle after Effective Lifetime | Variant | 0.4997 | 0.4997 | Allowed |
| 8 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | 0.4990 | 0.4990 | Allowed |
| 9 | 121 | Stack-based Buffer Overflow | Variant | 0.4905 | 0.4905 | Allowed |
| 10 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | 0.4889 | 0.4889 | Allowed |
| 11 | 131 | Incorrect Calculation of Buffer Size | Base | 0.4878 | 0.4878 | Allowed |
| 12 | 667 | Improper Locking | Class | 0.4876 | 0.4876 | Allowed-with-Review |
| 13 | 193 | Off-by-one Error | Base | 0.4857 | 0.4857 | Allowed |
| 14 | 416 | Use After Free | Variant | 0.4854 | 0.4854 | Allowed |
| 15 | 126 | Buffer Over-read | Variant | 0.4843 | 0.4843 | Allowed |

## Sparse Retriever Results (10)
| # | CWE ID | Name | Score | Original Score | Mapping Usage |
|---|--------|------|-------|---------------|---------------|
| 1 | 415 | Double Free | 830.4608 | 830.4608 | Allowed |
| 2 | 401 | Missing Release of Memory after Effective Lifetime | 762.7395 | 762.7395 | Allowed |
| 3 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | 755.0523 | 755.0523 | Allowed |
| 4 | 911 | Improper Update of Reference Count | 754.7663 | 754.7663 | Allowed |
| 5 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | 745.8976 | 745.8976 | Allowed-with-Review |
| 6 | 667 | Improper Locking | 720.7959 | 720.7959 | Allowed-with-Review |
| 7 | 617 | Reachable Assertion | 715.1997 | 715.1997 | Allowed |
| 8 | 770 | Allocation of Resources Without Limits or Throttling | 710.9084 | 710.9084 | Allowed |
| 9 | 191 | Integer Underflow (Wrap or Wraparound) | 706.9482 | 706.9482 | Allowed |
| 10 | 1284 | Improper Validation of Specified Quantity in Input | 706.6280 | 706.6280 | Allowed |
