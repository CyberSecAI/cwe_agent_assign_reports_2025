{
  "retriever": "graph",
  "query": "In the Linux kernel, the following vulnerability has been resolved usb musb Fix hardware lockup on first Rx endpoint request There is a possibility that a requests callback could be invoked from usb_ep_queue() (call trace below, supplemented with missing calls) req->complete from usb_gadget_giveback_request (drivers/usb/gadget/udc/core.c999) usb_gadget_giveback_request from musb_g_giveback (drivers/usb/musb/musb_gadget.c147) musb_g_giveback from rxstate (drivers/usb/musb/musb_gadget.c784) rxstate from musb_ep_restart (drivers/usb/musb/musb_gadget.c1169) musb_ep_restart from musb_ep_restart_resume_work (drivers/usb/musb/musb_gadget.c1176) musb_ep_restart_resume_work from musb_queue_resume_work (drivers/usb/musb/musb_core.c2279) musb_queue_resume_work from musb_gadget_queue (drivers/usb/musb/musb_gadget.c1241) musb_gadget_queue from usb_ep_queue (drivers/usb/gadget/udc/core.c300) According to the docstring of usb_ep_queue(), this should not happen Note that @reqs ->complete() callback must never be called from within usb_ep_queue() as that can create deadlock situations. In fact, a hardware lockup might occur in the following sequence 1. The gadget is initialized using musb_gadget_enable(). 2. Meanwhile, a packet arrives, and the RXPKTRDY flag is set, raising an interrupt. 3. If IRQs are enabled, the interrupt is handled, but musb_g_rx() finds an empty queue (next_request() returns NULL). The interrupt flag has already been cleared by the glue layer handler, but the RXPKTRDY flag remains set. 4. The first request is enqueued using usb_ep_queue(), leading to the call of req->complete(), as shown in the call trace above. 5. If the callback enables IRQs and another packet is waiting, step (3) repeats. The request queue is empty because usb_g_giveback() removes the request before invoking the callback. 6. The endpoint remains locked up, as the interrupt triggered by hardware setting the RXPKTRDY flag has been handled, but the flag itself remains set. For this scenario to occur, it is only necessary for IRQs to be enabled at some point during the complete callback. This happens with the USB Ethernet gadget, whose rx_complete() callback calls netif_rx(). If called in the task context, netif_rx() disables the bottom halves (BHs). When the BHs are re-enabled, IRQs are also enabled to allow soft IRQs to be processed. The gadget itself is initialized at module load (or at boot if built-in), but the first request is enqueued when the network interface is brought up, triggering rx_complete() in the task context via ioctl(). If a packet arrives while the interface is down, it can prevent the interface from receiving any further packets from the USB host. The situation is quite complicated with many parties involved. This particular issue can be resolved in several possible ways 1. Ensure that callbacks never enable IRQs. This would be difficult to enforce, as discovering how netif_rx() interacts with interrupts was already quite challenging and u_ether is not the only function driver. Similar bugs could be hidden in other drivers as well. 2. Disable MUSB interrupts in musb_g_giveback() before calling the callback and re-enable them afterwars (by calling musb_{dis,en}able_interrupts(), for example). This would ensure that MUSB interrupts are not handled during the callback, even if IRQs are enabled. In fact, it would allow IRQs to be enabled when releasing the lock. However, this feels like an inelegant hack. 3. Modify the interrupt handler to clear the RXPKTRDY flag if the request queue is empty. While this approach also feels like a hack, it wastes CPU time by attempting to handle incoming packets when the software is not ready to process them. 4. Flush the Rx FIFO instead of calling rxstate() in musb_ep_restart(). This ensures that the hardware can receive packets when there is at least one request in the queue. Once I ---truncated--- Consider specifically these CWEs: CWE-789 CWE-413 CWE-1284 CWE-191 CWE-476 CWE-362 CWE-1264 CWE-319 CWE-833",
  "keyphrases": {
    "original_query": "In the Linux kernel, the following vulnerability has been resolved usb musb Fix hardware lockup on first Rx endpoint request There is a possibility that a requests callback could be invoked from usb_ep_queue() (call trace below, supplemented with missing calls) req->complete from usb_gadget_giveback_request (drivers/usb/gadget/udc/core.c999) usb_gadget_giveback_request from musb_g_giveback (drivers/usb/musb/musb_gadget.c147) musb_g_giveback from rxstate (drivers/usb/musb/musb_gadget.c784) rxstate from musb_ep_restart (drivers/usb/musb/musb_gadget.c1169) musb_ep_restart from musb_ep_restart_resume_work (drivers/usb/musb/musb_gadget.c1176) musb_ep_restart_resume_work from musb_queue_resume_work (drivers/usb/musb/musb_core.c2279) musb_queue_resume_work from musb_gadget_queue (drivers/usb/musb/musb_gadget.c1241) musb_gadget_queue from usb_ep_queue (drivers/usb/gadget/udc/core.c300) According to the docstring of usb_ep_queue(), this should not happen Note that @reqs ->complete() callback must never be called from within usb_ep_queue() as that can create deadlock situations. In fact, a hardware lockup might occur in the following sequence 1. The gadget is initialized using musb_gadget_enable(). 2. Meanwhile, a packet arrives, and the RXPKTRDY flag is set, raising an interrupt. 3. If IRQs are enabled, the interrupt is handled, but musb_g_rx() finds an empty queue (next_request() returns NULL). The interrupt flag has already been cleared by the glue layer handler, but the RXPKTRDY flag remains set. 4. The first request is enqueued using usb_ep_queue(), leading to the call of req->complete(), as shown in the call trace above. 5. If the callback enables IRQs and another packet is waiting, step (3) repeats. The request queue is empty because usb_g_giveback() removes the request before invoking the callback. 6. The endpoint remains locked up, as the interrupt triggered by hardware setting the RXPKTRDY flag has been handled, but the flag itself remains set. For this scenario to occur, it is only necessary for IRQs to be enabled at some point during the complete callback. This happens with the USB Ethernet gadget, whose rx_complete() callback calls netif_rx(). If called in the task context, netif_rx() disables the bottom halves (BHs). When the BHs are re-enabled, IRQs are also enabled to allow soft IRQs to be processed. The gadget itself is initialized at module load (or at boot if built-in), but the first request is enqueued when the network interface is brought up, triggering rx_complete() in the task context via ioctl(). If a packet arrives while the interface is down, it can prevent the interface from receiving any further packets from the USB host. The situation is quite complicated with many parties involved. This particular issue can be resolved in several possible ways 1. Ensure that callbacks never enable IRQs. This would be difficult to enforce, as discovering how netif_rx() interacts with interrupts was already quite challenging and u_ether is not the only function driver. Similar bugs could be hidden in other drivers as well. 2. Disable MUSB interrupts in musb_g_giveback() before calling the callback and re-enable them afterwars (by calling musb_{dis,en}able_interrupts(), for example). This would ensure that MUSB interrupts are not handled during the callback, even if IRQs are enabled. In fact, it would allow IRQs to be enabled when releasing the lock. However, this feels like an inelegant hack. 3. Modify the interrupt handler to clear the RXPKTRDY flag if the request queue is empty. While this approach also feels like a hack, it wastes CPU time by attempting to handle incoming packets when the software is not ready to process them. 4. Flush the Rx FIFO instead of calling rxstate() in musb_ep_restart(). This ensures that the hardware can receive packets when there is at least one request in the queue. Once I ---truncated---",
    "enhanced_query": "In the Linux kernel, the following vulnerability has been resolved usb musb Fix hardware lockup on first Rx endpoint request There is a possibility that a requests callback could be invoked from usb_ep_queue() (call trace below, supplemented with missing calls) req->complete from usb_gadget_giveback_request (drivers/usb/gadget/udc/core.c999) usb_gadget_giveback_request from musb_g_giveback (drivers/usb/musb/musb_gadget.c147) musb_g_giveback from rxstate (drivers/usb/musb/musb_gadget.c784) rxstate from musb_ep_restart (drivers/usb/musb/musb_gadget.c1169) musb_ep_restart from musb_ep_restart_resume_work (drivers/usb/musb/musb_gadget.c1176) musb_ep_restart_resume_work from musb_queue_resume_work (drivers/usb/musb/musb_core.c2279) musb_queue_resume_work from musb_gadget_queue (drivers/usb/musb/musb_gadget.c1241) musb_gadget_queue from usb_ep_queue (drivers/usb/gadget/udc/core.c300) According to the docstring of usb_ep_queue(), this should not happen Note that @reqs ->complete() callback must never be called from within usb_ep_queue() as that can create deadlock situations. In fact, a hardware lockup might occur in the following sequence 1. The gadget is initialized using musb_gadget_enable(). 2. Meanwhile, a packet arrives, and the RXPKTRDY flag is set, raising an interrupt. 3. If IRQs are enabled, the interrupt is handled, but musb_g_rx() finds an empty queue (next_request() returns NULL). The interrupt flag has already been cleared by the glue layer handler, but the RXPKTRDY flag remains set. 4. The first request is enqueued using usb_ep_queue(), leading to the call of req->complete(), as shown in the call trace above. 5. If the callback enables IRQs and another packet is waiting, step (3) repeats. The request queue is empty because usb_g_giveback() removes the request before invoking the callback. 6. The endpoint remains locked up, as the interrupt triggered by hardware setting the RXPKTRDY flag has been handled, but the flag itself remains set. For this scenario to occur, it is only necessary for IRQs to be enabled at some point during the complete callback. This happens with the USB Ethernet gadget, whose rx_complete() callback calls netif_rx(). If called in the task context, netif_rx() disables the bottom halves (BHs). When the BHs are re-enabled, IRQs are also enabled to allow soft IRQs to be processed. The gadget itself is initialized at module load (or at boot if built-in), but the first request is enqueued when the network interface is brought up, triggering rx_complete() in the task context via ioctl(). If a packet arrives while the interface is down, it can prevent the interface from receiving any further packets from the USB host. The situation is quite complicated with many parties involved. This particular issue can be resolved in several possible ways 1. Ensure that callbacks never enable IRQs. This would be difficult to enforce, as discovering how netif_rx() interacts with interrupts was already quite challenging and u_ether is not the only function driver. Similar bugs could be hidden in other drivers as well. 2. Disable MUSB interrupts in musb_g_giveback() before calling the callback and re-enable them afterwars (by calling musb_{dis,en}able_interrupts(), for example). This would ensure that MUSB interrupts are not handled during the callback, even if IRQs are enabled. In fact, it would allow IRQs to be enabled when releasing the lock. However, this feels like an inelegant hack. 3. Modify the interrupt handler to clear the RXPKTRDY flag if the request queue is empty. While this approach also feels like a hack, it wastes CPU time by attempting to handle incoming packets when the software is not ready to process them. 4. Flush the Rx FIFO instead of calling rxstate() in musb_ep_restart(). This ensures that the hardware can receive packets when there is at least one request in the queue. Once I ---truncated--- Consider specifically these CWEs: CWE-789 CWE-413 CWE-1284 CWE-191 CWE-476 CWE-362 CWE-1264 CWE-319 CWE-833",
    "cwe_mentions": [
      "CWE-789",
      "CWE-413",
      "CWE-1284",
      "CWE-191",
      "CWE-476",
      "CWE-362",
      "CWE-1264",
      "CWE-319",
      "CWE-833"
    ],
    "search_time": 3.2754361629486084
  },
  "timestamp": "2025-07-12 06:43:07",
  "cve_id": "CVE-2024-56687",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "789",
      "name": "Memory Allocation with Excessive Size Value",
      "type": "variant",
      "score": 3.24,
      "relationship_count": 0
    },
    {
      "cwe_id": "1325",
      "name": "Improperly Controlled Sequential Memory Allocation",
      "type": "base",
      "score": 2.9120000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "type": "Base",
      "score": 2.7775743488370095,
      "relationship_count": 0
    },
    {
      "cwe_id": "319",
      "name": "Cleartext Transmission of Sensitive Information",
      "type": "base",
      "score": 2.1189999999999998,
      "relationship_count": 0
    },
    {
      "cwe_id": "129",
      "name": "Improper Validation of Array Index",
      "type": "variant",
      "score": 2.04,
      "relationship_count": 0
    },
    {
      "cwe_id": "823",
      "name": "Use of Out-of-range Pointer Offset",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "120",
      "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "123",
      "name": "Write-what-where Condition",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 1.729478976811396,
      "relationship_count": 0
    },
    {
      "cwe_id": "1265",
      "name": "Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "386",
      "name": "Symbolic Name not Mapping to Correct Object",
      "type": "base",
      "score": 1.6744000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "662",
      "name": "Improper Synchronization",
      "type": "class",
      "score": 1.6736000000000002,
      "relationship_count": 0
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 1.6370441296687408,
      "relationship_count": 0
    },
    {
      "cwe_id": "61",
      "name": "UNIX Symbolic Link (Symlink) Following",
      "type": "compound",
      "score": 1.61,
      "relationship_count": 0
    },
    {
      "cwe_id": "1264",
      "name": "Hardware Logic with Insecure De-Synchronization between Control and Data Channels",
      "type": "Base",
      "score": 1.589313054730392,
      "relationship_count": 0
    },
    {
      "cwe_id": "1037",
      "name": "Processor Optimization Removal or Modification of Security-critical Code",
      "type": "base",
      "score": 1.521,
      "relationship_count": 0
    },
    {
      "cwe_id": "252",
      "name": "Unchecked Return Value",
      "type": "Base",
      "score": 1.503356218277404,
      "relationship_count": 0
    },
    {
      "cwe_id": "415",
      "name": "Double Free",
      "type": "variant",
      "score": 1.4784000000000002,
      "relationship_count": 0
    },
    {
      "cwe_id": "413",
      "name": "Improper Resource Locking",
      "type": "Base",
      "score": 1.470592653748342,
      "relationship_count": 0
    }
  ]
}