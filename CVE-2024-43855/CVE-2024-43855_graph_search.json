{
  "retriever": "graph",
  "query": "In the Linux kernel, the following vulnerability has been resolved md fix deadlock between mddev_suspend and flush bio Deadlock occurs when mddev is being suspended while some flush bio is in progress. It is a complex issue. T1. the first flush is at the ending stage, it clears mddev->flush_bio and tries to submit data, but is blocked because mddev is suspended by T4. T2. the second flush sets mddev->flush_bio, and attempts to queue md_submit_flush_data(), which is already running (T1) and wont execute again if on the same CPU as T1. T3. the third flush inc active_io and tries to flush, but is blocked because mddev->flush_bio is not NULL (set by T2). T4. mddev_suspend() is called and waits for active_io dec to 0 which is inc by T3. T1T2T3T4 (flush 1)(flush 2)(third 3)(suspend) md_submit_flush_data mddev->flush_bio = NULL . . md_flush_request . mddev->flush_bio = bio . queue submit_flushes . . . .md_handle_request . . active_io + 1 . . md_flush_request . . wait !mddev->flush_bio . . . .mddev_suspend . . wait !active_io . . . submit_flushes . queue_work md_submit_flush_data . //md_submit_flush_data is already running (T1) . md_handle_request wait resume The root issue is non-atomic inc/dec of active_io during flush process. active_io is dec before md_submit_flush_data is queued, and inc soon after md_submit_flush_data() run. md_flush_request active_io + 1 sub Consider specifically these CWEs: CWE-413 CWE-1190 CWE-367 CWE-1250 CWE-1264 CWE-427 CWE-667 CWE-833",
  "keyphrases": {
    "original_query": "In the Linux kernel, the following vulnerability has been resolved md fix deadlock between mddev_suspend and flush bio Deadlock occurs when mddev is being suspended while some flush bio is in progress. It is a complex issue. T1. the first flush is at the ending stage, it clears mddev->flush_bio and tries to submit data, but is blocked because mddev is suspended by T4. T2. the second flush sets mddev->flush_bio, and attempts to queue md_submit_flush_data(), which is already running (T1) and wont execute again if on the same CPU as T1. T3. the third flush inc active_io and tries to flush, but is blocked because mddev->flush_bio is not NULL (set by T2). T4. mddev_suspend() is called and waits for active_io dec to 0 which is inc by T3. T1T2T3T4 (flush 1)(flush 2)(third 3)(suspend) md_submit_flush_data mddev->flush_bio = NULL . . md_flush_request . mddev->flush_bio = bio . queue submit_flushes . . . .md_handle_request . . active_io + 1 . . md_flush_request . . wait !mddev->flush_bio . . . .mddev_suspend . . wait !active_io . . . submit_flushes . queue_work md_submit_flush_data . //md_submit_flush_data is already running (T1) . md_handle_request wait resume The root issue is non-atomic inc/dec of active_io during flush process. active_io is dec before md_submit_flush_data is queued, and inc soon after md_submit_flush_data() run. md_flush_request active_io + 1 sub",
    "enhanced_query": "In the Linux kernel, the following vulnerability has been resolved md fix deadlock between mddev_suspend and flush bio Deadlock occurs when mddev is being suspended while some flush bio is in progress. It is a complex issue. T1. the first flush is at the ending stage, it clears mddev->flush_bio and tries to submit data, but is blocked because mddev is suspended by T4. T2. the second flush sets mddev->flush_bio, and attempts to queue md_submit_flush_data(), which is already running (T1) and wont execute again if on the same CPU as T1. T3. the third flush inc active_io and tries to flush, but is blocked because mddev->flush_bio is not NULL (set by T2). T4. mddev_suspend() is called and waits for active_io dec to 0 which is inc by T3. T1T2T3T4 (flush 1)(flush 2)(third 3)(suspend) md_submit_flush_data mddev->flush_bio = NULL . . md_flush_request . mddev->flush_bio = bio . queue submit_flushes . . . .md_handle_request . . active_io + 1 . . md_flush_request . . wait !mddev->flush_bio . . . .mddev_suspend . . wait !active_io . . . submit_flushes . queue_work md_submit_flush_data . //md_submit_flush_data is already running (T1) . md_handle_request wait resume The root issue is non-atomic inc/dec of active_io during flush process. active_io is dec before md_submit_flush_data is queued, and inc soon after md_submit_flush_data() run. md_flush_request active_io + 1 sub Consider specifically these CWEs: CWE-413 CWE-1190 CWE-367 CWE-1250 CWE-1264 CWE-427 CWE-667 CWE-833",
    "cwe_mentions": [
      "CWE-413",
      "CWE-1190",
      "CWE-367",
      "CWE-1250",
      "CWE-1264",
      "CWE-427",
      "CWE-667",
      "CWE-833"
    ],
    "search_time": 3.369513750076294
  },
  "timestamp": "2025-07-12 04:07:38",
  "cve_id": "CVE-2024-43855",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "609",
      "name": "Double-Checked Locking",
      "type": "base",
      "score": 2.8651999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "367",
      "name": "Time-of-check Time-of-use (TOCTOU) Race Condition",
      "type": "base",
      "score": 2.821,
      "relationship_count": 0
    },
    {
      "cwe_id": "427",
      "name": "Uncontrolled Search Path Element",
      "type": "base",
      "score": 2.3295999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 1.6928997614870478,
      "relationship_count": 0
    },
    {
      "cwe_id": "413",
      "name": "Improper Resource Locking",
      "type": "Base",
      "score": 1.6667262940422307,
      "relationship_count": 0
    },
    {
      "cwe_id": "386",
      "name": "Symbolic Name not Mapping to Correct Object",
      "type": "base",
      "score": 1.521,
      "relationship_count": 0
    },
    {
      "cwe_id": "426",
      "name": "Untrusted Search Path",
      "type": "base",
      "score": 1.521,
      "relationship_count": 0
    },
    {
      "cwe_id": "1037",
      "name": "Processor Optimization Removal or Modification of Security-critical Code",
      "type": "base",
      "score": 1.521,
      "relationship_count": 0
    },
    {
      "cwe_id": "1264",
      "name": "Hardware Logic with Insecure De-Synchronization between Control and Data Channels",
      "type": "Base",
      "score": 1.454870939891296,
      "relationship_count": 0
    },
    {
      "cwe_id": "1190",
      "name": "DMA Device Enabled Too Early in Boot Phase",
      "type": "Base",
      "score": 1.453549043040917,
      "relationship_count": 0
    },
    {
      "cwe_id": "1250",
      "name": "Improper Preservation of Consistency Between Independent Representations of Shared State",
      "type": "Base",
      "score": 1.449841887508522,
      "relationship_count": 0
    },
    {
      "cwe_id": "486",
      "name": "Comparison of Classes by Name",
      "type": "variant",
      "score": 1.0584,
      "relationship_count": 0
    },
    {
      "cwe_id": "98",
      "name": "Improper Control of Filename for Include/Require Statement in PHP Program ('PHP Remote File Inclusion')",
      "type": "variant",
      "score": 1.0584,
      "relationship_count": 0
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "type": "Class",
      "score": 1.0327020992089357,
      "relationship_count": 0
    },
    {
      "cwe_id": "832",
      "name": "Unlock of a Resource that is not Locked",
      "type": "base",
      "score": 1.0062,
      "relationship_count": 0
    },
    {
      "cwe_id": "414",
      "name": "Missing Lock Check",
      "type": "base",
      "score": 1.0062,
      "relationship_count": 0
    },
    {
      "cwe_id": "412",
      "name": "Unrestricted Externally Accessible Lock",
      "type": "base",
      "score": 1.0062,
      "relationship_count": 0
    },
    {
      "cwe_id": "1234",
      "name": "Hardware Internal or Debug Modes Allow Override of Locks",
      "type": "base",
      "score": 1.0062,
      "relationship_count": 0
    },
    {
      "cwe_id": "1233",
      "name": "Security-Sensitive Hardware Controls with Missing Lock Bit Protection",
      "type": "base",
      "score": 1.0062,
      "relationship_count": 0
    },
    {
      "cwe_id": "1232",
      "name": "Improper Lock Behavior After Power State Transition",
      "type": "base",
      "score": 1.0062,
      "relationship_count": 0
    }
  ]
}