# Vulnerability Information: CVE-2024-46692

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved firmware qcom scm Mark get_wq_ctx() as atomic call Currently get_wq_ctx() is wrongly configured as a standard call. When two SMC calls are in sleep and one SMC wakes up, it calls get_wq_ctx() to resume the corresponding sleeping thread. But if get_wq_ctx() is interrupted, goes to sleep and another SMC call is waiting to be allocated a waitq context, it leads to a deadlock. To avoid this get_wq_ctx() must be an atomic call and cant be a standard SMC call. Hence mark get_wq_ctx() as a fast call.

### Vulnerability Description Key Phrases
- **rootcause:** **wrong configuration of get_wq_ctx() as a standard call**
- **impact:** deadlock
- **product:** Linux kernel
- **component:** firmware qcom scm

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of the vulnerability:

**Root Cause:**
The `get_wq_ctx()` function, used for resuming sleeping threads after an SMC (Secure Monitor Call), was incorrectly configured as a standard call instead of an atomic (fast) call.

**Weaknesses/Vulnerabilities:**
- **Non-atomic operation:** The `get_wq_ctx()` function was vulnerable to interruption. If it was interrupted and went to sleep, another SMC call could potentially attempt to allocate a wait queue context, leading to a deadlock.
- **Incorrect call configuration:** The function was set up as a standard SMC call when it required the properties of a fast/atomic call.

**Impact of Exploitation:**
- **Deadlock:** The primary consequence of this vulnerability is a deadlock situation, where multiple SMC calls are blocked indefinitely, halting the system or specific processes that rely on SMC calls.

**Attack Vectors:**
- **Multiple concurrent SMC calls:** The vulnerability can be triggered by having multiple simultaneous SMC calls that involve sleeping and resuming threads using wait queues. Specifically, the scenario involves one SMC call waking up and calling `get_wq_ctx()`, while another SMC call is waiting to allocate a wait queue context.

**Required Attacker Capabilities/Position:**
- The attacker needs the capability to trigger multiple concurrent SMC calls that involve sleeping and resuming threads. This would typically require some level of access to the system and the ability to execute code that performs SMC calls.

**Additional Notes:**
- The fix involves changing the `get_wq_ctx()` function to use `ARM_SMCCC_FAST_CALL` instead of `ARM_SMCCC_STD_CALL`. This ensures that the call is atomic and cannot be interrupted, thus preventing the deadlock.
- The vulnerability is in the Qualcomm System Control Manager (SCM) driver within the Linux kernel.
- The patch addresses the issue by marking the function as a fast call. This change prevents the described scenario from causing a deadlock.
- The fix was backported to stable kernel branches.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.516 |
| 2 | 828 | Signal Handler with Functionality that is not Asynchronous-Safe | Variant | Allowed | sparse | 0.502 |
| 3 | 345 | Insufficient Verification of Data Authenticity | Class | Discouraged | sparse | 0.501 |
| 4 | 252 | Unchecked Return Value | Base | Allowed | sparse | 0.497 |
| 5 | 479 | Signal Handler Use of a Non-reentrant Function | Variant | Allowed | sparse | 0.484 |
| 6 | 863 | Incorrect Authorization | Class | Allowed-with-Review | sparse | 0.477 |
| 7 | 347 | Improper Verification of Cryptographic Signature | Base | Allowed | sparse | 0.477 |
| 8 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.477 |
| 9 | 413 | Improper Resource Locking | Base | Allowed | dense | 0.491 |
| 10 | 123 | Write-what-where Condition | Base | Allowed | graph | 0.002 |

