# Raw Retriever Results for CVE-2024-46797

# Raw Retriever Results for CVE-2024-46797
## Query
In the Linux kernel, the following vulnerability has been resolvedpowerpc/qspinlock Fix deadlock in MCS queueIf an interrupt occurs in queued_spin_lock_slowpath() after we incrementqnodesp->count and before node->lock is initialized, another CPU mightsee stale lock values in get_tail_qnode(). If the stale lock value happensto match the lock on that CPU, then we write to the next pointer ofthe wrong qnode. This causes a deadlock as the former CPU, once it becomesthe head of the MCS queue, will spin indefinitely until its next pointeris set by its successor in the queue.Running stress-ng on a 16 core (16EC/16VP) shared LPAR, results inoccasional lockups similar to the following $ stress-ng --all 128 --vm-bytes 80% --aggressive \ --maximize --oomable --verify --syslog \ --metrics --times --timeout 5m watchdog CPU 15 Hard LOCKUP ...... NIP [c0000000000b78f4] queued_spin_lock_slowpath+0x1184/0x1490 LR [c000000001037c5c] _raw_spin_lock+0x6c/0x90 Call Trace 0xc000002cfffa3bf0 (unreliable) _raw_spin_lock+0x6c/0x90 raw_spin_rq_lock_nested.part.135+0x4c/0xd0 sched_ttwu_pending+0x60/0x1f0 __flush_smp_call_function_queue+0x1dc/0x670 smp_ipi_demux_relaxed+0xa4/0x100 xive_muxed_ipi_action+0x20/0x40 __handle_irq_event_percpu+0x80/0x240 handle_irq_event_percpu+0x2c/0x80 handle_percpu_irq+0x84/0xd0 generic_handle_irq+0x54/0x80 __do_irq+0xac/0x210 __do_IRQ+0x74/0xd0 0x0 do_IRQ+0x8c/0x170 hardware_interrupt_common_virt+0x29c/0x2a0 --- interrupt 500 at queued_spin_lock_slowpath+0x4b8/0x1490 ...... NIP [c0000000000b6c28] queued_spin_lock_slowpath+0x4b8/0x1490 LR [c000000001037c5c] _raw_spin_lock+0x6c/0x90 --- interrupt 500 0xc0000029c1a41d00 (unreliable) _raw_spin_lock+0x6c/0x90 futex_wake+0x100/0x260 do_futex+0x21c/0x2a0 sys_futex+0x98/0x270 system_call_exception+0x14c/0x2f0 system_call_vectored_common+0x15c/0x2ecThe following code flow illustrates how the deadlock occurs.For the sake of brevity, assume that both locks (A and B) arecontended and we call the queued_spin_lock_slowpath() function. CPU0 CPU1 ---- ---- spin_lock_irqsave(A) | spin_unlock_irqrestore(A) | spin_lock(B) | | | ? | id = qnodesp->count++ | (Note that nodes[0].lock == A) | | | ? | Interrupt | (happens before nodes[0].lock = B) | | | ? | spin_lock_irqsave(A) | | | ? | id = qnodesp->count++ | nodes[1].lock = A | | | ? | Tail of MCS queue | | spin_lock_irqsave(A) ? | Head of MCS queue ? | CPU0 is previous tail ? | Spin indefinitely ? (until nodes[1].next != NULL) prev = get_tail_qnode(A, CPU0) | ? prev == &qnodes[CPU0].nodes[0] (as qnodes---truncated---

## Keyphrases
- **rootcause**: 'A race condition in queued_spin_lock_slowpath() leads to a deadlock. Specifically', 'an interrupt occurring after incrementing qnodesp->count but before initializing node->lock can cause another CPU to read stale lock values from get_tail_qnode(). If this stale lock value matches the lock on the other CPU', 'it can result in incorrect next pointer assignment in the MCS queue', 'causing a deadlock.'
- **weakness**: 'Race condition due to the lack of proper synchronization between incrementing the qnodesp->count', 'initializing node->lock in the queued_spin_lock_slowpath() function.'

## Score Statistics
| Retriever | Min | Max | Mean | Median | Count |
|-----------|-----|-----|------|--------|-------|
| Dense | 0.4756 | 0.5915 | 0.5100 | 0.5093 | 20 |
| Sparse | 796.7738 | 1074.4332 | 940.3881 | 943.5412 | 12 |
| Graph | 1.2715 | 2.2100 | 1.6466 | 1.6666 | 20 |

## Graph Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Mapping Usage |
|---|--------|------|-------------|-------|---------------|
| 1 | 476 | NULL Pointer Dereference | base | 2.2100 | Allowed |
| 2 | 1322 | Use of Blocking Code in Single-threaded, Non-blocking Context | base | 2.2100 | Allowed |
| 3 | 416 | Use After Free | variant | 2.0400 | Allowed |
| 4 | 123 | Write-what-where Condition | base | 1.7680 | Allowed |
| 5 | 120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | base | 1.7680 | Allowed-with-Review |
| 6 | 833 | Deadlock | Base | 1.7279 | Allowed |
| 7 | 413 | Improper Resource Locking | Base | 1.7137 | Allowed |
| 8 | 1265 | Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls | base | 1.6848 | Allowed |
| 9 | 252 | Unchecked Return Value | base | 1.6848 | Allowed |
| 10 | 386 | Symbolic Name not Mapping to Correct Object | base | 1.6744 | Allowed |
| 11 | 1281 | Sequence of Processor Instructions Leads to Unexpected Behavior | Base | 1.6589 | Allowed |
| 12 | 61 | UNIX Symbolic Link (Symlink) Following | compound | 1.6100 | Allowed |
| 13 | 789 | Memory Allocation with Excessive Size Value | variant | 1.5552 | Allowed |
| 14 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | 1.4870 | Allowed |
| 15 | 1342 | Information Exposure through Microarchitectural State after Transient Execution | Base | 1.4863 | Allowed |

## Dense Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Original Score | Mapping Usage |
|---|--------|------|-------------|-------|----------------|---------------|
| 1 | 833 | Deadlock | Base | 0.5915 | 0.5915 | Allowed |
| 2 | 667 | Improper Locking | Class | 0.5581 | 0.5581 | Allowed-with-Review |
| 3 | 413 | Improper Resource Locking | Base | 0.5558 | 0.5558 | Allowed |
| 4 | 1281 | Sequence of Processor Instructions Leads to Unexpected Behavior | Base | 0.5334 | 0.5334 | Allowed |
| 5 | 1342 | Information Exposure through Microarchitectural State after Transient Execution | Base | 0.5263 | 0.5263 | Allowed |
| 6 | 1264 | Hardware Logic with Insecure De-Synchronization between Control and Data Channels | Base | 0.5233 | 0.5233 | Allowed |
| 7 | 764 | Multiple Locks of a Critical Resource | Base | 0.5216 | 0.5216 | Allowed |
| 8 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | 0.5156 | 0.5156 | Allowed |
| 9 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | 0.5114 | 0.5114 | Allowed-with-Review |
| 10 | 909 | Missing Initialization of Resource | Class | 0.5113 | 0.5113 | Allowed-with-Review |
| 11 | 765 | Multiple Unlocks of a Critical Resource | Base | 0.5073 | 0.5073 | Allowed |
| 12 | 1421 | Exposure of Sensitive Information in Shared Microarchitectural Structures during Transient Execution | Base | 0.4890 | 0.4890 | Allowed |
| 13 | 606 | Unchecked Input for Loop Condition | Base | 0.4865 | 0.4865 | Allowed |
| 14 | 662 | Improper Synchronization | Class | 0.4864 | 0.4864 | Discouraged |
| 15 | 364 | Signal Handler Race Condition | Base | 0.4850 | 0.4850 | Allowed |

## Sparse Retriever Results (12)
| # | CWE ID | Name | Score | Original Score | Mapping Usage |
|---|--------|------|-------|---------------|---------------|
| 1 | 667 | Improper Locking | 1074.4332 | 1074.4332 | Allowed-with-Review |
| 2 | 833 | Deadlock | 1073.3653 | 1073.3653 | Allowed |
| 3 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | 971.0937 | 971.0937 | Allowed-with-Review |
| 4 | 451 | User Interface (UI) Misrepresentation of Critical Information | 968.0917 | 968.0917 | Allowed-with-Review |
| 5 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | 958.0269 | 958.0269 | Allowed |
| 6 | 1390 | Weak Authentication | 948.7712 | 948.7712 | Allowed-with-Review |
| 7 | 319 | Cleartext Transmission of Sensitive Information | 938.3111 | 938.3111 | Allowed |
| 8 | 400 | Uncontrolled Resource Consumption | 926.5619 | 926.5619 | Discouraged |
| 9 | 770 | Allocation of Resources Without Limits or Throttling | 916.7564 | 916.7564 | Allowed |
| 10 | 1284 | Improper Validation of Specified Quantity in Input | 914.8131 | 914.8131 | Allowed |
| 11 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | 797.6586 | 797.6586 | Discouraged |
| 12 | 364 | Signal Handler Race Condition | 796.7738 | 796.7738 | Allowed |
