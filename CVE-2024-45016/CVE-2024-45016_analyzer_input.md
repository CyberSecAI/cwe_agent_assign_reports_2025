# Vulnerability Information: CVE-2024-45016

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved netem fix return value if duplicate enqueue fails There is a bug in netem_enqueue() introduced by commit 5845f706388a (net netem fix skb length BUG_ON in __skb_to_sgvec) that can lead to a **use-after-free**. This commit made netem_enqueue() always return NET_XMIT_SUCCESS when a packet is duplicated, which can cause the parent qdiscs q.qlen to be mistakenly incremented. When this happens qlen_notify() may be skipped on the parent during destruction, leaving a dangling pointer for some classful qdiscs like DRR. There are two ways for the bug happen - If the duplicated packet is dropped by rootq->enqueue() and then the original packet is also dropped. - If rootq->enqueue() sends the duplicated packet to a different qdisc and the original packet is dropped. In both cases NET_XMIT_SUCCESS is returned even though no packets are enqueued at the netem qdisc. The fix is to defer the enqueue of the duplicate packet until after the original packet has been guaranteed to return NET_XMIT_SUCCESS.

### Vulnerability Description Key Phrases
- **rootcause:** **bug in netem_enqueue() that can lead to a use-after-free**
- **weakness:** **use-after-free**
- **product:** Linux kernel
- **component:** netem

## CVE Reference Links Content Summary
Based on the provided information, this content relates to **CVE-2024-45016**.

**Root cause of vulnerability:**
The vulnerability lies within the `netem_enqueue()` function in the Linux kernel's `sch_netem.c` file. A bug introduced by commit 5845f706388a caused `netem_enqueue()` to always return `NET_XMIT_SUCCESS` when a packet was duplicated, even if the duplicated packet was dropped or sent to a different qdisc.

**Weaknesses/vulnerabilities present:**
- Incorrect return value: The function incorrectly returns `NET_XMIT_SUCCESS` even when the duplicated packet is not enqueued by the netem qdisc.
- Qdisc length accounting issue: The incorrect return value causes the parent qdisc's `q.qlen` to be incremented, leading to a desynchronization.
- Use-after-free: The desynchronization of `q.qlen` may cause `qlen_notify()` to be skipped during the parent's destruction, potentially leaving a dangling pointer, which can lead to a use-after-free, particularly in classful qdiscs like DRR.

**Impact of exploitation:**
- Use-after-free: A potential use-after-free condition leading to possible crashes or arbitrary code execution.
- Denial of Service: Incorrect accounting may lead to incorrect handling of network traffic causing denial of service.

**Attack vectors:**
- Network traffic manipulation: The vulnerability can be triggered by sending network traffic that is then manipulated by the Netem qdisc to cause packet duplication. Specifically, manipulating network traffic to trigger the packet duplication logic in netem_enqueue where the duplicate is dropped or enqueued on different qdisc.

**Required attacker capabilities/position:**
- Ability to send network traffic to a system where the Netem qdisc is configured and active. The attacker does not need local access and can trigger the vulnerability through the network.
- The attacker needs the ability to set up traffic conditions that induce the packet duplication in Netem.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 416 | Use After Free | Variant | Allowed | alternate_terms | 0.800 |
| 2 | 252 | Unchecked Return Value | Base | Allowed | sparse | 0.979 |
| 3 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.927 |
| 4 | 833 | Deadlock | Base | Allowed | sparse | 0.923 |
| 5 | 617 | Reachable Assertion | Base | Allowed | sparse | 0.906 |
| 6 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.899 |
| 7 | 415 | Double Free | Variant | Allowed | sparse | 0.897 |
| 8 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.896 |
| 9 | 909 | Missing Initialization of Resource | Class | Allowed-with-Review | dense | 0.480 |
| 10 | 123 | Write-what-where Condition | Base | Allowed | graph | 0.003 |

