{
  "retriever": "sparse",
  "query": "In the Linux kernel, the following vulnerability has been resolved drm/xe/guc_submit add missing locking in wedged_fini Any non-wedged queue can have a zero refcount here and can be running concurrently with an async queue destroy, therefore dereferencing the queue ptr to check wedge status after the lookup can trigger UAF if queue is not wedged. Fix this by keeping the submission_state lock held around the check to postpone the free and make the check safe, before dropping again around the put() to avoid the deadlock. (cherry picked from commit d28af0b6b9580b9f90c265a7da0315b0ad20bbfd)",
  "keyphrases": {
    "rootcause": [
      "missing locking"
    ],
    "weakness": [
      "use-after-free"
    ]
  },
  "timestamp": "2025-07-12 05:24:24",
  "cve_id": "CVE-2024-49943",
  "result_count": 15,
  "results": [
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "score": 1000.0,
      "search_source": "alternate_term_match"
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "score": 497.4537194102585,
      "search_source": "rootcause:missing locking"
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "score": 486.4321359540402,
      "search_source": "rootcause:missing locking"
    },
    {
      "cwe_id": "606",
      "name": "Unchecked Input for Loop Condition",
      "score": 458.3190133073384,
      "search_source": "rootcause:missing locking"
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "score": 454.70631239485056,
      "search_source": "rootcause:missing locking"
    },
    {
      "cwe_id": "770",
      "name": "Allocation of Resources Without Limits or Throttling",
      "score": 450.3479593834452,
      "search_source": "rootcause:missing locking"
    },
    {
      "cwe_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "score": 446.59316405796017,
      "search_source": "rootcause:missing locking"
    },
    {
      "cwe_id": "190",
      "name": "Integer Overflow or Wraparound",
      "score": 422.2890314656711,
      "search_source": "rootcause:missing locking"
    },
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "score": 420.6503790283432,
      "search_source": "rootcause:missing locking"
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "score": 412.5193274579357,
      "search_source": "rootcause:missing locking"
    },
    {
      "cwe_id": "863",
      "name": "Incorrect Authorization",
      "score": 412.14187035492546,
      "search_source": "rootcause:missing locking"
    },
    {
      "cwe_id": "415",
      "name": "Double Free",
      "score": 406.4990599770605,
      "search_source": "weakness:use-after-free"
    },
    {
      "cwe_id": "911",
      "name": "Improper Update of Reference Count",
      "score": 404.8914919251551,
      "search_source": "weakness:use-after-free"
    },
    {
      "cwe_id": "367",
      "name": "Time-of-check Time-of-use (TOCTOU) Race Condition",
      "score": 398.3287940051995,
      "search_source": "weakness:use-after-free"
    },
    {
      "cwe_id": "789",
      "name": "Memory Allocation with Excessive Size Value",
      "score": 137.297145639711,
      "search_source": "base_query"
    }
  ]
}