# Vulnerability Information: CVE-2024-41074

## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved cachefiles Set object to close if ondemand_id < 0 in copen If copen is maliciously called in the user mode, it may delete the request corresponding to the random id. And the request may have not been read yet. Note that when the object is set to reopen, the open request will be done with the still reopen state in above case. As a result, the request corresponding to this object is always skipped in select_req function, so the read request is never completed and blocks other process. Fix this issue by simply set object to close if its id < 0 in copen.

### Vulnerability Description Key Phrases
- **impact:** delete the request
- **product:** Linux kernel
- **component:** cachefiles Set object

## CVE Reference Links Content Summary
The provided content relates to CVE-2024-41074.

**Root cause of vulnerability:**
The vulnerability stems from a flaw in the `cachefiles_ondemand_copen` function within the Linux kernel's cachefiles subsystem. If `copen` is called with a negative `ondemand_id`, it can lead to a situation where a request corresponding to a random ID is deleted before it is read.

**Weaknesses/vulnerabilities present:**
- The `copen` function could be maliciously triggered from user mode, leading to the deletion of a pending request.
- When an object is set to reopen, the open request is performed while in the "reopen" state. This prevents the request from being processed correctly by `select_req`, causing a read request to never complete and blocking other processes.
- The code did not properly handle cases where `ondemand_id` is negative, leading to incorrect object state management.

**Impact of exploitation:**
- A malicious user can cause a denial-of-service (DoS) by triggering the vulnerability. This occurs because a read request will never complete, blocking other processes that rely on the cachefiles subsystem.

**Attack vectors:**
- A malicious user-mode application could call the `copen` function with a negative `ondemand_id`.

**Required attacker capabilities/position:**
- The attacker needs to be able to execute code in user mode.
- The attacker would need to be able to call `cachefiles_ondemand_copen` with a crafted negative id.

The provided patches fix this vulnerability by setting the object to a closed state if its `ondemand_id` is negative within the `cachefiles_ondemand_copen` function.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 639 | Authorization Bypass Through User-Controlled Key | Base | Allowed | sparse | 0.210 |
| 2 | 863 | Incorrect Authorization | Class | Allowed-with-Review | sparse | 0.206 |
| 3 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.204 |
| 4 | 1321 | Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution') | Variant | Allowed | sparse | 0.199 |
| 5 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.198 |
| 6 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.197 |
| 7 | 212 | Improper Removal of Sensitive Information Before Storage or Transfer | Base | Allowed | sparse | 0.196 |
| 8 | 923 | Improper Restriction of Communication Channel to Intended Endpoints | Class | Allowed-with-Review | sparse | 0.196 |
| 9 | 403 | Exposure of File Descriptor to Unintended Control Sphere ('File Descriptor Leak') | Base | Allowed | dense | 0.520 |
| 10 | 364 | Signal Handler Race Condition | Base | Allowed | graph | 0.002 |

