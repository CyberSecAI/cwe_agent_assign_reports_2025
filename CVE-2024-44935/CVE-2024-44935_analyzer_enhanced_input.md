## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved sctp Fix **null-ptr-deref** in reuseport_add_sock(). syzbot reported a **null-ptr-deref** while accessing sk2->sk_reuseport_cb in reuseport_add_sock(). [0] The repro first creates a listener with SO_REUSEPORT. Then, it creates another listener on the same port and concurrently closes the first listener. The second listen() calls reuseport_add_sock() with the first listener as sk2, where sk2->sk_reuseport_cb is not expected to be cleared concurrently, but the close() does clear it by reuseport_detach_sock(). The problem is SCTP does not properly synchronise reuseport_alloc(), reuseport_add_sock(), and reuseport_detach_sock(). The caller of reuseport_alloc() and reuseport_{add,detach}_sock() must provide synchronisation for sockets that are classified into the same reuseport group. Otherwise, such sockets form multiple identical reuseport groups, and all groups except one would be silently dead. 1. Two sockets call listen() concurrently 2. No socket in the same group found in sctp_ep_hashtable[] 3. Two sockets call reuseport_alloc() and form two reuseport groups 4. Only one group hit first in __sctp_rcv_lookup_endpoint() receives incoming packets Also, the reported **null-ptr-deref** could occur. TCP/UDP guarantees that would not happen by holding the hash bucket lock. Lets apply the locking strategy to __sctp_hash_endpoint() and __sctp_unhash_endpoint(). [0] Oops general protection fault, pr

### Vulnerability Description Key Phrases
- **rootcause:** **improper synchronisation**
- **weakness:** **null-ptr-deref**
- **impact:** Oops and general protection fault
- **vector:** multiple identical reuseport groups
- **product:** Linux kernel
- **component:** sctp

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of the vulnerability described:

**Root Cause of Vulnerability:**

The root cause of the vulnerability is a lack of proper synchronization in the SCTP (Stream Control Transmission Protocol) implementation when handling SO_REUSEPORT sockets. Specifically, the functions `reuseport_alloc()`, `reuseport_add_sock()`, and `reuseport_detach_sock()` were not properly synchronized, leading to race conditions.

**Weaknesses/Vulnerabilities Present:**

- **Race Condition:** Concurrent calls to `listen()` on the same port, combined with the closing of one of the listeners, can trigger a race condition in the SCTP code. The `sk->sk_reuseport_cb` pointer of a socket could be cleared by a concurrent `close()` operation through `reuseport_detach_sock()` while another thread is using it in `reuseport_add_sock()`.
- **Null Pointer Dereference:** Due to the race condition, a thread calling `reuseport_add_sock()` might attempt to access the `sk->sk_reuseport_cb` member of a socket (`sk2`) after it has been freed (set to NULL). This leads to a null-pointer dereference.
- **Inconsistent Reuseport Groups:** The lack of synchronization could result in the creation of multiple identical reuseport groups, making all but one of the groups "silently dead" and non-functional, leading to issues when receiving incoming packets.

**Impact of Exploitation:**

- **Kernel Panic/Crash:** The null pointer dereference triggers a kernel panic, leading to a denial-of-service. The provided crash log clearly shows the KASAN report of null pointer dereference.
- **Unreliable Communication:** The creation of multiple reuseport groups can lead to unpredictable behavior, as only one of these groups will receive incoming packets, leading to dropped or misrouted communication.

**Attack Vectors:**

- **Local:** A local attacker can trigger this vulnerability by creating two SCTP listeners using `SO_REUSEPORT` option on the same port, and concurrently closing one of them. The second `listen()` call would trigger the race.

**Required Attacker Capabilities/Position:**

- **Ability to Create Sockets:** The attacker must be able to create SCTP sockets with the `SO_REUSEPORT` option.
- **Control over Socket Closure:** The attacker needs to be able to close the first listener while the second `listen()` call is being executed, triggering the race condition.
- **Privileged Access (Optional):** While the specific exploit trigger is not strictly requiring it, the impact (kernel crash) would require access at a certain privilege level. The syzbot reproducer is running as UID 0 which indicates a privileged attack.

**Additional Notes:**

- The provided diffs show the fix for this issue by adding a lock to the hash bucket in `__sctp_hash_endpoint()` and `__sctp_unhash_endpoint()`, which serializes access and prevents the race condition.
- The vulnerability was discovered and reported by syzbot, a kernel fuzzer, which highlights the importance of automated testing for finding such subtle concurrency issues.
- The fix is backported to the stable kernel branches.
- TCP/UDP do not have the issue, because the hash bucket lock is already held in those protocols.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 863 | Incorrect Authorization | Class | Allowed-with-Review | sparse | 0.817 |
| 2 | 476 | NULL Pointer Dereference | Base | Allowed | sparse | 0.807 |
| 3 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.769 |
| 4 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.768 |
| 5 | 833 | Deadlock | Base | Allowed | sparse | 0.761 |
| 6 | 1390 | Weak Authentication | Class | Allowed-with-Review | sparse | 0.756 |
| 7 | 287 | Improper Authentication | Class | Discouraged | sparse | 0.746 |
| 8 | 923 | Improper Restriction of Communication Channel to Intended Endpoints | Class | Allowed-with-Review | sparse | 0.745 |
| 9 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | dense | 0.582 |
| 10 | 252 | Unchecked Return Value | Base | Allowed | graph | 0.002 |



# Complete CWE Specifications

CWE-863: Incorrect Authorization

CWE-476: NULL Pointer Dereference

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-667: Improper Locking

CWE-833: Deadlock

CWE-1390: Weak Authentication

CWE-287: Improper Authentication

CWE-923: Improper Restriction of Communication Channel to Intended Endpoints

CWE-401: Missing Release of Memory after Effective Lifetime

CWE-252: Unchecked Return Value