{
  "retriever": "sparse",
  "query": "In the Linux kernel, the following vulnerability has been resolved parisc Try to fix random segmentation faults in package builds PA-RISC systems with PA8800 and PA8900 processors have had problems with random segmentation faults for many years. Systems with earlier processors are much more stable. Systems with PA8800 and PA8900 processors have a large L2 cache which needs per page flushing for decent performance when a large range is flushed. The combined cache in these systems is also more sensitive to non-equivalent aliases than the caches in earlier systems. The majority of random segmentation faults that I have looked at appear to be memory corruption in memory allocated using mmap and malloc. My first attempt at fixing the random faults didnt work. On reviewing the cache code, I realized that there were two issues which the existing code didnt handle correctly. Both relate to cache move-in. Another issue is that the present bit in PTEs is racy. 1) PA-RISC caches have a mind of their own and they can speculatively load data and instructions for a page as long as there is a entry in the TLB for the page which allows move-in. TLBs are local to each CPU. Thus, the TLB entry for a page must be purged before flushing the page. This is particularly important on SMP systems. In some of the flush routines, the flush routine would be called and then the TLB entry would be purged. This was because the flush routine needed the TLB entry to do the flush. 2) My initial a",
  "keyphrases": {
    "rootcause": [
      "non-equivalent aliases"
    ],
    "weakness": [
      "memory corruption"
    ]
  },
  "timestamp": "2025-07-12 03:19:15",
  "cve_id": "CVE-2024-40918",
  "result_count": 12,
  "results": [
    {
      "cwe_id": "190",
      "name": "Integer Overflow or Wraparound",
      "score": 1215.583430043322,
      "search_source": "rootcause:non-equivalent aliases"
    },
    {
      "cwe_id": "125",
      "name": "Out-of-bounds Read",
      "score": 1198.8749045219329,
      "search_source": "rootcause:non-equivalent aliases"
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "score": 1196.5614792975882,
      "search_source": "rootcause:non-equivalent aliases"
    },
    {
      "cwe_id": "770",
      "name": "Allocation of Resources Without Limits or Throttling",
      "score": 1191.8196267744668,
      "search_source": "rootcause:non-equivalent aliases"
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "score": 1184.3545704376506,
      "search_source": "rootcause:non-equivalent aliases"
    },
    {
      "cwe_id": "1250",
      "name": "Improper Preservation of Consistency Between Independent Representations of Shared State",
      "score": 1182.1945558209336,
      "search_source": "rootcause:non-equivalent aliases"
    },
    {
      "cwe_id": "923",
      "name": "Improper Restriction of Communication Channel to Intended Endpoints",
      "score": 1182.0321074848764,
      "search_source": "rootcause:non-equivalent aliases"
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "score": 1178.1770977688402,
      "search_source": "rootcause:non-equivalent aliases"
    },
    {
      "cwe_id": "863",
      "name": "Incorrect Authorization",
      "score": 1163.1331264657447,
      "search_source": "rootcause:non-equivalent aliases"
    },
    {
      "cwe_id": "212",
      "name": "Improper Removal of Sensitive Information Before Storage or Transfer",
      "score": 1160.9649243993936,
      "search_source": "rootcause:non-equivalent aliases"
    },
    {
      "cwe_id": "122",
      "name": "Heap-based Buffer Overflow",
      "score": 1094.7750045335601,
      "search_source": "weakness:memory corruption"
    },
    {
      "cwe_id": "787",
      "name": "Out-of-bounds Write",
      "score": 1091.4693116581136,
      "search_source": "weakness:memory corruption"
    }
  ]
}