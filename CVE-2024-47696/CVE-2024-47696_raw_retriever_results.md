# Raw Retriever Results for CVE-2024-47696

# Raw Retriever Results for CVE-2024-47696
## Query
In the Linux kernel, the following vulnerability has been resolved RDMA/iwcm Fix WARNINGat_kernel/workqueue.c#check_flush_dependency In the commit aee2424246f9 (RDMA/iwcm Fix a use-after-free related to destroying CM IDs), the function flush_workqueue is invoked to flush the work queue iwcm_wq. But at that time, the work queue iwcm_wq was created via the function alloc_ordered_workqueue without the flag WQ_MEM_RECLAIM. Because the current process is trying to flush the whole iwcm_wq, if iwcm_wq doesnt have the flag WQ_MEM_RECLAIM, verify that the current process is not reclaiming memory or running on a workqueue which doesnt have the flag WQ_MEM_RECLAIM as that can break forward-progress guarantee leading to a deadlock. The call trace is as below [ 125.350876][ T1430] Call Trace [ 125.356281][ T1430] [ 125.361285][ T1430] ? __warn (kernel/panic.c693) [ 125.367640][ T1430] ? check_flush_dependency (kernel/workqueue.c3706 (discriminator 9)) [ 125.375689][ T1430] ? report_bug (lib/bug.c180 lib/bug.c219) [ 125.382505][ T1430] ? handle_bug (arch/x86/kernel/traps.c239) [ 125.388987][ T1430] ? exc_invalid_op (arch/x86/kernel/traps.c260 (discriminator 1)) [ 125.395831][ T1430] ? asm_exc_invalid_op (arch/x86/include/asm/idtentry.h621) [ 125.403125][ T1430] ? check_flush_dependency (kernel/workqueue.c3706 (discriminator 9)) [ 125.410984][ T1430] ? check_flush_dependency (kernel/workqueue.c3706 (discriminator 9)) [ 125.418764][ T1430] __flush_workqueue (kernel/workqueue.c3970) [ 125.426021][ T1430] ? __pfx___might_resched (kernel/sched/core.c10151) [ 125.433431][ T1430] ? destroy_cm_id (drivers/infiniband/core/iwcm.c375) iw_cm [ 125.441209][ T1430] ? __pfx___flush_workqueue (kernel/workqueue.c3910) [ 125.473900][ T1430] ? _raw_spin_lock_irqsave (arch/x86/include/asm/atomic.h107 include/linux/atomic/atomic-arch-fallback.h2170 include/linux/atomic/atomic-instrumented.h1302 include/asm-generic/qspinlock.h111 include/linux/spinlock.h187 include/linux/spinlock_api_smp.h111 kernel/locking/spinlock.c162) [ 125.473909][ T1430] ? __pfx__raw_spin_lock_irqsave (kernel/locking/spinlock.c161) [ 125.482537][ T1430] _destroy_id (drivers/infiniband/core/cma.c2044) rdma_cm [ 125.495072][ T1430] nvme_rdma_free_queue (drivers/nvme/host/rdma.c656 drivers/nvme/host/rdma.c650) nvme_rdma [ 125.505827][ T1430] nvme_rdma_reset_ctrl_work (drivers/nvme/host/rdma.c2180) nvme_rdma [ 125.505831][ T1430] process_one_work (kernel/workqueue.c3231) [ 125.515122][ T1430] worker_thread (kernel/workqueue.c3306 kernel/workqueue.c3393) [ 125.515127][ T1430] ? __pfx_worker_thread (kernel/workqueue.c3339) [ 125.531837][ T1430] kthread (kernel/kthread.c389) [ 125.539864][ T1430] ? __pfx_kthread (kernel/kthread.c342) [ 125.550628][ T1430] ret_from_fork (arch/x86/kernel/process.c147) [ 125.558840][ T1430] ? __pfx_kthread (kernel/kthread.c342) [ 125.558844][ T1430] ret_from_fork_asm (arch/x86/entry/entry_64.S257) [ 125.566487][ T1430] [ 125.566488][ T1430] ---[ end trace 0000000000000000 ]---

## Keyphrases
- **rootcause**: 'The workqueue iwcm_wq was created without the WQ_MEM_RECLAIM flag', 'leading to a potential deadlock when trying to flush it during memory reclamation.'
- **weakness**: 'The workqueue iwcm_wq lacks the WQ_MEM_RECLAIM flag', 'which is necessary for safe flushing during memory reclamation.'

## Score Statistics
| Retriever | Min | Max | Mean | Median | Count |
|-----------|-----|-----|------|--------|-------|
| Dense | 0.5013 | 0.5835 | 0.5328 | 0.5309 | 20 |
| Sparse | 910.5025 | 1239.5394 | 1035.5468 | 980.2175 | 11 |
| Graph | 1.6848 | 4.3290 | 2.2021 | 1.9397 | 20 |

## Graph Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Mapping Usage |
|---|--------|------|-------------|-------|---------------|
| 1 | 125 | Out-of-bounds Read | base | 4.3290 | Allowed |
| 2 | 823 | Use of Out-of-range Pointer Offset | base | 4.3290 | Allowed |
| 3 | 822 | Untrusted Pointer Dereference | Base | 2.8210 | Allowed |
| 4 | 364 | Signal Handler Race Condition | base | 2.3400 | Allowed |
| 5 | 787 | Out-of-bounds Write | base | 2.2100 | Allowed |
| 6 | 825 | Expired Pointer Dereference | base | 2.2100 | Allowed |
| 7 | 824 | Access of Uninitialized Pointer | base | 2.2100 | Allowed |
| 8 | 772 | Missing Release of Resource after Effective Lifetime | base | 2.2100 | Allowed |
| 9 | 781 | Improper Address Validation in IOCTL with METHOD_NEITHER I/O Control Code | variant | 2.0400 | Allowed |
| 10 | 129 | Improper Validation of Array Index | variant | 2.0400 | Allowed |
| 11 | 456 | Missing Initialization of a Variable | variant | 1.8394 | Allowed |
| 12 | 123 | Write-what-where Condition | base | 1.7680 | Allowed |
| 13 | 120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | base | 1.7680 | Allowed-with-Review |
| 14 | 562 | Return of Stack Variable Address | base | 1.7680 | Allowed |
| 15 | 833 | Deadlock | Base | 1.7361 | Allowed |

## Dense Retriever Results (20)
| # | CWE ID | Name | Abstraction | Score | Original Score | Mapping Usage |
|---|--------|------|-------------|-------|----------------|---------------|
| 1 | 909 | Missing Initialization of Resource | Class | 0.5835 | 0.5835 | Allowed-with-Review |
| 2 | 667 | Improper Locking | Class | 0.5777 | 0.5777 | Allowed-with-Review |
| 3 | 833 | Deadlock | Base | 0.5733 | 0.5733 | Allowed |
| 4 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | 0.5598 | 0.5598 | Allowed-with-Review |
| 5 | 911 | Improper Update of Reference Count | Base | 0.5550 | 0.5550 | Allowed |
| 6 | 366 | Race Condition within a Thread | Base | 0.5512 | 0.5512 | Allowed |
| 7 | 413 | Improper Resource Locking | Base | 0.5403 | 0.5403 | Allowed |
| 8 | 401 | Missing Release of Memory after Effective Lifetime | Variant | 0.5391 | 0.5391 | Allowed |
| 9 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | 0.5385 | 0.5385 | Allowed |
| 10 | 191 | Integer Underflow (Wrap or Wraparound) | Base | 0.5378 | 0.5378 | Allowed |
| 11 | 789 | Memory Allocation with Excessive Size Value | Variant | 0.5240 | 0.5240 | Allowed |
| 12 | 1342 | Information Exposure through Microarchitectural State after Transient Execution | Base | 0.5239 | 0.5239 | Allowed |
| 13 | 835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | 0.5118 | 0.5118 | Allowed |
| 14 | 908 | Use of Uninitialized Resource | Base | 0.5106 | 0.5106 | Allowed |
| 15 | 1260 | Improper Handling of Overlap Between Protected Memory Ranges | Base | 0.5083 | 0.5083 | Allowed |

## Sparse Retriever Results (11)
| # | CWE ID | Name | Score | Original Score | Mapping Usage |
|---|--------|------|-------|---------------|---------------|
| 1 | 822 | Untrusted Pointer Dereference | 1239.5394 | 1239.5394 | Allowed |
| 2 | 125 | Out-of-bounds Read | 1237.4957 | 1237.4957 | Allowed |
| 3 | 667 | Improper Locking | 1081.2368 | 1081.2368 | Allowed-with-Review |
| 4 | 823 | Use of Out-of-range Pointer Offset | 1060.1561 | 1060.1561 | Allowed |
| 5 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | 1014.0382 | 1014.0382 | Allowed-with-Review |
| 6 | 416 | Use After Free | 980.2175 | 980.2175 | Allowed |
| 7 | 393 | Return of Wrong Status Code | 979.9936 | 979.9936 | Allowed |
| 8 | 833 | Deadlock | 975.3327 | 975.3327 | Allowed |
| 9 | 825 | Expired Pointer Dereference | 960.1956 | 960.1956 | Allowed |
| 10 | 127 | Buffer Under-read | 952.3063 | 952.3063 | Allowed |
| 11 | 457 | Use of Uninitialized Variable | 910.5025 | 910.5025 | Allowed |
