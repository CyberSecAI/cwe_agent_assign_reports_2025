{
  "retriever": "sparse",
  "query": "In the Linux kernel, the following vulnerability has been resolved PCI pciehp Avoid unnecessary device replacement check Hot-removal of nested PCI hotplug ports suffers from a long-standing race condition which can lead to a deadlock A parent hotplug port acquires pci_lock_rescan_remove(), then waits for pciehp to unbind from a child hotplug port. Meanwhile that child hotplug port tries to acquire pci_lock_rescan_remove() as well in order to remove its own children. The deadlock only occurs if the parent acquires pci_lock_rescan_remove() first, not if the child happens to acquire it first. Several workarounds to avoid the issue have been proposed and discarded over the years, e.g. https//lore.kernel.org/r/4c882e25194ba8282b78fe963fec8faae7cf23eb.1529173804.git.lukas@wunner.de/ A proper fix is being worked on, but needs more time as it is nontrivial and necessarily intrusive. Recent commit 9d573d19547b (PCI pciehp Detect device replacement during system sleep) provokes more frequent occurrence of the deadlock when removing more than one Thunderbolt device during system sleep. The commit sought to detect device replacement, but also triggered on device removal. Differentiating reliably between replacement and removal is impossible because pci_get_dsn() returns 0 both if the device was removed, as well as if it was replaced with one lacking a Device Serial Number. Avoid the more frequent occurrence of the deadlock by checking whether the hotplug port itself was hot-removed. If so, theres no sense in checking whether its child device was replaced. This works because the ->resume_noirq() callback is invoked in top-down order for the entire hierarchy A parent hotplug port detecting device replacement (or removal) marks all children as removed using pci_dev_set_disconnected() and a child hotplug port can then reliably detect being removed.",
  "keyphrases": {
    "rootcause": [
      "race condition"
    ]
  },
  "timestamp": "2025-07-12 13:24:38",
  "cve_id": "CVE-2025-37843",
  "result_count": 10,
  "results": [
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "score": 1185.473304492478,
      "search_source": "rootcause:race condition"
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "score": 1171.9678930444386,
      "search_source": "rootcause:race condition"
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "score": 1123.0494823868607,
      "search_source": "rootcause:race condition"
    },
    {
      "cwe_id": "367",
      "name": "Time-of-check Time-of-use (TOCTOU) Race Condition",
      "score": 1120.4341389183382,
      "search_source": "rootcause:race condition"
    },
    {
      "cwe_id": "212",
      "name": "Improper Removal of Sensitive Information Before Storage or Transfer",
      "score": 1114.1829859578338,
      "search_source": "rootcause:race condition"
    },
    {
      "cwe_id": "863",
      "name": "Incorrect Authorization",
      "score": 1093.1742685585855,
      "search_source": "rootcause:race condition"
    },
    {
      "cwe_id": "226",
      "name": "Sensitive Information in Resource Not Removed Before Reuse",
      "score": 1062.5336390694943,
      "search_source": "rootcause:race condition"
    },
    {
      "cwe_id": "59",
      "name": "Improper Link Resolution Before File Access ('Link Following')",
      "score": 1055.9871820623755,
      "search_source": "rootcause:race condition"
    },
    {
      "cwe_id": "306",
      "name": "Missing Authentication for Critical Function",
      "score": 1050.490588320186,
      "search_source": "rootcause:race condition"
    },
    {
      "cwe_id": "923",
      "name": "Improper Restriction of Communication Channel to Intended Endpoints",
      "score": 1044.2308962448374,
      "search_source": "rootcause:race condition"
    }
  ]
}