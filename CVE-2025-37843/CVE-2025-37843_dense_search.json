{
  "retriever": "dense",
  "query": "In the Linux kernel, the following vulnerability has been resolved PCI pciehp Avoid unnecessary device replacement check Hot-removal of nested PCI hotplug ports suffers from a long-standing race condition which can lead to a deadlock A parent hotplug port acquires pci_lock_rescan_remove(), then waits for pciehp to unbind from a child hotplug port. Meanwhile that child hotplug port tries to acquire pci_lock_rescan_remove() as well in order to remove its own children. The deadlock only occurs if the parent acquires pci_lock_rescan_remove() first, not if the child happens to acquire it first. Several workarounds to avoid the issue have been proposed and discarded over the years, e.g. https//lore.kernel.org/r/4c882e25194ba8282b78fe963fec8faae7cf23eb.1529173804.git.lukas@wunner.de/ A proper fix is being worked on, but needs more time as it is nontrivial and necessarily intrusive. Recent commit 9d573d19547b (PCI pciehp Detect device replacement during system sleep) provokes more frequent occurrence of the deadlock when removing more than one Thunderbolt device during system sleep. The commit sought to detect device replacement, but also triggered on device removal. Differentiating reliably between replacement and removal is impossible because pci_get_dsn() returns 0 both if the device was removed, as well as if it was replaced with one lacking a Device Serial Number. Avoid the more frequent occurrence of the deadlock by checking whether the hotplug port itself was hot-removed. If so, theres no sense in checking whether its child device was replaced. This works because the ->resume_noirq() callback is invoked in top-down order for the entire hierarchy A parent hotplug port detecting device replacement (or removal) marks all children as removed using pci_dev_set_disconnected() and a child hotplug port can then reliably detect being removed.",
  "keyphrases": {
    "rootcause": [
      "race condition"
    ]
  },
  "timestamp": "2025-07-14 21:34:52",
  "cve_id": "CVE-2025-37843",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 0.5209239248697006
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "type": "Class",
      "score": 0.5084320662845554
    },
    {
      "cwe_id": "1256",
      "name": "Improper Restriction of Software Interfaces to Hardware Features",
      "type": "Base",
      "score": 0.5028199448223492
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 0.493455122442376
    },
    {
      "cwe_id": "1299",
      "name": "Missing Protection Mechanism for Alternate Hardware Interface",
      "type": "Base",
      "score": 0.48441074221294417
    },
    {
      "cwe_id": "413",
      "name": "Improper Resource Locking",
      "type": "Base",
      "score": 0.48290934209205805
    },
    {
      "cwe_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "type": "Base",
      "score": 0.48092052993407997
    },
    {
      "cwe_id": "1233",
      "name": "Security-Sensitive Hardware Controls with Missing Lock Bit Protection",
      "type": "Base",
      "score": 0.47591741421207673
    },
    {
      "cwe_id": "1264",
      "name": "Hardware Logic with Insecure De-Synchronization between Control and Data Channels",
      "type": "Base",
      "score": 0.4750453935426869
    },
    {
      "cwe_id": "909",
      "name": "Missing Initialization of Resource",
      "type": "Class",
      "score": 0.47001858925668527
    },
    {
      "cwe_id": "119",
      "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
      "type": "Class",
      "score": 0.45965630801522545
    },
    {
      "cwe_id": "1338",
      "name": "Improper Protections Against Hardware Overheating",
      "type": "Base",
      "score": 0.4594456554454822
    },
    {
      "cwe_id": "401",
      "name": "Missing Release of Memory after Effective Lifetime",
      "type": "Variant",
      "score": 0.4585246785999325
    },
    {
      "cwe_id": "1272",
      "name": "Sensitive Information Uncleared Before Debug/Power State Transition",
      "type": "Base",
      "score": 0.4561542360643497
    },
    {
      "cwe_id": "908",
      "name": "Use of Uninitialized Resource",
      "type": "Base",
      "score": 0.455590452109581
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "type": "Variant",
      "score": 0.4538541834134252
    },
    {
      "cwe_id": "1331",
      "name": "Improper Isolation of Shared Resources in Network On Chip (NoC)",
      "type": "Base",
      "score": 0.4534664121709989
    },
    {
      "cwe_id": "226",
      "name": "Sensitive Information in Resource Not Removed Before Reuse",
      "type": "Base",
      "score": 0.451219969441877
    },
    {
      "cwe_id": "911",
      "name": "Improper Update of Reference Count",
      "type": "Base",
      "score": 0.45105926497500226
    },
    {
      "cwe_id": "1189",
      "name": "Improper Isolation of Shared Resources on System-on-a-Chip (SoC)",
      "type": "Base",
      "score": 0.4509455027685191
    }
  ]
}