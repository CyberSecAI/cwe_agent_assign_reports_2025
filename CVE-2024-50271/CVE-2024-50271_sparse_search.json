{
  "retriever": "sparse",
  "query": "In the Linux kernel, the following vulnerability has been resolved signal restore the override_rlimit logic Prior to commit d64696905554 (Reimplement RLIMIT_SIGPENDING on top of ucounts) UCOUNT_RLIMIT_SIGPENDING rlimit was not enforced for a class of signals. However now its enforced unconditionally, even if override_rlimit is set. This behavior change caused production issues. For example, if the limit is reached and a process receives a SIGSEGV signal, sigqueue_alloc fails to allocate the necessary resources for the signal delivery, preventing the signal from being delivered with siginfo. This prevents the process from correctly identifying the fault address and handling the error. From the user-space perspective, applications are unaware that the limit has been reached and that the siginfo is effectively corrupted. This can lead to unpredictable behavior and crashes, as we observed with java applications. Fix this by passing override_rlimit into inc_rlimit_get_ucounts() and skip the comparison to max there if override_rlimit is set. This effectively restores the old behavior.",
  "keyphrases": {
    "rootcause": [
      "UCOUNT_RLIMIT_SIGPENDING rlimit was not enforced for a class of signals"
    ]
  },
  "timestamp": "2025-07-12 05:30:14",
  "cve_id": "CVE-2024-50271",
  "result_count": 11,
  "results": [
    {
      "cwe_id": "364",
      "name": "Signal Handler Race Condition",
      "score": 860.960561216821,
      "search_source": "rootcause:UCOUNT_RLIMIT_SIGPENDING rlimit was not enforced for a class of signals"
    },
    {
      "cwe_id": "770",
      "name": "Allocation of Resources Without Limits or Throttling",
      "score": 854.5277787155032,
      "search_source": "rootcause:UCOUNT_RLIMIT_SIGPENDING rlimit was not enforced for a class of signals"
    },
    {
      "cwe_id": "828",
      "name": "Signal Handler with Functionality that is not Asynchronous-Safe",
      "score": 831.5811116677836,
      "search_source": "rootcause:UCOUNT_RLIMIT_SIGPENDING rlimit was not enforced for a class of signals"
    },
    {
      "cwe_id": "401",
      "name": "Missing Release of Memory after Effective Lifetime",
      "score": 802.1950334490066,
      "search_source": "rootcause:UCOUNT_RLIMIT_SIGPENDING rlimit was not enforced for a class of signals"
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "score": 797.230372442066,
      "search_source": "rootcause:UCOUNT_RLIMIT_SIGPENDING rlimit was not enforced for a class of signals"
    },
    {
      "cwe_id": "863",
      "name": "Incorrect Authorization",
      "score": 788.3660310809504,
      "search_source": "rootcause:UCOUNT_RLIMIT_SIGPENDING rlimit was not enforced for a class of signals"
    },
    {
      "cwe_id": "125",
      "name": "Out-of-bounds Read",
      "score": 785.96467618526,
      "search_source": "rootcause:UCOUNT_RLIMIT_SIGPENDING rlimit was not enforced for a class of signals"
    },
    {
      "cwe_id": "415",
      "name": "Double Free",
      "score": 781.5280112718715,
      "search_source": "rootcause:UCOUNT_RLIMIT_SIGPENDING rlimit was not enforced for a class of signals"
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "score": 779.8128778671761,
      "search_source": "rootcause:UCOUNT_RLIMIT_SIGPENDING rlimit was not enforced for a class of signals"
    },
    {
      "cwe_id": "835",
      "name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
      "score": 779.6160208518595,
      "search_source": "rootcause:UCOUNT_RLIMIT_SIGPENDING rlimit was not enforced for a class of signals"
    },
    {
      "cwe_id": "789",
      "name": "Memory Allocation with Excessive Size Value",
      "score": 245.7761042507892,
      "search_source": "base_query"
    }
  ]
}