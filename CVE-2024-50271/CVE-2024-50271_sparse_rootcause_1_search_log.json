{
  "method": "sparse_rootcause_1",
  "query": "In the Linux kernel, the following vulnerability has been resolved signal restore the override_rlimit logic Prior to commit d64696905554 (Reimplement RLIMIT_SIGPENDING on top of ucounts) UCOUNT_RLIMIT_SIGPENDING rlimit was not enforced for a class of signals. However now its enforced unconditionally, even if override_rlimit is set. This behavior change caused production issues. For example, if the limit is reached and a process receives a SIGSEGV signal, sigqueue_alloc fails to allocate the necessary resources for the signal delivery, preventing the signal from being delivered with siginfo. This prevents the process from correctly identifying the fault address and handling the error. From the user-space perspective, applications are unaware that the limit has been reached and that the siginfo is effectively corrupted. This can lead to unpredictable behavior and crashes, as we observed with java applications. Fix this by passing override_rlimit into inc_rlimit_get_ucounts() and skip the comparison to max there if override_rlimit is set. This effectively restores the old behavior.",
  "keyphrases": {
    "rootcause": "UCOUNT_RLIMIT_SIGPENDING rlimit was not enforced for a class of signals"
  },
  "timestamp": "2025-07-12T05:30:14.756113",
  "results_count": 10,
  "results_summary": [
    {
      "doc_id": "364",
      "name": "Signal Handler Race Condition",
      "score": 860.960561216821
    },
    {
      "doc_id": "770",
      "name": "Allocation of Resources Without Limits or Throttling",
      "score": 854.5277787155032
    },
    {
      "doc_id": "828",
      "name": "Signal Handler with Functionality that is not Asynchronous-Safe",
      "score": 831.5811116677836
    },
    {
      "doc_id": "401",
      "name": "Missing Release of Memory after Effective Lifetime",
      "score": 802.1950334490066
    },
    {
      "doc_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "score": 797.230372442066
    }
  ]
}