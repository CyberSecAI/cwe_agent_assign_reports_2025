## Vulnerability Description
Expr is an expression language and expression evaluation for Go. Prior to version 1.17.0, if the Expr expression parser is given an **unbounded input string**, it will attempt to compile the entire string and generate an Abstract Syntax Tree (AST) node for each part of the expression. In scenarios where input size isnt limited, a malicious or inadvertent extremely large expression can consume excessive memory as the parser builds a huge AST. This can ultimately lead to*excessive memory usage and an Out-Of-Memory (OOM) crash of the process. This issue is relatively uncommon and will only manifest when there are no restrictions on the input size, i.e. the expression length is allowed to grow arbitrarily large. In typical use cases where inputs are bounded or validated, this problem would not occur. The problem has been patched in the latest versions of the Expr library. The fix introduces compile-time limits on the number of AST nodes and memory usage during parsing, preventing any single expression from exhausting resources. Users should upgrade to Expr version 1.17.0 or later, as this release includes the new node budget and memory limit safeguards. Upgrading to v1.17.0 ensures that extremely deep or large expressions are detected and safely aborted during compilation, avoiding the OOM condition. For users who cannot immediately upgrade, the recommended workaround is to impose an input size restriction before parsing. In practice, this means validating or limiting the length of expression strings that your application will accept. For example, set a maximum allowable number of characters (or nodes) for any expression and reject or truncate inputs that exceed this limit. By ensuring no unbounded-length expression is ever fed into the parser, one can prevent the parser from constructing a pathologically large AST and avoid potential memory exhaustion. In short, pre-validate and cap input size as a safeguard in the absence of the patch.

### Vulnerability Description Key Phrases
- **weakness:** **unbounded input string**
- **product:** Expr library
- **impact:** excessive memory usage, OOM crash
- **version:** prior to version 1.17.0

## CVE Reference Links Content Summary
## Analysis of CVE-2025-29786 Content

This content **relates** to CVE-2025-29786. It provides significantly more detail than the placeholder CVE description.

**Root cause of vulnerability:**

The Expr expression parser attempts to compile the entire input string and generate an Abstract Syntax Tree (AST) node for each part of the expression.  Without input size restrictions, a large expression can consume excessive memory during AST construction.

**Weaknesses/vulnerabilities present:**

*   Memory Exhaustion
*   Unrestricted input size leading to excessive memory usage.

**Impact of exploitation:**

*   Excessive memory usage
*   Out-Of-Memory (OOM) crash of the process.

**Attack vectors:**

*   Providing an unbounded input string to the Expr expression parser.
*   Network (CVSS v3 base metrics)

**Required attacker capabilities/position:**

*   No privileges required.
*   No user interaction required.
*   Remote attacker (Network vector)

**Mitigation or fix:**

*   Upgrade to Expr version 1.17.0 or later, which includes compile-time limits on AST node count and memory usage.
*   Workaround: Impose an input size restriction (validate/limit the length of expression strings) before parsing. Pre-validate and cap input size.

**CVSS Score:** 7.5 / 10 (High)

**CVSS v3 base metrics:**

*   Attack Vector: Network
*   Attack Complexity: Low
*   Privileges Required: None
*   User Interaction: None
*   Scope: Unchanged
*   Confidentiality: None
*   Integrity: None
*   Availability: High

**References:**

*   [#762](https://github.com/expr-lang/expr/pull/762)

**Credits:**

*   [@thevilledev](https://github.com/thevilledev) (Reporter)

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 1333 | Inefficient Regular Expression Complexity | Base | Allowed | sparse | 1.818 |
| 2 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | sparse | 1.702 |
| 3 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | sparse | 1.649 |
| 4 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 1.631 |
| 5 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 1.628 |
| 6 | 190 | Integer Overflow or Wraparound | Base | Allowed | sparse | 1.513 |
| 7 | 617 | Reachable Assertion | Base | Allowed | sparse | 1.511 |
| 8 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 1.477 |
| 9 | 194 | Unexpected Sign Extension | Variant | Allowed | dense | 0.410 |
| 10 | 476 | NULL Pointer Dereference | Base | Allowed | graph | 0.002 |



# Complete CWE Specifications

CWE-1333: Inefficient Regular Expression Complexity

CWE-789: Memory Allocation with Excessive Size Value

CWE-674: Uncontrolled Recursion

CWE-770: Allocation of Resources Without Limits or Throttling

CWE-1284: Improper Validation of Specified Quantity in Input

CWE-190: Integer Overflow or Wraparound

CWE-617: Reachable Assertion

CWE-125: Out-of-bounds Read

CWE-194: Unexpected Sign Extension

CWE-476: NULL Pointer Dereference