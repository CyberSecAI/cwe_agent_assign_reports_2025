{
  "retriever": "graph",
  "query": "In the Linux kernel, the following vulnerability has been resolved rxrpc, afs Fix peer hash locking vs RCU callback In its address list, afs now retains pointers to and refs on one or more rxrpc_peer objects. The address list is freed under RCU and at this time, it puts the refs on those peers. Now, when an rxrpc_peer object runs out of refs, it gets removed from the peer hash table and, for that, rxrpc has to take a spinlock. However, it is now being called from afss RCU cleanup, which takes place in BH context - but it is just taking an ordinary spinlock. The put may also be called from non-BH context, and so there exists the possibility of deadlock if the BH-based RCU cleanup happens whilst the hash spinlock is held. This led to the attached lockdep complaint. Fix this by changing spinlocks of rxnet->peer_hash_lock back to BH-disabling locks. ================================ WARNING inconsistent lock state 6.13.0-rc5-build2+ #1223 Tainted G E -------------------------------- inconsistent {SOFTIRQ-ON-W} -> {IN-SOFTIRQ-W} usage. swapper/1/0 [HC0[0]SC1[1]HE1SE0] takes ffff88810babe228 (&rxnet->peer_hash_lock){+.?.}-{33}, at rxrpc_put_peer+0xcb/0x180 {SOFTIRQ-ON-W} state was registered at mark_usage+0x164/0x180 __lock_acquire+0x544/0x990 lock_acquire.part.0+0x103/0x280 _raw_spin_lock+0x2f/0x40 rxrpc_peer_keepalive_worker+0x144/0x440 process_one_work+0x486/0x7c0 process_scheduled_works+0x73/0x90 worker_thread+0x1c8/0x2a0 kthread+0x19b/0x1b0 ret_from_fork+0x24/0x40 ret_from_fork_asm+0x1a/0x30 irq event stamp 972402 hardirqs last enabled at (972402) [] _raw_spin_unlock_irqrestore+0x2e/0x50 hardirqs last disabled at (972401) [] _raw_spin_lock_irqsave+0x18/0x60 softirqs last enabled at (972300) [] handle_softirqs+0x3ee/0x430 softirqs last disabled at (972313) [] __irq_exit_rcu+0x44/0x110 other info that might help us debug this Possible unsafe locking scenario CPU0 ---- lock(&rxnet->peer_hash_lock) lock(&rxnet->peer_hash_lock) *** DEADLOCK *** 1 lock held by swapper/1/0 #0 ffffffff83576be0 (rcu_callback){....}-{00}, at rcu_lock_acquire+0x7/0x30 stack backtrace CPU 1 UID 0 PID 0 Comm swapper/1 Tainted G E 6.13.0-rc5-build2+ #1223 Tainted [E]=UNSIGNED_MODULE Hardware name ASUS All Series/H97-PLUS, BIOS 2306 10/09/2014 Call Trace dump_stack_lvl+0x57/0x80 print_usage_bug.part.0+0x227/0x240 valid_state+0x53/0x70 mark_lock_irq+0xa5/0x2f0 mark_lock+0xf7/0x170 mark_usage+0xe1/0x180 __lock_acquire+0x544/0x990 lock_acquire.part.0+0x103/0x280 _raw_spin_lock+0x2f/0x40 rxrpc_put_peer+0xcb/0x180 afs_free_addrlist+0x46/0x90 [kafs] rcu_do_batch+0x2d2/0x640 rcu_core+0x2f7/0x350 handle_softirqs+0x1ee/0x430 __irq_exit_rcu+0x44/0x110 irq_exit_rcu+0xa/0x30 sysvec_apic_timer_interrupt+0x7f/0xa0 Consider specifically these CWEs: CWE-413 CWE-201 CWE-401 CWE-1390 CWE-770 CWE-362 CWE-667 CWE-833",
  "keyphrases": {
    "original_query": "In the Linux kernel, the following vulnerability has been resolved rxrpc, afs Fix peer hash locking vs RCU callback In its address list, afs now retains pointers to and refs on one or more rxrpc_peer objects. The address list is freed under RCU and at this time, it puts the refs on those peers. Now, when an rxrpc_peer object runs out of refs, it gets removed from the peer hash table and, for that, rxrpc has to take a spinlock. However, it is now being called from afss RCU cleanup, which takes place in BH context - but it is just taking an ordinary spinlock. The put may also be called from non-BH context, and so there exists the possibility of deadlock if the BH-based RCU cleanup happens whilst the hash spinlock is held. This led to the attached lockdep complaint. Fix this by changing spinlocks of rxnet->peer_hash_lock back to BH-disabling locks. ================================ WARNING inconsistent lock state 6.13.0-rc5-build2+ #1223 Tainted G E -------------------------------- inconsistent {SOFTIRQ-ON-W} -> {IN-SOFTIRQ-W} usage. swapper/1/0 [HC0[0]SC1[1]HE1SE0] takes ffff88810babe228 (&rxnet->peer_hash_lock){+.?.}-{33}, at rxrpc_put_peer+0xcb/0x180 {SOFTIRQ-ON-W} state was registered at mark_usage+0x164/0x180 __lock_acquire+0x544/0x990 lock_acquire.part.0+0x103/0x280 _raw_spin_lock+0x2f/0x40 rxrpc_peer_keepalive_worker+0x144/0x440 process_one_work+0x486/0x7c0 process_scheduled_works+0x73/0x90 worker_thread+0x1c8/0x2a0 kthread+0x19b/0x1b0 ret_from_fork+0x24/0x40 ret_from_fork_asm+0x1a/0x30 irq event stamp 972402 hardirqs last enabled at (972402) [] _raw_spin_unlock_irqrestore+0x2e/0x50 hardirqs last disabled at (972401) [] _raw_spin_lock_irqsave+0x18/0x60 softirqs last enabled at (972300) [] handle_softirqs+0x3ee/0x430 softirqs last disabled at (972313) [] __irq_exit_rcu+0x44/0x110 other info that might help us debug this Possible unsafe locking scenario CPU0 ---- lock(&rxnet->peer_hash_lock) lock(&rxnet->peer_hash_lock) *** DEADLOCK *** 1 lock held by swapper/1/0 #0 ffffffff83576be0 (rcu_callback){....}-{00}, at rcu_lock_acquire+0x7/0x30 stack backtrace CPU 1 UID 0 PID 0 Comm swapper/1 Tainted G E 6.13.0-rc5-build2+ #1223 Tainted [E]=UNSIGNED_MODULE Hardware name ASUS All Series/H97-PLUS, BIOS 2306 10/09/2014 Call Trace dump_stack_lvl+0x57/0x80 print_usage_bug.part.0+0x227/0x240 valid_state+0x53/0x70 mark_lock_irq+0xa5/0x2f0 mark_lock+0xf7/0x170 mark_usage+0xe1/0x180 __lock_acquire+0x544/0x990 lock_acquire.part.0+0x103/0x280 _raw_spin_lock+0x2f/0x40 rxrpc_put_peer+0xcb/0x180 afs_free_addrlist+0x46/0x90 [kafs] rcu_do_batch+0x2d2/0x640 rcu_core+0x2f7/0x350 handle_softirqs+0x1ee/0x430 __irq_exit_rcu+0x44/0x110 irq_exit_rcu+0xa/0x30 sysvec_apic_timer_interrupt+0x7f/0xa0",
    "enhanced_query": "In the Linux kernel, the following vulnerability has been resolved rxrpc, afs Fix peer hash locking vs RCU callback In its address list, afs now retains pointers to and refs on one or more rxrpc_peer objects. The address list is freed under RCU and at this time, it puts the refs on those peers. Now, when an rxrpc_peer object runs out of refs, it gets removed from the peer hash table and, for that, rxrpc has to take a spinlock. However, it is now being called from afss RCU cleanup, which takes place in BH context - but it is just taking an ordinary spinlock. The put may also be called from non-BH context, and so there exists the possibility of deadlock if the BH-based RCU cleanup happens whilst the hash spinlock is held. This led to the attached lockdep complaint. Fix this by changing spinlocks of rxnet->peer_hash_lock back to BH-disabling locks. ================================ WARNING inconsistent lock state 6.13.0-rc5-build2+ #1223 Tainted G E -------------------------------- inconsistent {SOFTIRQ-ON-W} -> {IN-SOFTIRQ-W} usage. swapper/1/0 [HC0[0]SC1[1]HE1SE0] takes ffff88810babe228 (&rxnet->peer_hash_lock){+.?.}-{33}, at rxrpc_put_peer+0xcb/0x180 {SOFTIRQ-ON-W} state was registered at mark_usage+0x164/0x180 __lock_acquire+0x544/0x990 lock_acquire.part.0+0x103/0x280 _raw_spin_lock+0x2f/0x40 rxrpc_peer_keepalive_worker+0x144/0x440 process_one_work+0x486/0x7c0 process_scheduled_works+0x73/0x90 worker_thread+0x1c8/0x2a0 kthread+0x19b/0x1b0 ret_from_fork+0x24/0x40 ret_from_fork_asm+0x1a/0x30 irq event stamp 972402 hardirqs last enabled at (972402) [] _raw_spin_unlock_irqrestore+0x2e/0x50 hardirqs last disabled at (972401) [] _raw_spin_lock_irqsave+0x18/0x60 softirqs last enabled at (972300) [] handle_softirqs+0x3ee/0x430 softirqs last disabled at (972313) [] __irq_exit_rcu+0x44/0x110 other info that might help us debug this Possible unsafe locking scenario CPU0 ---- lock(&rxnet->peer_hash_lock) lock(&rxnet->peer_hash_lock) *** DEADLOCK *** 1 lock held by swapper/1/0 #0 ffffffff83576be0 (rcu_callback){....}-{00}, at rcu_lock_acquire+0x7/0x30 stack backtrace CPU 1 UID 0 PID 0 Comm swapper/1 Tainted G E 6.13.0-rc5-build2+ #1223 Tainted [E]=UNSIGNED_MODULE Hardware name ASUS All Series/H97-PLUS, BIOS 2306 10/09/2014 Call Trace dump_stack_lvl+0x57/0x80 print_usage_bug.part.0+0x227/0x240 valid_state+0x53/0x70 mark_lock_irq+0xa5/0x2f0 mark_lock+0xf7/0x170 mark_usage+0xe1/0x180 __lock_acquire+0x544/0x990 lock_acquire.part.0+0x103/0x280 _raw_spin_lock+0x2f/0x40 rxrpc_put_peer+0xcb/0x180 afs_free_addrlist+0x46/0x90 [kafs] rcu_do_batch+0x2d2/0x640 rcu_core+0x2f7/0x350 handle_softirqs+0x1ee/0x430 __irq_exit_rcu+0x44/0x110 irq_exit_rcu+0xa/0x30 sysvec_apic_timer_interrupt+0x7f/0xa0 Consider specifically these CWEs: CWE-413 CWE-201 CWE-401 CWE-1390 CWE-770 CWE-362 CWE-667 CWE-833",
    "cwe_mentions": [
      "CWE-413",
      "CWE-201",
      "CWE-401",
      "CWE-1390",
      "CWE-770",
      "CWE-362",
      "CWE-667",
      "CWE-833"
    ],
    "search_time": 3.621359348297119
  },
  "timestamp": "2025-07-12 09:55:21",
  "cve_id": "CVE-2025-21809",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "1325",
      "name": "Improperly Controlled Sequential Memory Allocation",
      "type": "base",
      "score": 2.3400000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "226",
      "name": "Sensitive Information in Resource Not Removed Before Reuse",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "212",
      "name": "Improper Removal of Sensitive Information Before Storage or Transfer",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "390",
      "name": "Detection of Error Condition Without Action",
      "type": "base",
      "score": 2.2100000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "201",
      "name": "Insertion of Sensitive Information Into Sent Data",
      "type": "base",
      "score": 2.1189999999999998,
      "relationship_count": 0
    },
    {
      "cwe_id": "22",
      "name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "41",
      "name": "Improper Resolution of Path Equivalence",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "120",
      "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "123",
      "name": "Write-what-where Condition",
      "type": "base",
      "score": 1.7680000000000005,
      "relationship_count": 0
    },
    {
      "cwe_id": "364",
      "name": "Signal Handler Race Condition",
      "type": "base",
      "score": 1.7550000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 1.7101861640473395,
      "relationship_count": 0
    },
    {
      "cwe_id": "413",
      "name": "Improper Resource Locking",
      "type": "Base",
      "score": 1.708549871144971,
      "relationship_count": 0
    },
    {
      "cwe_id": "1265",
      "name": "Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls",
      "type": "base",
      "score": 1.6848000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "386",
      "name": "Symbolic Name not Mapping to Correct Object",
      "type": "base",
      "score": 1.6744000000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "662",
      "name": "Improper Synchronization",
      "type": "class",
      "score": 1.6736000000000002,
      "relationship_count": 0
    },
    {
      "cwe_id": "61",
      "name": "UNIX Symbolic Link (Symlink) Following",
      "type": "compound",
      "score": 1.61,
      "relationship_count": 0
    },
    {
      "cwe_id": "770",
      "name": "Allocation of Resources Without Limits or Throttling",
      "type": "Base",
      "score": 1.6062746060242556,
      "relationship_count": 0
    },
    {
      "cwe_id": "476",
      "name": "NULL Pointer Dereference",
      "type": "Base",
      "score": 1.5316789975779745,
      "relationship_count": 0
    },
    {
      "cwe_id": "202",
      "name": "Exposure of Sensitive Information Through Data Queries",
      "type": "base",
      "score": 1.521,
      "relationship_count": 0
    },
    {
      "cwe_id": "209",
      "name": "Generation of Error Message Containing Sensitive Information",
      "type": "base",
      "score": 1.521,
      "relationship_count": 0
    }
  ]
}