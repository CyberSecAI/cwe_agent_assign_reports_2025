{
  "query": "In the Linux kernel, the following vulnerability has been resolved usb xhci Apply the link chain quirk on NEC isoc endpoints Two clearly different specimens of NEC uPD720200 (one with start/stop bug, one without) were seen to cause IOMMU faults after some Missed Service Errors. Faulting address is immediately after a transfer ring segment and patched dynamic debug messages revealed that the MSE was received when waiting for a TD near the end of that segment [ 1.041954] xhci_hcd Miss service interval error for slot 1 ep 2 expected TD DMA ffa08fe0 [ 1.042120] xhci_hcd AMD-Vi Event logged [IO_PAGE_FAULT domain=0x0005 address=0xffa09000 flags=0x0000] [ 1.042146] xhci_hcd AMD-Vi Event logged [IO_PAGE_FAULT domain=0x0005 address=0xffa09040 flags=0x0000] It gets even funnier if the next page is a ring segment accessible to the HC. Below, it reports MSE in segment at ff1e8000, plows through a zero-filled page at ff1e9000 and starts reporting events for TRBs in page at ff1ea000 every microframe, instead of jumping to seg ff1e6000. [ 7.041671] xhci_hcd Miss service interval error for slot 1 ep 2 expected TD DMA ff1e8fe0 [ 7.041999] xhci_hcd Miss service interval error for slot 1 ep 2 expected TD DMA ff1e8fe0 [ 7.042011] xhci_hcd WARN buffer overrun event for slot 1 ep 2 on endpoint [ 7.042028] xhci_hcd All TDs skipped for slot 1 ep 2. Clear skip flag. [ 7.042134] xhci_hcd WARN buffer overrun event for slot 1 ep 2 on endpoint [ 7.042138] xhci_hcd ERROR Transfer event TRB DMA ptr not part of current TD ep_index 2 comp_code 31 [ 7.042144] xhci_hcd Looking for event-dma 00000000ff1ea040 trb-start 00000000ff1e6820 trb-end 00000000ff1e6820 [ 7.042259] xhci_hcd WARN buffer overrun event for slot 1 ep 2 on endpoint [ 7.042262] xhci_hcd ERROR Transfer event TRB DMA ptr not part of current TD ep_index 2 comp_code 31 [ 7.042266] xhci_hcd Looking for event-dma 00000000ff1ea050 trb-start 00000000ff1e6820 trb-end 00000000ff1e6820 At some point completion events change from Isoch Buffer Overrun to Short Packet and the HC finally finds cycle bit mismatch in ff1ec000. [ 7.098130] xhci_hcd ERROR Transfer event TRB DMA ptr not part of current TD ep_index 2 comp_code 13 [ 7.098132] xhci_hcd Looking for event-dma 00000000ff1ecc50 trb-start 00000000ff1e6820 trb-end 00000000ff1e6820 [ 7.098254] xhci_hcd ERROR Transfer event TRB DMA ptr not part of current TD ep_index 2 comp_code 13 [ 7.098256] xhci_hcd Looking for event-dma 00000000ff1ecc60 trb-start 00000000ff1e6820 trb-end 00000000ff1e6820 [ 7.098379] xhci_hcd Overrun event on slot 1 ep 2 Its possible that data from the isochronous device were written to random buffers of pending TDs on other endpoints (either IN or OUT), other devices or even other HCs in the same IOMMU domain. Lastly, an error from a different USB device on another HC. Was it caused by the above? I dont know, but it may have been. The disk was working without any other issues and generated PCIe traffic to starve the NEC of upstream BW and trigger those MSEs. The two HCs shared one x1 slot by means of a commercial PCIe splitter board. [ 7.162604] usb 10-2 reset SuperSpeed USB device number 3 using xhci_hcd [ 7.178990] sd 9000 [sdb] tag#0 UNKNOWN(0x2003) Result hostbyte=0x07 driverbyte=DRIVER_OK cmd_age=0s [ 7.179001] sd 9000 [sdb] tag#0 CDB opcode=0x28 28 00 04 02 ae 00 00 02 00 00 [ 7.179004] I/O error, dev sdb, sector 67284480 op 0x0(READ) flags 0x80700 phys_seg 5 prio class 0 Fortunately, it appears that this ridiculous bug is avoided by setting the chain bit of Link TRBs on isochronous rings. Other ancient HCs are known which also expect the bit to be set and they ignore Link TRBs if its not. Reportedly, 0.95 spec guaranteed that the bit is set. The bandwidth-starved NEC HC running a 32KB/uframe UVC endpoint reports tens of MSEs per second and runs into the bug within seconds. Chaining Link TRBs allows the same workload to run for many minutes, many times. No ne ---truncated---",
  "count": 20,
  "results": [
    {
      "cwe_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "abstraction": "Base",
      "score": 0.5811986973025796,
      "original_score": 0.5811986973025796,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "191",
      "name": "Integer Underflow (Wrap or Wraparound)",
      "abstraction": "Base",
      "score": 0.5721788050661172,
      "original_score": 0.5721788050661172,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "abstraction": "Class",
      "score": 0.5660177249426799,
      "original_score": 0.5660177249426799,
      "mapping_usage": "Allowed-with-Review"
    },
    {
      "cwe_id": "119",
      "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
      "abstraction": "Class",
      "score": 0.5649496045195699,
      "original_score": 0.5649496045195699,
      "mapping_usage": "Discouraged"
    },
    {
      "cwe_id": "401",
      "name": "Missing Release of Memory after Effective Lifetime",
      "abstraction": "Variant",
      "score": 0.5590445668695561,
      "original_score": 0.5590445668695561,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "782",
      "name": "Exposed IOCTL with Insufficient Access Control",
      "abstraction": "Variant",
      "score": 0.5588596574722717,
      "original_score": 0.5588596574722717,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "1342",
      "name": "Information Exposure through Microarchitectural State after Transient Execution",
      "abstraction": "Base",
      "score": 0.5584979577895682,
      "original_score": 0.5584979577895682,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "121",
      "name": "Stack-based Buffer Overflow",
      "abstraction": "Variant",
      "score": 0.5484847150283325,
      "original_score": 0.5484847150283325,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "1331",
      "name": "Improper Isolation of Shared Resources in Network On Chip (NoC)",
      "abstraction": "Base",
      "score": 0.5468066905435238,
      "original_score": 0.5468066905435238,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "1264",
      "name": "Hardware Logic with Insecure De-Synchronization between Control and Data Channels",
      "abstraction": "Base",
      "score": 0.54601724245116,
      "original_score": 0.54601724245116,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "805",
      "name": "Buffer Access with Incorrect Length Value",
      "abstraction": "Base",
      "score": 0.535501625475588,
      "original_score": 0.535501625475588,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "abstraction": "Class",
      "score": 0.5353862518312473,
      "original_score": 0.5353862518312473,
      "mapping_usage": "Allowed-with-Review"
    },
    {
      "cwe_id": "696",
      "name": "Incorrect Behavior Order",
      "abstraction": "Class",
      "score": 0.5337860990538703,
      "original_score": 0.5337860990538703,
      "mapping_usage": "Allowed-with-Review"
    },
    {
      "cwe_id": "1256",
      "name": "Improper Restriction of Software Interfaces to Hardware Features",
      "abstraction": "Base",
      "score": 0.5337766107193624,
      "original_score": 0.5337766107193624,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "1332",
      "name": "Improper Handling of Faults that Lead to Instruction Skips",
      "abstraction": "Base",
      "score": 0.5329379583397632,
      "original_score": 0.5329379583397632,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "366",
      "name": "Race Condition within a Thread",
      "abstraction": "Base",
      "score": 0.5319988796169071,
      "original_score": 0.5319988796169071,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "130",
      "name": "Improper Handling of Length Parameter Inconsistency",
      "abstraction": "Base",
      "score": 0.5319908977246175,
      "original_score": 0.5319908977246175,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "abstraction": "Variant",
      "score": 0.5294492335417558,
      "original_score": 0.5294492335417558,
      "mapping_usage": "Allowed"
    },
    {
      "cwe_id": "400",
      "name": "Uncontrolled Resource Consumption",
      "abstraction": "Class",
      "score": 0.5288923672391086,
      "original_score": 0.5288923672391086,
      "mapping_usage": "Discouraged"
    },
    {
      "cwe_id": "190",
      "name": "Integer Overflow or Wraparound",
      "abstraction": "Base",
      "score": 0.5285667424960382,
      "original_score": 0.5285667424960382,
      "mapping_usage": "Allowed"
    }
  ],
  "statistics": {
    "min": 0.5285667424960382,
    "max": 0.5811986973025796,
    "mean": 0.5462171164011809,
    "median": 0.540759433963374,
    "count": 20
  }
}