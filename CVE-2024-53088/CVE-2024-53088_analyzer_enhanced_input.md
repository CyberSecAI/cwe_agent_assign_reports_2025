## Vulnerability Description
In the Linux kernel, the following vulnerability has been resolved i40e fix **race condition** by adding filters intermediate sync state Fix a **race condition** in the i40e driver that leads to MAC/VLAN filters becoming corrupted and leaking. Address the issue that occurs under heavy load when multiple threads are concurrently modifying MAC/VLAN filters by setting mac and port VLAN. 1. Thread T0 allocates a filter in i40e_add_filter() within i40e_ndo_set_vf_port_vlan(). 2. Thread T1 concurrently frees the filter in __i40e_del_filter() within i40e_ndo_set_vf_mac(). 3. Subsequently, i40e_service_task() calls i40e_sync_vsi_filters(), which refers to the already freed filter memory, causing corruption. Reproduction steps 1. Spawn multiple VFs. 2. Apply a concurrent heavy load by running parallel operations to change MAC addresses on the VFs and change port VLANs on the host. 3. Observe errors in dmesg Error I40E_AQ_RC_ENOSPC adding RX filters on VF XX, please set promiscuous on manually for VF XX. Exact code for stable reproduction Intel cant open-source now. The fix involves implementing a new intermediate filter state, I40E_FILTER_NEW_SYNC, for the time when a filter is on a tmp_add_list. These filters cannot be deleted from the hash list directly but must be removed using the full process.

### Vulnerability Description Key Phrases
- **rootcause:** **race condition**
- **impact:** MAC/VLAN filters becoming corrupted and leaking
- **vector:** multiple threads concurrently modifying MAC/VLAN filters
- **product:** Linux kernel
- **component:** i40e driver

## CVE Reference Links Content Summary
Based on the provided content, here's a breakdown of the vulnerability:

**Root Cause:**
The vulnerability is caused by a race condition in the i40e driver when handling MAC/VLAN filter modifications. Specifically, it occurs when multiple threads concurrently try to modify these filters.

**Weaknesses/Vulnerabilities Present:**
- **Race Condition:** Concurrent modification of MAC/VLAN filters without proper synchronization leads to data corruption.
- **Use-After-Free:** A filter can be freed by one thread while another thread is still referencing it, leading to a use-after-free vulnerability.

**Impact of Exploitation:**
- **Filter Corruption:** MAC/VLAN filters become corrupted.
- **Filter Leaking:**  Corrupted filters can leak, potentially exposing network traffic.
- **RX Filter Errors:** The system logs errors indicating issues with adding RX filters, and suggests setting promiscuous mode manually on affected VFs.

**Attack Vectors:**
- **Concurrent Operations:** The attack involves triggering concurrent modifications of MAC/VLAN filters. This occurs when multiple threads are setting MAC addresses on Virtual Functions (VFs) and changing port VLANs on the host simultaneously.

**Required Attacker Capabilities/Position:**
- **Multiple VFs:**  The attacker needs to be able to spawn multiple Virtual Functions (VFs).
- **Control over VF MAC Addresses:** The attacker needs to be able to change MAC addresses on the spawned VFs.
- **Control over Host VLANs:** The attacker needs to be able to change port VLANs on the host.
- **Heavy Load:** The attacker needs to generate a heavy load by running these operations in parallel to expose the race condition.

**Technical Details:**
- The vulnerability occurs when:
    - Thread T0 allocates a filter in `i40e_add_filter()` within `i40e_ndo_set_vf_port_vlan()`.
    - Thread T1 concurrently frees the filter in `__i40e_del_filter()` within `i40e_ndo_set_vf_mac()`.
    - Subsequently, `i40e_service_task()` calls `i40e_sync_vsi_filters()`, which then tries to access the freed filter memory, leading to corruption.

**Fix:**
The fix introduces a new intermediate filter state, `I40E_FILTER_NEW_SYNC`. When a filter is in the process of being added and is present on the temporary list (`tmp_add_list`), it will be set to this new state, preventing premature deletion.  Filters in this state can only be removed by the full synchronization process.

This information is more detailed than a typical CVE description, providing specific function names and a clear explanation of the race condition.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | alternate_terms | 1.000 |
| 2 | 367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | sparse | 0.875 |
| 3 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.872 |
| 4 | 364 | Signal Handler Race Condition | Base | Allowed | sparse | 0.856 |
| 5 | 184 | Incomplete List of Disallowed Inputs | Base | Allowed | sparse | 0.829 |
| 6 | 833 | Deadlock | Base | Allowed | sparse | 0.758 |
| 7 | 754 | Improper Check for Unusual or Exceptional Conditions | Class | Allowed-with-Review | sparse | 0.751 |
| 8 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.745 |
| 9 | 1331 | Improper Isolation of Shared Resources in Network On Chip (NoC) | Base | Allowed | dense | 0.477 |
| 10 | 609 | Double-Checked Locking | Base | Allowed | graph | 0.003 |



# Complete CWE Specifications

CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')

CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition

CWE-667: Improper Locking

CWE-364: Signal Handler Race Condition

CWE-184: Incomplete List of Disallowed Inputs

CWE-833: Deadlock

CWE-754: Improper Check for Unusual or Exceptional Conditions

CWE-401: Missing Release of Memory after Effective Lifetime

CWE-1331: Improper Isolation of Shared Resources in Network On Chip (NoC)

CWE-609: Double-Checked Locking