{
  "method": "sparse_rootcause_1",
  "query": "In the Linux kernel, the following vulnerability has been resolved mm zswap fix crypto_free_acomp() deadlock in zswap_cpu_comp_dead() Currently, zswap_cpu_comp_dead() calls crypto_free_acomp() while holding the per-CPU acomp_ctx mutex. crypto_free_acomp() then holds scomp_lock (through crypto_exit_scomp_ops_async()). On the other hand, crypto_alloc_acomp_node() holds the scomp_lock (through crypto_scomp_init_tfm()), and then allocates memory. If the allocation results in reclaim, we may attempt to hold the per-CPU acomp_ctx mutex. The above dependencies can cause an ABBA deadlock. For example in the following scenario (1) Task A running on CPU #1 crypto_alloc_acomp_node() Holds scomp_lock Enters reclaim Reads per_cpu_ptr(pool->acomp_ctx, 1) (2) Task A is descheduled (3) CPU #1 goes offline zswap_cpu_comp_dead(CPU #1) Holds per_cpu_ptr(pool->acomp_ctx, 1)) Calls crypto_free_acomp() Waits for scomp_lock (4) Task A running on CPU #2 Waits for per_cpu_ptr(pool->acomp_ctx, 1) // Read on CPU #1 DEADLOCK Since there is no requirement to call crypto_free_acomp() with the per-CPU acomp_ctx mutex held in zswap_cpu_comp_dead(), move it after the mutex is unlocked. Also move the acomp_request_free() and kfree() calls for consistency and to avoid any potential sublte locking dependencies in the future. With this, only setting acomp_ctx fields to NULL occurs with the mutex held. This is similar to how zswap_cpu_comp_prepare() only initializes acomp_ctx fields with the mutex held, after performing all allocations before holding the mutex. Opportunistically, move the NULL check on acomp_ctx so that it takes place before the mutex dereference.",
  "keyphrases": {
    "rootcause": "lock ordering dependency"
  },
  "timestamp": "2025-07-12T10:00:47.304690",
  "results_count": 10,
  "results_summary": [
    {
      "doc_id": "667",
      "name": "Improper Locking",
      "score": 1164.7295203262468
    },
    {
      "doc_id": "833",
      "name": "Deadlock",
      "score": 1039.203464636344
    },
    {
      "doc_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "score": 907.0817567214954
    },
    {
      "doc_id": "119",
      "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
      "score": 893.8035953263034
    },
    {
      "doc_id": "835",
      "name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
      "score": 889.0237288121032
    }
  ]
}