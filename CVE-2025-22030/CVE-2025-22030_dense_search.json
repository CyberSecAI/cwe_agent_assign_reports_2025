{
  "retriever": "dense",
  "query": "In the Linux kernel, the following vulnerability has been resolved mm zswap fix crypto_free_acomp() deadlock in zswap_cpu_comp_dead() Currently, zswap_cpu_comp_dead() calls crypto_free_acomp() while holding the per-CPU acomp_ctx mutex. crypto_free_acomp() then holds scomp_lock (through crypto_exit_scomp_ops_async()). On the other hand, crypto_alloc_acomp_node() holds the scomp_lock (through crypto_scomp_init_tfm()), and then allocates memory. If the allocation results in reclaim, we may attempt to hold the per-CPU acomp_ctx mutex. The above dependencies can cause an ABBA deadlock. For example in the following scenario (1) Task A running on CPU #1 crypto_alloc_acomp_node() Holds scomp_lock Enters reclaim Reads per_cpu_ptr(pool->acomp_ctx, 1) (2) Task A is descheduled (3) CPU #1 goes offline zswap_cpu_comp_dead(CPU #1) Holds per_cpu_ptr(pool->acomp_ctx, 1)) Calls crypto_free_acomp() Waits for scomp_lock (4) Task A running on CPU #2 Waits for per_cpu_ptr(pool->acomp_ctx, 1) // Read on CPU #1 DEADLOCK Since there is no requirement to call crypto_free_acomp() with the per-CPU acomp_ctx mutex held in zswap_cpu_comp_dead(), move it after the mutex is unlocked. Also move the acomp_request_free() and kfree() calls for consistency and to avoid any potential sublte locking dependencies in the future. With this, only setting acomp_ctx fields to NULL occurs with the mutex held. This is similar to how zswap_cpu_comp_prepare() only initializes acomp_ctx fields with the mutex held, after performing all allocations before holding the mutex. Opportunistically, move the NULL check on acomp_ctx so that it takes place before the mutex dereference.",
  "keyphrases": {
    "rootcause": [
      "lock ordering dependency"
    ],
    "weakness": [
      "deadlock"
    ]
  },
  "timestamp": "2025-07-14 10:07:14",
  "cve_id": "CVE-2025-22030",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 0.5147065376675826
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "type": "Class",
      "score": 0.49112639683036674
    },
    {
      "cwe_id": "1252",
      "name": "CPU Hardware Not Configured to Support Exclusivity of Write and Execute Operations",
      "type": "Base",
      "score": 0.4616084476801053
    },
    {
      "cwe_id": "909",
      "name": "Missing Initialization of Resource",
      "type": "Class",
      "score": 0.4531181081979294
    },
    {
      "cwe_id": "1264",
      "name": "Hardware Logic with Insecure De-Synchronization between Control and Data Channels",
      "type": "Base",
      "score": 0.4466794614422229
    },
    {
      "cwe_id": "413",
      "name": "Improper Resource Locking",
      "type": "Base",
      "score": 0.44589118726349997
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 0.44320305922898356
    },
    {
      "cwe_id": "765",
      "name": "Multiple Unlocks of a Critical Resource",
      "type": "Base",
      "score": 0.4347287786810555
    },
    {
      "cwe_id": "366",
      "name": "Race Condition within a Thread",
      "type": "Base",
      "score": 0.4341476096997424
    },
    {
      "cwe_id": "409",
      "name": "Improper Handling of Highly Compressed Data (Data Amplification)",
      "type": "Base",
      "score": 0.43311054936792565
    },
    {
      "cwe_id": "1281",
      "name": "Sequence of Processor Instructions Leads to Unexpected Behavior",
      "type": "Base",
      "score": 0.43123377392603346
    },
    {
      "cwe_id": "1037",
      "name": "Processor Optimization Removal or Modification of Security-critical Code",
      "type": "Base",
      "score": 0.42725903887573485
    },
    {
      "cwe_id": "1260",
      "name": "Improper Handling of Overlap Between Protected Memory Ranges",
      "type": "Base",
      "score": 0.42095070034191706
    },
    {
      "cwe_id": "832",
      "name": "Unlock of a Resource that is not Locked",
      "type": "Base",
      "score": 0.4195851717625138
    },
    {
      "cwe_id": "662",
      "name": "Improper Synchronization",
      "type": "Class",
      "score": 0.41954322409702716
    },
    {
      "cwe_id": "764",
      "name": "Multiple Locks of a Critical Resource",
      "type": "Base",
      "score": 0.4185239814971563
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "type": "Variant",
      "score": 0.41764748961322684
    },
    {
      "cwe_id": "126",
      "name": "Buffer Over-read",
      "type": "Variant",
      "score": 0.41613573524587455
    },
    {
      "cwe_id": "1421",
      "name": "Exposure of Sensitive Information in Shared Microarchitectural Structures during Transient Execution",
      "type": "Base",
      "score": 0.4159040388918853
    },
    {
      "cwe_id": "1176",
      "name": "Inefficient CPU Computation",
      "type": "Class",
      "score": 0.41454446837140424
    }
  ]
}