{
  "retriever": "sparse",
  "query": "In the Linux kernel, the following vulnerability has been resolved mm zswap fix crypto_free_acomp() deadlock in zswap_cpu_comp_dead() Currently, zswap_cpu_comp_dead() calls crypto_free_acomp() while holding the per-CPU acomp_ctx mutex. crypto_free_acomp() then holds scomp_lock (through crypto_exit_scomp_ops_async()). On the other hand, crypto_alloc_acomp_node() holds the scomp_lock (through crypto_scomp_init_tfm()), and then allocates memory. If the allocation results in reclaim, we may attempt to hold the per-CPU acomp_ctx mutex. The above dependencies can cause an ABBA deadlock. For example in the following scenario (1) Task A running on CPU #1 crypto_alloc_acomp_node() Holds scomp_lock Enters reclaim Reads per_cpu_ptr(pool->acomp_ctx, 1) (2) Task A is descheduled (3) CPU #1 goes offline zswap_cpu_comp_dead(CPU #1) Holds per_cpu_ptr(pool->acomp_ctx, 1)) Calls crypto_free_acomp() Waits for scomp_lock (4) Task A running on CPU #2 Waits for per_cpu_ptr(pool->acomp_ctx, 1) // Read on CPU #1 DEADLOCK Since there is no requirement to call crypto_free_acomp() with the per-CPU acomp_ctx mutex held in zswap_cpu_comp_dead(), move it after the mutex is unlocked. Also move the acomp_request_free() and kfree() calls for consistency and to avoid any potential sublte locking dependencies in the future. With this, only setting acomp_ctx fields to NULL occurs with the mutex held. This is similar to how zswap_cpu_comp_prepare() only initializes acomp_ctx fields with the mutex held, after performing all allocations before holding the mutex. Opportunistically, move the NULL check on acomp_ctx so that it takes place before the mutex dereference.",
  "keyphrases": {
    "rootcause": [
      "lock ordering dependency"
    ],
    "weakness": [
      "deadlock"
    ]
  },
  "timestamp": "2025-07-14 10:07:14",
  "cve_id": "CVE-2025-22030",
  "result_count": 11,
  "results": [
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "score": 1164.7295203262468,
      "search_source": "rootcause:lock ordering dependency"
    },
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "score": 1039.203464636344,
      "search_source": "rootcause:lock ordering dependency"
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "score": 907.0817567214954,
      "search_source": "rootcause:lock ordering dependency"
    },
    {
      "cwe_id": "119",
      "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
      "score": 893.8035953263034,
      "search_source": "rootcause:lock ordering dependency"
    },
    {
      "cwe_id": "835",
      "name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
      "score": 889.0237288121032,
      "search_source": "rootcause:lock ordering dependency"
    },
    {
      "cwe_id": "400",
      "name": "Uncontrolled Resource Consumption",
      "score": 880.1959882134165,
      "search_source": "rootcause:lock ordering dependency"
    },
    {
      "cwe_id": "407",
      "name": "Inefficient Algorithmic Complexity",
      "score": 875.4714238725852,
      "search_source": "rootcause:lock ordering dependency"
    },
    {
      "cwe_id": "125",
      "name": "Out-of-bounds Read",
      "score": 869.1987437366209,
      "search_source": "rootcause:lock ordering dependency"
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "score": 867.5635986564048,
      "search_source": "rootcause:lock ordering dependency"
    },
    {
      "cwe_id": "770",
      "name": "Allocation of Resources Without Limits or Throttling",
      "score": 867.3696203292673,
      "search_source": "rootcause:lock ordering dependency"
    },
    {
      "cwe_id": "662",
      "name": "Improper Synchronization",
      "score": 809.0298524283893,
      "search_source": "weakness:deadlock"
    }
  ]
}