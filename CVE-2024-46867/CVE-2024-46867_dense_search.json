{
  "retriever": "dense",
  "query": "In the Linux kernel, the following vulnerability has been resolved drm/xe/client fix deadlock in show_meminfo() There is a real deadlock as well as sleeping in atomic() bug in here, if the bo put happens to be the last ref, since bo destruction wants to grab the same spinlock and sleeping locks. Fix that by dropping the ref using xe_bo_put_deferred(), and moving the final commit outside of the lock. Dropping the lock around the put is tricky since the bo can go out of scope and delete itself from the list, making it difficult to navigate to the next list entry. (cherry picked from commit 0083b8e6f11d7662283a267d4ce7c966812ffd8a)",
  "keyphrases": {
    "rootcause": [
      "deadlock",
      "sleeping in atomic() bug"
    ]
  },
  "timestamp": "2025-07-13 17:40:24",
  "cve_id": "CVE-2024-46867",
  "result_count": 20,
  "results": [
    {
      "cwe_id": "833",
      "name": "Deadlock",
      "type": "Base",
      "score": 0.571411523835035
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "type": "Class",
      "score": 0.5358946237375718
    },
    {
      "cwe_id": "413",
      "name": "Improper Resource Locking",
      "type": "Base",
      "score": 0.5162907439871816
    },
    {
      "cwe_id": "909",
      "name": "Missing Initialization of Resource",
      "type": "Class",
      "score": 0.508204186415988
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "type": "Class",
      "score": 0.497066545042768
    },
    {
      "cwe_id": "1274",
      "name": "Improper Access Control for Volatile Memory Containing Boot Code",
      "type": "Base",
      "score": 0.4957499832196124
    },
    {
      "cwe_id": "1342",
      "name": "Information Exposure through Microarchitectural State after Transient Execution",
      "type": "Base",
      "score": 0.4923891369510551
    },
    {
      "cwe_id": "1285",
      "name": "Improper Validation of Specified Index, Position, or Offset in Input",
      "type": "Base",
      "score": 0.49132576149852836
    },
    {
      "cwe_id": "401",
      "name": "Missing Release of Memory after Effective Lifetime",
      "type": "Variant",
      "score": 0.48750405704338035
    },
    {
      "cwe_id": "832",
      "name": "Unlock of a Resource that is not Locked",
      "type": "Base",
      "score": 0.4845443564342567
    },
    {
      "cwe_id": "190",
      "name": "Integer Overflow or Wraparound",
      "type": "Base",
      "score": 0.4807569653885668
    },
    {
      "cwe_id": "908",
      "name": "Use of Uninitialized Resource",
      "type": "Base",
      "score": 0.47736264563026026
    },
    {
      "cwe_id": "126",
      "name": "Buffer Over-read",
      "type": "Variant",
      "score": 0.47549056079269525
    },
    {
      "cwe_id": "1233",
      "name": "Security-Sensitive Hardware Controls with Missing Lock Bit Protection",
      "type": "Base",
      "score": 0.4748552997260783
    },
    {
      "cwe_id": "789",
      "name": "Memory Allocation with Excessive Size Value",
      "type": "Variant",
      "score": 0.4725040555359821
    },
    {
      "cwe_id": "366",
      "name": "Race Condition within a Thread",
      "type": "Base",
      "score": 0.4721936414793186
    },
    {
      "cwe_id": "911",
      "name": "Improper Update of Reference Count",
      "type": "Base",
      "score": 0.47204842877547537
    },
    {
      "cwe_id": "1264",
      "name": "Hardware Logic with Insecure De-Synchronization between Control and Data Channels",
      "type": "Base",
      "score": 0.4716432907217811
    },
    {
      "cwe_id": "835",
      "name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
      "type": "Base",
      "score": 0.471550016618122
    },
    {
      "cwe_id": "591",
      "name": "Sensitive Data Storage in Improperly Locked Memory",
      "type": "Variant",
      "score": 0.47003043117271104
    }
  ]
}